import { KvKey, KvStore } from "./kv-BqEOXcZv.cjs";
import { AuthenticatedDocumentLoaderFactory, DocumentLoader, DocumentLoaderFactory, GetUserAgentOptions } from "./docloader-ChxNLZAA.cjs";
import { GetNodeInfoOptions, JsonValue, NodeInfo } from "./client-n6L4GtQL.cjs";
import { Activity, Collection, CryptographicKey, Hashtag, Link, Multikey, Object as Object$1 } from "./vocab-DPMmFPJ1.cjs";
import { Actor, Recipient } from "./actor-D190nbTD.cjs";
import { HttpMessageSignaturesSpec } from "./http-C_1RU1U_.cjs";
import { GetKeyOwnerOptions } from "./owner-AcrG3Xz1.cjs";
import { LookupObjectOptions, TraverseCollectionOptions } from "./mod-D5rfgGFE.cjs";
import { Link as Link$1, LookupWebFingerOptions, ResourceDescriptor } from "./mod-CxMBb_dd.cjs";
import { MessageQueue } from "./mq-B7R1Q-M5.cjs";
import { Span, TracerProvider } from "@opentelemetry/api";

//#region src/compat/types.d.ts
/**
 * A function that transforms an activity object.
 * @since 1.4.0
 */
type ActivityTransformer<TContextData> = (activity: Activity, context: Context<TContextData>) => Activity;
//#endregion
//#region src/federation/collection.d.ts
/**
 * A page of items.
 */
interface PageItems<TItem> {
  prevCursor?: string | null;
  nextCursor?: string | null;
  items: TItem[];
}
/**
 * Calculates the [partial follower collection digest][1].
 *
 * [1]: https://w3id.org/fep/8fcf#partial-follower-collection-digest
 * @param uris The URIs to calculate the digest.  Duplicate URIs are ignored.
 * @returns The digest.
 */
declare function digest(uris: Iterable<string | URL>): Promise<Uint8Array>;
/**
 * Builds [`Collection-Synchronization`][1] header content.
 *
 * [1]: https://w3id.org/fep/8fcf#the-collection-synchronization-http-header
 *
 * @param collectionId The sender's followers collection URI.
 * @param actorIds The actor URIs to digest.
 * @returns The header content.
 */
declare function buildCollectionSynchronizationHeader(collectionId: string | URL, actorIds: Iterable<string | URL>): Promise<string>;
//#endregion
//#region src/federation/send.d.ts
/**
 * A key pair for an actor who sends an activity.
 * @since 0.10.0
 */
interface SenderKeyPair {
  /**
   * The actor's private key to sign the request.
   */
  privateKey: CryptoKey;
  /**
   * The public key ID that corresponds to the private key.
   */
  keyId: URL;
}
/**
 * Parameters for {@link sendActivity}.
 */
//#endregion
//#region src/federation/callback.d.ts
/**
 * A callback that dispatches a {@link NodeInfo} object.
 *
 * @template TContextData The context data to pass to the {@link Context}.
 */
type NodeInfoDispatcher<TContextData> = (context: RequestContext<TContextData>) => NodeInfo | Promise<NodeInfo>;
/**
 * A callback that dispatches a array of {@link Link}.
 *
 * @template TContextData The context data to pass to the {@link Context}.
 * @param resource The URL queried via WebFinger.
 * @returns Links related to the queried resource.
 */
type WebFingerLinksDispatcher<TContextData> = (context: RequestContext<TContextData>, resource: URL) => readonly Link$1[] | Promise<readonly Link$1[]>;
/**
 * A callback that dispatches an {@link Actor} object.
 *
 * @template TContextData The context data to pass to the {@link Context}.
 * @param context The request context.
 * @param identifier The actor's internal identifier or username.
 */
type ActorDispatcher<TContextData> = (context: RequestContext<TContextData>, identifier: string) => Actor | null | Promise<Actor | null>;
/**
 * A callback that dispatches key pairs for an actor.
 *
 * @template TContextData The context data to pass to the {@link Context}.
 * @param context The context.
 * @param identifier The actor's internal identifier or username.
 * @returns The key pairs.
 * @since 0.10.0
 */
type ActorKeyPairsDispatcher<TContextData> = (context: Context<TContextData>, identifier: string) => CryptoKeyPair[] | Promise<CryptoKeyPair[]>;
/**
 * A callback that maps a WebFinger username to the corresponding actor's
 * internal identifier, or `null` if the username is not found.
 * @template TContextData The context data to pass to the {@link Context}.
 * @param context The context.
 * @param username The WebFinger username.
 * @returns The actor's internal identifier, or `null` if the username is not
 *          found.
 * @since 0.15.0
 */
type ActorHandleMapper<TContextData> = (context: Context<TContextData>, username: string) => string | null | Promise<string | null>;
/**
 * A callback that maps a WebFinger query to the corresponding actor's
 * internal identifier or username, or `null` if the query is not found.
 * @template TContextData The context data to pass to the {@link Context}.
 * @param context The request context.
 * @param resource The URL that was queried through WebFinger.
 * @returns The actor's internal identifier or username, or `null` if the query
 *          is not found.
 * @since 1.4.0
 */
type ActorAliasMapper<TContextData> = (context: RequestContext<TContextData>, resource: URL) => {
  identifier: string;
} | {
  username: string;
} | null | Promise<{
  identifier: string;
} | {
  username: string;
} | null>;
/**
 * A callback that dispatches an object.
 *
 * @template TContextData The context data to pass to the {@link Context}.
 * @template TObject The type of object to dispatch.
 * @template TParam The parameter names of the requested URL.
 * @since 0.7.0
 */
type ObjectDispatcher<TContextData, TObject extends Object$1, TParam extends string> = (context: RequestContext<TContextData>, values: Record<TParam, string>) => TObject | null | Promise<TObject | null>;
/**
 * A callback that dispatches a collection.
 *
 * @template TItem The type of items in the collection.
 * @template TContext The type of the context. {@link Context} or
 *                     {@link RequestContext}.
 * @template TContextData The context data to pass to the `TContext`.
 * @template TFilter The type of the filter, if any.
 * @param context The context.
 * @param identifier The internal identifier or the username of the collection
 *                   owner.
 * @param cursor The cursor to start the collection from, or `null` to dispatch
 *               the entire collection without pagination.
 * @param filter The filter to apply to the collection, if any.
 */
type CollectionDispatcher<TItem, TContext extends Context<TContextData>, TContextData, TFilter> = (context: TContext, identifier: string, cursor: string | null, filter?: TFilter) => PageItems<TItem> | null | Promise<PageItems<TItem> | null>;
/**
 * A callback that counts the number of items in a collection.
 *
 * @template TContextData The context data to pass to the {@link Context}.
 * @param context The context.
 * @param identifier The internal identifier or the username of the collection
 *                   owner.
 * @param filter The filter to apply to the collection, if any.
 */
type CollectionCounter<TContextData, TFilter> = (context: RequestContext<TContextData>, identifier: string, filter?: TFilter) => number | bigint | null | Promise<number | bigint | null>;
/**
 * A callback that returns a cursor for a collection.
 *
 * @template TContext The type of the context. {@link Context} or
 *                     {@link RequestContext}.
 * @template TContextData The context data to pass to the {@link Context}.
 * @template TFilter The type of the filter, if any.
 * @param context The context.
 * @param identifier The internal identifier or the username of the collection
 *                   owner.
 * @param filter The filter to apply to the collection, if any.
 */
type CollectionCursor<TContext extends Context<TContextData>, TContextData, TFilter> = (context: TContext, identifier: string, filter?: TFilter) => string | null | Promise<string | null>;
/**
 * A callback that listens for activities in an inbox.
 *
 * @template TContextData The context data to pass to the {@link Context}.
 * @template TActivity The type of activity to listen for.
 * @param context The inbox context.
 * @param activity The activity that was received.
 */
type InboxListener<TContextData, TActivity extends Activity> = (context: InboxContext<TContextData>, activity: TActivity) => void | Promise<void>;
/**
 * A callback that handles errors in an inbox.
 *
 * @template TContextData The context data to pass to the {@link Context}.
 * @param context The inbox context.
 */
type InboxErrorHandler<TContextData> = (context: Context<TContextData>, error: Error) => void | Promise<void>;
/**
 * A callback that dispatches the key pair for the authenticated document loader
 * of the {@link Context} passed to the shared inbox listener.
 *
 * @template TContextData The context data to pass to the {@link Context}.
 * @param context The context.
 * @returns The username or the internal identifier of the actor or the key pair
 *          for the authenticated document loader of the {@link Context} passed
 *          to the shared inbox listener.  If `null` is returned, the request is
 *          not authorized.
 * @since 0.11.0
 */
type SharedInboxKeyDispatcher<TContextData> = (context: Context<TContextData>) => SenderKeyPair | {
  identifier: string;
} | {
  username: string;
} | {
  handle: string;
} | null | Promise<SenderKeyPair | {
  identifier: string;
} | {
  username: string;
} | {
  handle: string;
} | null>;
/**
 * A callback that handles errors during outbox processing.
 *
 * @param error The error that occurred.
 * @param activity The activity that caused the error.  If it is `null`, the
 *                 error occurred during deserializing the activity.
 * @since 0.6.0
 */
type OutboxErrorHandler = (error: Error, activity: Activity | null) => void | Promise<void>;
/**
 * A callback that determines if a request is authorized or not.
 *
 * @template TContextData The context data to pass to the {@link Context}.
 * @param context The request context.
 * @param identifier The internal identifier of the actor that is being requested.
 * @param signedKey *Deprecated in Fedify 1.5.0 in favor of
 *                  {@link RequestContext.getSignedKey} method.*
 *                  The key that was used to sign the request, or `null` if
 *                  the request was not signed or the signature was invalid.
 * @param signedKeyOwner *Deprecated in Fedify 1.5.0 in favor of
 *                       {@link RequestContext.getSignedKeyOwner} method.*
 *                       The actor that owns the key that was used to sign the
 *                       request, or `null` if the request was not signed or the
 *                       signature was invalid, or if the key is not associated
 *                       with an actor.
 * @returns `true` if the request is authorized, `false` otherwise.
 * @since 0.7.0
 */
type AuthorizePredicate<TContextData> = (context: RequestContext<TContextData>, identifier: string, signedKey: CryptographicKey | null, signedKeyOwner: Actor | null) => boolean | Promise<boolean>;
/**
 * A callback that determines if a request is authorized or not.
 *
 * @template TContextData The context data to pass to the {@link Context}.
 * @template TParam The parameter names of the requested URL.
 * @param context The request context.
 * @param values The parameters of the requested URL.
 * @param signedKey *Deprecated in Fedify 1.5.0 in favor of
 *                  {@link RequestContext.getSignedKey} method.*
 *                  The key that was used to sign the request, or `null` if
 *                  the request was not signed or the signature was invalid.
 * @param signedKeyOwner *Deprecated in Fedify 1.5.0 in favor of
 *                       {@link RequestContext.getSignedKeyOwner} method.*
 *                       The actor that owns the key that was used to sign the
 *                       request, or `null` if the request was not signed or the
 *                       signature was invalid, or if the key is not associated
 *                       with an actor.
 * @returns `true` if the request is authorized, `false` otherwise.
 * @since 0.7.0
 */
type ObjectAuthorizePredicate<TContextData, TParam extends string> = (context: RequestContext<TContextData>, values: Record<TParam, string>, signedKey: CryptographicKey | null, signedKeyOwner: Actor | null) => boolean | Promise<boolean>;
/**
 * A callback that dispatches a custom collection.
 *
 * @template TItem The type of items in the collection.
 * @template TParams The parameter names of the requested URL.
 * @template TContext The type of the context. {@link Context} or
 *                     {@link RequestContext}.
 * @template TContextData The context data to pass to the `TContext`.
 * @template TFilter The type of the filter, if any.
 * @param context The context.
 * @param values The parameters of the requested URL.
 * @param cursor The cursor to start the collection from, or `null` to dispatch
 *               the entire collection without pagination.
 * @since 1.8.0
 */
type CustomCollectionDispatcher<TItem, TParam extends string, TContext extends Context<TContextData>, TContextData> = (context: TContext, values: Record<TParam, string>, cursor: string | null) => PageItems<TItem> | null | Promise<PageItems<TItem> | null>;
/**
 * A callback that counts the number of items in a custom collection.
 *
 * @template TParams The parameter names of the requested URL.
 * @template TContextData The context data to pass to the {@link Context}.
 * @param context The context.
 * @param values The parameters of the requested URL.
 * @since 1.8.0
 */
type CustomCollectionCounter<TParam extends string, TContextData> = (context: RequestContext<TContextData>, values: Record<TParam, string>) => number | bigint | null | Promise<number | bigint | null>;
/**
 * A callback that returns a cursor for a custom collection.
 *
 * @template TParams The parameter names of the requested URL.
 * @template TContext The type of the context. {@link Context} or
 *                     {@link RequestContext}.
 * @template TContextData The context data to pass to the {@link Context}.
 * @template TFilter The type of the filter, if any.
 * @param context The context.
 * @param values The parameters of the requested URL.
 * @since 1.8.0
 */
type CustomCollectionCursor<TParam extends string, TContext extends Context<TContextData>, TContextData> = (context: TContext, values: Record<TParam, string>) => string | null | Promise<string | null>;
//#endregion
//#region src/federation/handler.d.ts

/**
 * Options for the {@link respondWithObject} and
 * {@link respondWithObjectIfAcceptable} functions.
 * @since 0.3.0
 */
interface RespondWithObjectOptions {
  /**
   * The document loader to use for compacting JSON-LD.
   * @since 0.8.0
   */
  contextLoader: DocumentLoader;
}
/**
 * Responds with the given object in JSON-LD format.
 *
 * @param object The object to respond with.
 * @param options Options.
 * @since 0.3.0
 */
declare function respondWithObject(object: Object$1, options?: RespondWithObjectOptions): Promise<Response>;
/**
 * Responds with the given object in JSON-LD format if the request accepts
 * JSON-LD.
 *
 * @param object The object to respond with.
 * @param request The request to check for JSON-LD acceptability.
 * @param options Options.
 * @since 0.3.0
 */
declare function respondWithObjectIfAcceptable(object: Object$1, request: Request, options?: RespondWithObjectOptions): Promise<Response | null>;
//#endregion
//#region src/federation/router.d.ts
/**
 * Options for the {@link Router}.
 * @since 0.12.0
 */
interface RouterOptions {
  /**
   * Whether to ignore trailing slashes when matching paths.
   */
  trailingSlashInsensitive?: boolean;
}
/**
 * The result of {@link Router.route} method.
 * @since 1.3.0
 */
interface RouterRouteResult {
  /**
   * The matched route name.
   */
  name: string;
  /**
   * The URL template of the matched route.
   */
  template: string;
  /**
   * The values extracted from the URL.
   */
  values: Record<string, string>;
}
/**
 * URL router and constructor based on URI Template
 * ([RFC 6570](https://tools.ietf.org/html/rfc6570)).
 */
declare class Router {
  #private;
  /**
   * Whether to ignore trailing slashes when matching paths.
   * @since 1.6.0
   */
  trailingSlashInsensitive: boolean;
  /**
   * Create a new {@link Router}.
   * @param options Options for the router.
   */
  constructor(options?: RouterOptions);
  clone(): Router;
  /**
   * Checks if a path name exists in the router.
   * @param name The name of the path.
   * @returns `true` if the path name exists, otherwise `false`.
   */
  has(name: string): boolean;
  /**
   * Adds a new path rule to the router.
   * @param template The path pattern.
   * @param name The name of the path.
   * @returns The names of the variables in the path pattern.
   */
  add(template: string, name: string): Set<string>;
  /**
   * Resolves a path name and values from a URL, if any match.
   * @param url The URL to resolve.
   * @returns The name of the path and its values, if any match.  Otherwise,
   *          `null`.
   */
  route(url: string): RouterRouteResult | null;
  /**
   * Constructs a URL/path from a path name and values.
   * @param name The name of the path.
   * @param values The values to expand the path with.
   * @returns The URL/path, if the name exists.  Otherwise, `null`.
   */
  build(name: string, values: Record<string, string>): string | null;
}
/**
 * An error thrown by the {@link Router}.
 */
declare class RouterError extends Error {
  /**
   * Create a new {@link RouterError}.
   * @param message The error message.
   */
  constructor(message: string);
}
//#endregion
//#region src/federation/builder.d.ts
/**
 * Creates a new {@link FederationBuilder} instance.
 * @returns A new {@link FederationBuilder} instance.
 * @since 1.6.0
 */
declare function createFederationBuilder<TContextData>(): FederationBuilder<TContextData>;
//#endregion
//#region src/federation/queue.d.ts
interface SenderKeyJwkPair {
  keyId: string;
  privateKey: JsonWebKey;
}
/**
 * A message that represents a task to be processed by the background worker.
 * The concrete type of the message depends on the `type` property.
 *
 * Please do not depend on the concrete types of the messages, as they may
 * change in the future.  You should treat the `Message` type as an opaque
 * type.
 * @since 1.6.0
 */
type Message = FanoutMessage | OutboxMessage | InboxMessage;
interface FanoutMessage {
  type: "fanout";
  id: ReturnType<typeof crypto.randomUUID>;
  baseUrl: string;
  keys: SenderKeyJwkPair[];
  inboxes: Record<string, {
    actorIds: string[];
    sharedInbox: boolean;
  }>;
  activity: unknown;
  activityId?: string;
  activityType: string;
  collectionSync?: string;
  traceContext: Record<string, string>;
}
interface OutboxMessage {
  type: "outbox";
  id: ReturnType<typeof crypto.randomUUID>;
  baseUrl: string;
  keys: SenderKeyJwkPair[];
  activity: unknown;
  activityId?: string;
  activityType: string;
  inbox: string;
  sharedInbox: boolean;
  started: string;
  attempt: number;
  headers: Record<string, string>;
  traceContext: Record<string, string>;
}
interface InboxMessage {
  type: "inbox";
  id: ReturnType<typeof crypto.randomUUID>;
  baseUrl: string;
  activity: unknown;
  started: string;
  attempt: number;
  identifier: string | null;
  traceContext: Record<string, string>;
}
//#endregion
//#region src/federation/retry.d.ts
/**
 * The context passed to a {@link RetryPolicy} callback.
 * @since 0.12.0
 */
interface RetryContext {
  /**
   * The elapsed time since the first attempt.
   */
  readonly elapsedTime: Temporal.Duration;
  /**
   * The number of attempts so far.
   */
  readonly attempts: number;
}
/**
 * A policy that determines the delay before the next retry.
 * @param context The retry context.
 * @returns The delay before the next retry, or `null` to stop retrying.
 *          It must not negative.
 * @since 0.12.0
 */
type RetryPolicy = (context: RetryContext) => Temporal.Duration | null;
/**
 * Options for {@link createExponentialBackoffPolicy} function.
 * @since 0.12.0
 */
interface CreateExponentialBackoffPolicyOptions {
  /**
   * The initial delay before the first retry.  Defaults to 1 second.
   */
  readonly initialDelay?: Temporal.DurationLike;
  /**
   * The maximum delay between retries.  Defaults to 12 hours.
   */
  readonly maxDelay?: Temporal.DurationLike;
  /**
   * The maximum number of attempts before giving up.
   * Defaults to 10.
   */
  readonly maxAttempts?: number;
  /**
   * The factor to multiply the previous delay by for each retry.
   * Defaults to 2.
   */
  readonly factor?: number;
  /**
   * Whether to add jitter to the delay to avoid synchronization.
   * Turned on by default.
   */
  readonly jitter?: boolean;
}
/**
 * Creates an exponential backoff retry policy.  The delay between retries
 * starts at the `initialDelay` and is multiplied by the `factor` for each
 * subsequent retry, up to the `maxDelay`.  The policy will give up after
 * `maxAttempts` attempts.  The actual delay is randomized to avoid
 * synchronization (jitter).
 * @param options The options for the policy.
 * @returns The retry policy.
 * @since 0.12.0
 */
declare function createExponentialBackoffPolicy(options?: CreateExponentialBackoffPolicyOptions): RetryPolicy;
//#endregion
//#region src/federation/middleware.d.ts
/**
 * Options for {@link createFederation} function.
 * @template TContextData The type of the context data.
 * @since 0.10.0
 * @deprecated Use {@link FederationOptions} instead.
 */
interface CreateFederationOptions<TContextData> extends FederationOptions<TContextData> {}
/**
 * Configures the task queues for sending and receiving activities.
 * @since 1.3.0
 */
interface FederationQueueOptions {
  /**
   * The message queue for incoming activities.  If not provided, incoming
   * activities will not be queued and will be processed immediately.
   */
  inbox?: MessageQueue;
  /**
   * The message queue for outgoing activities.  If not provided, outgoing
   * activities will not be queued and will be sent immediately.
   */
  outbox?: MessageQueue;
  /**
   * The message queue for fanning out outgoing activities.  If not provided,
   * outgoing activities will not be fanned out in the background, but will be
   * fanned out immediately, which causes slow response times on
   * {@link Context.sendActivity} calls.
   */
  fanout?: MessageQueue;
}
/**
 * Prefixes for namespacing keys in the Deno KV store.
 */
interface FederationKvPrefixes {
  /**
   * The key prefix used for storing whether activities have already been
   * processed or not.
   * @default `["_fedify", "activityIdempotence"]`
   */
  activityIdempotence: KvKey;
  /**
   * The key prefix used for storing remote JSON-LD documents.
   * @default `["_fedify", "remoteDocument"]`
   */
  remoteDocument: KvKey;
  /**
   * The key prefix used for caching public keys.
   * @default `["_fedify", "publicKey"]`
   * @since 0.12.0
   */
  publicKey: KvKey;
  /**
   * The key prefix used for caching HTTP Message Signatures specs.
   * The cached spec is used to reduce the number of requests to make signed
   * requests ("double-knocking" technique).
   * @default `["_fedify", "httpMessageSignaturesSpec"]`
   * @since 1.6.0
   */
  httpMessageSignaturesSpec: KvKey;
}
/**
 * Options for {@link CreateFederationOptions.origin} when it is not a string.
 * @since 1.5.0
 */
interface FederationOrigin {
  /**
   * The canonical hostname for fediverse handles (which are looked up through
   * WebFinger).  This is used for WebFinger lookups.  It has to be a valid
   * hostname, e.g., `"example.com"`.
   */
  handleHost: string;
  /**
   * The canonical origin for web URLs.  This is used for constructing absolute
   * URLs.  It has to start with either `"http://"` or `"https://"`, and must
   * not contain a path or query string, e.g., `"https://example.com"`.
   */
  webOrigin: string;
}
/**
 * Create a new {@link Federation} instance.
 * @param parameters Parameters for initializing the instance.
 * @returns A new {@link Federation} instance.
 * @since 0.10.0
 */
declare function createFederation<TContextData>(options: CreateFederationOptions<TContextData>): Federation<TContextData>;
//#endregion
//#region src/federation/federation.d.ts
/**
 * Options for {@link Federation.startQueue} method.
 * @since 1.0.0
 */
interface FederationStartQueueOptions {
  /**
   * The signal to abort the task queue.
   */
  signal?: AbortSignal;
  /**
   * Starts the task worker only for the specified queue.  If unspecified,
   * which is the default, the task worker starts for all three queues:
   * inbox, outbox, and fanout.
   * @since 1.3.0
   */
  queue?: "inbox" | "outbox" | "fanout";
}
/**
 * A common interface between {@link Federation} and {@link FederationBuilder}.
 * @template TContextData The context data to pass to the {@link Context}.
 * @since 1.6.0
 */
interface Federatable<TContextData> {
  /**
   * Registers a NodeInfo dispatcher.
   * @param path The URI path pattern for the NodeInfo dispatcher.  The syntax
   *             is based on URI Template
   *             ([RFC 6570](https://tools.ietf.org/html/rfc6570)).  The path
   *             must have no variables.
   * @param dispatcher A NodeInfo dispatcher callback to register.
   * @throws {RouterError} Thrown if the path pattern is invalid.
   */
  setNodeInfoDispatcher(path: string, dispatcher: NodeInfoDispatcher<TContextData>): void;
  /**
   * Registers a links dispatcher to WebFinger
   * @param dispatcher A links dispatcher callback to register.
   */
  setWebFingerLinksDispatcher(dispatcher: WebFingerLinksDispatcher<TContextData>): void;
  /**
   * Registers an actor dispatcher.
   *
   * @example
   * ``` typescript
   * federation.setActorDispatcher(
   *   "/users/{identifier}",
   *   async (ctx, identifier) => {
   *     return new Person({
   *       id: ctx.getActorUri(identifier),
   *       // ...
   *     });
   *   }
   * );
   * ```
   *
   * @param path The URI path pattern for the actor dispatcher.  The syntax is
   *             based on URI Template
   *             ([RFC 6570](https://tools.ietf.org/html/rfc6570)).  The path
   *             must have one variable: `{identifier}`.
   * @param dispatcher An actor dispatcher callback to register.
   * @returns An object with methods to set other actor dispatcher callbacks.
   * @throws {RouterError} Thrown if the path pattern is invalid.
   */
  setActorDispatcher(path: `${string}${Rfc6570Expression<"identifier">}${string}` | `${string}${Rfc6570Expression<"handle">}${string}`, dispatcher: ActorDispatcher<TContextData>): ActorCallbackSetters<TContextData>;
  /**
   * Registers an object dispatcher.
   *
   * @template TContextData The context data to pass to the {@link Context}.
   * @template TObject The type of object to dispatch.
   * @template TParam The parameter names of the requested URL.
   * @param cls The Activity Vocabulary class of the object to dispatch.
   * @param path The URI path pattern for the object dispatcher.  The syntax is
   *             based on URI Template
   *             ([RFC 6570](https://tools.ietf.org/html/rfc6570)).  The path
   *             must have one or more variables.
   * @param dispatcher An object dispatcher callback to register.
   */
  setObjectDispatcher<TObject extends Object$1, TParam extends string>(cls: ConstructorWithTypeId<TObject>, path: `${string}{${TParam}}${string}{${TParam}}${string}{${TParam}}${string}{${TParam}}${string}{${TParam}}${string}{${TParam}}${string}`, dispatcher: ObjectDispatcher<TContextData, TObject, TParam>): ObjectCallbackSetters<TContextData, TObject, TParam>;
  /**
   * Registers an object dispatcher.
   *
   * @template TContextData The context data to pass to the {@link Context}.
   * @template TObject The type of object to dispatch.
   * @template TParam The parameter names of the requested URL.
   * @param cls The Activity Vocabulary class of the object to dispatch.
   * @param path The URI path pattern for the object dispatcher.  The syntax is
   *             based on URI Template
   *             ([RFC 6570](https://tools.ietf.org/html/rfc6570)).  The path
   *             must have one or more variables.
   * @param dispatcher An object dispatcher callback to register.
   */
  setObjectDispatcher<TObject extends Object$1, TParam extends string>(cls: ConstructorWithTypeId<TObject>, path: `${string}{${TParam}}${string}{${TParam}}${string}{${TParam}}${string}{${TParam}}${string}{${TParam}}${string}`, dispatcher: ObjectDispatcher<TContextData, TObject, TParam>): ObjectCallbackSetters<TContextData, TObject, TParam>;
  /**
   * Registers an object dispatcher.
   *
   * @template TContextData The context data to pass to the {@link Context}.
   * @template TObject The type of object to dispatch.
   * @template TParam The parameter names of the requested URL.
   * @param cls The Activity Vocabulary class of the object to dispatch.
   * @param path The URI path pattern for the object dispatcher.  The syntax is
   *             based on URI Template
   *             ([RFC 6570](https://tools.ietf.org/html/rfc6570)).  The path
   *             must have one or more variables.
   * @param dispatcher An object dispatcher callback to register.
   */
  setObjectDispatcher<TObject extends Object$1, TParam extends string>(cls: ConstructorWithTypeId<TObject>, path: `${string}{${TParam}}${string}{${TParam}}${string}{${TParam}}${string}{${TParam}}${string}`, dispatcher: ObjectDispatcher<TContextData, TObject, TParam>): ObjectCallbackSetters<TContextData, TObject, TParam>;
  /**
   * Registers an object dispatcher.
   *
   * @template TContextData The context data to pass to the {@link Context}.
   * @template TObject The type of object to dispatch.
   * @template TParam The parameter names of the requested URL.
   * @param cls The Activity Vocabulary class of the object to dispatch.
   * @param path The URI path pattern for the object dispatcher.  The syntax is
   *             based on URI Template
   *             ([RFC 6570](https://tools.ietf.org/html/rfc6570)).  The path
   *             must have one or more variables.
   * @param dispatcher An object dispatcher callback to register.
   */
  setObjectDispatcher<TObject extends Object$1, TParam extends string>(cls: ConstructorWithTypeId<TObject>, path: `${string}${Rfc6570Expression<TParam>}${string}${Rfc6570Expression<TParam>}${string}${Rfc6570Expression<TParam>}${string}`, dispatcher: ObjectDispatcher<TContextData, TObject, TParam>): ObjectCallbackSetters<TContextData, TObject, TParam>;
  /**
   * Registers an object dispatcher.
   *
   * @template TContextData The context data to pass to the {@link Context}.
   * @template TObject The type of object to dispatch.
   * @template TParam The parameter names of the requested URL.
   * @param cls The Activity Vocabulary class of the object to dispatch.
   * @param path The URI path pattern for the object dispatcher.  The syntax is
   *             based on URI Template
   *             ([RFC 6570](https://tools.ietf.org/html/rfc6570)).  The path
   *             must have one or more variables.
   * @param dispatcher An object dispatcher callback to register.
   */
  setObjectDispatcher<TObject extends Object$1, TParam extends string>(cls: ConstructorWithTypeId<TObject>, path: `${string}${Rfc6570Expression<TParam>}${string}${Rfc6570Expression<TParam>}${string}`, dispatcher: ObjectDispatcher<TContextData, TObject, TParam>): ObjectCallbackSetters<TContextData, TObject, TParam>;
  /**
   * Registers an object dispatcher.
   *
   * @template TContextData The context data to pass to the {@link Context}.
   * @template TObject The type of object to dispatch.
   * @template TParam The parameter names of the requested URL.
   * @param cls The Activity Vocabulary class of the object to dispatch.
   * @param path The URI path pattern for the object dispatcher.  The syntax is
   *             based on URI Template
   *             ([RFC 6570](https://tools.ietf.org/html/rfc6570)).  The path
   *             must have one or more variables.
   * @param dispatcher An object dispatcher callback to register.
   */
  setObjectDispatcher<TObject extends Object$1, TParam extends string>(cls: ConstructorWithTypeId<TObject>, path: `${string}${Rfc6570Expression<TParam>}${string}`, dispatcher: ObjectDispatcher<TContextData, TObject, TParam>): ObjectCallbackSetters<TContextData, TObject, TParam>;
  /**
   * Registers an inbox dispatcher.
   *
   * @param path The URI path pattern for the inbox dispatcher.  The syntax is
   *             based on URI Template
   *             ([RFC 6570](https://tools.ietf.org/html/rfc6570)).  The path
   *             must have one variable: `{identifier}`, and must match
   *             the inbox listener path.
   * @param dispatcher An inbox dispatcher callback to register.
   * @throws {@link RouterError} Thrown if the path pattern is invalid.
   */
  setInboxDispatcher(path: `${string}${Rfc6570Expression<"identifier">}${string}` | `${string}${Rfc6570Expression<"handle">}${string}`, dispatcher: CollectionDispatcher<Activity, RequestContext<TContextData>, TContextData, void>): CollectionCallbackSetters<RequestContext<TContextData>, TContextData, void>;
  /**
   * Registers an outbox dispatcher.
   *
   * @example
   * ``` typescript
   * federation.setOutboxDispatcher(
   *   "/users/{identifier}/outbox",
   *   async (ctx, identifier, options) => {
   *     let items: Activity[];
   *     let nextCursor: string;
   *     // ...
   *     return { items, nextCursor };
   *   }
   * );
   * ```
   *
   * @param path The URI path pattern for the outbox dispatcher.  The syntax is
   *             based on URI Template
   *             ([RFC 6570](https://tools.ietf.org/html/rfc6570)).  The path
   *             must have one variable: `{identifier}`.
   * @param dispatcher An outbox dispatcher callback to register.
   * @throws {@link RouterError} Thrown if the path pattern is invalid.
   */
  setOutboxDispatcher(path: `${string}${Rfc6570Expression<"identifier">}${string}` | `${string}${Rfc6570Expression<"handle">}${string}`, dispatcher: CollectionDispatcher<Activity, RequestContext<TContextData>, TContextData, void>): CollectionCallbackSetters<RequestContext<TContextData>, TContextData, void>;
  /**
   * Registers a following collection dispatcher.
   * @param path The URI path pattern for the following collection.  The syntax
   *             is based on URI Template
   *             ([RFC 6570](https://tools.ietf.org/html/rfc6570)).  The path
   *             must have one variable: `{identifier}`.
   * @param dispatcher A following collection callback to register.
   * @returns An object with methods to set other following collection
   *          callbacks.
   * @throws {RouterError} Thrown if the path pattern is invalid.
   */
  setFollowingDispatcher(path: `${string}${Rfc6570Expression<"identifier">}${string}` | `${string}${Rfc6570Expression<"handle">}${string}`, dispatcher: CollectionDispatcher<Actor | URL, RequestContext<TContextData>, TContextData, void>): CollectionCallbackSetters<RequestContext<TContextData>, TContextData, void>;
  /**
   * Registers a followers collection dispatcher.
   * @param path The URI path pattern for the followers collection.  The syntax
   *             is based on URI Template
   *             ([RFC 6570](https://tools.ietf.org/html/rfc6570)).  The path
   *             must have one variable: `{identifier}`.
   * @param dispatcher A followers collection callback to register.
   * @returns An object with methods to set other followers collection
   *          callbacks.
   * @throws {@link RouterError} Thrown if the path pattern is invalid.
   */
  setFollowersDispatcher(path: `${string}${Rfc6570Expression<"identifier">}${string}` | `${string}${Rfc6570Expression<"handle">}${string}`, dispatcher: CollectionDispatcher<Recipient, Context<TContextData>, TContextData, URL>): CollectionCallbackSetters<Context<TContextData>, TContextData, URL>;
  /**
   * Registers a liked collection dispatcher.
   * @param path The URI path pattern for the liked collection.  The syntax
   *             is based on URI Template
   *             ([RFC 6570](https://tools.ietf.org/html/rfc6570)).  The path
   *             must have one variable: `{identifier}`.
   * @param dispatcher A liked collection callback to register.
   * @returns An object with methods to set other liked collection
   *          callbacks.
   * @throws {@link RouterError} Thrown if the path pattern is invalid.
   */
  setLikedDispatcher(path: `${string}${Rfc6570Expression<"identifier">}${string}` | `${string}${Rfc6570Expression<"handle">}${string}`, dispatcher: CollectionDispatcher<Object$1 | URL, RequestContext<TContextData>, TContextData, void>): CollectionCallbackSetters<RequestContext<TContextData>, TContextData, void>;
  /**
   * Registers a featured collection dispatcher.
   * @param path The URI path pattern for the featured collection.  The syntax
   *             is based on URI Template
   *             ([RFC 6570](https://tools.ietf.org/html/rfc6570)).  The path
   *             must have one variable: `{identifier}`.
   * @param dispatcher A featured collection callback to register.
   * @returns An object with methods to set other featured collection
   *          callbacks.
   * @throws {@link RouterError} Thrown if the path pattern is invalid.
   */
  setFeaturedDispatcher(path: `${string}${Rfc6570Expression<"identifier">}${string}` | `${string}${Rfc6570Expression<"handle">}${string}`, dispatcher: CollectionDispatcher<Object$1, RequestContext<TContextData>, TContextData, void>): CollectionCallbackSetters<RequestContext<TContextData>, TContextData, void>;
  /**
   * Registers a featured tags collection dispatcher.
   * @param path The URI path pattern for the featured tags collection.
   *             The syntax is based on URI Template
   *             ([RFC 6570](https://tools.ietf.org/html/rfc6570)).  The path
   *             must have one variable: `{identifier}`.
   * @param dispatcher A featured tags collection callback to register.
   * @returns An object with methods to set other featured tags collection
   *          callbacks.
   * @throws {@link RouterError} Thrown if the path pattern is invalid.
   */
  setFeaturedTagsDispatcher(path: `${string}${Rfc6570Expression<"identifier">}${string}` | `${string}${Rfc6570Expression<"handle">}${string}`, dispatcher: CollectionDispatcher<Hashtag, RequestContext<TContextData>, TContextData, void>): CollectionCallbackSetters<RequestContext<TContextData>, TContextData, void>;
  /**
   * Assigns the URL path for the inbox and starts setting inbox listeners.
   *
   * @example
   * ``` typescript
   * federation
   *   .setInboxListeners("/users/{identifier}/inbox", "/inbox")
   *   .on(Follow, async (ctx, follow) => {
   *     const from = await follow.getActor(ctx);
   *     if (!isActor(from)) return;
   *     // ...
   *   })
   *   .on(Undo, async (ctx, undo) => {
   *     // ...
   *   });
   * ```
   *
   * @param inboxPath The URI path pattern for the inbox.  The syntax is based
   *                  on URI Template
   *                  ([RFC 6570](https://tools.ietf.org/html/rfc6570)).
   *                  The path must have one variable: `{identifier}`, and must
   *                  match the inbox dispatcher path.
   * @param sharedInboxPath An optional URI path pattern for the shared inbox.
   *                        The syntax is based on URI Template
   *                        ([RFC 6570](https://tools.ietf.org/html/rfc6570)).
   *                        The path must have no variables.
   * @returns An object to register inbox listeners.
   * @throws {RouteError} Thrown if the path pattern is invalid.
   */
  setInboxListeners(inboxPath: `${string}${Rfc6570Expression<"identifier">}${string}` | `${string}${Rfc6570Expression<"handle">}${string}`, sharedInboxPath?: string): InboxListenerSetters<TContextData>;
  /**
   * Registers a collection of objects dispatcher.
   *
   * @template TContextData The context data to pass to the {@link Context}.
   * @template TObject The type of objects to dispatch.
   * @template TParam The parameter names of the requested URL.
   * @param name A unique name for the collection dispatcher.
   * @param itemType The Activity Vocabulary class of the object to dispatch.
   * @param path The URI path pattern for the collection dispatcher.
   *             The syntax is based on URI Template
   *             ([RFC 6570](https://tools.ietf.org/html/rfc6570)).
   *             The path must have one or more variables.
   * @param dispatcher A collection dispatcher callback to register.
   */
  setCollectionDispatcher<TObject extends Object$1, TParam extends string>(name: string | symbol, itemType: ConstructorWithTypeId<TObject>, path: `${string}${Rfc6570Expression<TParam>}${string}${Rfc6570Expression<TParam>}${string}${Rfc6570Expression<TParam>}${string}`, dispatcher: CustomCollectionDispatcher<TObject, TParam, RequestContext<TContextData>, TContextData>): CustomCollectionCallbackSetters<TParam, RequestContext<TContextData>, TContextData>;
  /**
   * Registers a collection of objects dispatcher.
   *
   * @template TContextData The context data to pass to the {@link Context}.
   * @template TObject The type of objects to dispatch.
   * @template TParam The parameter names of the requested URL.
   * @param name A unique name for the collection dispatcher.
   * @param itemType The Activity Vocabulary class of the object to dispatch.
   * @param path The URI path pattern for the collection dispatcher.
   *             The syntax is based on URI Template
   *             ([RFC 6570](https://tools.ietf.org/html/rfc6570)).
   *             The path must have one or more variables.
   * @param dispatcher A collection dispatcher callback to register.
   */
  setCollectionDispatcher<TObject extends Object$1, TParam extends string>(name: string | symbol, itemType: ConstructorWithTypeId<TObject>, path: `${string}${Rfc6570Expression<TParam>}${string}${Rfc6570Expression<TParam>}${string}`, dispatcher: CustomCollectionDispatcher<TObject, TParam, RequestContext<TContextData>, TContextData>): CustomCollectionCallbackSetters<TParam, RequestContext<TContextData>, TContextData>;
  /**
   * Registers a collection of objects dispatcher.
   *
   * @template TContextData The context data to pass to the {@link Context}.
   * @template TObject The type of objects to dispatch.
   * @template TParam The parameter names of the requested URL.
   * @param name A unique name for the collection dispatcher.
   * @param itemType The Activity Vocabulary class of the object to dispatch.
   * @param path The URI path pattern for the collection dispatcher.
   *             The syntax is based on URI Template
   *             ([RFC 6570](https://tools.ietf.org/html/rfc6570)).
   *             The path must have one or more variables.
   * @param dispatcher A collection dispatcher callback to register.
   */
  setCollectionDispatcher<TObject extends Object$1, TParam extends string>(name: string | symbol, itemType: ConstructorWithTypeId<TObject>, path: `${string}${Rfc6570Expression<TParam>}${string}`, dispatcher: CustomCollectionDispatcher<TObject, TParam, RequestContext<TContextData>, TContextData>): CustomCollectionCallbackSetters<TParam, RequestContext<TContextData>, TContextData>;
  /**
   * Registers an ordered collection of objects dispatcher.
   *
   * @template TContextData The context data to pass to the {@link Context}.
   * @template TObject The type of objects to dispatch.
   * @template TParam The parameter names of the requested URL.
   * @param name A unique name for the collection dispatcher.
   * @param itemType The Activity Vocabulary class of the object to dispatch.
   * @param path The URI path pattern for the collection dispatcher.
   *             The syntax is based on URI Template
   *             ([RFC 6570](https://tools.ietf.org/html/rfc6570)).
   *             The path must have one or more variables.
   * @param dispatcher A collection dispatcher callback to register.
   */
  setOrderedCollectionDispatcher<TObject extends Object$1, TParam extends string>(name: string | symbol, itemType: ConstructorWithTypeId<TObject>, path: `${string}${Rfc6570Expression<TParam>}${string}${Rfc6570Expression<TParam>}${string}${Rfc6570Expression<TParam>}${string}`, dispatcher: CustomCollectionDispatcher<TObject, TParam, RequestContext<TContextData>, TContextData>): CustomCollectionCallbackSetters<TParam, RequestContext<TContextData>, TContextData>;
  /**
   * Registers an ordered collection of objects dispatcher.
   *
   * @template TContextData The context data to pass to the {@link Context}.
   * @template TObject The type of objects to dispatch.
   * @template TParam The parameter names of the requested URL.
   * @param name A unique name for the collection dispatcher.
   * @param itemType The Activity Vocabulary class of the object to dispatch.
   * @param path The URI path pattern for the collection dispatcher.
   *             The syntax is based on URI Template
   *             ([RFC 6570](https://tools.ietf.org/html/rfc6570)).
   *             The path must have one or more variables.
   * @param dispatcher A collection dispatcher callback to register.
   */
  setOrderedCollectionDispatcher<TObject extends Object$1, TParam extends string>(name: string | symbol, itemType: ConstructorWithTypeId<TObject>, path: `${string}${Rfc6570Expression<TParam>}${string}${Rfc6570Expression<TParam>}${string}`, dispatcher: CustomCollectionDispatcher<TObject, TParam, RequestContext<TContextData>, TContextData>): CustomCollectionCallbackSetters<TParam, RequestContext<TContextData>, TContextData>;
  /**
   * Registers an ordered collection of objects dispatcher.
   *
   * @template TContextData The context data to pass to the {@link Context}.
   * @template TObject The type of objects to dispatch.
   * @template TParam The parameter names of the requested URL.
   * @param name A unique name for the collection dispatcher.
   * @param itemType The Activity Vocabulary class of the object to dispatch.
   * @param path The URI path pattern for the collection dispatcher.
   *             The syntax is based on URI Template
   *             ([RFC 6570](https://tools.ietf.org/html/rfc6570)).
   *             The path must have one or more variables.
   * @param dispatcher A collection dispatcher callback to register.
   */
  setOrderedCollectionDispatcher<TObject extends Object$1, TParam extends string>(name: string | symbol, itemType: ConstructorWithTypeId<TObject>, path: `${string}${Rfc6570Expression<TParam>}${string}`, dispatcher: CustomCollectionDispatcher<TObject, TParam, RequestContext<TContextData>, TContextData>): CustomCollectionCallbackSetters<TParam, RequestContext<TContextData>, TContextData>;
}
/**
 * An object that registers federation-related business logic and dispatches
 * requests to the appropriate handlers.
 *
 * It also provides a middleware interface for handling requests before your
 * web framework's router; see {@link Federation.fetch}.
 * @template TContextData The context data to pass to the {@link Context}.
 * @since 0.13.0
 */
interface Federation<TContextData> extends Federatable<TContextData> {
  /**
   * Manually start the task queue.
   *
   * This method is useful when you set the `manuallyStartQueue` option to
   * `true` in the {@link createFederation} function.
   * @param contextData The context data to pass to the context.
   * @param options Additional options for starting the queue.
   */
  startQueue(contextData: TContextData, options?: FederationStartQueueOptions): Promise<void>;
  /**
   * Processes a queued message task.  This method handles different types of
   * tasks such as fanout, outbox, and inbox messages.
   *
   * Note that you usually do not need to call this method directly unless you
   * are deploying your federated application on a platform that does not
   * support long-running processing, such as Cloudflare Workers.
   * @param contextData The context data to pass to the context.
   * @param message The message that represents the task to be processed.
   * @returns A promise that resolves when the message has been processed.
   * @since 1.6.0
   */
  processQueuedTask(contextData: TContextData, message: Message): Promise<void>;
  /**
   * Create a new context.
   * @param baseUrl The base URL of the server.  The `pathname` remains root,
   *                and the `search` and `hash` are stripped.
   * @param contextData The context data to pass to the context.
   * @returns The new context.
   */
  createContext(baseUrl: URL, contextData: TContextData): Context<TContextData>;
  /**
   * Create a new context for a request.
   * @param request The request object.
   * @param contextData The context data to pass to the context.
   * @returns The new request context.
   */
  createContext(request: Request, contextData: TContextData): RequestContext<TContextData>;
  /**
   * Handles a request related to federation.  If a request is not related to
   * federation, the `onNotFound` or `onNotAcceptable` callback is called.
   *
   * Usually, this method is called from a server's request handler or
   * a web framework's middleware.
   *
   * @param request The request object.
   * @param parameters The parameters for handling the request.
   * @returns The response to the request.
   */
  fetch(request: Request, options: FederationFetchOptions<TContextData>): Promise<Response>;
}
/**
 * A builder for creating a {@link Federation} object. It defers the actual
 * instantiation of the {@link Federation} object until the {@link build}
 * method is called so that dispatchers and listeners can be registered
 * before the {@link Federation} object is instantiated.
 * @template TContextData The context data to pass to the {@link Context}.
 * @since 1.6.0
 */
interface FederationBuilder<TContextData> extends Federatable<TContextData> {
  /**
   * Builds the federation object.
   * @returns The federation object.
   */
  build(options: FederationOptions<TContextData>): Promise<Federation<TContextData>>;
}
/**
 * Options for creating a {@link Federation} object.
 * @template TContextData The context data to pass to the {@link Context}.
 * @since 1.6.0
 */
interface FederationOptions<TContextData> {
  /**
   * The keyvalue store used for caching, outbox queues, and inbox idempotence.
   */
  kv: KvStore;
  /**
   * Prefixes for namespacing keys in the Deno KV store.  By default, all keys
   * are prefixed with `["_fedify"]`.
   */
  kvPrefixes?: Partial<FederationKvPrefixes>;
  /**
   * The message queue for sending and receiving activities.  If not provided,
   * activities will not be queued and will be processed immediately.
   *
   * If a `MessageQueue` is provided, both the `inbox` and `outbox` queues
   * will be set to the same queue.
   *
   * If a `FederationQueueOptions` object is provided, you can set the queues
   * separately (since Fedify 1.3.0).
   */
  queue?: FederationQueueOptions | MessageQueue;
  /**
   * Whether to start the task queue manually or automatically.
   *
   * If `true`, the task queue will not start automatically and you need to
   * manually start it by calling the {@link Federation.startQueue} method.
   *
   * If `false`, the task queue will start automatically as soon as
   * the first task is enqueued.
   *
   * By default, the queue starts automatically.
   *
   * @since 0.12.0
   */
  manuallyStartQueue?: boolean;
  /**
   * The canonical base URL of the server.  This is used for constructing
   * absolute URLs and fediverse handles.
   * @since 1.5.0
   */
  origin?: string | FederationOrigin;
  /**
   * A custom JSON-LD document loader factory.  By default, this uses
   * the built-in cache-backed loader that fetches remote documents over
   * HTTP(S).
   * @since 1.4.0
   */
  documentLoaderFactory?: DocumentLoaderFactory;
  /**
   * A custom JSON-LD context loader factory.  By default, this uses the same
   * loader as the document loader.
   * @since 1.4.0
   */
  contextLoaderFactory?: DocumentLoaderFactory;
  /**
   * A custom JSON-LD document loader.  By default, this uses the built-in
   * cache-backed loader that fetches remote documents over HTTP(S).
   * @deprecated Use {@link documentLoaderFactory} instead.
   */
  documentLoader?: DocumentLoader;
  /**
   * A custom JSON-LD context loader.  By default, this uses the same loader
   * as the document loader.
   * @deprecated Use {@link contextLoaderFactory} instead.
   */
  contextLoader?: DocumentLoader;
  /**
   * A factory function that creates an authenticated document loader for a
   * given identity.  This is used for fetching documents that require
   * authentication.
   */
  authenticatedDocumentLoaderFactory?: AuthenticatedDocumentLoaderFactory;
  /**
   * Whether to allow fetching private network addresses in the document loader.
   *
   * If turned on, {@link CreateFederationOptions.documentLoader},
   * {@link CreateFederationOptions.contextLoader}, and
   * {@link CreateFederationOptions.authenticatedDocumentLoaderFactory}
   * cannot be configured.
   *
   * Mostly useful for testing purposes.  *Do not use in production.*
   *
   * Turned off by default.
   * @since 0.15.0
   */
  allowPrivateAddress?: boolean;
  /**
   * Options for making `User-Agent` strings for HTTP requests.
   * If a string is provided, it is used as the `User-Agent` header.
   * If an object is provided, it is passed to the {@link getUserAgent}
   * function.
   * @since 1.3.0
   */
  userAgent?: GetUserAgentOptions | string;
  /**
   * A callback that handles errors during outbox processing.  Note that this
   * callback can be called multiple times for the same activity, because
   * the delivery is retried according to the backoff schedule until it
   * succeeds or reaches the maximum retry count.
   *
   * If any errors are thrown in this callback, they are ignored.
   */
  onOutboxError?: OutboxErrorHandler;
  /**
   * The time window for verifying HTTP Signatures of incoming requests.  If the
   * request is older or newer than this window, it is rejected.  Or if it is
   * `false`, the request's timestamp is not checked at all.
   *
   * By default, the window is an hour.
   */
  signatureTimeWindow?: Temporal.Duration | Temporal.DurationLike | false;
  /**
   * Whether to skip HTTP Signatures verification for incoming activities.
   * This is useful for testing purposes, but should not be used in production.
   *
   * By default, this is `false` (i.e., signatures are verified).
   * @since 0.13.0
   */
  skipSignatureVerification?: boolean;
  /**
   * The HTTP Signatures specification to use for the first signature
   * attempt when communicating with unknown servers. This option affects
   * the "double-knocking" mechanism as described in the ActivityPub HTTP
   * Signature documentation.
   *
   * When making HTTP requests to servers that haven't been encountered before,
   * Fedify will first attempt to sign the request using the specified
   * signature specification. If the request fails, it will retry with the
   * alternative specification.
   *
   * Defaults to `"rfc9421"` (HTTP Message Signatures).
   *
   * @see {@link https://swicg.github.io/activitypub-http-signature/#how-to-upgrade-supported-versions}
   * @default `"rfc9421"`
   * @since 1.7.0
   */
  firstKnock?: HttpMessageSignaturesSpec;
  /**
   * The retry policy for sending activities to recipients' inboxes.
   * By default, this uses an exponential backoff strategy with a maximum of
   * 10 attempts and a maximum delay of 12 hours.
   * @since 0.12.0
   */
  outboxRetryPolicy?: RetryPolicy;
  /**
   * The retry policy for processing incoming activities.  By default, this
   * uses an exponential backoff strategy with a maximum of 10 attempts and a
   * maximum delay of 12 hours.
   * @since 0.12.0
   */
  inboxRetryPolicy?: RetryPolicy;
  /**
   * Activity transformers that are applied to outgoing activities.  It is
   * useful for adjusting outgoing activities to satisfy some ActivityPub
   * implementations.
   *
   * By default, {@link defaultActivityTransformers} are applied.
   * @since 1.4.0
   */
  activityTransformers?: readonly ActivityTransformer<TContextData>[];
  /**
   * Whether the router should be insensitive to trailing slashes in the URL
   * paths.  For example, if this option is `true`, `/foo` and `/foo/` are
   * treated as the same path.  Turned off by default.
   * @since 0.12.0
   */
  trailingSlashInsensitive?: boolean;
  /**
   * The OpenTelemetry tracer provider for tracing operations.  If not provided,
   * the default global tracer provider is used.
   * @since 1.3.0
   */
  tracerProvider?: TracerProvider;
}
/**
 * Additional settings for the actor dispatcher.
 *
 * ``` typescript
 * const federation = createFederation<void>({ ... });
 * federation
 *   .setActorDispatcher("/users/{identifier}", async (ctx, identifier) => {
 *     // ...
 *   })
 *   .setKeyPairsDispatcher(async (ctxData, identifier) => {
 *     // ...
 *   });
 * ```
 */
interface ActorCallbackSetters<TContextData> {
  /**
   * Sets the key pairs dispatcher for actors.
   * @param dispatcher A callback that returns the key pairs for an actor.
   * @returns The setters object so that settings can be chained.
   * @since 0.10.0
   */
  setKeyPairsDispatcher(dispatcher: ActorKeyPairsDispatcher<TContextData>): ActorCallbackSetters<TContextData>;
  /**
   * Sets the callback function that maps a WebFinger username to
   * the corresponding actor's identifier.  If it's omitted, the identifier
   * is assumed to be the same as the WebFinger username, which makes your
   * actors have the immutable handles.  If you want to let your actors change
   * their fediverse handles, you should set this dispatcher.
   * @param mapper A callback that maps a WebFinger username to
   *               the corresponding actor's identifier.
   * @returns The setters object so that settings can be chained.
   * @since 0.15.0
   */
  mapHandle(mapper: ActorHandleMapper<TContextData>): ActorCallbackSetters<TContextData>;
  /**
   * Sets the callback function that maps a WebFinger query to the corresponding
   * actor's identifier or username.  If it's omitted, the WebFinger handler
   * only supports the actor URIs and `acct:` URIs.  If you want to support
   * other queries, you should set this dispatcher.
   * @param mapper A callback that maps a WebFinger query to the corresponding
   *               actor's identifier or username.
   * @returns The setters object so that settings can be chained.
   * @since 1.4.0
   */
  mapAlias(mapper: ActorAliasMapper<TContextData>): ActorCallbackSetters<TContextData>;
  /**
   * Specifies the conditions under which requests are authorized.
   * @param predicate A callback that returns whether a request is authorized.
   * @returns The setters object so that settings can be chained.
   * @since 0.7.0
   */
  authorize(predicate: AuthorizePredicate<TContextData>): ActorCallbackSetters<TContextData>;
}
/**
 * Additional settings for an object dispatcher.
 */
interface ObjectCallbackSetters<TContextData, TObject extends Object$1, TParam extends string> {
  /**
   * Specifies the conditions under which requests are authorized.
   * @param predicate A callback that returns whether a request is authorized.
   * @returns The setters object so that settings can be chained.
   * @since 0.7.0
   */
  authorize(predicate: ObjectAuthorizePredicate<TContextData, TParam>): ObjectCallbackSetters<TContextData, TObject, TParam>;
}
/**
 * Additional settings for a collection dispatcher.
 *
 * @template TContext The type of the context.  {@link Context} or
 *                     {@link RequestContext}.
 * @template TContextData The context data to pass to the {@link Context}.
 * @template TFilter The type of filter for the collection.
 */
interface CollectionCallbackSetters<TContext extends Context<TContextData>, TContextData, TFilter> {
  /**
   * Sets the counter for the collection.
   * @param counter A callback that returns the number of items in the collection.
   * @returns The setters object so that settings can be chained.
   */
  setCounter(counter: CollectionCounter<TContextData, TFilter>): CollectionCallbackSetters<TContext, TContextData, TFilter>;
  /**
   * Sets the first cursor for the collection.
   * @param cursor The cursor for the first item in the collection.
   * @returns The setters object so that settings can be chained.
   */
  setFirstCursor(cursor: CollectionCursor<TContext, TContextData, TFilter>): CollectionCallbackSetters<TContext, TContextData, TFilter>;
  /**
   * Sets the last cursor for the collection.
   * @param cursor The cursor for the last item in the collection.
   * @returns The setters object so that settings can be chained.
   */
  setLastCursor(cursor: CollectionCursor<TContext, TContextData, TFilter>): CollectionCallbackSetters<TContext, TContextData, TFilter>;
  /**
   * Specifies the conditions under which requests are authorized.
   * @param predicate A callback that returns whether a request is authorized.
   * @returns The setters object so that settings can be chained.
   * @since 0.7.0
   */
  authorize(predicate: AuthorizePredicate<TContextData>): CollectionCallbackSetters<TContext, TContextData, TFilter>;
}
/**
 * The strategy for handling activity idempotency in inbox processing.
 *
 *  -  `"global"`: Activities are deduplicated globally across all inboxes and
 *     origins.  The same activity ID will be processed only once, regardless
 *     of which inbox receives it or which server sent it.
 *
 *  -  `"per-origin"`: Activities are deduplicated per receiving server's origin.
 *     The same activity ID will be processed only once on each receiving server,
 *     but can be processed separately on different receiving servers. This was
 *     the default behavior in Fedify 1.x versions.
 *
 *  -  `"per-inbox"`: Activities are deduplicated per inbox. The same activity
 *     ID can be processed once per inbox, allowing the same activity to be
 *     delivered to multiple inboxes independently.  This follows standard
 *     ActivityPub behavior and will be the default in Fedify 2.0.
 *
 * @since 1.9.0
 */
type IdempotencyStrategy = "global" | "per-origin" | "per-inbox";
/**
 * A callback to generate a custom idempotency key for an activity.
 * Returns the cache key to use, or null to skip idempotency checking.
 * @template TContextData The context data to pass to the {@link InboxContext}.
 * @param ctx The inbox context.
 * @param activity The activity being processed.
 * @returns The idempotency key to use for caching, or null to skip caching.
 * @since 1.9.0
 */
type IdempotencyKeyCallback<TContextData> = (ctx: InboxContext<TContextData>, activity: Activity) => string | null | Promise<string | null>;
/**
 * Registry for inbox listeners for different activity types.
 */
interface InboxListenerSetters<TContextData> {
  /**
   * Registers a listener for a specific incoming activity type.
   *
   * @param type A subclass of {@link Activity} to listen to.
   * @param listener A callback to handle an incoming activity.
   * @returns The setters object so that settings can be chained.
   */
  on<TActivity extends Activity>(type: new (...args: any[]) => TActivity, listener: InboxListener<TContextData, TActivity>): InboxListenerSetters<TContextData>;
  /**
   * Registers an error handler for inbox listeners.  Any exceptions thrown
   * from the listeners are caught and passed to this handler.
   *
   * @param handler A callback to handle an error.
   * @returns The setters object so that settings can be chained.
   */
  onError(handler: InboxErrorHandler<TContextData>): InboxListenerSetters<TContextData>;
  /**
   * Configures a callback to dispatch the key pair for the authenticated
   * document loader of the {@link Context} passed to the shared inbox listener.
   *
   * @param dispatcher A callback to dispatch the key pair for the authenticated
   *                   document loader.
   * @returns The setters object so that settings can be chained.
   * @since 0.11.0
   */
  setSharedKeyDispatcher(dispatcher: SharedInboxKeyDispatcher<TContextData>): InboxListenerSetters<TContextData>;
  /**
   * Configures the strategy for handling activity idempotency in inbox processing.
   *
   * @example
   * Use per-inbox strategy (standard ActivityPub behavior):
   * ```
   * federation
   *   .setInboxListeners("/users/{identifier}/inbox", "/inbox")
   *   .withIdempotency("per-inbox");
   * ```
   *
   * Use custom strategy:
   * ```
   * federation
   *   .setInboxListeners("/users/{identifier}/inbox", "/inbox")
   *   .withIdempotency((ctx, activity) => {
   *     // Return null to skip idempotency
   *     return `${ctx.origin}:${activity.id?.href}:${ctx.recipient}`;
   *   });
   * ```
   *
   * @param strategy The idempotency strategy to use. Can be:
   *   - `"global"`: Activities are deduplicated across all inboxes and origins
   *   - `"per-origin"`: Activities are deduplicated per inbox origin
   *   - `"per-inbox"`: Activities are deduplicated per inbox
   *   - A custom callback function that returns the cache key to use
   * @returns The setters object so that settings can be chained.
   * @since 1.9.0
   */
  withIdempotency(strategy: IdempotencyStrategy | IdempotencyKeyCallback<TContextData>): InboxListenerSetters<TContextData>;
}
/**
 * Parameters of {@link Federation.fetch} method.
 *
 * @template TContextData The context data to pass to the {@link Context}.
 * @since 0.6.0
 */
interface FederationFetchOptions<TContextData> {
  /**
   * The context data to pass to the {@link Context}.
   */
  contextData: TContextData;
  /**
   * A callback to handle a request when the route is not found.
   * If not provided, a 404 response is returned.
   * @param request The request object.
   * @returns The response to the request.
   */
  onNotFound?: (request: Request) => Response | Promise<Response>;
  /**
   * A callback to handle a request when the request's `Accept` header is not
   * acceptable.  If not provided, a 406 response is returned.
   * @param request The request object.
   * @returns The response to the request.
   */
  onNotAcceptable?: (request: Request) => Response | Promise<Response>;
  /**
   * A callback to handle a request when the request is unauthorized.
   * If not provided, a 401 response is returned.
   * @param request The request object.
   * @returns The response to the request.
   * @since 0.7.0
   */
  onUnauthorized?: (request: Request) => Response | Promise<Response>;
}
/**
 * Additional settings for a custom collection dispatcher.
 *
 * @template TParam The type of the parameters in the URL path.
 * @template TContext The type of the context.  {@link Context} or
 *                     {@link RequestContext}.
 * @template TContextData The context data to pass to the {@link Context}.
 * @template TFilter The type of filter for the collection.
 */
interface CustomCollectionCallbackSetters<TParam extends string, TContext extends Context<TContextData>, TContextData> {
  /**
   * Sets the counter for the custom collection.
   * @param counter A callback that returns the number of items in the custom collection.
   * @returns The setters object so that settings can be chained.
   */
  setCounter(counter: CustomCollectionCounter<TParam, TContextData>): CustomCollectionCallbackSetters<TParam, TContext, TContextData>;
  /**
   * Sets the first cursor for the custom collection.
   * @param cursor The cursor for the first item in the custom collection.
   * @returns The setters object so that settings can be chained.
   */
  setFirstCursor(cursor: CustomCollectionCursor<TParam, TContext, TContextData>): CustomCollectionCallbackSetters<TParam, TContext, TContextData>;
  /**
   * Sets the last cursor for the custom collection.
   * @param cursor The cursor for the last item in the custom collection.
   * @returns The setters object so that settings can be chained.
   */
  setLastCursor(cursor: CustomCollectionCursor<TParam, TContext, TContextData>): CustomCollectionCallbackSetters<TParam, TContext, TContextData>;
  /**
   * Specifies the conditions under which requests are authorized.
   * @param predicate A callback that returns whether a request is authorized.
   * @returns The setters object so that settings can be chained.
   * @since 0.7.0
   */
  authorize(predicate: ObjectAuthorizePredicate<TContextData, string>): CustomCollectionCallbackSetters<TParam, TContext, TContextData>;
}
/**
 * Represents an object with a type ID, which is either a constructor or an
 * instance of the object.
 *
 * @template TObject The type of the object.
 */
type ConstructorWithTypeId<TObject extends Object$1> = (new (...args: any[]) => TObject) & {
  typeId: URL;
};
/**
 * Defines a union of all valid RFC 6570 URI Template expressions for a given
 * parameter name.
 *
 * RFC 6570 specifies a syntax for URI templates, allowing for variable
 * expansion. This type captures all Level 1-4 operator expressions for a
 * single, named variable.
 *
 * The supported expression types are:
 * - `{Param}`: Simple string expansion
 * - `+{Param}`: Reserved string expansion
 * - `#{Param}`: Fragment expansion
 * - `{.Param}`: Label expansion with a dot-prefix
 * - `{/Param}`: Path segment expansion
 * - `{;Param}`: Path-style parameter expansion
 * - `{?Param}`: Query component expansion
 * - `{&Param}`: Query continuation expansion
 *
 * @template Param The name of the parameter to be used in the expressions.
 * @example
 * ```ts
 * type UserIdExpression = Rfc6570Expression<"userId">;
 *
 * // The variable `userPath` can be assigned any of the valid expressions.
 * const userPath: UserIdExpression = "{/userId}";
 * ```
 * @see {@link https://tools.ietf.org/html/rfc6570} for the full specification.
 */
type Rfc6570Expression<Param extends string> = `{${Param}}` | `{+${Param}}` | `{#${Param}}` | `{.${Param}}` | `{/${Param}}` | `{;${Param}}` | `{?${Param}}` | `{&${Param}}`;
//#endregion
//#region src/federation/context.d.ts
/**
 * A context.
 */
interface Context<TContextData> {
  /**
   * The origin of the federated server, including the scheme (`http://` or
   * `https://`) and the host (e.g., `example.com:8080`).
   * @since 0.12.0
   */
  readonly origin: string;
  /**
   * The canonical origin of the federated server, including the scheme
   * (`http://` or `https://`) and the host (e.g., `example.com:8080`).
   *
   * When the associated {@link Federation} object does not have any explicit
   * canonical origin, it is the same as the {@link Context.origin}.
   * @since 1.5.0
   */
  readonly canonicalOrigin: string;
  /**
   * The host of the federated server, including the hostname
   * (e.g., `example.com`) and the port following a colon (e.g., `:8080`)
   * if it is not the default port for the scheme.
   * @since 0.12.0
   */
  readonly host: string;
  /**
   * The hostname of the federated server (e.g., `example.com`).  This is
   * the same as the host without the port.
   * @since 0.12.0
   */
  readonly hostname: string;
  /**
   * The user-defined data associated with the context.
   */
  readonly data: TContextData;
  /**
   * The OpenTelemetry tracer provider.
   * @since 1.3.0
   */
  readonly tracerProvider: TracerProvider;
  /**
   * The document loader for loading remote JSON-LD documents.
   */
  readonly documentLoader: DocumentLoader;
  /**
   * The context loader for loading remote JSON-LD contexts.
   */
  readonly contextLoader: DocumentLoader;
  /**
   * The federation object that this context belongs to.
   * @since 1.6.0
   */
  readonly federation: Federation<TContextData>;
  /**
   * Creates a new context with the same properties as this one,
   * but with the given data.
   * @param data The new data to associate with the context.
   * @returns A new context with the same properties as this one,
   *          but with the given data.
   * @since 1.6.0
   */
  clone(data: TContextData): Context<TContextData>;
  /**
   * Builds the URI of the NodeInfo document.
   * @returns The NodeInfo URI.
   * @throws {RouterError} If no NodeInfo dispatcher is available.
   * @since 0.2.0
   */
  getNodeInfoUri(): URL;
  /**
   * Builds the URI of an actor with the given identifier.
   * @param identifier The actor's identifier.
   * @returns The actor's URI.
   * @throws {RouterError} If no actor dispatcher is available.
   */
  getActorUri(identifier: string): URL;
  /**
   * Builds the URI of an object with the given class and values.
   * @param cls The class of the object.
   * @param values The values to pass to the object dispatcher.
   * @returns The object's URI.
   * @throws {RouteError} If no object dispatcher is available for the class.
   * @throws {TypeError} If values are invalid.
   * @since 0.7.0
   */
  getObjectUri<TObject extends Object$1>(cls: ConstructorWithTypeId<TObject>, values: Record<string, string>): URL;
  /**
   * Builds the URI of an actor's outbox with the given identifier.
   * @param identifier The actor's identifier.
   * @returns The actor's outbox URI.
   * @throws {RouterError} If no outbox dispatcher is available.
   */
  getOutboxUri(identifier: string): URL;
  /**
   * Builds the URI of the shared inbox.
   * @returns The shared inbox URI.
   * @throws {RouterError} If no inbox listener is available.
   */
  getInboxUri(): URL;
  /**
   * Builds the URI of an actor's inbox with the given identifier.
   * @param identifier The actor's identifier.
   * @returns The actor's inbox URI.
   * @throws {RouterError} If no inbox listener is available.
   */
  getInboxUri(identifier: string): URL;
  /**
   * Builds the URI of an actor's following collection with the given
   * identifier.
   * @param identifier The actor's identifier.
   * @returns The actor's following collection URI.
   * @throws {RouterError} If no following collection is available.
   */
  getFollowingUri(identifier: string): URL;
  /**
   * Builds the URI of an actor's followers collection with the given
   * identifier.
   * @param identifier The actor's identifier.
   * @returns The actor's followers collection URI.
   * @throws {RouterError} If no followers collection is available.
   */
  getFollowersUri(identifier: string): URL;
  /**
   * Builds the URI of an actor's liked collection with the given identifier.
   * @param identifier The actor's identifier.
   * @returns The actor's liked collection URI.
   * @throws {RouterError} If no liked collection is available.
   * @since 0.11.0
   */
  getLikedUri(identifier: string): URL;
  /**
   * Builds the URI of an actor's featured collection with the given identifier.
   * @param identifier The actor's identifier.
   * @returns The actor's featured collection URI.
   * @throws {RouterError} If no featured collection is available.
   * @since 0.11.0
   */
  getFeaturedUri(identifier: string): URL;
  /**
   * Builds the URI of an actor's featured tags collection with the given
   * identifier.
   * @param identifier The actor's identifier.
   * @returns The actor's featured tags collection URI.
   * @throws {RouterError} If no featured tags collection is available.
   * @since 0.11.0
   */
  getFeaturedTagsUri(identifier: string): URL;
  /**
   * Determines the type of the URI and extracts the associated data.
   * @param uri The URI to parse.
   * @returns The result of parsing the URI.  If `null` is given or
   *          the URI is not recognized, `null` is returned.
   * @since 0.9.0
   */
  parseUri(uri: URL | null): ParseUriResult | null;
  /**
   * Gets the key pairs for an actor.
   * @param identifier The actor's identifier.
   * @returns An async iterable of the actor's key pairs.  It can be empty.
   * @since 0.10.0
   */
  getActorKeyPairs(identifier: string): Promise<ActorKeyPair[]>;
  /**
   * Gets an authenticated {@link DocumentLoader} for the given identity.
   * Note that an authenticated document loader intentionally does not cache
   * the fetched documents.
   * @param identity The identity to get the document loader for.
   *                 The actor's identifier or username.
   * @returns The authenticated document loader.
   * @throws {Error} If the identity is not valid.
   * @throws {TypeError} If the key is invalid or unsupported.
   * @since 0.4.0
   */
  getDocumentLoader(identity: {
    identifier: string;
  } | {
    username: string;
  } | {
    handle: string;
  }): Promise<DocumentLoader>;
  /**
   * Gets an authenticated {@link DocumentLoader} for the given identity.
   * Note that an authenticated document loader intentionally does not cache
   * the fetched documents.
   * @param identity The identity to get the document loader for.
   *                 The actor's key pair.
   * @returns The authenticated document loader.
   * @throws {TypeError} If the key is invalid or unsupported.
   * @since 0.4.0
   */
  getDocumentLoader(identity: {
    keyId: URL;
    privateKey: CryptoKey;
  }): DocumentLoader;
  /**
   * Looks up an ActivityStreams object by its URI (including `acct:` URIs)
   * or a fediverse handle (e.g., `@user@server` or `user@server`).
   *
   * @example
   * ``` typescript
   * // Look up an actor by its fediverse handle:
   * await ctx.lookupObject("@hongminhee@fosstodon.org");
   * // returning a `Person` object.
   *
   * // A fediverse handle can omit the leading '@':
   * await ctx.lookupObject("hongminhee@fosstodon.org");
   * // returning a `Person` object.
   *
   * // A `acct:` URI can be used as well:
   * await ctx.lookupObject("acct:hongminhee@fosstodon.org");
   * // returning a `Person` object.
   *
   * // Look up an object by its URI:
   * await ctx.lookupObject("https://todon.eu/@hongminhee/112060633798771581");
   * // returning a `Note` object.
   *
   * // It can be a `URL` object as well:
   * await ctx.lookupObject(
   *   new URL("https://todon.eu/@hongminhee/112060633798771581")
   * );
   * // returning a `Note` object.
   * ```
   *
   * It's almost the same as the {@link lookupObject} function, but it uses
   * the context's document loader and context loader by default.
   *
   * @param identifier The URI or fediverse handle to look up.
   * @param options Lookup options.
   * @returns The object, or `null` if not found.
   * @since 0.15.0
   */
  lookupObject(identifier: string | URL, options?: LookupObjectOptions): Promise<Object$1 | null>;
  /**
   * Traverses a collection, yielding each item in the collection.
   * If the collection is paginated, it will fetch the next page
   * automatically.
   *
   * @example
   * ``` typescript
   * const collection = await ctx.lookupObject(collectionUrl);
   * if (collection instanceof Collection) {
   *   for await (const item of ctx.traverseCollection(collection)) {
   *     console.log(item.id?.href);
   *   }
   * }
   * ```
   *
   * It's almost the same as the {@link traverseCollection} function, but it
   * uses the context's document loader and context loader by default.
   * @param collection The collection to traverse.
   * @param options Options for traversing the collection.
   * @returns An async iterable of each item in the collection.
   * @since 1.1.0
   */
  traverseCollection(collection: Collection, options?: TraverseCollectionOptions): AsyncIterable<Object$1 | Link>;
  /**
   * Fetches the NodeInfo document from the given URL.
   * @param url The base URL of the server.  If `options.direct` is turned off
   *            (default), the NodeInfo document will be fetched from
   *            the `.well-known` location of this URL (hence the only origin
   *            of the URL is used).  If `options.direct` is turned on,
   *            the NodeInfo document will be fetched from the given URL.
   * @param options Options for fetching the NodeInfo document.
   * @returns The NodeInfo document if it could be fetched successfully.
   *          Otherwise, `undefined` is returned.
   * @since 1.4.0
   */
  lookupNodeInfo(url: URL | string, options?: GetNodeInfoOptions & {
    parse?: "strict" | "best-effort";
  }): Promise<NodeInfo | undefined>;
  /**
   * Fetches the NodeInfo document from the given URL.
   * @param url The base URL of the server.  If `options.direct` is turned off
   *            (default), the NodeInfo document will be fetched from
   *            the `.well-known` location of this URL (hence the only origin
   *            of the URL is used).  If `options.direct` is turned on,
   *            the NodeInfo document will be fetched from the given URL.
   * @param options Options for fetching the NodeInfo document.
   * @returns The NodeInfo document if it could be fetched successfully.
   *          Otherwise, `undefined` is returned.
   * @since 1.4.0
   */
  lookupNodeInfo(url: URL | string, options?: GetNodeInfoOptions & {
    parse: "none";
  }): Promise<JsonValue | undefined>;
  /**
   * Looks up a WebFinger resource.
   *
   * It's almost the same as the {@link lookupWebFinger} function, but it uses
   * the context's configuration by default.
   *
   * @param resource The resource URL to look up.
   * @param options Extra options for looking up the resource.
   * @returns The resource descriptor, or `null` if not found.
   * @since 1.6.0
   */
  lookupWebFinger(resource: URL | string, options?: LookupWebFingerOptions): Promise<ResourceDescriptor | null>;
  /**
   * Sends an activity to recipients' inboxes.
   * @param sender The sender's identifier or the sender's username or
   *               the sender's key pair(s).
   * @param recipients The recipients of the activity.
   * @param activity The activity to send.
   * @param options Options for sending the activity.
   */
  sendActivity(sender: SenderKeyPair | SenderKeyPair[] | {
    identifier: string;
  } | {
    username: string;
  } | {
    handle: string;
  }, recipients: Recipient | Recipient[], activity: Activity, options?: SendActivityOptions): Promise<void>;
  /**
   * Sends an activity to the outboxes of the sender's followers.
   * @param sender The sender's identifier or the sender's username.
   * @param recipients In this case, it must be `"followers"`.
   * @param activity The activity to send.
   * @param options Options for sending the activity.
   * @throws {Error} If no followers collection is registered.
   * @since 0.14.0
   */
  sendActivity(sender: {
    identifier: string;
  } | {
    username: string;
  } | {
    handle: string;
  }, recipients: "followers", activity: Activity, options?: SendActivityOptionsForCollection): Promise<void>;
  /**
   * Manually routes an activity to the appropriate inbox listener.
   *
   * It is useful for routing an activity that is not received from the network,
   * or for routing an activity that is enclosed in another activity.
   *
   * Note that the activity will be verified if it has Object Integrity Proofs
   * or is equivalent to the actual remote object.  If the activity is not
   * verified, it will be rejected.
   * @param recipient The recipient of the activity.  If it is `null`,
   *                  the activity will be routed to the shared inbox.
   *                  Otherwise, the activity will be routed to the personal
   *                  inbox of the recipient with the given identifier.
   * @param activity The activity to route.  It must have a proof or
   *                 a dereferenceable `id` to verify the activity.
   * @param options Options for routing the activity.
   * @returns `true` if the activity is successfully verified and routed.
   *          Otherwise, `false`.
   * @since 1.3.0
   */
  routeActivity(recipient: string | null, activity: Activity, options?: RouteActivityOptions): Promise<boolean>;
  /**
   * Builds the URI of a collection of objects with the given name and values.
   * @param name The name of the collection, which can be a string or a symbol.
   * @param values The values of the URI parameters.
   * @return The URI of the collection.
   * @throws {RouteError} If no object dispatcher is available for the name.
   * @throws {TypeError} If values are invalid.
   * @since 1.8.0
   */
  getCollectionUri<TParam extends Record<string, string>>(name: string | symbol, values: TParam): URL;
}
/**
 * A context for a request.
 */
interface RequestContext<TContextData> extends Context<TContextData> {
  /**
   * The request object.
   */
  readonly request: Request;
  /**
   * The URL of the request.
   */
  readonly url: URL;
  /**
   * Creates a new context with the same properties as this one,
   * but with the given data.
   * @param data The new data to associate with the context.
   * @returns A new context with the same properties as this one,
   *          but with the given data.
   * @since 1.6.0
   */
  clone(data: TContextData): RequestContext<TContextData>;
  /**
   * Gets an {@link Actor} object for the given identifier.
   * @param identifier The actor's identifier.
   * @returns The actor object, or `null` if the actor is not found.
   * @throws {Error} If no actor dispatcher is available.
   * @since 0.7.0
   */
  getActor(identifier: string): Promise<Actor | null>;
  /**
   * Gets an object of the given class with the given values.
   * @param cls The class to instantiate.
   * @param values The values to pass to the object dispatcher.
   * @returns The object of the given class with the given values, or `null`
   *          if the object is not found.
   * @throws {Error} If no object dispatcher is available for the class.
   * @throws {TypeError} If values are invalid.
   * @since 0.7.0
   */
  getObject<TObject extends Object$1>(cls: ConstructorWithTypeId<TObject>, values: Record<string, string>): Promise<TObject | null>;
  /**
   * Gets the public key of the sender, if any exists and it is verified.
   * Otherwise, `null` is returned.
   *
   * This can be used for implementing [authorized fetch] (also known as
   * secure mode) in ActivityPub.
   *
   * [authorized fetch]: https://swicg.github.io/activitypub-http-signature/#authorized-fetch
   *
   * @returns The public key of the sender, or `null` if the sender is not verified.
   * @since 0.7.0
   */
  getSignedKey(): Promise<CryptographicKey | null>;
  /**
   * Gets the public key of the sender, if any exists and it is verified.
   * Otherwise, `null` is returned.
   *
   * This can be used for implementing [authorized fetch] (also known as
   * secure mode) in ActivityPub.
   *
   * [authorized fetch]: https://swicg.github.io/activitypub-http-signature/#authorized-fetch
   *
   * @param options Options for getting the signed key. You usually may want to
   *                specify the custom `documentLoader` so that making
   *                an HTTP request to the sender's server is signed with
   *                your [instance actor].
   * @returns The public key of the sender, or `null` if the sender is not verified.
   * @since 1.5.0
   *
   * [instance actor]: https://swicg.github.io/activitypub-http-signature/#instance-actor
   */
  getSignedKey(options: GetSignedKeyOptions): Promise<CryptographicKey | null>;
  /**
   * Gets the owner of the signed key, if any exists and it is verified.
   * Otherwise, `null` is returned.
   *
   * This can be used for implementing [authorized fetch] (also known as
   * secure mode) in ActivityPub.
   *
   * [authorized fetch]: https://swicg.github.io/activitypub-http-signature/#authorized-fetch
   *
   * @returns The owner of the signed key, or `null` if the key is not verified
   *          or the owner is not found.
   * @since 0.7.0
   */
  getSignedKeyOwner(): Promise<Actor | null>;
  /**
   * Gets the owner of the signed key, if any exists and it is verified.
   * Otherwise, `null` is returned.
   *
   * This can be used for implementing [authorized fetch] (also known as
   * secure mode) in ActivityPub.
   *
   * [authorized fetch]: https://swicg.github.io/activitypub-http-signature/#authorized-fetch
   *
   * @param options Options for getting the key owner. You usually may want to
   *                specify the custom `documentLoader` so that making
   *                an HTTP request to the key owner's server is signed with
   *                your [instance actor].
   * @returns The owner of the signed key, or `null` if the key is not verified
   *          or the owner is not found.
   * @since 1.5.0
   *
   * [instance actor]: https://swicg.github.io/activitypub-http-signature/#instance-actor
   */
  getSignedKeyOwner(options: GetKeyOwnerOptions): Promise<Actor | null>;
}
/**
 * A context for inbox listeners.
 * @since 1.0.0
 */
interface InboxContext<TContextData> extends Context<TContextData> {
  /**
   * The identifier of the recipient of the inbox.  If the inbox is a shared
   * inbox, it is `null`.
   * @since 1.2.0
   */
  recipient: string | null;
  /**
   * Creates a new context with the same properties as this one,
   * but with the given data.
   * @param data The new data to associate with the context.
   * @returns A new context with the same properties as this one,
   *          but with the given data.
   * @since 1.6.0
   */
  clone(data: TContextData): InboxContext<TContextData>;
  /**
   * Forwards a received activity to the recipients' inboxes.  The forwarded
   * activity will be signed in HTTP Signatures by the forwarder, but its
   * payload will not be modified, i.e., Linked Data Signatures and Object
   * Integrity Proofs will not be added.  Therefore, if the activity is not
   * signed (i.e., it has neither Linked Data Signatures nor Object Integrity
   * Proofs), the recipient probably will not trust the activity.
   * @param forwarder The forwarder's identifier or the forwarder's username
   *                  or the forwarder's key pair(s).
   * @param recipients The recipients of the activity.
   * @param options Options for forwarding the activity.
   * @since 1.0.0
   */
  forwardActivity(forwarder: SenderKeyPair | SenderKeyPair[] | {
    identifier: string;
  } | {
    username: string;
  } | {
    handle: string;
  }, recipients: Recipient | Recipient[], options?: ForwardActivityOptions): Promise<void>;
  /**
   * Forwards a received activity to the recipients' inboxes.  The forwarded
   * activity will be signed in HTTP Signatures by the forwarder, but its
   * payload will not be modified, i.e., Linked Data Signatures and Object
   * Integrity Proofs will not be added.  Therefore, if the activity is not
   * signed (i.e., it has neither Linked Data Signatures nor Object Integrity
   * Proofs), the recipient probably will not trust the activity.
   * @param forwarder The forwarder's identifier or the forwarder's username.
   * @param recipients In this case, it must be `"followers"`.
   * @param options Options for forwarding the activity.
   * @since 1.0.0
   */
  forwardActivity(forwarder: {
    identifier: string;
  } | {
    username: string;
  } | {
    handle: string;
  }, recipients: "followers", options?: ForwardActivityOptions): Promise<void>;
}
/**
 * A result of parsing an URI.
 */
type ParseUriResult =
/**
 * The case of an actor URI.
 */
{
  readonly type: "actor";
  readonly identifier: string;
  readonly handle: string;
}
/**
 * The case of an object URI.
 */ | {
  readonly type: "object";
  readonly class: ConstructorWithTypeId<Object$1>;
  readonly typeId: URL;
  readonly values: Record<string, string>;
}
/**
 * The case of an shared inbox URI.
 */ | {
  readonly type: "inbox";
  readonly identifier: undefined;
  readonly handle: undefined;
}
/**
 * The case of an personal inbox URI.
 */ | {
  readonly type: "inbox";
  readonly identifier: string;
  readonly handle: string;
}
/**
 * The case of an outbox collection URI.
 */ | {
  readonly type: "outbox";
  readonly identifier: string;
  readonly handle: string;
}
/**
 * The case of a following collection URI.
 */ | {
  readonly type: "following";
  readonly identifier: string;
  readonly handle: string;
}
/**
 * The case of a followers collection URI.
 */ | {
  readonly type: "followers";
  readonly identifier: string;
  readonly handle: string;
}
/**
 * The case of a liked collection URI.
 * @since 0.11.0
 */ | {
  readonly type: "liked";
  readonly identifier: string;
  readonly handle: string;
}
/**
 * The case of a featured collection URI.
 * @since 0.11.0
 */ | {
  readonly type: "featured";
  readonly identifier: string;
  readonly handle: string;
}
/**
 * The case of a featured tags collection URI.
 * @since 0.11.0
 */ | {
  readonly type: "featuredTags";
  readonly identifier: string;
  readonly handle: string;
}
/**
 * The case of a custom collection URI.
 * @since 1.8.0
 */ | {
  readonly type: "collection";
  readonly name: string | symbol;
  readonly class: ConstructorWithTypeId<Object$1>;
  readonly typeId: URL;
  readonly values: Record<string, string>;
}
/**
 * The case of a custom ordered collection URI.
 * @since 1.8.0
 */ | {
  readonly type: "orderedCollection";
  readonly name: string | symbol;
  readonly class: ConstructorWithTypeId<Object$1>;
  readonly typeId: URL;
  readonly values: Record<string, string>;
};
/**
 * Options for {@link Context.sendActivity} method.
 */
interface SendActivityOptions {
  /**
   * Whether to prefer the shared inbox for the recipients.
   */
  preferSharedInbox?: boolean;
  /**
   * Whether to send the activity immediately, without enqueuing it.
   * If `true`, the activity will be sent immediately and the retrial
   * policy will not be applied.
   *
   * @since 0.3.0
   */
  immediate?: boolean;
  /**
   * Determines how activities are queued when sent to multiple recipients.
   *
   * - "auto" (default): Automatically chooses optimal strategy based on
   *   recipient count.
   * - "skip": Always enqueues individual messages per recipient,
   *   bypassing the fanout queue. Use when payload needs to vary per recipient.
   * - "force": Always uses fanout queue regardless of recipient count.
   *   Useful for testing or special cases.
   *
   * This option is ignored when `immediate: true` is specified, as immediate
   * delivery bypasses all queuing mechanisms.
   *
   * @default `"auto"`
   * @since 1.5.0
   */
  fanout?: "auto" | "skip" | "force";
  /**
   * The base URIs to exclude from the recipients' inboxes.  It is useful
   * for excluding the recipients having the same shared inbox with the sender.
   *
   * Note that the only `origin` parts of the `URL`s are compared.
   *
   * @since 0.9.0
   */
  excludeBaseUris?: URL[];
}
/**
 * Options for {@link Context.sendActivity} method when sending to a collection.
 * @since 1.5.0
 */
interface SendActivityOptionsForCollection extends SendActivityOptions {
  /**
   * Whether to synchronize the collection using `Collection-Synchronization`
   * header ([FEP-8fcf]).
   *
   * [FEP-8fcf]: https://w3id.org/fep/8fcf
   */
  syncCollection?: boolean;
}
/**
 * Options for {@link InboxContext.forwardActivity} method.
 * @since 1.0.0
 */
type ForwardActivityOptions = Omit<SendActivityOptions, "fanout"> & {
  /**
   * Whether to skip forwarding the activity if it is not signed, i.e., it has
   * neither Linked Data Signatures nor Object Integrity Proofs.
   *
   * If the activity is not signed, the recipient probably will not trust the
   * activity.  Therefore, it is recommended to skip forwarding the activity
   * if it is not signed.
   */
  skipIfUnsigned: boolean;
};
/**
 * Options for {@link Context.routeActivity} method.
 * @since 1.3.0
 */
interface RouteActivityOptions {
  /**
   * Whether to skip enqueuing the activity and invoke the listener immediately.
   * If no inbox queue is available, this option is ignored and the activity
   * will be always invoked immediately.
   * @default false
   */
  immediate?: boolean;
  /**
   * The document loader for loading remote JSON-LD documents.
   */
  documentLoader?: DocumentLoader;
  /**
   * The context loader for loading remote JSON-LD contexts.
   */
  contextLoader?: DocumentLoader;
  /**
   * The OpenTelemetry tracer provider.  If omitted, the global tracer provider
   * is used.
   */
  tracerProvider?: TracerProvider;
}
/**
 * Options for {@link Context.getSignedKey} method.
 * @since 1.5.0
 */
interface GetSignedKeyOptions {
  /**
   * The document loader for loading remote JSON-LD documents.
   */
  documentLoader?: DocumentLoader;
  /**
   * The context loader for loading remote JSON-LD contexts.
   */
  contextLoader?: DocumentLoader;
  /**
   * The OpenTelemetry tracer provider.  If omitted, the global tracer provider
   * is used.
   */
  tracerProvider?: TracerProvider;
}
/**
 * A pair of a public key and a private key in various formats.
 * @since 0.10.0
 */
interface ActorKeyPair extends CryptoKeyPair {
  /**
   * The URI of the public key, which is used for verifying HTTP Signatures.
   */
  keyId: URL;
  /**
   * A {@link CryptographicKey} instance of the public key.
   */
  cryptographicKey: CryptographicKey;
  /**
   * A {@link Multikey} instance of the public key.
   */
  multikey: Multikey;
}
//#endregion
export { ActivityTransformer, ActorAliasMapper, ActorCallbackSetters, ActorDispatcher, ActorHandleMapper, ActorKeyPair, ActorKeyPairsDispatcher, AuthorizePredicate, CollectionCallbackSetters, CollectionCounter, CollectionCursor, CollectionDispatcher, ConstructorWithTypeId, Context, CreateExponentialBackoffPolicyOptions, CreateFederationOptions, CustomCollectionCallbackSetters, CustomCollectionCounter, CustomCollectionCursor, CustomCollectionDispatcher, Federatable, Federation, FederationBuilder, FederationFetchOptions, FederationKvPrefixes, FederationOptions, FederationOrigin, FederationQueueOptions, FederationStartQueueOptions, ForwardActivityOptions, GetSignedKeyOptions, IdempotencyKeyCallback, IdempotencyStrategy, InboxContext, InboxErrorHandler, InboxListener, InboxListenerSetters, Message, NodeInfoDispatcher, ObjectAuthorizePredicate, ObjectCallbackSetters, ObjectDispatcher, OutboxErrorHandler, PageItems, ParseUriResult, RequestContext, RespondWithObjectOptions, RetryContext, RetryPolicy, Rfc6570Expression, RouteActivityOptions, Router, RouterError, RouterOptions, RouterRouteResult, SendActivityOptions, SendActivityOptionsForCollection, SenderKeyPair, SharedInboxKeyDispatcher, WebFingerLinksDispatcher, buildCollectionSynchronizationHeader, createExponentialBackoffPolicy, createFederation, createFederationBuilder, digest, respondWithObject, respondWithObjectIfAcceptable };