
      import { Temporal } from "@js-temporal/polyfill";
      import { URLPattern } from "urlpattern-polyfill";
      globalThis.addEventListener = () => {};
    
import { Application, Group, Organization, Person, Service, __export } from "../type-BVpqRkFR.js";
import { assertEquals } from "../assert_equals-DSbWqCm3.js";
import { assert } from "../assert-MZs1qjMx.js";
import "../assert_instance_of-DHz7EHNU.js";
import "../lookup-CyI7sF0p.js";
import { getActorClassByTypeName, getActorHandle, getActorTypeName, isActor, normalizeActorHandle } from "../actor-BdLqN1gg.js";
import { test } from "../testing-DoQEBY_a.js";
import { assertStrictEquals } from "../std__assert-X-_kMxKM.js";
import { assertFalse, assertRejects } from "../assert_rejects-DiIiJbZn.js";
import "../assert_is_error-BPGph1Jx.js";
import "../assert_not_equals-f3m3epl3.js";
import { assertThrows } from "../assert_throws-BOO88avQ.js";
import { esm_default } from "../esm-gCncx4Xn.js";

//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/precondition/PreconditionFailure.js
var PreconditionFailure = class PreconditionFailure extends Error {
	constructor(interruptExecution = false) {
		super();
		this.interruptExecution = interruptExecution;
		this.footprint = PreconditionFailure.SharedFootPrint;
	}
	static isFailure(err) {
		return err != null && err.footprint === PreconditionFailure.SharedFootPrint;
	}
};
PreconditionFailure.SharedFootPrint = Symbol.for("fast-check/PreconditionFailure");

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/stream/StreamHelpers.js
var Nil = class {
	[Symbol.iterator]() {
		return this;
	}
	next(value) {
		return {
			value,
			done: true
		};
	}
};
Nil.nil = new Nil();
function nilHelper() {
	return Nil.nil;
}
function* mapHelper(g, f) {
	for (const v of g) yield f(v);
}
function* flatMapHelper(g, f) {
	for (const v of g) yield* f(v);
}
function* filterHelper(g, f) {
	for (const v of g) if (f(v)) yield v;
}
function* takeNHelper(g, n) {
	for (let i = 0; i < n; ++i) {
		const cur = g.next();
		if (cur.done) break;
		yield cur.value;
	}
}
function* takeWhileHelper(g, f) {
	let cur = g.next();
	while (!cur.done && f(cur.value)) {
		yield cur.value;
		cur = g.next();
	}
}
function* joinHelper(g, others) {
	for (let cur = g.next(); !cur.done; cur = g.next()) yield cur.value;
	for (const s of others) for (let cur = s.next(); !cur.done; cur = s.next()) yield cur.value;
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/stream/Stream.js
const safeSymbolIterator = Symbol.iterator;
var Stream = class Stream {
	static nil() {
		return new Stream(nilHelper());
	}
	static of(...elements) {
		return new Stream(elements[safeSymbolIterator]());
	}
	constructor(g) {
		this.g = g;
	}
	next() {
		return this.g.next();
	}
	[Symbol.iterator]() {
		return this.g;
	}
	map(f) {
		return new Stream(mapHelper(this.g, f));
	}
	flatMap(f) {
		return new Stream(flatMapHelper(this.g, f));
	}
	dropWhile(f) {
		let foundEligible = false;
		function* helper(v) {
			if (foundEligible || !f(v)) {
				foundEligible = true;
				yield v;
			}
		}
		return this.flatMap(helper);
	}
	drop(n) {
		if (n <= 0) return this;
		let idx = 0;
		function helper() {
			return idx++ < n;
		}
		return this.dropWhile(helper);
	}
	takeWhile(f) {
		return new Stream(takeWhileHelper(this.g, f));
	}
	take(n) {
		return new Stream(takeNHelper(this.g, n));
	}
	filter(f) {
		return new Stream(filterHelper(this.g, f));
	}
	every(f) {
		for (const v of this.g) if (!f(v)) return false;
		return true;
	}
	has(f) {
		for (const v of this.g) if (f(v)) return [true, v];
		return [false, null];
	}
	join(...others) {
		return new Stream(joinHelper(this.g, others));
	}
	getNthOrLast(nth) {
		let remaining = nth;
		let last = null;
		for (const v of this.g) {
			if (remaining-- === 0) return v;
			last = v;
		}
		return last;
	}
};
function stream(g) {
	return new Stream(g);
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/symbols.js
const cloneMethod = Symbol.for("fast-check/cloneMethod");
function hasCloneMethod(instance) {
	return instance !== null && (typeof instance === "object" || typeof instance === "function") && cloneMethod in instance && typeof instance[cloneMethod] === "function";
}
function cloneIfNeeded(instance) {
	return hasCloneMethod(instance) ? instance[cloneMethod]() : instance;
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/arbitrary/definition/Value.js
const safeObjectDefineProperty$2 = Object.defineProperty;
var Value = class {
	constructor(value_, context, customGetValue = void 0) {
		this.value_ = value_;
		this.context = context;
		this.hasToBeCloned = customGetValue !== void 0 || hasCloneMethod(value_);
		this.readOnce = false;
		if (this.hasToBeCloned) safeObjectDefineProperty$2(this, "value", { get: customGetValue !== void 0 ? customGetValue : this.getValue });
		else this.value = value_;
	}
	getValue() {
		if (this.hasToBeCloned) {
			if (!this.readOnce) {
				this.readOnce = true;
				return this.value_;
			}
			return this.value_[cloneMethod]();
		}
		return this.value_;
	}
};

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/arbitrary/definition/Arbitrary.js
const safeObjectAssign$4 = Object.assign;
var Arbitrary = class {
	filter(refinement) {
		return new FilterArbitrary(this, refinement);
	}
	map(mapper, unmapper) {
		return new MapArbitrary(this, mapper, unmapper);
	}
	chain(chainer) {
		return new ChainArbitrary(this, chainer);
	}
	noShrink() {
		return new NoShrinkArbitrary(this);
	}
	noBias() {
		return new NoBiasArbitrary(this);
	}
};
var ChainArbitrary = class extends Arbitrary {
	constructor(arb, chainer) {
		super();
		this.arb = arb;
		this.chainer = chainer;
	}
	generate(mrng, biasFactor) {
		const clonedMrng = mrng.clone();
		const src = this.arb.generate(mrng, biasFactor);
		return this.valueChainer(src, mrng, clonedMrng, biasFactor);
	}
	canShrinkWithoutContext(value) {
		return false;
	}
	shrink(value, context) {
		if (this.isSafeContext(context)) return (!context.stoppedForOriginal ? this.arb.shrink(context.originalValue, context.originalContext).map((v) => this.valueChainer(v, context.clonedMrng.clone(), context.clonedMrng, context.originalBias)) : Stream.nil()).join(context.chainedArbitrary.shrink(value, context.chainedContext).map((dst) => {
			const newContext = safeObjectAssign$4(safeObjectAssign$4({}, context), {
				chainedContext: dst.context,
				stoppedForOriginal: true
			});
			return new Value(dst.value_, newContext);
		}));
		return Stream.nil();
	}
	valueChainer(v, generateMrng, clonedMrng, biasFactor) {
		const chainedArbitrary = this.chainer(v.value_);
		const dst = chainedArbitrary.generate(generateMrng, biasFactor);
		const context = {
			originalBias: biasFactor,
			originalValue: v.value_,
			originalContext: v.context,
			stoppedForOriginal: false,
			chainedArbitrary,
			chainedContext: dst.context,
			clonedMrng
		};
		return new Value(dst.value_, context);
	}
	isSafeContext(context) {
		return context != null && typeof context === "object" && "originalBias" in context && "originalValue" in context && "originalContext" in context && "stoppedForOriginal" in context && "chainedArbitrary" in context && "chainedContext" in context && "clonedMrng" in context;
	}
};
var MapArbitrary = class extends Arbitrary {
	constructor(arb, mapper, unmapper) {
		super();
		this.arb = arb;
		this.mapper = mapper;
		this.unmapper = unmapper;
		this.bindValueMapper = (v) => this.valueMapper(v);
	}
	generate(mrng, biasFactor) {
		const g = this.arb.generate(mrng, biasFactor);
		return this.valueMapper(g);
	}
	canShrinkWithoutContext(value) {
		if (this.unmapper !== void 0) try {
			const unmapped = this.unmapper(value);
			return this.arb.canShrinkWithoutContext(unmapped);
		} catch (_err) {
			return false;
		}
		return false;
	}
	shrink(value, context) {
		if (this.isSafeContext(context)) return this.arb.shrink(context.originalValue, context.originalContext).map(this.bindValueMapper);
		if (this.unmapper !== void 0) {
			const unmapped = this.unmapper(value);
			return this.arb.shrink(unmapped, void 0).map(this.bindValueMapper);
		}
		return Stream.nil();
	}
	mapperWithCloneIfNeeded(v) {
		const sourceValue = v.value;
		const mappedValue = this.mapper(sourceValue);
		if (v.hasToBeCloned && (typeof mappedValue === "object" && mappedValue !== null || typeof mappedValue === "function") && Object.isExtensible(mappedValue) && !hasCloneMethod(mappedValue)) Object.defineProperty(mappedValue, cloneMethod, { get: () => () => this.mapperWithCloneIfNeeded(v)[0] });
		return [mappedValue, sourceValue];
	}
	valueMapper(v) {
		const [mappedValue, sourceValue] = this.mapperWithCloneIfNeeded(v);
		const context = {
			originalValue: sourceValue,
			originalContext: v.context
		};
		return new Value(mappedValue, context);
	}
	isSafeContext(context) {
		return context != null && typeof context === "object" && "originalValue" in context && "originalContext" in context;
	}
};
var FilterArbitrary = class extends Arbitrary {
	constructor(arb, refinement) {
		super();
		this.arb = arb;
		this.refinement = refinement;
		this.bindRefinementOnValue = (v) => this.refinementOnValue(v);
	}
	generate(mrng, biasFactor) {
		while (true) {
			const g = this.arb.generate(mrng, biasFactor);
			if (this.refinementOnValue(g)) return g;
		}
	}
	canShrinkWithoutContext(value) {
		return this.arb.canShrinkWithoutContext(value) && this.refinement(value);
	}
	shrink(value, context) {
		return this.arb.shrink(value, context).filter(this.bindRefinementOnValue);
	}
	refinementOnValue(v) {
		return this.refinement(v.value);
	}
};
var NoShrinkArbitrary = class extends Arbitrary {
	constructor(arb) {
		super();
		this.arb = arb;
	}
	generate(mrng, biasFactor) {
		return this.arb.generate(mrng, biasFactor);
	}
	canShrinkWithoutContext(value) {
		return this.arb.canShrinkWithoutContext(value);
	}
	shrink(_value, _context) {
		return Stream.nil();
	}
	noShrink() {
		return this;
	}
};
var NoBiasArbitrary = class extends Arbitrary {
	constructor(arb) {
		super();
		this.arb = arb;
	}
	generate(mrng, _biasFactor) {
		return this.arb.generate(mrng, void 0);
	}
	canShrinkWithoutContext(value) {
		return this.arb.canShrinkWithoutContext(value);
	}
	shrink(value, context) {
		return this.arb.shrink(value, context);
	}
	noBias() {
		return this;
	}
};
function isArbitrary(instance) {
	return typeof instance === "object" && instance !== null && "generate" in instance && "shrink" in instance && "canShrinkWithoutContext" in instance;
}
function assertIsArbitrary(instance) {
	if (!isArbitrary(instance)) throw new Error("Unexpected value received: not an instance of Arbitrary");
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/utils/apply.js
const untouchedApply = Function.prototype.apply;
const ApplySymbol = Symbol("apply");
function safeExtractApply(f) {
	try {
		return f.apply;
	} catch (err) {
		return void 0;
	}
}
function safeApplyHacky(f, instance, args) {
	const ff = f;
	ff[ApplySymbol] = untouchedApply;
	const out = ff[ApplySymbol](instance, args);
	delete ff[ApplySymbol];
	return out;
}
function safeApply(f, instance, args) {
	if (safeExtractApply(f) === untouchedApply) return f.apply(instance, args);
	return safeApplyHacky(f, instance, args);
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/utils/globals.js
const SArray = typeof Array !== "undefined" ? Array : void 0;
const SBigInt = typeof BigInt !== "undefined" ? BigInt : void 0;
const SBoolean = typeof Boolean !== "undefined" ? Boolean : void 0;
const SDate = typeof Date !== "undefined" ? Date : void 0;
const SError = typeof Error !== "undefined" ? Error : void 0;
const SFloat32Array = typeof Float32Array !== "undefined" ? Float32Array : void 0;
const SFloat64Array = typeof Float64Array !== "undefined" ? Float64Array : void 0;
const SInt8Array = typeof Int8Array !== "undefined" ? Int8Array : void 0;
const SInt16Array = typeof Int16Array !== "undefined" ? Int16Array : void 0;
const SInt32Array = typeof Int32Array !== "undefined" ? Int32Array : void 0;
const SNumber = typeof Number !== "undefined" ? Number : void 0;
const SString = typeof String !== "undefined" ? String : void 0;
const SSet = typeof Set !== "undefined" ? Set : void 0;
const SUint8Array = typeof Uint8Array !== "undefined" ? Uint8Array : void 0;
const SUint8ClampedArray = typeof Uint8ClampedArray !== "undefined" ? Uint8ClampedArray : void 0;
const SUint16Array = typeof Uint16Array !== "undefined" ? Uint16Array : void 0;
const SUint32Array = typeof Uint32Array !== "undefined" ? Uint32Array : void 0;
const SMap = Map;
const SSymbol = Symbol;
const untouchedForEach = Array.prototype.forEach;
const untouchedIndexOf = Array.prototype.indexOf;
const untouchedJoin = Array.prototype.join;
const untouchedMap = Array.prototype.map;
const untouchedFilter = Array.prototype.filter;
const untouchedPush = Array.prototype.push;
const untouchedPop = Array.prototype.pop;
const untouchedSplice = Array.prototype.splice;
const untouchedSlice = Array.prototype.slice;
const untouchedSort = Array.prototype.sort;
const untouchedEvery = Array.prototype.every;
function extractForEach(instance) {
	try {
		return instance.forEach;
	} catch (err) {
		return void 0;
	}
}
function extractIndexOf(instance) {
	try {
		return instance.indexOf;
	} catch (err) {
		return void 0;
	}
}
function extractJoin(instance) {
	try {
		return instance.join;
	} catch (err) {
		return void 0;
	}
}
function extractMap(instance) {
	try {
		return instance.map;
	} catch (err) {
		return void 0;
	}
}
function extractFilter(instance) {
	try {
		return instance.filter;
	} catch (err) {
		return void 0;
	}
}
function extractPush(instance) {
	try {
		return instance.push;
	} catch (err) {
		return void 0;
	}
}
function extractPop(instance) {
	try {
		return instance.pop;
	} catch (err) {
		return void 0;
	}
}
function extractSlice(instance) {
	try {
		return instance.slice;
	} catch (err) {
		return void 0;
	}
}
function extractEvery(instance) {
	try {
		return instance.every;
	} catch (err) {
		return void 0;
	}
}
function safeForEach(instance, fn) {
	if (extractForEach(instance) === untouchedForEach) return instance.forEach(fn);
	return safeApply(untouchedForEach, instance, [fn]);
}
function safeIndexOf(instance, ...args) {
	if (extractIndexOf(instance) === untouchedIndexOf) return instance.indexOf(...args);
	return safeApply(untouchedIndexOf, instance, args);
}
function safeJoin(instance, ...args) {
	if (extractJoin(instance) === untouchedJoin) return instance.join(...args);
	return safeApply(untouchedJoin, instance, args);
}
function safeMap(instance, fn) {
	if (extractMap(instance) === untouchedMap) return instance.map(fn);
	return safeApply(untouchedMap, instance, [fn]);
}
function safeFilter(instance, predicate) {
	if (extractFilter(instance) === untouchedFilter) return instance.filter(predicate);
	return safeApply(untouchedFilter, instance, [predicate]);
}
function safePush(instance, ...args) {
	if (extractPush(instance) === untouchedPush) return instance.push(...args);
	return safeApply(untouchedPush, instance, args);
}
function safePop(instance) {
	if (extractPop(instance) === untouchedPop) return instance.pop();
	return safeApply(untouchedPop, instance, []);
}
function safeSlice(instance, ...args) {
	if (extractSlice(instance) === untouchedSlice) return instance.slice(...args);
	return safeApply(untouchedSlice, instance, args);
}
function safeEvery(instance, ...args) {
	if (extractEvery(instance) === untouchedEvery) return instance.every(...args);
	return safeApply(untouchedEvery, instance, args);
}
const untouchedGetTime = Date.prototype.getTime;
const untouchedToISOString = Date.prototype.toISOString;
function extractGetTime(instance) {
	try {
		return instance.getTime;
	} catch (err) {
		return void 0;
	}
}
function extractToISOString(instance) {
	try {
		return instance.toISOString;
	} catch (err) {
		return void 0;
	}
}
function safeGetTime(instance) {
	if (extractGetTime(instance) === untouchedGetTime) return instance.getTime();
	return safeApply(untouchedGetTime, instance, []);
}
function safeToISOString(instance) {
	if (extractToISOString(instance) === untouchedToISOString) return instance.toISOString();
	return safeApply(untouchedToISOString, instance, []);
}
const untouchedAdd = Set.prototype.add;
const untouchedHas = Set.prototype.has;
function extractAdd(instance) {
	try {
		return instance.add;
	} catch (err) {
		return void 0;
	}
}
function extractHas(instance) {
	try {
		return instance.has;
	} catch (err) {
		return void 0;
	}
}
function safeAdd(instance, value) {
	if (extractAdd(instance) === untouchedAdd) return instance.add(value);
	return safeApply(untouchedAdd, instance, [value]);
}
function safeHas(instance, value) {
	if (extractHas(instance) === untouchedHas) return instance.has(value);
	return safeApply(untouchedHas, instance, [value]);
}
const untouchedSet = WeakMap.prototype.set;
const untouchedGet = WeakMap.prototype.get;
function extractSet(instance) {
	try {
		return instance.set;
	} catch (err) {
		return void 0;
	}
}
function extractGet(instance) {
	try {
		return instance.get;
	} catch (err) {
		return void 0;
	}
}
function safeSet(instance, key, value) {
	if (extractSet(instance) === untouchedSet) return instance.set(key, value);
	return safeApply(untouchedSet, instance, [key, value]);
}
function safeGet(instance, key) {
	if (extractGet(instance) === untouchedGet) return instance.get(key);
	return safeApply(untouchedGet, instance, [key]);
}
const untouchedMapSet = Map.prototype.set;
const untouchedMapGet = Map.prototype.get;
function extractMapSet(instance) {
	try {
		return instance.set;
	} catch (err) {
		return void 0;
	}
}
function extractMapGet(instance) {
	try {
		return instance.get;
	} catch (err) {
		return void 0;
	}
}
function safeMapSet(instance, key, value) {
	if (extractMapSet(instance) === untouchedMapSet) return instance.set(key, value);
	return safeApply(untouchedMapSet, instance, [key, value]);
}
function safeMapGet(instance, key) {
	if (extractMapGet(instance) === untouchedMapGet) return instance.get(key);
	return safeApply(untouchedMapGet, instance, [key]);
}
const untouchedSplit = String.prototype.split;
const untouchedStartsWith = String.prototype.startsWith;
const untouchedEndsWith = String.prototype.endsWith;
const untouchedSubstring = String.prototype.substring;
const untouchedToLowerCase = String.prototype.toLowerCase;
const untouchedToUpperCase = String.prototype.toUpperCase;
const untouchedPadStart = String.prototype.padStart;
const untouchedCharCodeAt = String.prototype.charCodeAt;
const untouchedNormalize = String.prototype.normalize;
const untouchedReplace = String.prototype.replace;
function extractSplit(instance) {
	try {
		return instance.split;
	} catch (err) {
		return void 0;
	}
}
function extractSubstring(instance) {
	try {
		return instance.substring;
	} catch (err) {
		return void 0;
	}
}
function extractCharCodeAt(instance) {
	try {
		return instance.charCodeAt;
	} catch (err) {
		return void 0;
	}
}
function extractNormalize(instance) {
	try {
		return instance.normalize;
	} catch (err) {
		return void 0;
	}
}
function extractReplace(instance) {
	try {
		return instance.replace;
	} catch (err) {
		return void 0;
	}
}
function safeSplit(instance, ...args) {
	if (extractSplit(instance) === untouchedSplit) return instance.split(...args);
	return safeApply(untouchedSplit, instance, args);
}
function safeSubstring(instance, ...args) {
	if (extractSubstring(instance) === untouchedSubstring) return instance.substring(...args);
	return safeApply(untouchedSubstring, instance, args);
}
function safeCharCodeAt(instance, index) {
	if (extractCharCodeAt(instance) === untouchedCharCodeAt) return instance.charCodeAt(index);
	return safeApply(untouchedCharCodeAt, instance, [index]);
}
function safeNormalize(instance, form) {
	if (extractNormalize(instance) === untouchedNormalize) return instance.normalize(form);
	return safeApply(untouchedNormalize, instance, [form]);
}
function safeReplace(instance, pattern, replacement) {
	if (extractReplace(instance) === untouchedReplace) return instance.replace(pattern, replacement);
	return safeApply(untouchedReplace, instance, [pattern, replacement]);
}
const untouchedNumberToString = Number.prototype.toString;
const untouchedHasOwnProperty = Object.prototype.hasOwnProperty;
const untouchedToString = Object.prototype.toString;
function safeHasOwnProperty(instance, v) {
	return safeApply(untouchedHasOwnProperty, instance, [v]);
}
function safeToString(instance) {
	return safeApply(untouchedToString, instance, []);
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/stream/LazyIterableIterator.js
var LazyIterableIterator = class {
	constructor(producer) {
		this.producer = producer;
	}
	[Symbol.iterator]() {
		if (this.it === void 0) this.it = this.producer();
		return this.it;
	}
	next() {
		if (this.it === void 0) this.it = this.producer();
		return this.it.next();
	}
};
function makeLazy(producer) {
	return new LazyIterableIterator(producer);
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/TupleArbitrary.js
const safeArrayIsArray$2 = Array.isArray;
const safeObjectDefineProperty$1 = Object.defineProperty;
function tupleMakeItCloneable(vs, values) {
	return safeObjectDefineProperty$1(vs, cloneMethod, { value: () => {
		const cloned = [];
		for (let idx = 0; idx !== values.length; ++idx) safePush(cloned, values[idx].value);
		tupleMakeItCloneable(cloned, values);
		return cloned;
	} });
}
function tupleWrapper(values) {
	let cloneable = false;
	const vs = [];
	const ctxs = [];
	for (let idx = 0; idx !== values.length; ++idx) {
		const v = values[idx];
		cloneable = cloneable || v.hasToBeCloned;
		safePush(vs, v.value);
		safePush(ctxs, v.context);
	}
	if (cloneable) tupleMakeItCloneable(vs, values);
	return new Value(vs, ctxs);
}
function tupleShrink(arbs, value, context) {
	const shrinks = [];
	const safeContext = safeArrayIsArray$2(context) ? context : [];
	for (let idx = 0; idx !== arbs.length; ++idx) safePush(shrinks, makeLazy(() => arbs[idx].shrink(value[idx], safeContext[idx]).map((v) => {
		const nextValues = safeMap(value, (v$1, idx$1) => new Value(cloneIfNeeded(v$1), safeContext[idx$1]));
		return [
			...safeSlice(nextValues, 0, idx),
			v,
			...safeSlice(nextValues, idx + 1)
		];
	}).map(tupleWrapper)));
	return Stream.nil().join(...shrinks);
}
var TupleArbitrary = class extends Arbitrary {
	constructor(arbs) {
		super();
		this.arbs = arbs;
		for (let idx = 0; idx !== arbs.length; ++idx) {
			const arb = arbs[idx];
			if (arb == null || arb.generate == null) throw new Error(`Invalid parameter encountered at index ${idx}: expecting an Arbitrary`);
		}
	}
	generate(mrng, biasFactor) {
		const mapped = [];
		for (let idx = 0; idx !== this.arbs.length; ++idx) safePush(mapped, this.arbs[idx].generate(mrng, biasFactor));
		return tupleWrapper(mapped);
	}
	canShrinkWithoutContext(value) {
		if (!safeArrayIsArray$2(value) || value.length !== this.arbs.length) return false;
		for (let index = 0; index !== this.arbs.length; ++index) if (!this.arbs[index].canShrinkWithoutContext(value[index])) return false;
		return true;
	}
	shrink(value, context) {
		return tupleShrink(this.arbs, value, context);
	}
};

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/tuple.js
function tuple(...arbs) {
	return new TupleArbitrary(arbs);
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/property/IRawProperty.js
const safeMathLog$2 = Math.log;
function runIdToFrequency(runId) {
	return 2 + ~~(safeMathLog$2(runId + 1) * .4342944819032518);
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/configuration/GlobalParameters.js
let globalParameters = {};
function readConfigureGlobal() {
	return globalParameters;
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/NoUndefinedAsContext.js
const UndefinedContextPlaceholder = Symbol("UndefinedContextPlaceholder");
function noUndefinedAsContext(value) {
	if (value.context !== void 0) return value;
	if (value.hasToBeCloned) return new Value(value.value_, UndefinedContextPlaceholder, () => value.value);
	return new Value(value.value_, UndefinedContextPlaceholder);
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/AlwaysShrinkableArbitrary.js
var AlwaysShrinkableArbitrary = class extends Arbitrary {
	constructor(arb) {
		super();
		this.arb = arb;
	}
	generate(mrng, biasFactor) {
		const value = this.arb.generate(mrng, biasFactor);
		return noUndefinedAsContext(value);
	}
	canShrinkWithoutContext(value) {
		return true;
	}
	shrink(value, context) {
		if (context === void 0 && !this.arb.canShrinkWithoutContext(value)) return Stream.nil();
		const safeContext = context !== UndefinedContextPlaceholder ? context : void 0;
		return this.arb.shrink(value, safeContext).map(noUndefinedAsContext);
	}
};

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/property/Property.generic.js
var Property = class Property {
	constructor(arb, predicate) {
		this.arb = arb;
		this.predicate = predicate;
		const { beforeEach = Property.dummyHook, afterEach = Property.dummyHook, asyncBeforeEach, asyncAfterEach } = readConfigureGlobal() || {};
		if (asyncBeforeEach !== void 0) throw SError("\"asyncBeforeEach\" can't be set when running synchronous properties");
		if (asyncAfterEach !== void 0) throw SError("\"asyncAfterEach\" can't be set when running synchronous properties");
		this.beforeEachHook = beforeEach;
		this.afterEachHook = afterEach;
	}
	isAsync() {
		return false;
	}
	generate(mrng, runId) {
		const value = this.arb.generate(mrng, runId != null ? runIdToFrequency(runId) : void 0);
		return noUndefinedAsContext(value);
	}
	shrink(value) {
		if (value.context === void 0 && !this.arb.canShrinkWithoutContext(value.value_)) return Stream.nil();
		const safeContext = value.context !== UndefinedContextPlaceholder ? value.context : void 0;
		return this.arb.shrink(value.value_, safeContext).map(noUndefinedAsContext);
	}
	runBeforeEach() {
		this.beforeEachHook();
	}
	runAfterEach() {
		this.afterEachHook();
	}
	run(v, dontRunHook) {
		if (!dontRunHook) this.beforeEachHook();
		try {
			const output = this.predicate(v);
			return output == null || output === true ? null : {
				error: new SError("Property failed by returning false"),
				errorMessage: "Error: Property failed by returning false"
			};
		} catch (err) {
			if (PreconditionFailure.isFailure(err)) return err;
			if (err instanceof SError && err.stack) return {
				error: err,
				errorMessage: err.stack
			};
			return {
				error: err,
				errorMessage: SString(err)
			};
		} finally {
			if (!dontRunHook) this.afterEachHook();
		}
	}
	beforeEach(hookFunction) {
		const previousBeforeEachHook = this.beforeEachHook;
		this.beforeEachHook = () => hookFunction(previousBeforeEachHook);
		return this;
	}
	afterEach(hookFunction) {
		const previousAfterEachHook = this.afterEachHook;
		this.afterEachHook = () => hookFunction(previousAfterEachHook);
		return this;
	}
};
Property.dummyHook = () => {};

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/property/Property.js
function property(...args) {
	if (args.length < 2) throw new Error("property expects at least two parameters");
	const arbs = safeSlice(args, 0, args.length - 1);
	const p = args[args.length - 1];
	safeForEach(arbs, assertIsArbitrary);
	const mappedArbs = safeMap(arbs, (arb) => new AlwaysShrinkableArbitrary(arb));
	return new Property(tuple(...mappedArbs), (t) => p(...t));
}

//#endregion
//#region ../../node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/generator/RandomGenerator.js
function unsafeGenerateN(rng, num) {
	var out = [];
	for (var idx = 0; idx != num; ++idx) out.push(rng.unsafeNext());
	return out;
}
function generateN(rng, num) {
	var nextRng = rng.clone();
	var out = unsafeGenerateN(nextRng, num);
	return [out, nextRng];
}
function unsafeSkipN(rng, num) {
	for (var idx = 0; idx != num; ++idx) rng.unsafeNext();
}
function skipN(rng, num) {
	var nextRng = rng.clone();
	unsafeSkipN(nextRng, num);
	return nextRng;
}

//#endregion
//#region ../../node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/generator/LinearCongruential.js
var MULTIPLIER = 214013;
var INCREMENT = 2531011;
var MASK = 4294967295;
var MASK_2 = (1 << 31) - 1;
var computeNextSeed = function(seed) {
	return seed * MULTIPLIER + INCREMENT & MASK;
};
var computeValueFromNextSeed = function(nextseed) {
	return (nextseed & MASK_2) >> 16;
};
var LinearCongruential32 = function() {
	function LinearCongruential32$1(seed) {
		this.seed = seed;
	}
	LinearCongruential32$1.prototype.clone = function() {
		return new LinearCongruential32$1(this.seed);
	};
	LinearCongruential32$1.prototype.next = function() {
		var nextRng = new LinearCongruential32$1(this.seed);
		var out = nextRng.unsafeNext();
		return [out, nextRng];
	};
	LinearCongruential32$1.prototype.unsafeNext = function() {
		var s1 = computeNextSeed(this.seed);
		var v1 = computeValueFromNextSeed(s1);
		var s2 = computeNextSeed(s1);
		var v2 = computeValueFromNextSeed(s2);
		this.seed = computeNextSeed(s2);
		var v3 = computeValueFromNextSeed(this.seed);
		var vnext = v3 + (v2 + (v1 << 15) << 15);
		return vnext | 0;
	};
	LinearCongruential32$1.prototype.getState = function() {
		return [this.seed];
	};
	return LinearCongruential32$1;
}();
function fromState$3(state) {
	var valid = state.length === 1;
	if (!valid) throw new Error("The state must have been produced by a congruential32 RandomGenerator");
	return new LinearCongruential32(state[0]);
}
var congruential32 = Object.assign(function(seed) {
	return new LinearCongruential32(seed);
}, { fromState: fromState$3 });

//#endregion
//#region ../../node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/generator/MersenneTwister.js
var __read = void 0 && (void 0).__read || function(o, n) {
	var m = typeof Symbol === "function" && o[Symbol.iterator];
	if (!m) return o;
	var i = m.call(o), r, ar = [], e;
	try {
		while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	} catch (error) {
		e = { error };
	} finally {
		try {
			if (r && !r.done && (m = i["return"])) m.call(i);
		} finally {
			if (e) throw e.error;
		}
	}
	return ar;
};
var __spreadArray = void 0 && (void 0).__spreadArray || function(to, from, pack) {
	if (pack || arguments.length === 2) {
		for (var i = 0, l = from.length, ar; i < l; i++) if (ar || !(i in from)) {
			if (!ar) ar = Array.prototype.slice.call(from, 0, i);
			ar[i] = from[i];
		}
	}
	return to.concat(ar || Array.prototype.slice.call(from));
};
var MersenneTwister = function() {
	function MersenneTwister$1(states, index) {
		this.states = states;
		this.index = index;
	}
	MersenneTwister$1.twist = function(prev) {
		var mt = prev.slice();
		for (var idx = 0; idx !== MersenneTwister$1.N - MersenneTwister$1.M; ++idx) {
			var y_1 = (mt[idx] & MersenneTwister$1.MASK_UPPER) + (mt[idx + 1] & MersenneTwister$1.MASK_LOWER);
			mt[idx] = mt[idx + MersenneTwister$1.M] ^ y_1 >>> 1 ^ -(y_1 & 1) & MersenneTwister$1.A;
		}
		for (var idx = MersenneTwister$1.N - MersenneTwister$1.M; idx !== MersenneTwister$1.N - 1; ++idx) {
			var y_2 = (mt[idx] & MersenneTwister$1.MASK_UPPER) + (mt[idx + 1] & MersenneTwister$1.MASK_LOWER);
			mt[idx] = mt[idx + MersenneTwister$1.M - MersenneTwister$1.N] ^ y_2 >>> 1 ^ -(y_2 & 1) & MersenneTwister$1.A;
		}
		var y = (mt[MersenneTwister$1.N - 1] & MersenneTwister$1.MASK_UPPER) + (mt[0] & MersenneTwister$1.MASK_LOWER);
		mt[MersenneTwister$1.N - 1] = mt[MersenneTwister$1.M - 1] ^ y >>> 1 ^ -(y & 1) & MersenneTwister$1.A;
		return mt;
	};
	MersenneTwister$1.seeded = function(seed) {
		var out = Array(MersenneTwister$1.N);
		out[0] = seed;
		for (var idx = 1; idx !== MersenneTwister$1.N; ++idx) {
			var xored = out[idx - 1] ^ out[idx - 1] >>> 30;
			out[idx] = Math.imul(MersenneTwister$1.F, xored) + idx | 0;
		}
		return out;
	};
	MersenneTwister$1.from = function(seed) {
		return new MersenneTwister$1(MersenneTwister$1.twist(MersenneTwister$1.seeded(seed)), 0);
	};
	MersenneTwister$1.prototype.clone = function() {
		return new MersenneTwister$1(this.states, this.index);
	};
	MersenneTwister$1.prototype.next = function() {
		var nextRng = new MersenneTwister$1(this.states, this.index);
		var out = nextRng.unsafeNext();
		return [out, nextRng];
	};
	MersenneTwister$1.prototype.unsafeNext = function() {
		var y = this.states[this.index];
		y ^= this.states[this.index] >>> MersenneTwister$1.U;
		y ^= y << MersenneTwister$1.S & MersenneTwister$1.B;
		y ^= y << MersenneTwister$1.T & MersenneTwister$1.C;
		y ^= y >>> MersenneTwister$1.L;
		if (++this.index >= MersenneTwister$1.N) {
			this.states = MersenneTwister$1.twist(this.states);
			this.index = 0;
		}
		return y;
	};
	MersenneTwister$1.prototype.getState = function() {
		return __spreadArray([this.index], __read(this.states), false);
	};
	MersenneTwister$1.fromState = function(state) {
		var valid = state.length === MersenneTwister$1.N + 1 && state[0] >= 0 && state[0] < MersenneTwister$1.N;
		if (!valid) throw new Error("The state must have been produced by a mersenne RandomGenerator");
		return new MersenneTwister$1(state.slice(1), state[0]);
	};
	MersenneTwister$1.N = 624;
	MersenneTwister$1.M = 397;
	MersenneTwister$1.R = 31;
	MersenneTwister$1.A = 2567483615;
	MersenneTwister$1.F = 1812433253;
	MersenneTwister$1.U = 11;
	MersenneTwister$1.S = 7;
	MersenneTwister$1.B = 2636928640;
	MersenneTwister$1.T = 15;
	MersenneTwister$1.C = 4022730752;
	MersenneTwister$1.L = 18;
	MersenneTwister$1.MASK_LOWER = Math.pow(2, MersenneTwister$1.R) - 1;
	MersenneTwister$1.MASK_UPPER = Math.pow(2, MersenneTwister$1.R);
	return MersenneTwister$1;
}();
function fromState$2(state) {
	return MersenneTwister.fromState(state);
}
var MersenneTwister_default = Object.assign(function(seed) {
	return MersenneTwister.from(seed);
}, { fromState: fromState$2 });

//#endregion
//#region ../../node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/generator/XorShift.js
var XorShift128Plus = function() {
	function XorShift128Plus$1(s01, s00, s11, s10) {
		this.s01 = s01;
		this.s00 = s00;
		this.s11 = s11;
		this.s10 = s10;
	}
	XorShift128Plus$1.prototype.clone = function() {
		return new XorShift128Plus$1(this.s01, this.s00, this.s11, this.s10);
	};
	XorShift128Plus$1.prototype.next = function() {
		var nextRng = new XorShift128Plus$1(this.s01, this.s00, this.s11, this.s10);
		var out = nextRng.unsafeNext();
		return [out, nextRng];
	};
	XorShift128Plus$1.prototype.unsafeNext = function() {
		var a0 = this.s00 ^ this.s00 << 23;
		var a1 = this.s01 ^ (this.s01 << 23 | this.s00 >>> 9);
		var b0 = a0 ^ this.s10 ^ (a0 >>> 18 | a1 << 14) ^ (this.s10 >>> 5 | this.s11 << 27);
		var b1 = a1 ^ this.s11 ^ a1 >>> 18 ^ this.s11 >>> 5;
		var out = this.s00 + this.s10 | 0;
		this.s01 = this.s11;
		this.s00 = this.s10;
		this.s11 = b1;
		this.s10 = b0;
		return out;
	};
	XorShift128Plus$1.prototype.jump = function() {
		var nextRng = new XorShift128Plus$1(this.s01, this.s00, this.s11, this.s10);
		nextRng.unsafeJump();
		return nextRng;
	};
	XorShift128Plus$1.prototype.unsafeJump = function() {
		var ns01 = 0;
		var ns00 = 0;
		var ns11 = 0;
		var ns10 = 0;
		var jump = [
			1667051007,
			2321340297,
			1548169110,
			304075285
		];
		for (var i = 0; i !== 4; ++i) for (var mask = 1; mask; mask <<= 1) {
			if (jump[i] & mask) {
				ns01 ^= this.s01;
				ns00 ^= this.s00;
				ns11 ^= this.s11;
				ns10 ^= this.s10;
			}
			this.unsafeNext();
		}
		this.s01 = ns01;
		this.s00 = ns00;
		this.s11 = ns11;
		this.s10 = ns10;
	};
	XorShift128Plus$1.prototype.getState = function() {
		return [
			this.s01,
			this.s00,
			this.s11,
			this.s10
		];
	};
	return XorShift128Plus$1;
}();
function fromState$1(state) {
	var valid = state.length === 4;
	if (!valid) throw new Error("The state must have been produced by a xorshift128plus RandomGenerator");
	return new XorShift128Plus(state[0], state[1], state[2], state[3]);
}
var xorshift128plus = Object.assign(function(seed) {
	return new XorShift128Plus(-1, ~seed, seed | 0, 0);
}, { fromState: fromState$1 });

//#endregion
//#region ../../node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/generator/XoroShiro.js
var XoroShiro128Plus = function() {
	function XoroShiro128Plus$1(s01, s00, s11, s10) {
		this.s01 = s01;
		this.s00 = s00;
		this.s11 = s11;
		this.s10 = s10;
	}
	XoroShiro128Plus$1.prototype.clone = function() {
		return new XoroShiro128Plus$1(this.s01, this.s00, this.s11, this.s10);
	};
	XoroShiro128Plus$1.prototype.next = function() {
		var nextRng = new XoroShiro128Plus$1(this.s01, this.s00, this.s11, this.s10);
		var out = nextRng.unsafeNext();
		return [out, nextRng];
	};
	XoroShiro128Plus$1.prototype.unsafeNext = function() {
		var out = this.s00 + this.s10 | 0;
		var a0 = this.s10 ^ this.s00;
		var a1 = this.s11 ^ this.s01;
		var s00 = this.s00;
		var s01 = this.s01;
		this.s00 = s00 << 24 ^ s01 >>> 8 ^ a0 ^ a0 << 16;
		this.s01 = s01 << 24 ^ s00 >>> 8 ^ a1 ^ (a1 << 16 | a0 >>> 16);
		this.s10 = a1 << 5 ^ a0 >>> 27;
		this.s11 = a0 << 5 ^ a1 >>> 27;
		return out;
	};
	XoroShiro128Plus$1.prototype.jump = function() {
		var nextRng = new XoroShiro128Plus$1(this.s01, this.s00, this.s11, this.s10);
		nextRng.unsafeJump();
		return nextRng;
	};
	XoroShiro128Plus$1.prototype.unsafeJump = function() {
		var ns01 = 0;
		var ns00 = 0;
		var ns11 = 0;
		var ns10 = 0;
		var jump = [
			3639956645,
			3750757012,
			1261568508,
			386426335
		];
		for (var i = 0; i !== 4; ++i) for (var mask = 1; mask; mask <<= 1) {
			if (jump[i] & mask) {
				ns01 ^= this.s01;
				ns00 ^= this.s00;
				ns11 ^= this.s11;
				ns10 ^= this.s10;
			}
			this.unsafeNext();
		}
		this.s01 = ns01;
		this.s00 = ns00;
		this.s11 = ns11;
		this.s10 = ns10;
	};
	XoroShiro128Plus$1.prototype.getState = function() {
		return [
			this.s01,
			this.s00,
			this.s11,
			this.s10
		];
	};
	return XoroShiro128Plus$1;
}();
function fromState(state) {
	var valid = state.length === 4;
	if (!valid) throw new Error("The state must have been produced by a xoroshiro128plus RandomGenerator");
	return new XoroShiro128Plus(state[0], state[1], state[2], state[3]);
}
var xoroshiro128plus = Object.assign(function(seed) {
	return new XoroShiro128Plus(-1, ~seed, seed | 0, 0);
}, { fromState });

//#endregion
//#region ../../node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/distribution/internals/ArrayInt.js
function addArrayIntToNew(arrayIntA, arrayIntB) {
	if (arrayIntA.sign !== arrayIntB.sign) return substractArrayIntToNew(arrayIntA, {
		sign: -arrayIntB.sign,
		data: arrayIntB.data
	});
	var data = [];
	var reminder = 0;
	var dataA = arrayIntA.data;
	var dataB = arrayIntB.data;
	for (var indexA = dataA.length - 1, indexB = dataB.length - 1; indexA >= 0 || indexB >= 0; --indexA, --indexB) {
		var vA = indexA >= 0 ? dataA[indexA] : 0;
		var vB = indexB >= 0 ? dataB[indexB] : 0;
		var current = vA + vB + reminder;
		data.push(current >>> 0);
		reminder = ~~(current / 4294967296);
	}
	if (reminder !== 0) data.push(reminder);
	return {
		sign: arrayIntA.sign,
		data: data.reverse()
	};
}
function addOneToPositiveArrayInt(arrayInt) {
	arrayInt.sign = 1;
	var data = arrayInt.data;
	for (var index = data.length - 1; index >= 0; --index) if (data[index] === 4294967295) data[index] = 0;
	else {
		data[index] += 1;
		return arrayInt;
	}
	data.unshift(1);
	return arrayInt;
}
function isStrictlySmaller(dataA, dataB) {
	var maxLength = Math.max(dataA.length, dataB.length);
	for (var index = 0; index < maxLength; ++index) {
		var indexA = index + dataA.length - maxLength;
		var indexB = index + dataB.length - maxLength;
		var vA = indexA >= 0 ? dataA[indexA] : 0;
		var vB = indexB >= 0 ? dataB[indexB] : 0;
		if (vA < vB) return true;
		if (vA > vB) return false;
	}
	return false;
}
function substractArrayIntToNew(arrayIntA, arrayIntB) {
	if (arrayIntA.sign !== arrayIntB.sign) return addArrayIntToNew(arrayIntA, {
		sign: -arrayIntB.sign,
		data: arrayIntB.data
	});
	var dataA = arrayIntA.data;
	var dataB = arrayIntB.data;
	if (isStrictlySmaller(dataA, dataB)) {
		var out = substractArrayIntToNew(arrayIntB, arrayIntA);
		out.sign = -out.sign;
		return out;
	}
	var data = [];
	var reminder = 0;
	for (var indexA = dataA.length - 1, indexB = dataB.length - 1; indexA >= 0 || indexB >= 0; --indexA, --indexB) {
		var vA = indexA >= 0 ? dataA[indexA] : 0;
		var vB = indexB >= 0 ? dataB[indexB] : 0;
		var current = vA - vB - reminder;
		data.push(current >>> 0);
		reminder = current < 0 ? 1 : 0;
	}
	return {
		sign: arrayIntA.sign,
		data: data.reverse()
	};
}
function trimArrayIntInplace(arrayInt) {
	var data = arrayInt.data;
	var firstNonZero = 0;
	for (; firstNonZero !== data.length && data[firstNonZero] === 0; ++firstNonZero);
	if (firstNonZero === data.length) {
		arrayInt.sign = 1;
		arrayInt.data = [0];
		return arrayInt;
	}
	data.splice(0, firstNonZero);
	return arrayInt;
}
function fromNumberToArrayInt64(out, n) {
	if (n < 0) {
		var posN = -n;
		out.sign = -1;
		out.data[0] = ~~(posN / 4294967296);
		out.data[1] = posN >>> 0;
	} else {
		out.sign = 1;
		out.data[0] = ~~(n / 4294967296);
		out.data[1] = n >>> 0;
	}
	return out;
}
function substractArrayInt64(out, arrayIntA, arrayIntB) {
	var lowA = arrayIntA.data[1];
	var highA = arrayIntA.data[0];
	var signA = arrayIntA.sign;
	var lowB = arrayIntB.data[1];
	var highB = arrayIntB.data[0];
	var signB = arrayIntB.sign;
	out.sign = 1;
	if (signA === 1 && signB === -1) {
		var low_1 = lowA + lowB;
		var high = highA + highB + (low_1 > 4294967295 ? 1 : 0);
		out.data[0] = high >>> 0;
		out.data[1] = low_1 >>> 0;
		return out;
	}
	var lowFirst = lowA;
	var highFirst = highA;
	var lowSecond = lowB;
	var highSecond = highB;
	if (signA === -1) {
		lowFirst = lowB;
		highFirst = highB;
		lowSecond = lowA;
		highSecond = highA;
	}
	var reminderLow = 0;
	var low = lowFirst - lowSecond;
	if (low < 0) {
		reminderLow = 1;
		low = low >>> 0;
	}
	out.data[0] = highFirst - highSecond - reminderLow;
	out.data[1] = low;
	return out;
}

//#endregion
//#region ../../node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/distribution/internals/UnsafeUniformIntDistributionInternal.js
function unsafeUniformIntDistributionInternal(rangeSize, rng) {
	var MaxAllowed = rangeSize > 2 ? ~~(4294967296 / rangeSize) * rangeSize : 4294967296;
	var deltaV = rng.unsafeNext() + 2147483648;
	while (deltaV >= MaxAllowed) deltaV = rng.unsafeNext() + 2147483648;
	return deltaV % rangeSize;
}

//#endregion
//#region ../../node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/distribution/internals/UnsafeUniformArrayIntDistributionInternal.js
function unsafeUniformArrayIntDistributionInternal(out, rangeSize, rng) {
	var rangeLength = rangeSize.length;
	while (true) {
		for (var index = 0; index !== rangeLength; ++index) {
			var indexRangeSize = index === 0 ? rangeSize[0] + 1 : 4294967296;
			var g = unsafeUniformIntDistributionInternal(indexRangeSize, rng);
			out[index] = g;
		}
		for (var index = 0; index !== rangeLength; ++index) {
			var current = out[index];
			var currentInRange = rangeSize[index];
			if (current < currentInRange) return out;
			else if (current > currentInRange) break;
		}
	}
}

//#endregion
//#region ../../node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/distribution/UnsafeUniformArrayIntDistribution.js
function unsafeUniformArrayIntDistribution(from, to, rng) {
	var rangeSize = trimArrayIntInplace(addOneToPositiveArrayInt(substractArrayIntToNew(to, from)));
	var emptyArrayIntData = rangeSize.data.slice(0);
	var g = unsafeUniformArrayIntDistributionInternal(emptyArrayIntData, rangeSize.data, rng);
	return trimArrayIntInplace(addArrayIntToNew({
		sign: 1,
		data: g
	}, from));
}

//#endregion
//#region ../../node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/distribution/UniformArrayIntDistribution.js
function uniformArrayIntDistribution(from, to, rng) {
	if (rng != null) {
		var nextRng = rng.clone();
		return [unsafeUniformArrayIntDistribution(from, to, nextRng), nextRng];
	}
	return function(rng$1) {
		var nextRng$1 = rng$1.clone();
		return [unsafeUniformArrayIntDistribution(from, to, nextRng$1), nextRng$1];
	};
}

//#endregion
//#region ../../node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/distribution/UnsafeUniformBigIntDistribution.js
var SBigInt$1 = typeof BigInt !== "undefined" ? BigInt : void 0;
function unsafeUniformBigIntDistribution(from, to, rng) {
	var diff = to - from + SBigInt$1(1);
	var MinRng = SBigInt$1(-2147483648);
	var NumValues = SBigInt$1(4294967296);
	var FinalNumValues = NumValues;
	var NumIterations = 1;
	while (FinalNumValues < diff) {
		FinalNumValues *= NumValues;
		++NumIterations;
	}
	var MaxAcceptedRandom = FinalNumValues - FinalNumValues % diff;
	while (true) {
		var value = SBigInt$1(0);
		for (var num = 0; num !== NumIterations; ++num) {
			var out = rng.unsafeNext();
			value = NumValues * value + (SBigInt$1(out) - MinRng);
		}
		if (value < MaxAcceptedRandom) {
			var inDiff = value % diff;
			return inDiff + from;
		}
	}
}

//#endregion
//#region ../../node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/distribution/UniformBigIntDistribution.js
function uniformBigIntDistribution(from, to, rng) {
	if (rng != null) {
		var nextRng = rng.clone();
		return [unsafeUniformBigIntDistribution(from, to, nextRng), nextRng];
	}
	return function(rng$1) {
		var nextRng$1 = rng$1.clone();
		return [unsafeUniformBigIntDistribution(from, to, nextRng$1), nextRng$1];
	};
}

//#endregion
//#region ../../node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/distribution/UnsafeUniformIntDistribution.js
var safeNumberMaxSafeInteger = Number.MAX_SAFE_INTEGER;
var sharedA = {
	sign: 1,
	data: [0, 0]
};
var sharedB = {
	sign: 1,
	data: [0, 0]
};
var sharedC = {
	sign: 1,
	data: [0, 0]
};
var sharedData = [0, 0];
function uniformLargeIntInternal(from, to, rangeSize, rng) {
	var rangeSizeArrayIntValue = rangeSize <= safeNumberMaxSafeInteger ? fromNumberToArrayInt64(sharedC, rangeSize) : substractArrayInt64(sharedC, fromNumberToArrayInt64(sharedA, to), fromNumberToArrayInt64(sharedB, from));
	if (rangeSizeArrayIntValue.data[1] === 4294967295) {
		rangeSizeArrayIntValue.data[0] += 1;
		rangeSizeArrayIntValue.data[1] = 0;
	} else rangeSizeArrayIntValue.data[1] += 1;
	unsafeUniformArrayIntDistributionInternal(sharedData, rangeSizeArrayIntValue.data, rng);
	return sharedData[0] * 4294967296 + sharedData[1] + from;
}
function unsafeUniformIntDistribution(from, to, rng) {
	var rangeSize = to - from;
	if (rangeSize <= 4294967295) {
		var g = unsafeUniformIntDistributionInternal(rangeSize + 1, rng);
		return g + from;
	}
	return uniformLargeIntInternal(from, to, rangeSize, rng);
}

//#endregion
//#region ../../node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/distribution/UniformIntDistribution.js
function uniformIntDistribution(from, to, rng) {
	if (rng != null) {
		var nextRng = rng.clone();
		return [unsafeUniformIntDistribution(from, to, nextRng), nextRng];
	}
	return function(rng$1) {
		var nextRng$1 = rng$1.clone();
		return [unsafeUniformIntDistribution(from, to, nextRng$1), nextRng$1];
	};
}

//#endregion
//#region ../../node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/pure-rand-default.js
var pure_rand_default_exports = {};
__export(pure_rand_default_exports, {
	__commitHash: () => __commitHash,
	__type: () => __type,
	__version: () => __version,
	congruential32: () => congruential32,
	generateN: () => generateN,
	mersenne: () => MersenneTwister_default,
	skipN: () => skipN,
	uniformArrayIntDistribution: () => uniformArrayIntDistribution,
	uniformBigIntDistribution: () => uniformBigIntDistribution,
	uniformIntDistribution: () => uniformIntDistribution,
	unsafeGenerateN: () => unsafeGenerateN,
	unsafeSkipN: () => unsafeSkipN,
	unsafeUniformArrayIntDistribution: () => unsafeUniformArrayIntDistribution,
	unsafeUniformBigIntDistribution: () => unsafeUniformBigIntDistribution,
	unsafeUniformIntDistribution: () => unsafeUniformIntDistribution,
	xoroshiro128plus: () => xoroshiro128plus,
	xorshift128plus: () => xorshift128plus
});
var __type = "module";
var __version = "6.1.0";
var __commitHash = "a413dd2b721516be2ef29adffb515c5ae67bfbad";

//#endregion
//#region ../../node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/pure-rand.js
var pure_rand_default = pure_rand_default_exports;

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/configuration/VerbosityLevel.js
var VerbosityLevel;
(function(VerbosityLevel$1) {
	VerbosityLevel$1[VerbosityLevel$1["None"] = 0] = "None";
	VerbosityLevel$1[VerbosityLevel$1["Verbose"] = 1] = "Verbose";
	VerbosityLevel$1[VerbosityLevel$1["VeryVerbose"] = 2] = "VeryVerbose";
})(VerbosityLevel || (VerbosityLevel = {}));

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/configuration/QualifiedParameters.js
const safeDateNow$1 = Date.now;
const safeMathMin$5 = Math.min;
const safeMathRandom = Math.random;
var QualifiedParameters = class QualifiedParameters {
	constructor(op) {
		const p = op || {};
		this.seed = QualifiedParameters.readSeed(p);
		this.randomType = QualifiedParameters.readRandomType(p);
		this.numRuns = QualifiedParameters.readNumRuns(p);
		this.verbose = QualifiedParameters.readVerbose(p);
		this.maxSkipsPerRun = QualifiedParameters.readOrDefault(p, "maxSkipsPerRun", 100);
		this.timeout = QualifiedParameters.safeTimeout(QualifiedParameters.readOrDefault(p, "timeout", null));
		this.skipAllAfterTimeLimit = QualifiedParameters.safeTimeout(QualifiedParameters.readOrDefault(p, "skipAllAfterTimeLimit", null));
		this.interruptAfterTimeLimit = QualifiedParameters.safeTimeout(QualifiedParameters.readOrDefault(p, "interruptAfterTimeLimit", null));
		this.markInterruptAsFailure = QualifiedParameters.readBoolean(p, "markInterruptAsFailure");
		this.skipEqualValues = QualifiedParameters.readBoolean(p, "skipEqualValues");
		this.ignoreEqualValues = QualifiedParameters.readBoolean(p, "ignoreEqualValues");
		this.logger = QualifiedParameters.readOrDefault(p, "logger", (v) => {
			console.log(v);
		});
		this.path = QualifiedParameters.readOrDefault(p, "path", "");
		this.unbiased = QualifiedParameters.readBoolean(p, "unbiased");
		this.examples = QualifiedParameters.readOrDefault(p, "examples", []);
		this.endOnFailure = QualifiedParameters.readBoolean(p, "endOnFailure");
		this.reporter = QualifiedParameters.readOrDefault(p, "reporter", null);
		this.asyncReporter = QualifiedParameters.readOrDefault(p, "asyncReporter", null);
		this.errorWithCause = QualifiedParameters.readBoolean(p, "errorWithCause");
	}
	toParameters() {
		const orUndefined = (value) => value !== null ? value : void 0;
		const parameters = {
			seed: this.seed,
			randomType: this.randomType,
			numRuns: this.numRuns,
			maxSkipsPerRun: this.maxSkipsPerRun,
			timeout: orUndefined(this.timeout),
			skipAllAfterTimeLimit: orUndefined(this.skipAllAfterTimeLimit),
			interruptAfterTimeLimit: orUndefined(this.interruptAfterTimeLimit),
			markInterruptAsFailure: this.markInterruptAsFailure,
			skipEqualValues: this.skipEqualValues,
			ignoreEqualValues: this.ignoreEqualValues,
			path: this.path,
			logger: this.logger,
			unbiased: this.unbiased,
			verbose: this.verbose,
			examples: this.examples,
			endOnFailure: this.endOnFailure,
			reporter: orUndefined(this.reporter),
			asyncReporter: orUndefined(this.asyncReporter),
			errorWithCause: this.errorWithCause
		};
		return parameters;
	}
	static read(op) {
		return new QualifiedParameters(op);
	}
};
QualifiedParameters.createQualifiedRandomGenerator = (random) => {
	return (seed) => {
		const rng = random(seed);
		if (rng.unsafeJump === void 0) rng.unsafeJump = () => unsafeSkipN(rng, 42);
		return rng;
	};
};
QualifiedParameters.readSeed = (p) => {
	if (p.seed == null) return safeDateNow$1() ^ safeMathRandom() * 4294967296;
	const seed32 = p.seed | 0;
	if (p.seed === seed32) return seed32;
	const gap = p.seed - seed32;
	return seed32 ^ gap * 4294967296;
};
QualifiedParameters.readRandomType = (p) => {
	if (p.randomType == null) return pure_rand_default.xorshift128plus;
	if (typeof p.randomType === "string") switch (p.randomType) {
		case "mersenne": return QualifiedParameters.createQualifiedRandomGenerator(pure_rand_default.mersenne);
		case "congruential":
		case "congruential32": return QualifiedParameters.createQualifiedRandomGenerator(pure_rand_default.congruential32);
		case "xorshift128plus": return pure_rand_default.xorshift128plus;
		case "xoroshiro128plus": return pure_rand_default.xoroshiro128plus;
		default: throw new Error(`Invalid random specified: '${p.randomType}'`);
	}
	const mrng = p.randomType(0);
	if ("min" in mrng && mrng.min !== -2147483648) throw new Error(`Invalid random number generator: min must equal -0x80000000, got ${String(mrng.min)}`);
	if ("max" in mrng && mrng.max !== 2147483647) throw new Error(`Invalid random number generator: max must equal 0x7fffffff, got ${String(mrng.max)}`);
	if ("unsafeJump" in mrng) return p.randomType;
	return QualifiedParameters.createQualifiedRandomGenerator(p.randomType);
};
QualifiedParameters.readNumRuns = (p) => {
	const defaultValue = 100;
	if (p.numRuns != null) return p.numRuns;
	if (p.num_runs != null) return p.num_runs;
	return defaultValue;
};
QualifiedParameters.readVerbose = (p) => {
	if (p.verbose == null) return VerbosityLevel.None;
	if (typeof p.verbose === "boolean") return p.verbose === true ? VerbosityLevel.Verbose : VerbosityLevel.None;
	if (p.verbose <= VerbosityLevel.None) return VerbosityLevel.None;
	if (p.verbose >= VerbosityLevel.VeryVerbose) return VerbosityLevel.VeryVerbose;
	return p.verbose | 0;
};
QualifiedParameters.readBoolean = (p, key) => p[key] === true;
QualifiedParameters.readOrDefault = (p, key, defaultValue) => {
	const value = p[key];
	return value != null ? value : defaultValue;
};
QualifiedParameters.safeTimeout = (value) => {
	if (value === null) return null;
	return safeMathMin$5(value, 2147483647);
};

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/property/SkipAfterProperty.js
function interruptAfter(timeMs, setTimeoutSafe, clearTimeoutSafe) {
	let timeoutHandle = null;
	const promise = new Promise((resolve) => {
		timeoutHandle = setTimeoutSafe(() => {
			const preconditionFailure = new PreconditionFailure(true);
			resolve(preconditionFailure);
		}, timeMs);
	});
	return {
		clear: () => clearTimeoutSafe(timeoutHandle),
		promise
	};
}
var SkipAfterProperty = class {
	constructor(property$1, getTime, timeLimit, interruptExecution, setTimeoutSafe, clearTimeoutSafe) {
		this.property = property$1;
		this.getTime = getTime;
		this.interruptExecution = interruptExecution;
		this.setTimeoutSafe = setTimeoutSafe;
		this.clearTimeoutSafe = clearTimeoutSafe;
		this.skipAfterTime = this.getTime() + timeLimit;
		if (this.property.runBeforeEach !== void 0 && this.property.runAfterEach !== void 0) {
			this.runBeforeEach = () => this.property.runBeforeEach();
			this.runAfterEach = () => this.property.runAfterEach();
		}
	}
	isAsync() {
		return this.property.isAsync();
	}
	generate(mrng, runId) {
		return this.property.generate(mrng, runId);
	}
	shrink(value) {
		return this.property.shrink(value);
	}
	run(v, dontRunHook) {
		const remainingTime = this.skipAfterTime - this.getTime();
		if (remainingTime <= 0) {
			const preconditionFailure = new PreconditionFailure(this.interruptExecution);
			if (this.isAsync()) return Promise.resolve(preconditionFailure);
			else return preconditionFailure;
		}
		if (this.interruptExecution && this.isAsync()) {
			const t = interruptAfter(remainingTime, this.setTimeoutSafe, this.clearTimeoutSafe);
			const propRun = Promise.race([this.property.run(v, dontRunHook), t.promise]);
			propRun.then(t.clear, t.clear);
			return propRun;
		}
		return this.property.run(v, dontRunHook);
	}
};

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/property/TimeoutProperty.js
const timeoutAfter = (timeMs, setTimeoutSafe, clearTimeoutSafe) => {
	let timeoutHandle = null;
	const promise = new Promise((resolve) => {
		timeoutHandle = setTimeoutSafe(() => {
			resolve({
				error: new SError(`Property timeout: exceeded limit of ${timeMs} milliseconds`),
				errorMessage: `Property timeout: exceeded limit of ${timeMs} milliseconds`
			});
		}, timeMs);
	});
	return {
		clear: () => clearTimeoutSafe(timeoutHandle),
		promise
	};
};
var TimeoutProperty = class {
	constructor(property$1, timeMs, setTimeoutSafe, clearTimeoutSafe) {
		this.property = property$1;
		this.timeMs = timeMs;
		this.setTimeoutSafe = setTimeoutSafe;
		this.clearTimeoutSafe = clearTimeoutSafe;
		if (this.property.runBeforeEach !== void 0 && this.property.runAfterEach !== void 0) {
			this.runBeforeEach = () => Promise.resolve(this.property.runBeforeEach());
			this.runAfterEach = () => Promise.resolve(this.property.runAfterEach());
		}
	}
	isAsync() {
		return true;
	}
	generate(mrng, runId) {
		return this.property.generate(mrng, runId);
	}
	shrink(value) {
		return this.property.shrink(value);
	}
	async run(v, dontRunHook) {
		const t = timeoutAfter(this.timeMs, this.setTimeoutSafe, this.clearTimeoutSafe);
		const propRun = Promise.race([this.property.run(v, dontRunHook), t.promise]);
		propRun.then(t.clear, t.clear);
		return propRun;
	}
};

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/property/UnbiasedProperty.js
var UnbiasedProperty = class {
	constructor(property$1) {
		this.property = property$1;
		if (this.property.runBeforeEach !== void 0 && this.property.runAfterEach !== void 0) {
			this.runBeforeEach = () => this.property.runBeforeEach();
			this.runAfterEach = () => this.property.runAfterEach();
		}
	}
	isAsync() {
		return this.property.isAsync();
	}
	generate(mrng, _runId) {
		return this.property.generate(mrng, void 0);
	}
	shrink(value) {
		return this.property.shrink(value);
	}
	run(v, dontRunHook) {
		return this.property.run(v, dontRunHook);
	}
};

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/utils/stringify.js
const safeArrayFrom = Array.from;
const safeBufferIsBuffer = typeof Buffer !== "undefined" ? Buffer.isBuffer : void 0;
const safeJsonStringify = JSON.stringify;
const safeNumberIsNaN$5 = Number.isNaN;
const safeObjectKeys = Object.keys;
const safeObjectGetOwnPropertySymbols$1 = Object.getOwnPropertySymbols;
const safeObjectGetOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;
const safeObjectGetPrototypeOf$1 = Object.getPrototypeOf;
const safeNegativeInfinity$7 = Number.NEGATIVE_INFINITY;
const safePositiveInfinity$8 = Number.POSITIVE_INFINITY;
const toStringMethod = Symbol.for("fast-check/toStringMethod");
function hasToStringMethod(instance) {
	return instance !== null && (typeof instance === "object" || typeof instance === "function") && toStringMethod in instance && typeof instance[toStringMethod] === "function";
}
const asyncToStringMethod = Symbol.for("fast-check/asyncToStringMethod");
function hasAsyncToStringMethod(instance) {
	return instance !== null && (typeof instance === "object" || typeof instance === "function") && asyncToStringMethod in instance && typeof instance[asyncToStringMethod] === "function";
}
const findSymbolNameRegex = /^Symbol\((.*)\)$/;
function getSymbolDescription(s) {
	if (s.description !== void 0) return s.description;
	const m = findSymbolNameRegex.exec(SString(s));
	return m && m[1].length ? m[1] : null;
}
function stringifyNumber(numValue) {
	switch (numValue) {
		case 0: return 1 / numValue === safeNegativeInfinity$7 ? "-0" : "0";
		case safeNegativeInfinity$7: return "Number.NEGATIVE_INFINITY";
		case safePositiveInfinity$8: return "Number.POSITIVE_INFINITY";
		default: return numValue === numValue ? SString(numValue) : "Number.NaN";
	}
}
function isSparseArray(arr) {
	let previousNumberedIndex = -1;
	for (const index in arr) {
		const numberedIndex = Number(index);
		if (numberedIndex !== previousNumberedIndex + 1) return true;
		previousNumberedIndex = numberedIndex;
	}
	return previousNumberedIndex + 1 !== arr.length;
}
function stringifyInternal(value, previousValues, getAsyncContent) {
	const currentValues = [...previousValues, value];
	if (typeof value === "object") {
		if (safeIndexOf(previousValues, value) !== -1) return "[cyclic]";
	}
	if (hasAsyncToStringMethod(value)) {
		const content = getAsyncContent(value);
		if (content.state === "fulfilled") return content.value;
	}
	if (hasToStringMethod(value)) try {
		return value[toStringMethod]();
	} catch (err) {}
	switch (safeToString(value)) {
		case "[object Array]": {
			const arr = value;
			if (arr.length >= 50 && isSparseArray(arr)) {
				const assignments = [];
				for (const index in arr) if (!safeNumberIsNaN$5(Number(index))) safePush(assignments, `${index}:${stringifyInternal(arr[index], currentValues, getAsyncContent)}`);
				return assignments.length !== 0 ? `Object.assign(Array(${arr.length}),{${safeJoin(assignments, ",")}})` : `Array(${arr.length})`;
			}
			const stringifiedArray = safeJoin(safeMap(arr, (v) => stringifyInternal(v, currentValues, getAsyncContent)), ",");
			return arr.length === 0 || arr.length - 1 in arr ? `[${stringifiedArray}]` : `[${stringifiedArray},]`;
		}
		case "[object BigInt]": return `${value}n`;
		case "[object Boolean]": {
			const unboxedToString = value == true ? "true" : "false";
			return typeof value === "boolean" ? unboxedToString : `new Boolean(${unboxedToString})`;
		}
		case "[object Date]": {
			const d = value;
			return safeNumberIsNaN$5(safeGetTime(d)) ? `new Date(NaN)` : `new Date(${safeJsonStringify(safeToISOString(d))})`;
		}
		case "[object Map]": return `new Map(${stringifyInternal(Array.from(value), currentValues, getAsyncContent)})`;
		case "[object Null]": return `null`;
		case "[object Number]": return typeof value === "number" ? stringifyNumber(value) : `new Number(${stringifyNumber(Number(value))})`;
		case "[object Object]": {
			try {
				const toStringAccessor = value.toString;
				if (typeof toStringAccessor === "function" && toStringAccessor !== Object.prototype.toString) return value.toString();
			} catch (err) {
				return "[object Object]";
			}
			const mapper = (k) => `${k === "__proto__" ? "[\"__proto__\"]" : typeof k === "symbol" ? `[${stringifyInternal(k, currentValues, getAsyncContent)}]` : safeJsonStringify(k)}:${stringifyInternal(value[k], currentValues, getAsyncContent)}`;
			const stringifiedProperties = [...safeMap(safeObjectKeys(value), mapper), ...safeMap(safeFilter(safeObjectGetOwnPropertySymbols$1(value), (s) => {
				const descriptor = safeObjectGetOwnPropertyDescriptor$1(value, s);
				return descriptor && descriptor.enumerable;
			}), mapper)];
			const rawRepr = "{" + safeJoin(stringifiedProperties, ",") + "}";
			if (safeObjectGetPrototypeOf$1(value) === null) return rawRepr === "{}" ? "Object.create(null)" : `Object.assign(Object.create(null),${rawRepr})`;
			return rawRepr;
		}
		case "[object Set]": return `new Set(${stringifyInternal(Array.from(value), currentValues, getAsyncContent)})`;
		case "[object String]": return typeof value === "string" ? safeJsonStringify(value) : `new String(${safeJsonStringify(value)})`;
		case "[object Symbol]": {
			const s = value;
			if (SSymbol.keyFor(s) !== void 0) return `Symbol.for(${safeJsonStringify(SSymbol.keyFor(s))})`;
			const desc = getSymbolDescription(s);
			if (desc === null) return "Symbol()";
			const knownSymbol = desc.startsWith("Symbol.") && SSymbol[desc.substring(7)];
			return s === knownSymbol ? desc : `Symbol(${safeJsonStringify(desc)})`;
		}
		case "[object Promise]": {
			const promiseContent = getAsyncContent(value);
			switch (promiseContent.state) {
				case "fulfilled": return `Promise.resolve(${stringifyInternal(promiseContent.value, currentValues, getAsyncContent)})`;
				case "rejected": return `Promise.reject(${stringifyInternal(promiseContent.value, currentValues, getAsyncContent)})`;
				case "pending": return `new Promise(() => {/*pending*/})`;
				case "unknown":
				default: return `new Promise(() => {/*unknown*/})`;
			}
		}
		case "[object Error]":
			if (value instanceof Error) return `new Error(${stringifyInternal(value.message, currentValues, getAsyncContent)})`;
			break;
		case "[object Undefined]": return `undefined`;
		case "[object Int8Array]":
		case "[object Uint8Array]":
		case "[object Uint8ClampedArray]":
		case "[object Int16Array]":
		case "[object Uint16Array]":
		case "[object Int32Array]":
		case "[object Uint32Array]":
		case "[object Float32Array]":
		case "[object Float64Array]":
		case "[object BigInt64Array]":
		case "[object BigUint64Array]": {
			if (typeof safeBufferIsBuffer === "function" && safeBufferIsBuffer(value)) return `Buffer.from(${stringifyInternal(safeArrayFrom(value.values()), currentValues, getAsyncContent)})`;
			const valuePrototype = safeObjectGetPrototypeOf$1(value);
			const className = valuePrototype && valuePrototype.constructor && valuePrototype.constructor.name;
			if (typeof className === "string") {
				const typedArray$1 = value;
				const valuesFromTypedArr = typedArray$1.values();
				return `${className}.from(${stringifyInternal(safeArrayFrom(valuesFromTypedArr), currentValues, getAsyncContent)})`;
			}
			break;
		}
	}
	try {
		return value.toString();
	} catch (_a) {
		return safeToString(value);
	}
}
function stringify(value) {
	return stringifyInternal(value, [], () => ({
		state: "unknown",
		value: void 0
	}));
}
function possiblyAsyncStringify(value) {
	const stillPendingMarker = SSymbol();
	const pendingPromisesForCache = [];
	const cache = new SMap();
	function createDelay0() {
		let handleId = null;
		const cancel = () => {
			if (handleId !== null) clearTimeout(handleId);
		};
		const delay = new Promise((resolve) => {
			handleId = setTimeout(() => {
				handleId = null;
				resolve(stillPendingMarker);
			}, 0);
		});
		return {
			delay,
			cancel
		};
	}
	const unknownState = {
		state: "unknown",
		value: void 0
	};
	const getAsyncContent = function getAsyncContent$1(data) {
		const cacheKey = data;
		if (cache.has(cacheKey)) return cache.get(cacheKey);
		const delay0 = createDelay0();
		const p = asyncToStringMethod in data ? Promise.resolve().then(() => data[asyncToStringMethod]()) : data;
		p.catch(() => {});
		pendingPromisesForCache.push(Promise.race([p, delay0.delay]).then((successValue) => {
			if (successValue === stillPendingMarker) cache.set(cacheKey, {
				state: "pending",
				value: void 0
			});
			else cache.set(cacheKey, {
				state: "fulfilled",
				value: successValue
			});
			delay0.cancel();
		}, (errorValue) => {
			cache.set(cacheKey, {
				state: "rejected",
				value: errorValue
			});
			delay0.cancel();
		}));
		cache.set(cacheKey, unknownState);
		return unknownState;
	};
	function loop() {
		const stringifiedValue = stringifyInternal(value, [], getAsyncContent);
		if (pendingPromisesForCache.length === 0) return stringifiedValue;
		return Promise.all(pendingPromisesForCache.splice(0)).then(loop);
	}
	return loop();
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/property/IgnoreEqualValuesProperty.js
function fromSyncCached(cachedValue) {
	return cachedValue === null ? new PreconditionFailure() : cachedValue;
}
function fromCached(...data) {
	if (data[1]) return data[0].then(fromSyncCached);
	return fromSyncCached(data[0]);
}
function fromCachedUnsafe(cachedValue, isAsync) {
	return fromCached(cachedValue, isAsync);
}
var IgnoreEqualValuesProperty = class {
	constructor(property$1, skipRuns) {
		this.property = property$1;
		this.skipRuns = skipRuns;
		this.coveredCases = /* @__PURE__ */ new Map();
		if (this.property.runBeforeEach !== void 0 && this.property.runAfterEach !== void 0) {
			this.runBeforeEach = () => this.property.runBeforeEach();
			this.runAfterEach = () => this.property.runAfterEach();
		}
	}
	isAsync() {
		return this.property.isAsync();
	}
	generate(mrng, runId) {
		return this.property.generate(mrng, runId);
	}
	shrink(value) {
		return this.property.shrink(value);
	}
	run(v, dontRunHook) {
		const stringifiedValue = stringify(v);
		if (this.coveredCases.has(stringifiedValue)) {
			const lastOutput = this.coveredCases.get(stringifiedValue);
			if (!this.skipRuns) return lastOutput;
			return fromCachedUnsafe(lastOutput, this.property.isAsync());
		}
		const out = this.property.run(v, dontRunHook);
		this.coveredCases.set(stringifiedValue, out);
		return out;
	}
};

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/DecorateProperty.js
const safeDateNow = Date.now;
const safeSetTimeout = setTimeout;
const safeClearTimeout = clearTimeout;
function decorateProperty(rawProperty, qParams) {
	let prop = rawProperty;
	if (rawProperty.isAsync() && qParams.timeout != null) prop = new TimeoutProperty(prop, qParams.timeout, safeSetTimeout, safeClearTimeout);
	if (qParams.unbiased) prop = new UnbiasedProperty(prop);
	if (qParams.skipAllAfterTimeLimit != null) prop = new SkipAfterProperty(prop, safeDateNow, qParams.skipAllAfterTimeLimit, false, safeSetTimeout, safeClearTimeout);
	if (qParams.interruptAfterTimeLimit != null) prop = new SkipAfterProperty(prop, safeDateNow, qParams.interruptAfterTimeLimit, true, safeSetTimeout, safeClearTimeout);
	if (qParams.skipEqualValues) prop = new IgnoreEqualValuesProperty(prop, true);
	if (qParams.ignoreEqualValues) prop = new IgnoreEqualValuesProperty(prop, false);
	return prop;
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/reporter/ExecutionStatus.js
var ExecutionStatus;
(function(ExecutionStatus$1) {
	ExecutionStatus$1[ExecutionStatus$1["Success"] = 0] = "Success";
	ExecutionStatus$1[ExecutionStatus$1["Skipped"] = -1] = "Skipped";
	ExecutionStatus$1[ExecutionStatus$1["Failure"] = 1] = "Failure";
})(ExecutionStatus || (ExecutionStatus = {}));

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/reporter/RunExecution.js
var RunExecution = class RunExecution {
	constructor(verbosity, interruptedAsFailure) {
		this.verbosity = verbosity;
		this.interruptedAsFailure = interruptedAsFailure;
		this.isSuccess = () => this.pathToFailure == null;
		this.firstFailure = () => this.pathToFailure ? +safeSplit(this.pathToFailure, ":")[0] : -1;
		this.numShrinks = () => this.pathToFailure ? safeSplit(this.pathToFailure, ":").length - 1 : 0;
		this.rootExecutionTrees = [];
		this.currentLevelExecutionTrees = this.rootExecutionTrees;
		this.failure = null;
		this.numSkips = 0;
		this.numSuccesses = 0;
		this.interrupted = false;
	}
	appendExecutionTree(status, value) {
		const currentTree = {
			status,
			value,
			children: []
		};
		this.currentLevelExecutionTrees.push(currentTree);
		return currentTree;
	}
	fail(value, id, failure) {
		if (this.verbosity >= VerbosityLevel.Verbose) {
			const currentTree = this.appendExecutionTree(ExecutionStatus.Failure, value);
			this.currentLevelExecutionTrees = currentTree.children;
		}
		if (this.pathToFailure == null) this.pathToFailure = `${id}`;
		else this.pathToFailure += `:${id}`;
		this.value = value;
		this.failure = failure;
	}
	skip(value) {
		if (this.verbosity >= VerbosityLevel.VeryVerbose) this.appendExecutionTree(ExecutionStatus.Skipped, value);
		if (this.pathToFailure == null) ++this.numSkips;
	}
	success(value) {
		if (this.verbosity >= VerbosityLevel.VeryVerbose) this.appendExecutionTree(ExecutionStatus.Success, value);
		if (this.pathToFailure == null) ++this.numSuccesses;
	}
	interrupt() {
		this.interrupted = true;
	}
	extractFailures() {
		if (this.isSuccess()) return [];
		const failures = [];
		let cursor = this.rootExecutionTrees;
		while (cursor.length > 0 && cursor[cursor.length - 1].status === ExecutionStatus.Failure) {
			const failureTree = cursor[cursor.length - 1];
			failures.push(failureTree.value);
			cursor = failureTree.children;
		}
		return failures;
	}
	toRunDetails(seed, basePath, maxSkips, qParams) {
		if (!this.isSuccess()) return {
			failed: true,
			interrupted: this.interrupted,
			numRuns: this.firstFailure() + 1 - this.numSkips,
			numSkips: this.numSkips,
			numShrinks: this.numShrinks(),
			seed,
			counterexample: this.value,
			counterexamplePath: RunExecution.mergePaths(basePath, this.pathToFailure),
			error: this.failure.errorMessage,
			errorInstance: this.failure.error,
			failures: this.extractFailures(),
			executionSummary: this.rootExecutionTrees,
			verbose: this.verbosity,
			runConfiguration: qParams.toParameters()
		};
		const considerInterruptedAsFailure = this.interruptedAsFailure || this.numSuccesses === 0;
		const failed = this.numSkips > maxSkips || this.interrupted && considerInterruptedAsFailure;
		const out = {
			failed,
			interrupted: this.interrupted,
			numRuns: this.numSuccesses,
			numSkips: this.numSkips,
			numShrinks: 0,
			seed,
			counterexample: null,
			counterexamplePath: null,
			error: null,
			errorInstance: null,
			failures: [],
			executionSummary: this.rootExecutionTrees,
			verbose: this.verbosity,
			runConfiguration: qParams.toParameters()
		};
		return out;
	}
};
RunExecution.mergePaths = (offsetPath, path) => {
	if (offsetPath.length === 0) return path;
	const offsetItems = offsetPath.split(":");
	const remainingItems = path.split(":");
	const middle = +offsetItems[offsetItems.length - 1] + +remainingItems[0];
	return [
		...offsetItems.slice(0, offsetItems.length - 1),
		`${middle}`,
		...remainingItems.slice(1)
	].join(":");
};

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/RunnerIterator.js
var RunnerIterator = class {
	constructor(sourceValues, shrink, verbose, interruptedAsFailure) {
		this.sourceValues = sourceValues;
		this.shrink = shrink;
		this.runExecution = new RunExecution(verbose, interruptedAsFailure);
		this.currentIdx = -1;
		this.nextValues = sourceValues;
	}
	[Symbol.iterator]() {
		return this;
	}
	next() {
		const nextValue = this.nextValues.next();
		if (nextValue.done || this.runExecution.interrupted) return {
			done: true,
			value: void 0
		};
		this.currentValue = nextValue.value;
		++this.currentIdx;
		return {
			done: false,
			value: nextValue.value.value_
		};
	}
	handleResult(result) {
		if (result != null && typeof result === "object" && !PreconditionFailure.isFailure(result)) {
			this.runExecution.fail(this.currentValue.value_, this.currentIdx, result);
			this.currentIdx = -1;
			this.nextValues = this.shrink(this.currentValue);
		} else if (result != null) if (!result.interruptExecution) {
			this.runExecution.skip(this.currentValue.value_);
			this.sourceValues.skippedOne();
		} else this.runExecution.interrupt();
		else this.runExecution.success(this.currentValue.value_);
	}
};

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/SourceValuesIterator.js
var SourceValuesIterator = class {
	constructor(initialValues, maxInitialIterations, remainingSkips) {
		this.initialValues = initialValues;
		this.maxInitialIterations = maxInitialIterations;
		this.remainingSkips = remainingSkips;
	}
	[Symbol.iterator]() {
		return this;
	}
	next() {
		if (--this.maxInitialIterations !== -1 && this.remainingSkips >= 0) {
			const n = this.initialValues.next();
			if (!n.done) return {
				value: n.value,
				done: false
			};
		}
		return {
			value: void 0,
			done: true
		};
	}
	skippedOne() {
		--this.remainingSkips;
		++this.maxInitialIterations;
	}
};

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/random/generator/Random.js
var Random = class Random {
	constructor(sourceRng) {
		this.internalRng = sourceRng.clone();
	}
	clone() {
		return new Random(this.internalRng);
	}
	next(bits) {
		return unsafeUniformIntDistribution(0, (1 << bits) - 1, this.internalRng);
	}
	nextBoolean() {
		return unsafeUniformIntDistribution(0, 1, this.internalRng) == 1;
	}
	nextInt(min, max) {
		return unsafeUniformIntDistribution(min == null ? Random.MIN_INT : min, max == null ? Random.MAX_INT : max, this.internalRng);
	}
	nextBigInt(min, max) {
		return unsafeUniformBigIntDistribution(min, max, this.internalRng);
	}
	nextArrayInt(min, max) {
		return unsafeUniformArrayIntDistribution(min, max, this.internalRng);
	}
	nextDouble() {
		const a = this.next(26);
		const b = this.next(27);
		return (a * Random.DBL_FACTOR + b) * Random.DBL_DIVISOR;
	}
	getState() {
		if ("getState" in this.internalRng && typeof this.internalRng.getState === "function") return this.internalRng.getState();
		return void 0;
	}
};
Random.MIN_INT = -2147483648;
Random.MAX_INT = 2147483647;
Random.DBL_FACTOR = Math.pow(2, 27);
Random.DBL_DIVISOR = Math.pow(2, -53);

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/Tosser.js
function tossNext(generator, rng, index) {
	rng.unsafeJump();
	return generator.generate(new Random(rng), index);
}
function* toss(generator, seed, random, examples) {
	for (let idx = 0; idx !== examples.length; ++idx) yield new Value(examples[idx], void 0);
	for (let idx = 0, rng = random(seed);; ++idx) yield tossNext(generator, rng, idx);
}
function lazyGenerate(generator, rng, idx) {
	return () => generator.generate(new Random(rng), idx);
}
function* lazyToss(generator, seed, random, examples) {
	yield* safeMap(examples, (e) => () => new Value(e, void 0));
	let idx = 0;
	let rng = random(seed);
	for (;;) {
		rng = rng.jump ? rng.jump() : skipN(rng, 42);
		yield lazyGenerate(generator, rng, idx++);
	}
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/utils/PathWalker.js
function produce(producer) {
	return producer();
}
function pathWalk(path, initialProducers, shrink) {
	const producers = initialProducers;
	const segments = path.split(":").map((text) => +text);
	if (segments.length === 0) return producers.map(produce);
	if (!segments.every((v) => !Number.isNaN(v))) throw new Error(`Unable to replay, got invalid path=${path}`);
	let values = producers.drop(segments[0]).map(produce);
	for (const s of segments.slice(1)) {
		const valueToShrink = values.getNthOrLast(0);
		if (valueToShrink === null) throw new Error(`Unable to replay, got wrong path=${path}`);
		values = shrink(valueToShrink).drop(s);
	}
	return values;
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/utils/RunDetailsFormatter.js
const safeObjectAssign$3 = Object.assign;
function formatHints(hints) {
	if (hints.length === 1) return `Hint: ${hints[0]}`;
	return hints.map((h, idx) => `Hint (${idx + 1}): ${h}`).join("\n");
}
function formatFailures(failures, stringifyOne) {
	return `Encountered failures were:\n- ${failures.map(stringifyOne).join("\n- ")}`;
}
function formatExecutionSummary(executionTrees, stringifyOne) {
	const summaryLines = [];
	const remainingTreesAndDepth = [];
	for (const tree of executionTrees.slice().reverse()) remainingTreesAndDepth.push({
		depth: 1,
		tree
	});
	while (remainingTreesAndDepth.length !== 0) {
		const currentTreeAndDepth = remainingTreesAndDepth.pop();
		const currentTree = currentTreeAndDepth.tree;
		const currentDepth = currentTreeAndDepth.depth;
		const statusIcon = currentTree.status === ExecutionStatus.Success ? "\x1B[32m\x1B[0m" : currentTree.status === ExecutionStatus.Failure ? "\x1B[31m\x1B[0m" : "\x1B[33m!\x1B[0m";
		const leftPadding = Array(currentDepth).join(". ");
		summaryLines.push(`${leftPadding}${statusIcon} ${stringifyOne(currentTree.value)}`);
		for (const tree of currentTree.children.slice().reverse()) remainingTreesAndDepth.push({
			depth: currentDepth + 1,
			tree
		});
	}
	return `Execution summary:\n${summaryLines.join("\n")}`;
}
function preFormatTooManySkipped(out, stringifyOne) {
	const message = `Failed to run property, too many pre-condition failures encountered\n{ seed: ${out.seed} }\n\nRan ${out.numRuns} time(s)\nSkipped ${out.numSkips} time(s)`;
	let details = null;
	const hints = ["Try to reduce the number of rejected values by combining map, flatMap and built-in arbitraries", "Increase failure tolerance by setting maxSkipsPerRun to an higher value"];
	if (out.verbose >= VerbosityLevel.VeryVerbose) details = formatExecutionSummary(out.executionSummary, stringifyOne);
	else safePush(hints, "Enable verbose mode at level VeryVerbose in order to check all generated values and their associated status");
	return {
		message,
		details,
		hints
	};
}
function preFormatFailure(out, stringifyOne) {
	const noErrorInMessage = out.runConfiguration.errorWithCause;
	const messageErrorPart = noErrorInMessage ? "" : `\nGot ${safeReplace(out.error, /^Error: /, "error: ")}`;
	const message = `Property failed after ${out.numRuns} tests\n{ seed: ${out.seed}, path: "${out.counterexamplePath}", endOnFailure: true }\nCounterexample: ${stringifyOne(out.counterexample)}\nShrunk ${out.numShrinks} time(s)${messageErrorPart}`;
	let details = null;
	const hints = [];
	if (out.verbose >= VerbosityLevel.VeryVerbose) details = formatExecutionSummary(out.executionSummary, stringifyOne);
	else if (out.verbose === VerbosityLevel.Verbose) details = formatFailures(out.failures, stringifyOne);
	else safePush(hints, "Enable verbose mode in order to have the list of all failing values encountered during the run");
	return {
		message,
		details,
		hints
	};
}
function preFormatEarlyInterrupted(out, stringifyOne) {
	const message = `Property interrupted after ${out.numRuns} tests\n{ seed: ${out.seed} }`;
	let details = null;
	const hints = [];
	if (out.verbose >= VerbosityLevel.VeryVerbose) details = formatExecutionSummary(out.executionSummary, stringifyOne);
	else safePush(hints, "Enable verbose mode at level VeryVerbose in order to check all generated values and their associated status");
	return {
		message,
		details,
		hints
	};
}
function defaultReportMessageInternal(out, stringifyOne) {
	if (!out.failed) return;
	const { message, details, hints } = out.counterexamplePath === null ? out.interrupted ? preFormatEarlyInterrupted(out, stringifyOne) : preFormatTooManySkipped(out, stringifyOne) : preFormatFailure(out, stringifyOne);
	let errorMessage = message;
	if (details != null) errorMessage += `\n\n${details}`;
	if (hints.length > 0) errorMessage += `\n\n${formatHints(hints)}`;
	return errorMessage;
}
function defaultReportMessage(out) {
	return defaultReportMessageInternal(out, stringify);
}
async function asyncDefaultReportMessage(out) {
	const pendingStringifieds = [];
	function stringifyOne(value) {
		const stringified = possiblyAsyncStringify(value);
		if (typeof stringified === "string") return stringified;
		pendingStringifieds.push(Promise.all([value, stringified]));
		return "";
	}
	const firstTryMessage = defaultReportMessageInternal(out, stringifyOne);
	if (pendingStringifieds.length === 0) return firstTryMessage;
	const registeredValues = new SMap(await Promise.all(pendingStringifieds));
	function stringifySecond(value) {
		const asyncStringifiedIfRegistered = safeMapGet(registeredValues, value);
		if (asyncStringifiedIfRegistered !== void 0) return asyncStringifiedIfRegistered;
		return stringify(value);
	}
	return defaultReportMessageInternal(out, stringifySecond);
}
function buildError(errorMessage, out) {
	if (!out.runConfiguration.errorWithCause) throw new SError(errorMessage);
	const ErrorWithCause = SError;
	const error = new ErrorWithCause(errorMessage, { cause: out.errorInstance });
	if (!("cause" in error)) safeObjectAssign$3(error, { cause: out.errorInstance });
	return error;
}
function throwIfFailed(out) {
	if (!out.failed) return;
	throw buildError(defaultReportMessage(out), out);
}
async function asyncThrowIfFailed(out) {
	if (!out.failed) return;
	throw buildError(await asyncDefaultReportMessage(out), out);
}
function reportRunDetails(out) {
	if (out.runConfiguration.asyncReporter) return out.runConfiguration.asyncReporter(out);
	else if (out.runConfiguration.reporter) return out.runConfiguration.reporter(out);
	else return throwIfFailed(out);
}
async function asyncReportRunDetails(out) {
	if (out.runConfiguration.asyncReporter) return out.runConfiguration.asyncReporter(out);
	else if (out.runConfiguration.reporter) return out.runConfiguration.reporter(out);
	else return asyncThrowIfFailed(out);
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/Runner.js
const safeObjectAssign$2 = Object.assign;
function runIt(property$1, shrink, sourceValues, verbose, interruptedAsFailure) {
	const isModernProperty = property$1.runBeforeEach !== void 0 && property$1.runAfterEach !== void 0;
	const runner = new RunnerIterator(sourceValues, shrink, verbose, interruptedAsFailure);
	for (const v of runner) {
		if (isModernProperty) property$1.runBeforeEach();
		const out = property$1.run(v, isModernProperty);
		if (isModernProperty) property$1.runAfterEach();
		runner.handleResult(out);
	}
	return runner.runExecution;
}
async function asyncRunIt(property$1, shrink, sourceValues, verbose, interruptedAsFailure) {
	const isModernProperty = property$1.runBeforeEach !== void 0 && property$1.runAfterEach !== void 0;
	const runner = new RunnerIterator(sourceValues, shrink, verbose, interruptedAsFailure);
	for (const v of runner) {
		if (isModernProperty) await property$1.runBeforeEach();
		const out = await property$1.run(v, isModernProperty);
		if (isModernProperty) await property$1.runAfterEach();
		runner.handleResult(out);
	}
	return runner.runExecution;
}
function check(rawProperty, params) {
	if (rawProperty == null || rawProperty.generate == null) throw new Error("Invalid property encountered, please use a valid property");
	if (rawProperty.run == null) throw new Error("Invalid property encountered, please use a valid property not an arbitrary");
	const qParams = QualifiedParameters.read(safeObjectAssign$2(safeObjectAssign$2({}, readConfigureGlobal()), params));
	if (qParams.reporter !== null && qParams.asyncReporter !== null) throw new Error("Invalid parameters encountered, reporter and asyncReporter cannot be specified together");
	if (qParams.asyncReporter !== null && !rawProperty.isAsync()) throw new Error("Invalid parameters encountered, only asyncProperty can be used when asyncReporter specified");
	const property$1 = decorateProperty(rawProperty, qParams);
	const maxInitialIterations = qParams.path.length === 0 || qParams.path.indexOf(":") === -1 ? qParams.numRuns : -1;
	const maxSkips = qParams.numRuns * qParams.maxSkipsPerRun;
	const shrink = (...args) => property$1.shrink(...args);
	const initialValues = qParams.path.length === 0 ? toss(property$1, qParams.seed, qParams.randomType, qParams.examples) : pathWalk(qParams.path, stream(lazyToss(property$1, qParams.seed, qParams.randomType, qParams.examples)), shrink);
	const sourceValues = new SourceValuesIterator(initialValues, maxInitialIterations, maxSkips);
	const finalShrink = !qParams.endOnFailure ? shrink : Stream.nil;
	return property$1.isAsync() ? asyncRunIt(property$1, finalShrink, sourceValues, qParams.verbose, qParams.markInterruptAsFailure).then((e) => e.toRunDetails(qParams.seed, qParams.path, maxSkips, qParams)) : runIt(property$1, finalShrink, sourceValues, qParams.verbose, qParams.markInterruptAsFailure).toRunDetails(qParams.seed, qParams.path, maxSkips, qParams);
}
function assert$1(property$1, params) {
	const out = check(property$1, params);
	if (property$1.isAsync()) return out.then(asyncReportRunDetails);
	else reportRunDetails(out);
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/BiasNumericRange.js
const safeMathFloor$4 = Math.floor;
const safeMathLog$1 = Math.log;
function integerLogLike(v) {
	return safeMathFloor$4(safeMathLog$1(v) / safeMathLog$1(2));
}
function bigIntLogLike(v) {
	if (v === SBigInt(0)) return SBigInt(0);
	return SBigInt(SString(v).length);
}
function biasNumericRange(min, max, logLike) {
	if (min === max) return [{
		min,
		max
	}];
	if (min < 0 && max > 0) {
		const logMin = logLike(-min);
		const logMax = logLike(max);
		return [
			{
				min: -logMin,
				max: logMax
			},
			{
				min: max - logMax,
				max
			},
			{
				min,
				max: min + logMin
			}
		];
	}
	const logGap = logLike(max - min);
	const arbCloseToMin = {
		min,
		max: min + logGap
	};
	const arbCloseToMax = {
		min: max - logGap,
		max
	};
	return min < 0 ? [arbCloseToMax, arbCloseToMin] : [arbCloseToMin, arbCloseToMax];
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/ShrinkInteger.js
const safeMathCeil = Math.ceil;
const safeMathFloor$3 = Math.floor;
function halvePosInteger(n) {
	return safeMathFloor$3(n / 2);
}
function halveNegInteger(n) {
	return safeMathCeil(n / 2);
}
function shrinkInteger(current, target, tryTargetAsap) {
	const realGap = current - target;
	function* shrinkDecr() {
		let previous = tryTargetAsap ? void 0 : target;
		const gap = tryTargetAsap ? realGap : halvePosInteger(realGap);
		for (let toremove = gap; toremove > 0; toremove = halvePosInteger(toremove)) {
			const next = toremove === realGap ? target : current - toremove;
			yield new Value(next, previous);
			previous = next;
		}
	}
	function* shrinkIncr() {
		let previous = tryTargetAsap ? void 0 : target;
		const gap = tryTargetAsap ? realGap : halveNegInteger(realGap);
		for (let toremove = gap; toremove < 0; toremove = halveNegInteger(toremove)) {
			const next = toremove === realGap ? target : current - toremove;
			yield new Value(next, previous);
			previous = next;
		}
	}
	return realGap > 0 ? stream(shrinkDecr()) : stream(shrinkIncr());
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/IntegerArbitrary.js
const safeMathSign = Math.sign;
const safeNumberIsInteger$6 = Number.isInteger;
const safeObjectIs$4 = Object.is;
var IntegerArbitrary = class IntegerArbitrary extends Arbitrary {
	constructor(min, max) {
		super();
		this.min = min;
		this.max = max;
	}
	generate(mrng, biasFactor) {
		const range = this.computeGenerateRange(mrng, biasFactor);
		return new Value(mrng.nextInt(range.min, range.max), void 0);
	}
	canShrinkWithoutContext(value) {
		return typeof value === "number" && safeNumberIsInteger$6(value) && !safeObjectIs$4(value, -0) && this.min <= value && value <= this.max;
	}
	shrink(current, context) {
		if (!IntegerArbitrary.isValidContext(current, context)) {
			const target = this.defaultTarget();
			return shrinkInteger(current, target, true);
		}
		if (this.isLastChanceTry(current, context)) return Stream.of(new Value(context, void 0));
		return shrinkInteger(current, context, false);
	}
	defaultTarget() {
		if (this.min <= 0 && this.max >= 0) return 0;
		return this.min < 0 ? this.max : this.min;
	}
	computeGenerateRange(mrng, biasFactor) {
		if (biasFactor === void 0 || mrng.nextInt(1, biasFactor) !== 1) return {
			min: this.min,
			max: this.max
		};
		const ranges = biasNumericRange(this.min, this.max, integerLogLike);
		if (ranges.length === 1) return ranges[0];
		const id = mrng.nextInt(-2 * (ranges.length - 1), ranges.length - 2);
		return id < 0 ? ranges[0] : ranges[id + 1];
	}
	isLastChanceTry(current, context) {
		if (current > 0) return current === context + 1 && current > this.min;
		if (current < 0) return current === context - 1 && current < this.max;
		return false;
	}
	static isValidContext(current, context) {
		if (context === void 0) return false;
		if (typeof context !== "number") throw new Error(`Invalid context type passed to IntegerArbitrary (#1)`);
		if (context !== 0 && safeMathSign(current) !== safeMathSign(context)) throw new Error(`Invalid context value passed to IntegerArbitrary (#2)`);
		return true;
	}
};

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/integer.js
const safeNumberIsInteger$5 = Number.isInteger;
function buildCompleteIntegerConstraints(constraints) {
	const min = constraints.min !== void 0 ? constraints.min : -2147483648;
	const max = constraints.max !== void 0 ? constraints.max : 2147483647;
	return {
		min,
		max
	};
}
function integer(constraints = {}) {
	const fullConstraints = buildCompleteIntegerConstraints(constraints);
	if (fullConstraints.min > fullConstraints.max) throw new Error("fc.integer maximum value should be equal or greater than the minimum one");
	if (!safeNumberIsInteger$5(fullConstraints.min)) throw new Error("fc.integer minimum value should be an integer");
	if (!safeNumberIsInteger$5(fullConstraints.max)) throw new Error("fc.integer maximum value should be an integer");
	return new IntegerArbitrary(fullConstraints.min, fullConstraints.max);
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/DepthContext.js
const depthContextCache = /* @__PURE__ */ new Map();
function getDepthContextFor(contextMeta) {
	if (contextMeta === void 0) return { depth: 0 };
	if (typeof contextMeta !== "string") return contextMeta;
	const cachedContext = safeMapGet(depthContextCache, contextMeta);
	if (cachedContext !== void 0) return cachedContext;
	const context = { depth: 0 };
	safeMapSet(depthContextCache, contextMeta, context);
	return context;
}
function createDepthIdentifier() {
	const identifier = { depth: 0 };
	return identifier;
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/implementations/NoopSlicedGenerator.js
var NoopSlicedGenerator = class {
	constructor(arb, mrng, biasFactor) {
		this.arb = arb;
		this.mrng = mrng;
		this.biasFactor = biasFactor;
	}
	attemptExact() {
		return;
	}
	next() {
		return this.arb.generate(this.mrng, this.biasFactor);
	}
};

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/implementations/SlicedBasedGenerator.js
const safeMathMin$4 = Math.min;
const safeMathMax$3 = Math.max;
var SlicedBasedGenerator = class {
	constructor(arb, mrng, slices, biasFactor) {
		this.arb = arb;
		this.mrng = mrng;
		this.slices = slices;
		this.biasFactor = biasFactor;
		this.activeSliceIndex = 0;
		this.nextIndexInSlice = 0;
		this.lastIndexInSlice = -1;
	}
	attemptExact(targetLength) {
		if (targetLength !== 0 && this.mrng.nextInt(1, this.biasFactor) === 1) {
			const eligibleIndices = [];
			for (let index = 0; index !== this.slices.length; ++index) {
				const slice = this.slices[index];
				if (slice.length === targetLength) safePush(eligibleIndices, index);
			}
			if (eligibleIndices.length === 0) return;
			this.activeSliceIndex = eligibleIndices[this.mrng.nextInt(0, eligibleIndices.length - 1)];
			this.nextIndexInSlice = 0;
			this.lastIndexInSlice = targetLength - 1;
		}
	}
	next() {
		if (this.nextIndexInSlice <= this.lastIndexInSlice) return new Value(this.slices[this.activeSliceIndex][this.nextIndexInSlice++], void 0);
		if (this.mrng.nextInt(1, this.biasFactor) !== 1) return this.arb.generate(this.mrng, this.biasFactor);
		this.activeSliceIndex = this.mrng.nextInt(0, this.slices.length - 1);
		const slice = this.slices[this.activeSliceIndex];
		if (this.mrng.nextInt(1, this.biasFactor) !== 1) {
			this.nextIndexInSlice = 1;
			this.lastIndexInSlice = slice.length - 1;
			return new Value(slice[0], void 0);
		}
		const rangeBoundaryA = this.mrng.nextInt(0, slice.length - 1);
		const rangeBoundaryB = this.mrng.nextInt(0, slice.length - 1);
		this.nextIndexInSlice = safeMathMin$4(rangeBoundaryA, rangeBoundaryB);
		this.lastIndexInSlice = safeMathMax$3(rangeBoundaryA, rangeBoundaryB);
		return new Value(slice[this.nextIndexInSlice++], void 0);
	}
};

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/BuildSlicedGenerator.js
function buildSlicedGenerator(arb, mrng, slices, biasFactor) {
	if (biasFactor === void 0 || slices.length === 0 || mrng.nextInt(1, biasFactor) !== 1) return new NoopSlicedGenerator(arb, mrng, biasFactor);
	return new SlicedBasedGenerator(arb, mrng, slices, biasFactor);
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/ArrayArbitrary.js
const safeMathFloor$2 = Math.floor;
const safeMathLog = Math.log;
const safeMathMax$2 = Math.max;
const safeArrayIsArray$1 = Array.isArray;
function biasedMaxLength(minLength, maxLength) {
	if (minLength === maxLength) return minLength;
	return minLength + safeMathFloor$2(safeMathLog(maxLength - minLength) / safeMathLog(2));
}
var ArrayArbitrary = class ArrayArbitrary extends Arbitrary {
	constructor(arb, minLength, maxGeneratedLength, maxLength, depthIdentifier, setBuilder, customSlices) {
		super();
		this.arb = arb;
		this.minLength = minLength;
		this.maxGeneratedLength = maxGeneratedLength;
		this.maxLength = maxLength;
		this.setBuilder = setBuilder;
		this.customSlices = customSlices;
		this.lengthArb = integer({
			min: minLength,
			max: maxGeneratedLength
		});
		this.depthContext = getDepthContextFor(depthIdentifier);
	}
	preFilter(tab) {
		if (this.setBuilder === void 0) return tab;
		const s = this.setBuilder();
		for (let index = 0; index !== tab.length; ++index) s.tryAdd(tab[index]);
		return s.getData();
	}
	static makeItCloneable(vs, shrinkables) {
		vs[cloneMethod] = () => {
			const cloned = [];
			for (let idx = 0; idx !== shrinkables.length; ++idx) safePush(cloned, shrinkables[idx].value);
			this.makeItCloneable(cloned, shrinkables);
			return cloned;
		};
		return vs;
	}
	generateNItemsNoDuplicates(setBuilder, N, mrng, biasFactorItems) {
		let numSkippedInRow = 0;
		const s = setBuilder();
		const slicedGenerator = buildSlicedGenerator(this.arb, mrng, this.customSlices, biasFactorItems);
		while (s.size() < N && numSkippedInRow < this.maxGeneratedLength) {
			const current = slicedGenerator.next();
			if (s.tryAdd(current)) numSkippedInRow = 0;
			else numSkippedInRow += 1;
		}
		return s.getData();
	}
	safeGenerateNItemsNoDuplicates(setBuilder, N, mrng, biasFactorItems) {
		const depthImpact = safeMathMax$2(0, N - biasedMaxLength(this.minLength, this.maxGeneratedLength));
		this.depthContext.depth += depthImpact;
		try {
			return this.generateNItemsNoDuplicates(setBuilder, N, mrng, biasFactorItems);
		} finally {
			this.depthContext.depth -= depthImpact;
		}
	}
	generateNItems(N, mrng, biasFactorItems) {
		const items = [];
		const slicedGenerator = buildSlicedGenerator(this.arb, mrng, this.customSlices, biasFactorItems);
		slicedGenerator.attemptExact(N);
		for (let index = 0; index !== N; ++index) {
			const current = slicedGenerator.next();
			safePush(items, current);
		}
		return items;
	}
	safeGenerateNItems(N, mrng, biasFactorItems) {
		const depthImpact = safeMathMax$2(0, N - biasedMaxLength(this.minLength, this.maxGeneratedLength));
		this.depthContext.depth += depthImpact;
		try {
			return this.generateNItems(N, mrng, biasFactorItems);
		} finally {
			this.depthContext.depth -= depthImpact;
		}
	}
	wrapper(itemsRaw, shrunkOnce, itemsRawLengthContext, startIndex) {
		const items = shrunkOnce ? this.preFilter(itemsRaw) : itemsRaw;
		let cloneable = false;
		const vs = [];
		const itemsContexts = [];
		for (let idx = 0; idx !== items.length; ++idx) {
			const s = items[idx];
			cloneable = cloneable || s.hasToBeCloned;
			safePush(vs, s.value);
			safePush(itemsContexts, s.context);
		}
		if (cloneable) ArrayArbitrary.makeItCloneable(vs, items);
		const context = {
			shrunkOnce,
			lengthContext: itemsRaw.length === items.length && itemsRawLengthContext !== void 0 ? itemsRawLengthContext : void 0,
			itemsContexts,
			startIndex
		};
		return new Value(vs, context);
	}
	generate(mrng, biasFactor) {
		const biasMeta = this.applyBias(mrng, biasFactor);
		const targetSize = biasMeta.size;
		const items = this.setBuilder !== void 0 ? this.safeGenerateNItemsNoDuplicates(this.setBuilder, targetSize, mrng, biasMeta.biasFactorItems) : this.safeGenerateNItems(targetSize, mrng, biasMeta.biasFactorItems);
		return this.wrapper(items, false, void 0, 0);
	}
	applyBias(mrng, biasFactor) {
		if (biasFactor === void 0) return { size: this.lengthArb.generate(mrng, void 0).value };
		if (this.minLength === this.maxGeneratedLength) return {
			size: this.lengthArb.generate(mrng, void 0).value,
			biasFactorItems: biasFactor
		};
		if (mrng.nextInt(1, biasFactor) !== 1) return { size: this.lengthArb.generate(mrng, void 0).value };
		if (mrng.nextInt(1, biasFactor) !== 1 || this.minLength === this.maxGeneratedLength) return {
			size: this.lengthArb.generate(mrng, void 0).value,
			biasFactorItems: biasFactor
		};
		const maxBiasedLength = biasedMaxLength(this.minLength, this.maxGeneratedLength);
		const targetSizeValue = integer({
			min: this.minLength,
			max: maxBiasedLength
		}).generate(mrng, void 0);
		return {
			size: targetSizeValue.value,
			biasFactorItems: biasFactor
		};
	}
	canShrinkWithoutContext(value) {
		if (!safeArrayIsArray$1(value) || this.minLength > value.length || value.length > this.maxLength) return false;
		for (let index = 0; index !== value.length; ++index) {
			if (!(index in value)) return false;
			if (!this.arb.canShrinkWithoutContext(value[index])) return false;
		}
		const filtered = this.preFilter(safeMap(value, (item) => new Value(item, void 0)));
		return filtered.length === value.length;
	}
	shrinkItemByItem(value, safeContext, endIndex) {
		const shrinks = [];
		for (let index = safeContext.startIndex; index < endIndex; ++index) safePush(shrinks, makeLazy(() => this.arb.shrink(value[index], safeContext.itemsContexts[index]).map((v) => {
			const beforeCurrent = safeMap(safeSlice(value, 0, index), (v$1, i) => new Value(cloneIfNeeded(v$1), safeContext.itemsContexts[i]));
			const afterCurrent = safeMap(safeSlice(value, index + 1), (v$1, i) => new Value(cloneIfNeeded(v$1), safeContext.itemsContexts[i + index + 1]));
			return [
				[
					...beforeCurrent,
					v,
					...afterCurrent
				],
				void 0,
				index
			];
		})));
		return Stream.nil().join(...shrinks);
	}
	shrinkImpl(value, context) {
		if (value.length === 0) return Stream.nil();
		const safeContext = context !== void 0 ? context : {
			shrunkOnce: false,
			lengthContext: void 0,
			itemsContexts: [],
			startIndex: 0
		};
		return this.lengthArb.shrink(value.length, safeContext.lengthContext).drop(safeContext.shrunkOnce && safeContext.lengthContext === void 0 && value.length > this.minLength + 1 ? 1 : 0).map((lengthValue) => {
			const sliceStart = value.length - lengthValue.value;
			return [
				safeMap(safeSlice(value, sliceStart), (v, index) => new Value(cloneIfNeeded(v), safeContext.itemsContexts[index + sliceStart])),
				lengthValue.context,
				0
			];
		}).join(makeLazy(() => value.length > this.minLength ? this.shrinkItemByItem(value, safeContext, 1) : this.shrinkItemByItem(value, safeContext, value.length))).join(value.length > this.minLength ? makeLazy(() => {
			const subContext = {
				shrunkOnce: false,
				lengthContext: void 0,
				itemsContexts: safeSlice(safeContext.itemsContexts, 1),
				startIndex: 0
			};
			return this.shrinkImpl(safeSlice(value, 1), subContext).filter((v) => this.minLength <= v[0].length + 1).map((v) => {
				return [
					[new Value(cloneIfNeeded(value[0]), safeContext.itemsContexts[0]), ...v[0]],
					void 0,
					0
				];
			});
		}) : Stream.nil());
	}
	shrink(value, context) {
		return this.shrinkImpl(value, context).map((contextualValue) => this.wrapper(contextualValue[0], true, contextualValue[1], contextualValue[2]));
	}
};

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/MaxLengthFromMinLength.js
const safeMathFloor$1 = Math.floor;
const safeMathMin$3 = Math.min;
const MaxLengthUpperBound = 2147483647;
const orderedSize = [
	"xsmall",
	"small",
	"medium",
	"large",
	"xlarge"
];
const orderedRelativeSize = [
	"-4",
	"-3",
	"-2",
	"-1",
	"=",
	"+1",
	"+2",
	"+3",
	"+4"
];
const DefaultSize = "small";
function maxLengthFromMinLength(minLength, size) {
	switch (size) {
		case "xsmall": return safeMathFloor$1(1.1 * minLength) + 1;
		case "small": return 2 * minLength + 10;
		case "medium": return 11 * minLength + 100;
		case "large": return 101 * minLength + 1e3;
		case "xlarge": return 1001 * minLength + 1e4;
		default: throw new Error(`Unable to compute lengths based on received size: ${size}`);
	}
}
function relativeSizeToSize(size, defaultSize) {
	const sizeInRelative = safeIndexOf(orderedRelativeSize, size);
	if (sizeInRelative === -1) return size;
	const defaultSizeInSize = safeIndexOf(orderedSize, defaultSize);
	if (defaultSizeInSize === -1) throw new Error(`Unable to offset size based on the unknown defaulted one: ${defaultSize}`);
	const resultingSizeInSize = defaultSizeInSize + sizeInRelative - 4;
	return resultingSizeInSize < 0 ? orderedSize[0] : resultingSizeInSize >= orderedSize.length ? orderedSize[orderedSize.length - 1] : orderedSize[resultingSizeInSize];
}
function maxGeneratedLengthFromSizeForArbitrary(size, minLength, maxLength, specifiedMaxLength) {
	const { baseSize: defaultSize = DefaultSize, defaultSizeToMaxWhenMaxSpecified } = readConfigureGlobal() || {};
	const definedSize = size !== void 0 ? size : specifiedMaxLength && defaultSizeToMaxWhenMaxSpecified ? "max" : defaultSize;
	if (definedSize === "max") return maxLength;
	const finalSize = relativeSizeToSize(definedSize, defaultSize);
	return safeMathMin$3(maxLengthFromMinLength(minLength, finalSize), maxLength);
}
function depthBiasFromSizeForArbitrary(depthSizeOrSize, specifiedMaxDepth) {
	if (typeof depthSizeOrSize === "number") return 1 / depthSizeOrSize;
	const { baseSize: defaultSize = DefaultSize, defaultSizeToMaxWhenMaxSpecified } = readConfigureGlobal() || {};
	const definedSize = depthSizeOrSize !== void 0 ? depthSizeOrSize : specifiedMaxDepth && defaultSizeToMaxWhenMaxSpecified ? "max" : defaultSize;
	if (definedSize === "max") return 0;
	const finalSize = relativeSizeToSize(definedSize, defaultSize);
	switch (finalSize) {
		case "xsmall": return 1;
		case "small": return .5;
		case "medium": return .25;
		case "large": return .125;
		case "xlarge": return .0625;
	}
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/array.js
function array(arb, constraints = {}) {
	const size = constraints.size;
	const minLength = constraints.minLength || 0;
	const maxLengthOrUnset = constraints.maxLength;
	const depthIdentifier = constraints.depthIdentifier;
	const maxLength = maxLengthOrUnset !== void 0 ? maxLengthOrUnset : MaxLengthUpperBound;
	const specifiedMaxLength = maxLengthOrUnset !== void 0;
	const maxGeneratedLength = maxGeneratedLengthFromSizeForArbitrary(size, minLength, maxLength, specifiedMaxLength);
	const customSlices = constraints.experimentalCustomSlices || [];
	return new ArrayArbitrary(arb, minLength, maxGeneratedLength, maxLength, depthIdentifier, void 0, customSlices);
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/ShrinkBigInt.js
function halveBigInt(n) {
	return n / SBigInt(2);
}
function shrinkBigInt(current, target, tryTargetAsap) {
	const realGap = current - target;
	function* shrinkDecr() {
		let previous = tryTargetAsap ? void 0 : target;
		const gap = tryTargetAsap ? realGap : halveBigInt(realGap);
		for (let toremove = gap; toremove > 0; toremove = halveBigInt(toremove)) {
			const next = current - toremove;
			yield new Value(next, previous);
			previous = next;
		}
	}
	function* shrinkIncr() {
		let previous = tryTargetAsap ? void 0 : target;
		const gap = tryTargetAsap ? realGap : halveBigInt(realGap);
		for (let toremove = gap; toremove < 0; toremove = halveBigInt(toremove)) {
			const next = current - toremove;
			yield new Value(next, previous);
			previous = next;
		}
	}
	return realGap > 0 ? stream(shrinkDecr()) : stream(shrinkIncr());
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/BigIntArbitrary.js
var BigIntArbitrary = class BigIntArbitrary extends Arbitrary {
	constructor(min, max) {
		super();
		this.min = min;
		this.max = max;
	}
	generate(mrng, biasFactor) {
		const range = this.computeGenerateRange(mrng, biasFactor);
		return new Value(mrng.nextBigInt(range.min, range.max), void 0);
	}
	computeGenerateRange(mrng, biasFactor) {
		if (biasFactor === void 0 || mrng.nextInt(1, biasFactor) !== 1) return {
			min: this.min,
			max: this.max
		};
		const ranges = biasNumericRange(this.min, this.max, bigIntLogLike);
		if (ranges.length === 1) return ranges[0];
		const id = mrng.nextInt(-2 * (ranges.length - 1), ranges.length - 2);
		return id < 0 ? ranges[0] : ranges[id + 1];
	}
	canShrinkWithoutContext(value) {
		return typeof value === "bigint" && this.min <= value && value <= this.max;
	}
	shrink(current, context) {
		if (!BigIntArbitrary.isValidContext(current, context)) {
			const target = this.defaultTarget();
			return shrinkBigInt(current, target, true);
		}
		if (this.isLastChanceTry(current, context)) return Stream.of(new Value(context, void 0));
		return shrinkBigInt(current, context, false);
	}
	defaultTarget() {
		if (this.min <= 0 && this.max >= 0) return SBigInt(0);
		return this.min < 0 ? this.max : this.min;
	}
	isLastChanceTry(current, context) {
		if (current > 0) return current === context + SBigInt(1) && current > this.min;
		if (current < 0) return current === context - SBigInt(1) && current < this.max;
		return false;
	}
	static isValidContext(current, context) {
		if (context === void 0) return false;
		if (typeof context !== "bigint") throw new Error(`Invalid context type passed to BigIntArbitrary (#1)`);
		const differentSigns = current > 0 && context < 0 || current < 0 && context > 0;
		if (context !== SBigInt(0) && differentSigns) throw new Error(`Invalid context value passed to BigIntArbitrary (#2)`);
		return true;
	}
};

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/bigInt.js
function buildCompleteBigIntConstraints(constraints) {
	const DefaultPow = 256;
	const DefaultMin = SBigInt(-1) << SBigInt(DefaultPow - 1);
	const DefaultMax = (SBigInt(1) << SBigInt(DefaultPow - 1)) - SBigInt(1);
	const min = constraints.min;
	const max = constraints.max;
	return {
		min: min !== void 0 ? min : DefaultMin - (max !== void 0 && max < SBigInt(0) ? max * max : SBigInt(0)),
		max: max !== void 0 ? max : DefaultMax + (min !== void 0 && min > SBigInt(0) ? min * min : SBigInt(0))
	};
}
function extractBigIntConstraints(args) {
	if (args[0] === void 0) return {};
	if (args[1] === void 0) {
		const constraints = args[0];
		return constraints;
	}
	return {
		min: args[0],
		max: args[1]
	};
}
function bigInt(...args) {
	const constraints = buildCompleteBigIntConstraints(extractBigIntConstraints(args));
	if (constraints.min > constraints.max) throw new Error("fc.bigInt expects max to be greater than or equal to min");
	return new BigIntArbitrary(constraints.min, constraints.max);
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/noBias.js
function noBias(arb) {
	return arb.noBias();
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/boolean.js
function booleanMapper(v) {
	return v === 1;
}
function booleanUnmapper(v) {
	if (typeof v !== "boolean") throw new Error("Unsupported input type");
	return v === true ? 1 : 0;
}
function boolean() {
	return noBias(integer({
		min: 0,
		max: 1
	}).map(booleanMapper, booleanUnmapper));
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/ConstantArbitrary.js
const safeObjectIs$3 = Object.is;
var ConstantArbitrary = class extends Arbitrary {
	constructor(values) {
		super();
		this.values = values;
	}
	generate(mrng, _biasFactor) {
		const idx = this.values.length === 1 ? 0 : mrng.nextInt(0, this.values.length - 1);
		const value = this.values[idx];
		if (!hasCloneMethod(value)) return new Value(value, idx);
		return new Value(value, idx, () => value[cloneMethod]());
	}
	canShrinkWithoutContext(value) {
		if (this.values.length === 1) return safeObjectIs$3(this.values[0], value);
		if (this.fastValues === void 0) this.fastValues = new FastConstantValuesLookup(this.values);
		return this.fastValues.has(value);
	}
	shrink(value, context) {
		if (context === 0 || safeObjectIs$3(value, this.values[0])) return Stream.nil();
		return Stream.of(new Value(this.values[0], 0));
	}
};
var FastConstantValuesLookup = class {
	constructor(values) {
		this.values = values;
		this.fastValues = new SSet(this.values);
		let hasMinusZero = false;
		let hasPlusZero = false;
		if (safeHas(this.fastValues, 0)) for (let idx = 0; idx !== this.values.length; ++idx) {
			const value = this.values[idx];
			hasMinusZero = hasMinusZero || safeObjectIs$3(value, -0);
			hasPlusZero = hasPlusZero || safeObjectIs$3(value, 0);
		}
		this.hasMinusZero = hasMinusZero;
		this.hasPlusZero = hasPlusZero;
	}
	has(value) {
		if (value === 0) {
			if (safeObjectIs$3(value, 0)) return this.hasPlusZero;
			return this.hasMinusZero;
		}
		return safeHas(this.fastValues, value);
	}
};

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/constantFrom.js
function constantFrom(...values) {
	if (values.length === 0) throw new Error("fc.constantFrom expects at least one parameter");
	return new ConstantArbitrary(values);
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/IndexToCharString.js
const indexToCharStringMapper = String.fromCodePoint;
function indexToCharStringUnmapper(c) {
	if (typeof c !== "string") throw new Error("Cannot unmap non-string");
	if (c.length === 0 || c.length > 2) throw new Error("Cannot unmap string with more or less than one character");
	const c1 = safeCharCodeAt(c, 0);
	if (c.length === 1) return c1;
	const c2 = safeCharCodeAt(c, 1);
	if (c1 < 55296 || c1 > 56319 || c2 < 56320 || c2 > 57343) throw new Error("Cannot unmap invalid surrogate pairs");
	return c.codePointAt(0);
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/builders/CharacterArbitraryBuilder.js
function buildCharacterArbitrary(min, max, mapToCode, unmapFromCode) {
	return integer({
		min,
		max
	}).map((n) => indexToCharStringMapper(mapToCode(n)), (c) => unmapFromCode(indexToCharStringUnmapper(c)));
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/IndexToPrintableIndex.js
function indexToPrintableIndexMapper(v) {
	if (v < 95) return v + 32;
	if (v <= 126) return v - 95;
	return v;
}
function indexToPrintableIndexUnmapper(v) {
	if (v >= 32 && v <= 126) return v - 32;
	if (v >= 0 && v <= 31) return v + 95;
	return v;
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/fullUnicode.js
const gapSize = 2048;
function unicodeMapper(v) {
	if (v < 55296) return indexToPrintableIndexMapper(v);
	return v + gapSize;
}
function unicodeUnmapper(v) {
	if (v < 55296) return indexToPrintableIndexUnmapper(v);
	if (v <= 57343) return -1;
	return v - gapSize;
}
function fullUnicode() {
	return buildCharacterArbitrary(0, 1114111 - gapSize, unicodeMapper, unicodeUnmapper);
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/constant.js
function constant(value) {
	return new ConstantArbitrary([value]);
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/TimeToDate.js
const safeNaN$2 = NaN;
const safeNumberIsNaN$4 = Number.isNaN;
function timeToDateMapper(time) {
	return new SDate(time);
}
function timeToDateUnmapper(value) {
	if (!(value instanceof SDate) || value.constructor !== SDate) throw new SError("Not a valid value for date unmapper");
	return safeGetTime(value);
}
function timeToDateMapperWithNaN(valueForNaN) {
	return (time) => {
		return time === valueForNaN ? new SDate(safeNaN$2) : timeToDateMapper(time);
	};
}
function timeToDateUnmapperWithNaN(valueForNaN) {
	return (value) => {
		const time = timeToDateUnmapper(value);
		return safeNumberIsNaN$4(time) ? valueForNaN : time;
	};
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/date.js
const safeNumberIsNaN$3 = Number.isNaN;
function date(constraints = {}) {
	const intMin = constraints.min !== void 0 ? safeGetTime(constraints.min) : -864e13;
	const intMax = constraints.max !== void 0 ? safeGetTime(constraints.max) : 864e13;
	const noInvalidDate = constraints.noInvalidDate === void 0 || constraints.noInvalidDate;
	if (safeNumberIsNaN$3(intMin)) throw new Error("fc.date min must be valid instance of Date");
	if (safeNumberIsNaN$3(intMax)) throw new Error("fc.date max must be valid instance of Date");
	if (intMin > intMax) throw new Error("fc.date max must be greater or equal to min");
	if (noInvalidDate) return integer({
		min: intMin,
		max: intMax
	}).map(timeToDateMapper, timeToDateUnmapper);
	const valueForNaN = intMax + 1;
	return integer({
		min: intMin,
		max: intMax + 1
	}).map(timeToDateMapperWithNaN(valueForNaN), timeToDateUnmapperWithNaN(valueForNaN));
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/CustomEqualSet.js
var CustomEqualSet = class {
	constructor(isEqual) {
		this.isEqual = isEqual;
		this.data = [];
	}
	tryAdd(value) {
		for (let idx = 0; idx !== this.data.length; ++idx) if (this.isEqual(this.data[idx], value)) return false;
		safePush(this.data, value);
		return true;
	}
	size() {
		return this.data.length;
	}
	getData() {
		return this.data;
	}
};

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/StrictlyEqualSet.js
const safeNumberIsNaN$2 = Number.isNaN;
var StrictlyEqualSet = class {
	constructor(selector) {
		this.selector = selector;
		this.selectedItemsExceptNaN = new SSet();
		this.data = [];
	}
	tryAdd(value) {
		const selected = this.selector(value);
		if (safeNumberIsNaN$2(selected)) {
			safePush(this.data, value);
			return true;
		}
		const sizeBefore = this.selectedItemsExceptNaN.size;
		safeAdd(this.selectedItemsExceptNaN, selected);
		if (sizeBefore !== this.selectedItemsExceptNaN.size) {
			safePush(this.data, value);
			return true;
		}
		return false;
	}
	size() {
		return this.data.length;
	}
	getData() {
		return this.data;
	}
};

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/SameValueSet.js
const safeObjectIs$2 = Object.is;
var SameValueSet = class {
	constructor(selector) {
		this.selector = selector;
		this.selectedItemsExceptMinusZero = new SSet();
		this.data = [];
		this.hasMinusZero = false;
	}
	tryAdd(value) {
		const selected = this.selector(value);
		if (safeObjectIs$2(selected, -0)) {
			if (this.hasMinusZero) return false;
			safePush(this.data, value);
			this.hasMinusZero = true;
			return true;
		}
		const sizeBefore = this.selectedItemsExceptMinusZero.size;
		safeAdd(this.selectedItemsExceptMinusZero, selected);
		if (sizeBefore !== this.selectedItemsExceptMinusZero.size) {
			safePush(this.data, value);
			return true;
		}
		return false;
	}
	size() {
		return this.data.length;
	}
	getData() {
		return this.data;
	}
};

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/SameValueZeroSet.js
var SameValueZeroSet = class {
	constructor(selector) {
		this.selector = selector;
		this.selectedItems = new SSet();
		this.data = [];
	}
	tryAdd(value) {
		const selected = this.selector(value);
		const sizeBefore = this.selectedItems.size;
		safeAdd(this.selectedItems, selected);
		if (sizeBefore !== this.selectedItems.size) {
			safePush(this.data, value);
			return true;
		}
		return false;
	}
	size() {
		return this.data.length;
	}
	getData() {
		return this.data;
	}
};

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/uniqueArray.js
function buildUniqueArraySetBuilder(constraints) {
	if (typeof constraints.comparator === "function") {
		if (constraints.selector === void 0) {
			const comparator$1 = constraints.comparator;
			const isEqualForBuilder$1 = (nextA, nextB) => comparator$1(nextA.value_, nextB.value_);
			return () => new CustomEqualSet(isEqualForBuilder$1);
		}
		const comparator = constraints.comparator;
		const selector$1 = constraints.selector;
		const refinedSelector$1 = (next) => selector$1(next.value_);
		const isEqualForBuilder = (nextA, nextB) => comparator(refinedSelector$1(nextA), refinedSelector$1(nextB));
		return () => new CustomEqualSet(isEqualForBuilder);
	}
	const selector = constraints.selector || ((v) => v);
	const refinedSelector = (next) => selector(next.value_);
	switch (constraints.comparator) {
		case "IsStrictlyEqual": return () => new StrictlyEqualSet(refinedSelector);
		case "SameValueZero": return () => new SameValueZeroSet(refinedSelector);
		case "SameValue":
		case void 0: return () => new SameValueSet(refinedSelector);
	}
}
function uniqueArray(arb, constraints = {}) {
	const minLength = constraints.minLength !== void 0 ? constraints.minLength : 0;
	const maxLength = constraints.maxLength !== void 0 ? constraints.maxLength : MaxLengthUpperBound;
	const maxGeneratedLength = maxGeneratedLengthFromSizeForArbitrary(constraints.size, minLength, maxLength, constraints.maxLength !== void 0);
	const depthIdentifier = constraints.depthIdentifier;
	const setBuilder = buildUniqueArraySetBuilder(constraints);
	const arrayArb = new ArrayArbitrary(arb, minLength, maxGeneratedLength, maxLength, depthIdentifier, setBuilder, []);
	if (minLength === 0) return arrayArb;
	return arrayArb.filter((tab) => tab.length >= minLength);
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/KeyValuePairsToObject.js
const safeObjectCreate$1 = Object.create;
const safeObjectDefineProperty = Object.defineProperty;
const safeObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
const safeObjectGetPrototypeOf = Object.getPrototypeOf;
const safeObjectGetOwnPropertySymbols = Object.getOwnPropertySymbols;
const safeObjectGetOwnPropertyNames = Object.getOwnPropertyNames;
const safeObjectEntries$1 = Object.entries;
function keyValuePairsToObjectMapper(definition) {
	const obj = definition[1] ? safeObjectCreate$1(null) : {};
	for (const keyValue of definition[0]) safeObjectDefineProperty(obj, keyValue[0], {
		enumerable: true,
		configurable: true,
		writable: true,
		value: keyValue[1]
	});
	return obj;
}
function buildIsValidPropertyNameFilter(obj) {
	return function isValidPropertyNameFilter(key) {
		const descriptor = safeObjectGetOwnPropertyDescriptor(obj, key);
		return descriptor !== void 0 && !!descriptor.configurable && !!descriptor.enumerable && !!descriptor.writable && descriptor.get === void 0 && descriptor.set === void 0;
	};
}
function keyValuePairsToObjectUnmapper(value) {
	if (typeof value !== "object" || value === null) throw new SError("Incompatible instance received: should be a non-null object");
	const hasNullPrototype = safeObjectGetPrototypeOf(value) === null;
	const hasObjectPrototype = "constructor" in value && value.constructor === Object;
	if (!hasNullPrototype && !hasObjectPrototype) throw new SError("Incompatible instance received: should be of exact type Object");
	if (safeObjectGetOwnPropertySymbols(value).length > 0) throw new SError("Incompatible instance received: should contain symbols");
	if (!safeEvery(safeObjectGetOwnPropertyNames(value), buildIsValidPropertyNameFilter(value))) throw new SError("Incompatible instance received: should contain only c/e/w properties without get/set");
	return [safeObjectEntries$1(value), hasNullPrototype];
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/dictionary.js
function dictionaryKeyExtractor(entry) {
	return entry[0];
}
function dictionary(keyArb, valueArb, constraints = {}) {
	const noNullPrototype = constraints.noNullPrototype !== false;
	return tuple(uniqueArray(tuple(keyArb, valueArb), {
		minLength: constraints.minKeys,
		maxLength: constraints.maxKeys,
		size: constraints.size,
		selector: dictionaryKeyExtractor,
		depthIdentifier: constraints.depthIdentifier
	}), noNullPrototype ? constant(false) : boolean()).map(keyValuePairsToObjectMapper, keyValuePairsToObjectUnmapper);
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/FrequencyArbitrary.js
const safePositiveInfinity$7 = Number.POSITIVE_INFINITY;
const safeMaxSafeInteger$1 = Number.MAX_SAFE_INTEGER;
const safeNumberIsInteger$4 = Number.isInteger;
const safeMathFloor = Math.floor;
const safeMathPow = Math.pow;
const safeMathMin$2 = Math.min;
var FrequencyArbitrary = class FrequencyArbitrary extends Arbitrary {
	static from(warbs, constraints, label) {
		if (warbs.length === 0) throw new Error(`${label} expects at least one weighted arbitrary`);
		let totalWeight = 0;
		for (let idx = 0; idx !== warbs.length; ++idx) {
			const currentArbitrary = warbs[idx].arbitrary;
			if (currentArbitrary === void 0) throw new Error(`${label} expects arbitraries to be specified`);
			const currentWeight = warbs[idx].weight;
			totalWeight += currentWeight;
			if (!safeNumberIsInteger$4(currentWeight)) throw new Error(`${label} expects weights to be integer values`);
			if (currentWeight < 0) throw new Error(`${label} expects weights to be superior or equal to 0`);
		}
		if (totalWeight <= 0) throw new Error(`${label} expects the sum of weights to be strictly superior to 0`);
		const sanitizedConstraints = {
			depthBias: depthBiasFromSizeForArbitrary(constraints.depthSize, constraints.maxDepth !== void 0),
			maxDepth: constraints.maxDepth != void 0 ? constraints.maxDepth : safePositiveInfinity$7,
			withCrossShrink: !!constraints.withCrossShrink
		};
		return new FrequencyArbitrary(warbs, sanitizedConstraints, getDepthContextFor(constraints.depthIdentifier));
	}
	constructor(warbs, constraints, context) {
		super();
		this.warbs = warbs;
		this.constraints = constraints;
		this.context = context;
		let currentWeight = 0;
		this.cumulatedWeights = [];
		for (let idx = 0; idx !== warbs.length; ++idx) {
			currentWeight += warbs[idx].weight;
			safePush(this.cumulatedWeights, currentWeight);
		}
		this.totalWeight = currentWeight;
	}
	generate(mrng, biasFactor) {
		if (this.mustGenerateFirst()) return this.safeGenerateForIndex(mrng, 0, biasFactor);
		const selected = mrng.nextInt(this.computeNegDepthBenefit(), this.totalWeight - 1);
		for (let idx = 0; idx !== this.cumulatedWeights.length; ++idx) if (selected < this.cumulatedWeights[idx]) return this.safeGenerateForIndex(mrng, idx, biasFactor);
		throw new Error(`Unable to generate from fc.frequency`);
	}
	canShrinkWithoutContext(value) {
		return this.canShrinkWithoutContextIndex(value) !== -1;
	}
	shrink(value, context) {
		if (context !== void 0) {
			const safeContext = context;
			const selectedIndex = safeContext.selectedIndex;
			const originalBias = safeContext.originalBias;
			const originalArbitrary = this.warbs[selectedIndex].arbitrary;
			const originalShrinks = originalArbitrary.shrink(value, safeContext.originalContext).map((v) => this.mapIntoValue(selectedIndex, v, null, originalBias));
			if (safeContext.clonedMrngForFallbackFirst !== null) {
				if (safeContext.cachedGeneratedForFirst === void 0) safeContext.cachedGeneratedForFirst = this.safeGenerateForIndex(safeContext.clonedMrngForFallbackFirst, 0, originalBias);
				const valueFromFirst = safeContext.cachedGeneratedForFirst;
				return Stream.of(valueFromFirst).join(originalShrinks);
			}
			return originalShrinks;
		}
		const potentialSelectedIndex = this.canShrinkWithoutContextIndex(value);
		if (potentialSelectedIndex === -1) return Stream.nil();
		return this.defaultShrinkForFirst(potentialSelectedIndex).join(this.warbs[potentialSelectedIndex].arbitrary.shrink(value, void 0).map((v) => this.mapIntoValue(potentialSelectedIndex, v, null, void 0)));
	}
	defaultShrinkForFirst(selectedIndex) {
		++this.context.depth;
		try {
			if (!this.mustFallbackToFirstInShrink(selectedIndex) || this.warbs[0].fallbackValue === void 0) return Stream.nil();
		} finally {
			--this.context.depth;
		}
		const rawShrinkValue = new Value(this.warbs[0].fallbackValue.default, void 0);
		return Stream.of(this.mapIntoValue(0, rawShrinkValue, null, void 0));
	}
	canShrinkWithoutContextIndex(value) {
		if (this.mustGenerateFirst()) return this.warbs[0].arbitrary.canShrinkWithoutContext(value) ? 0 : -1;
		try {
			++this.context.depth;
			for (let idx = 0; idx !== this.warbs.length; ++idx) {
				const warb = this.warbs[idx];
				if (warb.weight !== 0 && warb.arbitrary.canShrinkWithoutContext(value)) return idx;
			}
			return -1;
		} finally {
			--this.context.depth;
		}
	}
	mapIntoValue(idx, value, clonedMrngForFallbackFirst, biasFactor) {
		const context = {
			selectedIndex: idx,
			originalBias: biasFactor,
			originalContext: value.context,
			clonedMrngForFallbackFirst
		};
		return new Value(value.value, context);
	}
	safeGenerateForIndex(mrng, idx, biasFactor) {
		++this.context.depth;
		try {
			const value = this.warbs[idx].arbitrary.generate(mrng, biasFactor);
			const clonedMrngForFallbackFirst = this.mustFallbackToFirstInShrink(idx) ? mrng.clone() : null;
			return this.mapIntoValue(idx, value, clonedMrngForFallbackFirst, biasFactor);
		} finally {
			--this.context.depth;
		}
	}
	mustGenerateFirst() {
		return this.constraints.maxDepth <= this.context.depth;
	}
	mustFallbackToFirstInShrink(idx) {
		return idx !== 0 && this.constraints.withCrossShrink && this.warbs[0].weight !== 0;
	}
	computeNegDepthBenefit() {
		const depthBias = this.constraints.depthBias;
		if (depthBias <= 0 || this.warbs[0].weight === 0) return 0;
		const depthBenefit = safeMathFloor(safeMathPow(1 + depthBias, this.context.depth)) - 1;
		return -safeMathMin$2(this.totalWeight * depthBenefit, safeMaxSafeInteger$1) || 0;
	}
};

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/oneof.js
function isOneOfContraints(param) {
	return param != null && typeof param === "object" && !("generate" in param) && !("arbitrary" in param) && !("weight" in param);
}
function toWeightedArbitrary(maybeWeightedArbitrary) {
	if (isArbitrary(maybeWeightedArbitrary)) return {
		arbitrary: maybeWeightedArbitrary,
		weight: 1
	};
	return maybeWeightedArbitrary;
}
function oneof(...args) {
	const constraints = args[0];
	if (isOneOfContraints(constraints)) {
		const weightedArbs$1 = safeMap(safeSlice(args, 1), toWeightedArbitrary);
		return FrequencyArbitrary.from(weightedArbs$1, constraints, "fc.oneof");
	}
	const weightedArbs = safeMap(args, toWeightedArbitrary);
	return FrequencyArbitrary.from(weightedArbs, {}, "fc.oneof");
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/nat.js
const safeNumberIsInteger$3 = Number.isInteger;
function nat(arg) {
	const max = typeof arg === "number" ? arg : arg && arg.max !== void 0 ? arg.max : 2147483647;
	if (max < 0) throw new Error("fc.nat value should be greater than or equal to 0");
	if (!safeNumberIsInteger$3(max)) throw new Error("fc.nat maximum value should be an integer");
	return new IntegerArbitrary(0, max);
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/IndexToMappedConstant.js
const safeObjectIs$1 = Object.is;
function buildDichotomyEntries(entries) {
	let currentFrom = 0;
	const dichotomyEntries = [];
	for (const entry of entries) {
		const from = currentFrom;
		currentFrom = from + entry.num;
		const to = currentFrom - 1;
		dichotomyEntries.push({
			from,
			to,
			entry
		});
	}
	return dichotomyEntries;
}
function findDichotomyEntry(dichotomyEntries, choiceIndex) {
	let min = 0;
	let max = dichotomyEntries.length;
	while (max - min > 1) {
		const mid = ~~((min + max) / 2);
		if (choiceIndex < dichotomyEntries[mid].from) max = mid;
		else min = mid;
	}
	return dichotomyEntries[min];
}
function indexToMappedConstantMapperFor(entries) {
	const dichotomyEntries = buildDichotomyEntries(entries);
	return function indexToMappedConstantMapper(choiceIndex) {
		const dichotomyEntry = findDichotomyEntry(dichotomyEntries, choiceIndex);
		return dichotomyEntry.entry.build(choiceIndex - dichotomyEntry.from);
	};
}
function buildReverseMapping(entries) {
	const reverseMapping = {
		mapping: new SMap(),
		negativeZeroIndex: void 0
	};
	let choiceIndex = 0;
	for (let entryIdx = 0; entryIdx !== entries.length; ++entryIdx) {
		const entry = entries[entryIdx];
		for (let idxInEntry = 0; idxInEntry !== entry.num; ++idxInEntry) {
			const value = entry.build(idxInEntry);
			if (value === 0 && 1 / value === SNumber.NEGATIVE_INFINITY) reverseMapping.negativeZeroIndex = choiceIndex;
			else safeMapSet(reverseMapping.mapping, value, choiceIndex);
			++choiceIndex;
		}
	}
	return reverseMapping;
}
function indexToMappedConstantUnmapperFor(entries) {
	let reverseMapping = null;
	return function indexToMappedConstantUnmapper(value) {
		if (reverseMapping === null) reverseMapping = buildReverseMapping(entries);
		const choiceIndex = safeObjectIs$1(value, -0) ? reverseMapping.negativeZeroIndex : safeMapGet(reverseMapping.mapping, value);
		if (choiceIndex === void 0) throw new SError("Unknown value encountered cannot be built using this mapToConstant");
		return choiceIndex;
	};
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/mapToConstant.js
function computeNumChoices(options) {
	if (options.length === 0) throw new SError(`fc.mapToConstant expects at least one option`);
	let numChoices = 0;
	for (let idx = 0; idx !== options.length; ++idx) {
		if (options[idx].num < 0) throw new SError(`fc.mapToConstant expects all options to have a number of entries greater or equal to zero`);
		numChoices += options[idx].num;
	}
	if (numChoices === 0) throw new SError(`fc.mapToConstant expects at least one choice among options`);
	return numChoices;
}
function mapToConstant(...entries) {
	const numChoices = computeNumChoices(entries);
	return nat({ max: numChoices - 1 }).map(indexToMappedConstantMapperFor(entries), indexToMappedConstantUnmapperFor(entries));
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/TokenizeString.js
function tokenizeString(patternsArb, value, minLength, maxLength) {
	if (value.length === 0) {
		if (minLength > 0) return void 0;
		return [];
	}
	if (maxLength <= 0) return void 0;
	const stack = [{
		endIndexChunks: 0,
		nextStartIndex: 1,
		chunks: []
	}];
	while (stack.length > 0) {
		const last = safePop(stack);
		for (let index = last.nextStartIndex; index <= value.length; ++index) {
			const chunk = safeSubstring(value, last.endIndexChunks, index);
			if (patternsArb.canShrinkWithoutContext(chunk)) {
				const newChunks = [...last.chunks, chunk];
				if (index === value.length) {
					if (newChunks.length < minLength) break;
					return newChunks;
				}
				safePush(stack, {
					endIndexChunks: last.endIndexChunks,
					nextStartIndex: index + 1,
					chunks: last.chunks
				});
				if (newChunks.length < maxLength) safePush(stack, {
					endIndexChunks: index,
					nextStartIndex: index + 1,
					chunks: newChunks
				});
				break;
			}
		}
	}
	return void 0;
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/PatternsToString.js
function patternsToStringMapper(tab) {
	return safeJoin(tab, "");
}
function minLengthFrom(constraints) {
	return constraints.minLength !== void 0 ? constraints.minLength : 0;
}
function maxLengthFrom(constraints) {
	return constraints.maxLength !== void 0 ? constraints.maxLength : MaxLengthUpperBound;
}
function patternsToStringUnmapperIsValidLength(tokens, constraints) {
	return minLengthFrom(constraints) <= tokens.length && tokens.length <= maxLengthFrom(constraints);
}
function patternsToStringUnmapperFor(patternsArb, constraints) {
	return function patternsToStringUnmapper(value) {
		if (typeof value !== "string") throw new SError("Unsupported value");
		const tokens = tokenizeString(patternsArb, value, minLengthFrom(constraints), maxLengthFrom(constraints));
		if (tokens === void 0) throw new SError("Unable to unmap received string");
		return tokens;
	};
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/SlicesForStringBuilder.js
const dangerousStrings = [
	"__defineGetter__",
	"__defineSetter__",
	"__lookupGetter__",
	"__lookupSetter__",
	"__proto__",
	"constructor",
	"hasOwnProperty",
	"isPrototypeOf",
	"propertyIsEnumerable",
	"toLocaleString",
	"toString",
	"valueOf",
	"apply",
	"arguments",
	"bind",
	"call",
	"caller",
	"length",
	"name",
	"prototype",
	"key",
	"ref"
];
function computeCandidateStringLegacy(dangerous, charArbitrary, stringSplitter) {
	let candidate;
	try {
		candidate = stringSplitter(dangerous);
	} catch (err) {
		return void 0;
	}
	for (const entry of candidate) if (!charArbitrary.canShrinkWithoutContext(entry)) return void 0;
	return candidate;
}
function createSlicesForStringLegacy(charArbitrary, stringSplitter) {
	const slicesForString = [];
	for (const dangerous of dangerousStrings) {
		const candidate = computeCandidateStringLegacy(dangerous, charArbitrary, stringSplitter);
		if (candidate !== void 0) safePush(slicesForString, candidate);
	}
	return slicesForString;
}
const slicesPerArbitrary = /* @__PURE__ */ new WeakMap();
function createSlicesForStringNoConstraints(charArbitrary) {
	const slicesForString = [];
	for (const dangerous of dangerousStrings) {
		const candidate = tokenizeString(charArbitrary, dangerous, 0, MaxLengthUpperBound);
		if (candidate !== void 0) safePush(slicesForString, candidate);
	}
	return slicesForString;
}
function createSlicesForString(charArbitrary, constraints) {
	let slices = safeGet(slicesPerArbitrary, charArbitrary);
	if (slices === void 0) {
		slices = createSlicesForStringNoConstraints(charArbitrary);
		safeSet(slicesPerArbitrary, charArbitrary, slices);
	}
	const slicesForConstraints = [];
	for (const slice of slices) if (patternsToStringUnmapperIsValidLength(slice, constraints)) safePush(slicesForConstraints, slice);
	return slicesForConstraints;
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/data/GraphemeRanges.js
const asciiAlphabetRanges = [[0, 127]];
const fullAlphabetRanges = [[0, 55295], [57344, 1114111]];
const autonomousGraphemeRanges = [
	[32, 126],
	[160, 172],
	[174, 767],
	[880, 887],
	[890, 895],
	[900, 906],
	[908],
	[910, 929],
	[931, 1154],
	[1162, 1327],
	[1329, 1366],
	[1369, 1418],
	[1421, 1423],
	[1470],
	[1472],
	[1475],
	[1478],
	[1488, 1514],
	[1519, 1524],
	[1542, 1551],
	[1563],
	[1565, 1610],
	[1632, 1647],
	[1649, 1749],
	[1758],
	[1765, 1766],
	[1769],
	[1774, 1805],
	[1808],
	[1810, 1839],
	[1869, 1957],
	[1969],
	[1984, 2026],
	[2036, 2042],
	[2046, 2069],
	[2074],
	[2084],
	[2088],
	[2096, 2110],
	[2112, 2136],
	[2142],
	[2144, 2154],
	[2160, 2190],
	[2208, 2249],
	[2308, 2361],
	[2365],
	[2384],
	[2392, 2401],
	[2404, 2432],
	[2437, 2444],
	[2447, 2448],
	[2451, 2472],
	[2474, 2480],
	[2482],
	[2486, 2489],
	[2493],
	[2510],
	[2524, 2525],
	[2527, 2529],
	[2534, 2557],
	[2565, 2570],
	[2575, 2576],
	[2579, 2600],
	[2602, 2608],
	[2610, 2611],
	[2613, 2614],
	[2616, 2617],
	[2649, 2652],
	[2654],
	[2662, 2671],
	[2674, 2676],
	[2678],
	[2693, 2701],
	[2703, 2705],
	[2707, 2728],
	[2730, 2736],
	[2738, 2739],
	[2741, 2745],
	[2749],
	[2768],
	[2784, 2785],
	[2790, 2801],
	[2809],
	[2821, 2828],
	[2831, 2832],
	[2835, 2856],
	[2858, 2864],
	[2866, 2867],
	[2869, 2873],
	[2877],
	[2908, 2909],
	[2911, 2913],
	[2918, 2935],
	[2947],
	[2949, 2954],
	[2958, 2960],
	[2962, 2965],
	[2969, 2970],
	[2972],
	[2974, 2975],
	[2979, 2980],
	[2984, 2986],
	[2990, 3001],
	[3024],
	[3046, 3066],
	[3077, 3084],
	[3086, 3088],
	[3090, 3112],
	[3114, 3129],
	[3133],
	[3160, 3162],
	[3165],
	[3168, 3169],
	[3174, 3183],
	[3191, 3200],
	[3204, 3212],
	[3214, 3216],
	[3218, 3240],
	[3242, 3251],
	[3253, 3257],
	[3261],
	[3293, 3294],
	[3296, 3297],
	[3302, 3311],
	[3313, 3314],
	[3332, 3340],
	[3342, 3344],
	[3346, 3386],
	[3389],
	[3407],
	[3412, 3414],
	[3416, 3425],
	[3430, 3455],
	[3461, 3478],
	[3482, 3505],
	[3507, 3515],
	[3517],
	[3520, 3526],
	[3558, 3567],
	[3572],
	[3585, 3632],
	[3634],
	[3647, 3654],
	[3663, 3675],
	[3713, 3714],
	[3716],
	[3718, 3722],
	[3724, 3747],
	[3749],
	[3751, 3760],
	[3762],
	[3773],
	[3776, 3780],
	[3782],
	[3792, 3801],
	[3804, 3807],
	[3840, 3863],
	[3866, 3892],
	[3894],
	[3896],
	[3898, 3901],
	[3904, 3911],
	[3913, 3948],
	[3973],
	[3976, 3980],
	[4030, 4037],
	[4039, 4044],
	[4046, 4058],
	[4096, 4138],
	[4159, 4181],
	[4186, 4189],
	[4193],
	[4197, 4198],
	[4206, 4208],
	[4213, 4225],
	[4238],
	[4240, 4249],
	[4254, 4293],
	[4295],
	[4301],
	[4304, 4351],
	[4608, 4680],
	[4682, 4685],
	[4688, 4694],
	[4696],
	[4698, 4701],
	[4704, 4744],
	[4746, 4749],
	[4752, 4784],
	[4786, 4789],
	[4792, 4798],
	[4800],
	[4802, 4805],
	[4808, 4822],
	[4824, 4880],
	[4882, 4885],
	[4888, 4954],
	[4960, 4988],
	[4992, 5017],
	[5024, 5109],
	[5112, 5117],
	[5120, 5788],
	[5792, 5880],
	[5888, 5905],
	[5919, 5937],
	[5941, 5942],
	[5952, 5969],
	[5984, 5996],
	[5998, 6e3],
	[6016, 6067],
	[6100, 6108],
	[6112, 6121],
	[6128, 6137],
	[6144, 6154],
	[6160, 6169],
	[6176, 6264],
	[6272, 6276],
	[6279, 6312],
	[6314],
	[6320, 6389],
	[6400, 6430],
	[6464],
	[6468, 6509],
	[6512, 6516],
	[6528, 6571],
	[6576, 6601],
	[6608, 6618],
	[6622, 6678],
	[6686, 6740],
	[6784, 6793],
	[6800, 6809],
	[6816, 6829],
	[6917, 6963],
	[6981, 6988],
	[6992, 7018],
	[7028, 7038],
	[7043, 7072],
	[7086, 7141],
	[7164, 7203],
	[7227, 7241],
	[7245, 7304],
	[7312, 7354],
	[7357, 7367],
	[7379],
	[7401, 7404],
	[7406, 7411],
	[7413, 7414],
	[7418],
	[7424, 7615],
	[7680, 7957],
	[7960, 7965],
	[7968, 8005],
	[8008, 8013],
	[8016, 8023],
	[8025],
	[8027],
	[8029],
	[8031, 8061],
	[8064, 8116],
	[8118, 8132],
	[8134, 8147],
	[8150, 8155],
	[8157, 8175],
	[8178, 8180],
	[8182, 8190],
	[8192, 8202],
	[8208, 8233],
	[8239, 8287],
	[8304, 8305],
	[8308, 8334],
	[8336, 8348],
	[8352, 8384],
	[8448, 8587],
	[8592, 9254],
	[9280, 9290],
	[9312, 11123],
	[11126, 11157],
	[11159, 11502],
	[11506, 11507],
	[11513, 11557],
	[11559],
	[11565],
	[11568, 11623],
	[11631, 11632],
	[11648, 11670],
	[11680, 11686],
	[11688, 11694],
	[11696, 11702],
	[11704, 11710],
	[11712, 11718],
	[11720, 11726],
	[11728, 11734],
	[11736, 11742],
	[11776, 11869],
	[11904, 11929],
	[11931, 12019],
	[12032, 12245],
	[12272, 12329],
	[12336, 12351],
	[12353, 12438],
	[12443, 12543],
	[12549, 12591],
	[12593, 12686],
	[12688, 12771],
	[12783, 12830],
	[12832, 13312],
	[19903, 19968],
	[40959, 42124],
	[42128, 42182],
	[42192, 42539],
	[42560, 42606],
	[42611],
	[42622, 42653],
	[42656, 42735],
	[42738, 42743],
	[42752, 42954],
	[42960, 42961],
	[42963],
	[42965, 42969],
	[42994, 43009],
	[43011, 43013],
	[43015, 43018],
	[43020, 43042],
	[43048, 43051],
	[43056, 43065],
	[43072, 43127],
	[43138, 43187],
	[43214, 43225],
	[43250, 43262],
	[43264, 43301],
	[43310, 43334],
	[43359],
	[43396, 43442],
	[43457, 43469],
	[43471, 43481],
	[43486, 43492],
	[43494, 43518],
	[43520, 43560],
	[43584, 43586],
	[43588, 43595],
	[43600, 43609],
	[43612, 43642],
	[43646, 43695],
	[43697],
	[43701, 43702],
	[43705, 43709],
	[43712],
	[43714],
	[43739, 43754],
	[43760, 43764],
	[43777, 43782],
	[43785, 43790],
	[43793, 43798],
	[43808, 43814],
	[43816, 43822],
	[43824, 43883],
	[43888, 44002],
	[44011],
	[44016, 44025],
	[44032],
	[55203],
	[63744, 64109],
	[64112, 64217],
	[64256, 64262],
	[64275, 64279],
	[64285],
	[64287, 64310],
	[64312, 64316],
	[64318],
	[64320, 64321],
	[64323, 64324],
	[64326, 64450],
	[64467, 64911],
	[64914, 64967],
	[64975],
	[65008, 65023],
	[65040, 65049],
	[65072, 65106],
	[65108, 65126],
	[65128, 65131],
	[65136, 65140],
	[65142, 65276],
	[65281, 65437],
	[65440, 65470],
	[65474, 65479],
	[65482, 65487],
	[65490, 65495],
	[65498, 65500],
	[65504, 65510],
	[65512, 65518],
	[65532, 65533],
	[65536, 65547],
	[65549, 65574],
	[65576, 65594],
	[65596, 65597],
	[65599, 65613],
	[65616, 65629],
	[65664, 65786],
	[65792, 65794],
	[65799, 65843],
	[65847, 65934],
	[65936, 65948],
	[65952],
	[66e3, 66044],
	[66176, 66204],
	[66208, 66256],
	[66273, 66299],
	[66304, 66339],
	[66349, 66378],
	[66384, 66421],
	[66432, 66461],
	[66463, 66499],
	[66504, 66517],
	[66560, 66717],
	[66720, 66729],
	[66736, 66771],
	[66776, 66811],
	[66816, 66855],
	[66864, 66915],
	[66927, 66938],
	[66940, 66954],
	[66956, 66962],
	[66964, 66965],
	[66967, 66977],
	[66979, 66993],
	[66995, 67001],
	[67003, 67004],
	[67072, 67382],
	[67392, 67413],
	[67424, 67431],
	[67456, 67461],
	[67463, 67504],
	[67506, 67514],
	[67584, 67589],
	[67592],
	[67594, 67637],
	[67639, 67640],
	[67644],
	[67647, 67669],
	[67671, 67742],
	[67751, 67759],
	[67808, 67826],
	[67828, 67829],
	[67835, 67867],
	[67871, 67897],
	[67903],
	[67968, 68023],
	[68028, 68047],
	[68050, 68096],
	[68112, 68115],
	[68117, 68119],
	[68121, 68149],
	[68160, 68168],
	[68176, 68184],
	[68192, 68255],
	[68288, 68324],
	[68331, 68342],
	[68352, 68405],
	[68409, 68437],
	[68440, 68466],
	[68472, 68497],
	[68505, 68508],
	[68521, 68527],
	[68608, 68680],
	[68736, 68786],
	[68800, 68850],
	[68858, 68899],
	[68912, 68921],
	[69216, 69246],
	[69248, 69289],
	[69293],
	[69296, 69297],
	[69376, 69415],
	[69424, 69445],
	[69457, 69465],
	[69488, 69505],
	[69510, 69513],
	[69552, 69579],
	[69600, 69622],
	[69635, 69687],
	[69703, 69709],
	[69714, 69743],
	[69745, 69746],
	[69749],
	[69763, 69807],
	[69819, 69820],
	[69822, 69825],
	[69840, 69864],
	[69872, 69881],
	[69891, 69926],
	[69942, 69956],
	[69959],
	[69968, 70002],
	[70004, 70006],
	[70019, 70066],
	[70081],
	[70084, 70088],
	[70093],
	[70096, 70111],
	[70113, 70132],
	[70144, 70161],
	[70163, 70187],
	[70200, 70205],
	[70207, 70208],
	[70272, 70278],
	[70280],
	[70282, 70285],
	[70287, 70301],
	[70303, 70313],
	[70320, 70366],
	[70384, 70393],
	[70405, 70412],
	[70415, 70416],
	[70419, 70440],
	[70442, 70448],
	[70450, 70451],
	[70453, 70457],
	[70461],
	[70480],
	[70493, 70497],
	[70656, 70708],
	[70727, 70747],
	[70749],
	[70751, 70753],
	[70784, 70831],
	[70852, 70855],
	[70864, 70873],
	[71040, 71086],
	[71105, 71131],
	[71168, 71215],
	[71233, 71236],
	[71248, 71257],
	[71264, 71276],
	[71296, 71338],
	[71352, 71353],
	[71360, 71369],
	[71424, 71450],
	[71472, 71494],
	[71680, 71723],
	[71739],
	[71840, 71922],
	[71935, 71942],
	[71945],
	[71948, 71955],
	[71957, 71958],
	[71960, 71983],
	[72004, 72006],
	[72016, 72025],
	[72096, 72103],
	[72106, 72144],
	[72161, 72163],
	[72192],
	[72203, 72242],
	[72255, 72262],
	[72272],
	[72284, 72323],
	[72346, 72354],
	[72368, 72440],
	[72448, 72457],
	[72704, 72712],
	[72714, 72750],
	[72768, 72773],
	[72784, 72812],
	[72816, 72847],
	[72960, 72966],
	[72968, 72969],
	[72971, 73008],
	[73040, 73049],
	[73056, 73061],
	[73063, 73064],
	[73066, 73097],
	[73112],
	[73120, 73129],
	[73440, 73458],
	[73463, 73464],
	[73476, 73488],
	[73490, 73523],
	[73539, 73561],
	[73648],
	[73664, 73713],
	[73727, 74649],
	[74752, 74862],
	[74864, 74868],
	[74880, 75075],
	[77712, 77810],
	[77824, 78895],
	[78913, 78918],
	[82944, 83526],
	[92160, 92728],
	[92736, 92766],
	[92768, 92777],
	[92782, 92862],
	[92864, 92873],
	[92880, 92909],
	[92917],
	[92928, 92975],
	[92983, 92997],
	[93008, 93017],
	[93019, 93025],
	[93027, 93047],
	[93053, 93071],
	[93760, 93850],
	[93952, 94026],
	[94032],
	[94099, 94111],
	[94176, 94179],
	[94208],
	[100343],
	[100352, 101589],
	[101632],
	[101640],
	[110576, 110579],
	[110581, 110587],
	[110589, 110590],
	[110592, 110882],
	[110898],
	[110928, 110930],
	[110933],
	[110948, 110951],
	[110960, 111355],
	[113664, 113770],
	[113776, 113788],
	[113792, 113800],
	[113808, 113817],
	[113820],
	[113823],
	[118608, 118723],
	[118784, 119029],
	[119040, 119078],
	[119081, 119140],
	[119146, 119148],
	[119171, 119172],
	[119180, 119209],
	[119214, 119274],
	[119296, 119361],
	[119365],
	[119488, 119507],
	[119520, 119539],
	[119552, 119638],
	[119648, 119672],
	[119808, 119892],
	[119894, 119964],
	[119966, 119967],
	[119970],
	[119973, 119974],
	[119977, 119980],
	[119982, 119993],
	[119995],
	[119997, 120003],
	[120005, 120069],
	[120071, 120074],
	[120077, 120084],
	[120086, 120092],
	[120094, 120121],
	[120123, 120126],
	[120128, 120132],
	[120134],
	[120138, 120144],
	[120146, 120485],
	[120488, 120779],
	[120782, 121343],
	[121399, 121402],
	[121453, 121460],
	[121462, 121475],
	[121477, 121483],
	[122624, 122654],
	[122661, 122666],
	[122928, 122989],
	[123136, 123180],
	[123191, 123197],
	[123200, 123209],
	[123214, 123215],
	[123536, 123565],
	[123584, 123627],
	[123632, 123641],
	[123647],
	[124112, 124139],
	[124144, 124153],
	[124896, 124902],
	[124904, 124907],
	[124909, 124910],
	[124912, 124926],
	[124928, 125124],
	[125127, 125135],
	[125184, 125251],
	[125259],
	[125264, 125273],
	[125278, 125279],
	[126065, 126132],
	[126209, 126269],
	[126464, 126467],
	[126469, 126495],
	[126497, 126498],
	[126500],
	[126503],
	[126505, 126514],
	[126516, 126519],
	[126521],
	[126523],
	[126530],
	[126535],
	[126537],
	[126539],
	[126541, 126543],
	[126545, 126546],
	[126548],
	[126551],
	[126553],
	[126555],
	[126557],
	[126559],
	[126561, 126562],
	[126564],
	[126567, 126570],
	[126572, 126578],
	[126580, 126583],
	[126585, 126588],
	[126590],
	[126592, 126601],
	[126603, 126619],
	[126625, 126627],
	[126629, 126633],
	[126635, 126651],
	[126704, 126705],
	[126976, 127019],
	[127024, 127123],
	[127136, 127150],
	[127153, 127167],
	[127169, 127183],
	[127185, 127221],
	[127232, 127405],
	[127488, 127490],
	[127504, 127547],
	[127552, 127560],
	[127568, 127569],
	[127584, 127589],
	[127744, 127994],
	[128e3, 128727],
	[128732, 128748],
	[128752, 128764],
	[128768, 128886],
	[128891, 128985],
	[128992, 129003],
	[129008],
	[129024, 129035],
	[129040, 129095],
	[129104, 129113],
	[129120, 129159],
	[129168, 129197],
	[129200, 129201],
	[129280, 129619],
	[129632, 129645],
	[129648, 129660],
	[129664, 129672],
	[129680, 129725],
	[129727, 129733],
	[129742, 129755],
	[129760, 129768],
	[129776, 129784],
	[129792, 129938],
	[129940, 129994],
	[130032, 130041],
	[131072],
	[173791],
	[173824],
	[177977],
	[177984],
	[178205],
	[178208],
	[183969],
	[183984],
	[191456],
	[191472],
	[192093],
	[194560, 195101],
	[196608],
	[201546],
	[201552],
	[205743]
];
const autonomousDecomposableGraphemeRanges = [
	[192, 197],
	[199, 207],
	[209, 214],
	[217, 221],
	[224, 229],
	[231, 239],
	[241, 246],
	[249, 253],
	[255, 271],
	[274, 293],
	[296, 304],
	[308, 311],
	[313, 318],
	[323, 328],
	[332, 337],
	[340, 357],
	[360, 382],
	[416, 417],
	[431, 432],
	[461, 476],
	[478, 483],
	[486, 496],
	[500, 501],
	[504, 539],
	[542, 543],
	[550, 563],
	[901, 902],
	[904, 906],
	[908],
	[910, 912],
	[938, 944],
	[970, 974],
	[979, 980],
	[1024, 1025],
	[1027],
	[1031],
	[1036, 1038],
	[1049],
	[1081],
	[1104, 1105],
	[1107],
	[1111],
	[1116, 1118],
	[1142, 1143],
	[1217, 1218],
	[1232, 1235],
	[1238, 1239],
	[1242, 1247],
	[1250, 1255],
	[1258, 1269],
	[1272, 1273],
	[1570, 1574],
	[1728],
	[1730],
	[1747],
	[2345],
	[2353],
	[2356],
	[2392, 2399],
	[2524, 2525],
	[2527],
	[2611],
	[2614],
	[2649, 2651],
	[2654],
	[2908, 2909],
	[2964],
	[3907],
	[3917],
	[3922],
	[3927],
	[3932],
	[3945],
	[4134],
	[6918],
	[6920],
	[6922],
	[6924],
	[6926],
	[6930],
	[7680, 7833],
	[7835],
	[7840, 7929],
	[7936, 7957],
	[7960, 7965],
	[7968, 8005],
	[8008, 8013],
	[8016, 8023],
	[8025],
	[8027],
	[8029],
	[8031, 8048],
	[8050],
	[8052],
	[8054],
	[8056],
	[8058],
	[8060],
	[8064, 8116],
	[8118, 8122],
	[8124],
	[8129, 8132],
	[8134, 8136],
	[8138],
	[8140, 8146],
	[8150, 8154],
	[8157, 8162],
	[8164, 8170],
	[8172, 8173],
	[8178, 8180],
	[8182, 8184],
	[8186],
	[8188],
	[8602, 8603],
	[8622],
	[8653, 8655],
	[8708],
	[8713],
	[8716],
	[8740],
	[8742],
	[8769],
	[8772],
	[8775],
	[8777],
	[8800],
	[8802],
	[8813, 8817],
	[8820, 8821],
	[8824, 8825],
	[8832, 8833],
	[8836, 8837],
	[8840, 8841],
	[8876, 8879],
	[8928, 8931],
	[8938, 8941],
	[10972],
	[12364],
	[12366],
	[12368],
	[12370],
	[12372],
	[12374],
	[12376],
	[12378],
	[12380],
	[12382],
	[12384],
	[12386],
	[12389],
	[12391],
	[12393],
	[12400, 12401],
	[12403, 12404],
	[12406, 12407],
	[12409, 12410],
	[12412, 12413],
	[12436],
	[12446],
	[12460],
	[12462],
	[12464],
	[12466],
	[12468],
	[12470],
	[12472],
	[12474],
	[12476],
	[12478],
	[12480],
	[12482],
	[12485],
	[12487],
	[12489],
	[12496, 12497],
	[12499, 12500],
	[12502, 12503],
	[12505, 12506],
	[12508, 12509],
	[12532],
	[12535, 12538],
	[12542],
	[44032],
	[55203],
	[64285],
	[64287],
	[64298, 64310],
	[64312, 64316],
	[64318],
	[64320, 64321],
	[64323, 64324],
	[64326, 64334],
	[69786],
	[69788],
	[69803],
	[119134, 119140],
	[119227, 119232]
];

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/GraphemeRangesHelpers.js
const safeStringFromCodePoint = String.fromCodePoint;
const safeMathMin$1 = Math.min;
const safeMathMax$1 = Math.max;
function convertGraphemeRangeToMapToConstantEntry(range) {
	if (range.length === 1) {
		const codePointString = safeStringFromCodePoint(range[0]);
		return {
			num: 1,
			build: () => codePointString
		};
	}
	const rangeStart = range[0];
	return {
		num: range[1] - range[0] + 1,
		build: (idInGroup) => safeStringFromCodePoint(rangeStart + idInGroup)
	};
}
function intersectGraphemeRanges(rangesA, rangesB) {
	const mergedRanges = [];
	let cursorA = 0;
	let cursorB = 0;
	while (cursorA < rangesA.length && cursorB < rangesB.length) {
		const rangeA = rangesA[cursorA];
		const rangeAMin = rangeA[0];
		const rangeAMax = rangeA.length === 1 ? rangeA[0] : rangeA[1];
		const rangeB = rangesB[cursorB];
		const rangeBMin = rangeB[0];
		const rangeBMax = rangeB.length === 1 ? rangeB[0] : rangeB[1];
		if (rangeAMax < rangeBMin) cursorA += 1;
		else if (rangeBMax < rangeAMin) cursorB += 1;
		else {
			let min = safeMathMax$1(rangeAMin, rangeBMin);
			const max = safeMathMin$1(rangeAMax, rangeBMax);
			if (mergedRanges.length >= 1) {
				const lastMergedRange = mergedRanges[mergedRanges.length - 1];
				const lastMergedRangeMax = lastMergedRange.length === 1 ? lastMergedRange[0] : lastMergedRange[1];
				if (lastMergedRangeMax + 1 === min) {
					min = lastMergedRange[0];
					safePop(mergedRanges);
				}
			}
			safePush(mergedRanges, min === max ? [min] : [min, max]);
			if (rangeAMax <= max) cursorA += 1;
			if (rangeBMax <= max) cursorB += 1;
		}
	}
	return mergedRanges;
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/StringUnitArbitrary.js
const registeredStringUnitInstancesMap = Object.create(null);
function getAlphabetRanges(alphabet) {
	switch (alphabet) {
		case "full": return fullAlphabetRanges;
		case "ascii": return asciiAlphabetRanges;
	}
}
function getOrCreateStringUnitInstance(type, alphabet) {
	const key = `${type}:${alphabet}`;
	const registered = registeredStringUnitInstancesMap[key];
	if (registered !== void 0) return registered;
	const alphabetRanges = getAlphabetRanges(alphabet);
	const ranges = type === "binary" ? alphabetRanges : intersectGraphemeRanges(alphabetRanges, autonomousGraphemeRanges);
	const entries = [];
	for (const range of ranges) safePush(entries, convertGraphemeRangeToMapToConstantEntry(range));
	if (type === "grapheme") {
		const decomposedRanges = intersectGraphemeRanges(alphabetRanges, autonomousDecomposableGraphemeRanges);
		for (const range of decomposedRanges) {
			const rawEntry = convertGraphemeRangeToMapToConstantEntry(range);
			safePush(entries, {
				num: rawEntry.num,
				build: (idInGroup) => safeNormalize(rawEntry.build(idInGroup), "NFD")
			});
		}
	}
	const stringUnitInstance = mapToConstant(...entries);
	registeredStringUnitInstancesMap[key] = stringUnitInstance;
	return stringUnitInstance;
}
function stringUnit(type, alphabet) {
	return getOrCreateStringUnitInstance(type, alphabet);
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/string.js
const safeObjectAssign$1 = Object.assign;
function extractUnitArbitrary(constraints) {
	if (typeof constraints.unit === "object") return constraints.unit;
	switch (constraints.unit) {
		case "grapheme": return stringUnit("grapheme", "full");
		case "grapheme-composite": return stringUnit("composite", "full");
		case "grapheme-ascii":
		case void 0: return stringUnit("grapheme", "ascii");
		case "binary": return stringUnit("binary", "full");
		case "binary-ascii": return stringUnit("binary", "ascii");
	}
}
function string(constraints = {}) {
	const charArbitrary = extractUnitArbitrary(constraints);
	const unmapper = patternsToStringUnmapperFor(charArbitrary, constraints);
	const experimentalCustomSlices = createSlicesForString(charArbitrary, constraints);
	const enrichedConstraints = safeObjectAssign$1(safeObjectAssign$1({}, constraints), { experimentalCustomSlices });
	return array(charArbitrary, enrichedConstraints).map(patternsToStringMapper, unmapper);
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/ArrayInt64.js
const Zero64 = {
	sign: 1,
	data: [0, 0]
};
const Unit64 = {
	sign: 1,
	data: [0, 1]
};
function isZero64(a) {
	return a.data[0] === 0 && a.data[1] === 0;
}
function isStrictlyNegative64(a) {
	return a.sign === -1 && !isZero64(a);
}
function isStrictlyPositive64(a) {
	return a.sign === 1 && !isZero64(a);
}
function isEqual64(a, b) {
	if (a.data[0] === b.data[0] && a.data[1] === b.data[1]) return a.sign === b.sign || a.data[0] === 0 && a.data[1] === 0;
	return false;
}
function isStrictlySmaller64Internal(a, b) {
	return a[0] < b[0] || a[0] === b[0] && a[1] < b[1];
}
function isStrictlySmaller64(a, b) {
	if (a.sign === b.sign) return a.sign === 1 ? isStrictlySmaller64Internal(a.data, b.data) : isStrictlySmaller64Internal(b.data, a.data);
	return a.sign === -1 && (!isZero64(a) || !isZero64(b));
}
function clone64(a) {
	return {
		sign: a.sign,
		data: [a.data[0], a.data[1]]
	};
}
function substract64DataInternal(a, b) {
	let reminderLow = 0;
	let low = a[1] - b[1];
	if (low < 0) {
		reminderLow = 1;
		low = low >>> 0;
	}
	return [a[0] - b[0] - reminderLow, low];
}
function substract64Internal(a, b) {
	if (a.sign === 1 && b.sign === -1) {
		const low = a.data[1] + b.data[1];
		const high = a.data[0] + b.data[0] + (low > 4294967295 ? 1 : 0);
		return {
			sign: 1,
			data: [high >>> 0, low >>> 0]
		};
	}
	return {
		sign: 1,
		data: a.sign === 1 ? substract64DataInternal(a.data, b.data) : substract64DataInternal(b.data, a.data)
	};
}
function substract64(arrayIntA, arrayIntB) {
	if (isStrictlySmaller64(arrayIntA, arrayIntB)) {
		const out = substract64Internal(arrayIntB, arrayIntA);
		out.sign = -1;
		return out;
	}
	return substract64Internal(arrayIntA, arrayIntB);
}
function negative64(arrayIntA) {
	return {
		sign: -arrayIntA.sign,
		data: [arrayIntA.data[0], arrayIntA.data[1]]
	};
}
function add64(arrayIntA, arrayIntB) {
	if (isZero64(arrayIntB)) {
		if (isZero64(arrayIntA)) return clone64(Zero64);
		return clone64(arrayIntA);
	}
	return substract64(arrayIntA, negative64(arrayIntB));
}
function halve64(a) {
	return {
		sign: a.sign,
		data: [Math.floor(a.data[0] / 2), (a.data[0] % 2 === 1 ? 2147483648 : 0) + Math.floor(a.data[1] / 2)]
	};
}
function logLike64(a) {
	return {
		sign: a.sign,
		data: [0, Math.floor(Math.log(a.data[0] * 4294967296 + a.data[1]) / Math.log(2))]
	};
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/ArrayInt64Arbitrary.js
var ArrayInt64Arbitrary = class ArrayInt64Arbitrary extends Arbitrary {
	constructor(min, max) {
		super();
		this.min = min;
		this.max = max;
		this.biasedRanges = null;
	}
	generate(mrng, biasFactor) {
		const range = this.computeGenerateRange(mrng, biasFactor);
		const uncheckedValue = mrng.nextArrayInt(range.min, range.max);
		if (uncheckedValue.data.length === 1) uncheckedValue.data.unshift(0);
		return new Value(uncheckedValue, void 0);
	}
	computeGenerateRange(mrng, biasFactor) {
		if (biasFactor === void 0 || mrng.nextInt(1, biasFactor) !== 1) return {
			min: this.min,
			max: this.max
		};
		const ranges = this.retrieveBiasedRanges();
		if (ranges.length === 1) return ranges[0];
		const id = mrng.nextInt(-2 * (ranges.length - 1), ranges.length - 2);
		return id < 0 ? ranges[0] : ranges[id + 1];
	}
	canShrinkWithoutContext(value) {
		const unsafeValue = value;
		return typeof value === "object" && value !== null && (unsafeValue.sign === -1 || unsafeValue.sign === 1) && Array.isArray(unsafeValue.data) && unsafeValue.data.length === 2 && (isStrictlySmaller64(this.min, unsafeValue) && isStrictlySmaller64(unsafeValue, this.max) || isEqual64(this.min, unsafeValue) || isEqual64(this.max, unsafeValue));
	}
	shrinkArrayInt64(value, target, tryTargetAsap) {
		const realGap = substract64(value, target);
		function* shrinkGen() {
			let previous = tryTargetAsap ? void 0 : target;
			const gap = tryTargetAsap ? realGap : halve64(realGap);
			for (let toremove = gap; !isZero64(toremove); toremove = halve64(toremove)) {
				const next = substract64(value, toremove);
				yield new Value(next, previous);
				previous = next;
			}
		}
		return stream(shrinkGen());
	}
	shrink(current, context) {
		if (!ArrayInt64Arbitrary.isValidContext(current, context)) {
			const target = this.defaultTarget();
			return this.shrinkArrayInt64(current, target, true);
		}
		if (this.isLastChanceTry(current, context)) return Stream.of(new Value(context, void 0));
		return this.shrinkArrayInt64(current, context, false);
	}
	defaultTarget() {
		if (!isStrictlyPositive64(this.min) && !isStrictlyNegative64(this.max)) return Zero64;
		return isStrictlyNegative64(this.min) ? this.max : this.min;
	}
	isLastChanceTry(current, context) {
		if (isZero64(current)) return false;
		if (current.sign === 1) return isEqual64(current, add64(context, Unit64)) && isStrictlyPositive64(substract64(current, this.min));
		else return isEqual64(current, substract64(context, Unit64)) && isStrictlyNegative64(substract64(current, this.max));
	}
	static isValidContext(_current, context) {
		if (context === void 0) return false;
		if (typeof context !== "object" || context === null || !("sign" in context) || !("data" in context)) throw new Error(`Invalid context type passed to ArrayInt64Arbitrary (#1)`);
		return true;
	}
	retrieveBiasedRanges() {
		if (this.biasedRanges != null) return this.biasedRanges;
		if (isEqual64(this.min, this.max)) {
			this.biasedRanges = [{
				min: this.min,
				max: this.max
			}];
			return this.biasedRanges;
		}
		const minStrictlySmallerZero = isStrictlyNegative64(this.min);
		const maxStrictlyGreaterZero = isStrictlyPositive64(this.max);
		if (minStrictlySmallerZero && maxStrictlyGreaterZero) {
			const logMin = logLike64(this.min);
			const logMax = logLike64(this.max);
			this.biasedRanges = [
				{
					min: logMin,
					max: logMax
				},
				{
					min: substract64(this.max, logMax),
					max: this.max
				},
				{
					min: this.min,
					max: substract64(this.min, logMin)
				}
			];
		} else {
			const logGap = logLike64(substract64(this.max, this.min));
			const arbCloseToMin = {
				min: this.min,
				max: add64(this.min, logGap)
			};
			const arbCloseToMax = {
				min: substract64(this.max, logGap),
				max: this.max
			};
			this.biasedRanges = minStrictlySmallerZero ? [arbCloseToMax, arbCloseToMin] : [arbCloseToMin, arbCloseToMax];
		}
		return this.biasedRanges;
	}
};
function arrayInt64(min, max) {
	const arb = new ArrayInt64Arbitrary(min, max);
	return arb;
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/DoubleHelpers.js
const safeNegativeInfinity$6 = Number.NEGATIVE_INFINITY;
const safePositiveInfinity$6 = Number.POSITIVE_INFINITY;
const safeEpsilon = Number.EPSILON;
const INDEX_POSITIVE_INFINITY$1 = {
	sign: 1,
	data: [2146435072, 0]
};
const INDEX_NEGATIVE_INFINITY$1 = {
	sign: -1,
	data: [2146435072, 1]
};
const f64 = new Float64Array(1);
const u32$1 = new Uint32Array(f64.buffer, f64.byteOffset);
function bitCastDoubleToUInt64(f) {
	f64[0] = f;
	return [u32$1[1], u32$1[0]];
}
function decomposeDouble(d) {
	const { 0: hi, 1: lo } = bitCastDoubleToUInt64(d);
	const signBit = hi >>> 31;
	const exponentBits = hi >>> 20 & 2047;
	const significandBits = (hi & 1048575) * 4294967296 + lo;
	const exponent = exponentBits === 0 ? -1022 : exponentBits - 1023;
	let significand = exponentBits === 0 ? 0 : 1;
	significand += significandBits / 2 ** 52;
	significand *= signBit === 0 ? 1 : -1;
	return {
		exponent,
		significand
	};
}
function positiveNumberToInt64(n) {
	return [~~(n / 4294967296), n >>> 0];
}
function indexInDoubleFromDecomp(exponent, significand) {
	if (exponent === -1022) {
		const rescaledSignificand$1 = significand * 2 ** 52;
		return positiveNumberToInt64(rescaledSignificand$1);
	}
	const rescaledSignificand = (significand - 1) * 2 ** 52;
	const exponentOnlyHigh = (exponent + 1023) * 2 ** 20;
	const index = positiveNumberToInt64(rescaledSignificand);
	index[0] += exponentOnlyHigh;
	return index;
}
function doubleToIndex(d) {
	if (d === safePositiveInfinity$6) return clone64(INDEX_POSITIVE_INFINITY$1);
	if (d === safeNegativeInfinity$6) return clone64(INDEX_NEGATIVE_INFINITY$1);
	const decomp = decomposeDouble(d);
	const exponent = decomp.exponent;
	const significand = decomp.significand;
	if (d > 0 || d === 0 && 1 / d === safePositiveInfinity$6) return {
		sign: 1,
		data: indexInDoubleFromDecomp(exponent, significand)
	};
	else {
		const indexOpposite = indexInDoubleFromDecomp(exponent, -significand);
		if (indexOpposite[1] === 4294967295) {
			indexOpposite[0] += 1;
			indexOpposite[1] = 0;
		} else indexOpposite[1] += 1;
		return {
			sign: -1,
			data: indexOpposite
		};
	}
}
function indexToDouble(index) {
	if (index.sign === -1) {
		const indexOpposite = {
			sign: 1,
			data: [index.data[0], index.data[1]]
		};
		if (indexOpposite.data[1] === 0) {
			indexOpposite.data[0] -= 1;
			indexOpposite.data[1] = 4294967295;
		} else indexOpposite.data[1] -= 1;
		return -indexToDouble(indexOpposite);
	}
	if (isEqual64(index, INDEX_POSITIVE_INFINITY$1)) return safePositiveInfinity$6;
	if (index.data[0] < 2097152) return (index.data[0] * 4294967296 + index.data[1]) * 2 ** -1074;
	const postIndexHigh = index.data[0] - 2097152;
	const exponent = -1021 + (postIndexHigh >> 20);
	const significand = 1 + ((postIndexHigh & 1048575) * 2 ** 32 + index.data[1]) * safeEpsilon;
	return significand * 2 ** exponent;
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/FloatingOnlyHelpers.js
const safeNumberIsInteger$2 = Number.isInteger;
const safeObjectIs = Object.is;
const safeNegativeInfinity$5 = Number.NEGATIVE_INFINITY;
const safePositiveInfinity$5 = Number.POSITIVE_INFINITY;
function refineConstraintsForFloatingOnly(constraints, maxValue, maxNonIntegerValue$2, onlyIntegersAfterThisValue$2) {
	const { noDefaultInfinity = false, minExcluded = false, maxExcluded = false, min = noDefaultInfinity ? -maxValue : safeNegativeInfinity$5, max = noDefaultInfinity ? maxValue : safePositiveInfinity$5 } = constraints;
	const effectiveMin = minExcluded ? min < -maxNonIntegerValue$2 ? -onlyIntegersAfterThisValue$2 : Math.max(min, -maxNonIntegerValue$2) : min === safeNegativeInfinity$5 ? Math.max(min, -onlyIntegersAfterThisValue$2) : Math.max(min, -maxNonIntegerValue$2);
	const effectiveMax = maxExcluded ? max > maxNonIntegerValue$2 ? onlyIntegersAfterThisValue$2 : Math.min(max, maxNonIntegerValue$2) : max === safePositiveInfinity$5 ? Math.min(max, onlyIntegersAfterThisValue$2) : Math.min(max, maxNonIntegerValue$2);
	const fullConstraints = {
		noDefaultInfinity: false,
		minExcluded: minExcluded || (min !== safeNegativeInfinity$5 || minExcluded) && safeNumberIsInteger$2(effectiveMin),
		maxExcluded: maxExcluded || (max !== safePositiveInfinity$5 || maxExcluded) && safeNumberIsInteger$2(effectiveMax),
		min: safeObjectIs(effectiveMin, -0) ? 0 : effectiveMin,
		max: safeObjectIs(effectiveMax, 0) ? -0 : effectiveMax,
		noNaN: constraints.noNaN || false
	};
	return fullConstraints;
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/DoubleOnlyHelpers.js
const safeNegativeInfinity$4 = Number.NEGATIVE_INFINITY;
const safePositiveInfinity$4 = Number.POSITIVE_INFINITY;
const safeMaxValue$2 = Number.MAX_VALUE;
const maxNonIntegerValue$1 = 4503599627370495.5;
const onlyIntegersAfterThisValue$1 = 4503599627370496;
function refineConstraintsForDoubleOnly(constraints) {
	return refineConstraintsForFloatingOnly(constraints, safeMaxValue$2, maxNonIntegerValue$1, onlyIntegersAfterThisValue$1);
}
function doubleOnlyMapper(value) {
	return value === onlyIntegersAfterThisValue$1 ? safePositiveInfinity$4 : value === -onlyIntegersAfterThisValue$1 ? safeNegativeInfinity$4 : value;
}
function doubleOnlyUnmapper(value) {
	if (typeof value !== "number") throw new Error("Unsupported type");
	return value === safePositiveInfinity$4 ? onlyIntegersAfterThisValue$1 : value === safeNegativeInfinity$4 ? -onlyIntegersAfterThisValue$1 : value;
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/double.js
const safeNumberIsInteger$1 = Number.isInteger;
const safeNumberIsNaN$1 = Number.isNaN;
const safeNegativeInfinity$3 = Number.NEGATIVE_INFINITY;
const safePositiveInfinity$3 = Number.POSITIVE_INFINITY;
const safeMaxValue$1 = Number.MAX_VALUE;
const safeNaN$1 = NaN;
function safeDoubleToIndex(d, constraintsLabel) {
	if (safeNumberIsNaN$1(d)) throw new Error("fc.double constraints." + constraintsLabel + " must be a 64-bit float");
	return doubleToIndex(d);
}
function unmapperDoubleToIndex(value) {
	if (typeof value !== "number") throw new Error("Unsupported type");
	return doubleToIndex(value);
}
function numberIsNotInteger$1(value) {
	return !safeNumberIsInteger$1(value);
}
function anyDouble(constraints) {
	const { noDefaultInfinity = false, noNaN = false, minExcluded = false, maxExcluded = false, min = noDefaultInfinity ? -safeMaxValue$1 : safeNegativeInfinity$3, max = noDefaultInfinity ? safeMaxValue$1 : safePositiveInfinity$3 } = constraints;
	const minIndexRaw = safeDoubleToIndex(min, "min");
	const minIndex = minExcluded ? add64(minIndexRaw, Unit64) : minIndexRaw;
	const maxIndexRaw = safeDoubleToIndex(max, "max");
	const maxIndex = maxExcluded ? substract64(maxIndexRaw, Unit64) : maxIndexRaw;
	if (isStrictlySmaller64(maxIndex, minIndex)) throw new Error("fc.double constraints.min must be smaller or equal to constraints.max");
	if (noNaN) return arrayInt64(minIndex, maxIndex).map(indexToDouble, unmapperDoubleToIndex);
	const positiveMaxIdx = isStrictlyPositive64(maxIndex);
	const minIndexWithNaN = positiveMaxIdx ? minIndex : substract64(minIndex, Unit64);
	const maxIndexWithNaN = positiveMaxIdx ? add64(maxIndex, Unit64) : maxIndex;
	return arrayInt64(minIndexWithNaN, maxIndexWithNaN).map((index) => {
		if (isStrictlySmaller64(maxIndex, index) || isStrictlySmaller64(index, minIndex)) return safeNaN$1;
		else return indexToDouble(index);
	}, (value) => {
		if (typeof value !== "number") throw new Error("Unsupported type");
		if (safeNumberIsNaN$1(value)) return !isEqual64(maxIndex, maxIndexWithNaN) ? maxIndexWithNaN : minIndexWithNaN;
		return doubleToIndex(value);
	});
}
function double(constraints = {}) {
	if (!constraints.noInteger) return anyDouble(constraints);
	return anyDouble(refineConstraintsForDoubleOnly(constraints)).map(doubleOnlyMapper, doubleOnlyUnmapper).filter(numberIsNotInteger$1);
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/FloatHelpers.js
const safeNegativeInfinity$2 = Number.NEGATIVE_INFINITY;
const safePositiveInfinity$2 = Number.POSITIVE_INFINITY;
const MIN_VALUE_32 = 2 ** -126 * 2 ** -23;
const MAX_VALUE_32 = 2 ** 127 * (1 + (2 ** 23 - 1) / 2 ** 23);
const EPSILON_32 = 2 ** -23;
const INDEX_POSITIVE_INFINITY = 2139095040;
const INDEX_NEGATIVE_INFINITY = -2139095041;
const f32 = new Float32Array(1);
const u32 = new Uint32Array(f32.buffer, f32.byteOffset);
function bitCastFloatToUInt32(f) {
	f32[0] = f;
	return u32[0];
}
function decomposeFloat(f) {
	const bits = bitCastFloatToUInt32(f);
	const signBit = bits >>> 31;
	const exponentBits = bits >>> 23 & 255;
	const significandBits = bits & 8388607;
	const exponent = exponentBits === 0 ? -126 : exponentBits - 127;
	let significand = exponentBits === 0 ? 0 : 1;
	significand += significandBits / 2 ** 23;
	significand *= signBit === 0 ? 1 : -1;
	return {
		exponent,
		significand
	};
}
function indexInFloatFromDecomp(exponent, significand) {
	if (exponent === -126) return significand * 8388608;
	return (exponent + 127) * 8388608 + (significand - 1) * 8388608;
}
function floatToIndex(f) {
	if (f === safePositiveInfinity$2) return INDEX_POSITIVE_INFINITY;
	if (f === safeNegativeInfinity$2) return INDEX_NEGATIVE_INFINITY;
	const decomp = decomposeFloat(f);
	const exponent = decomp.exponent;
	const significand = decomp.significand;
	if (f > 0 || f === 0 && 1 / f === safePositiveInfinity$2) return indexInFloatFromDecomp(exponent, significand);
	else return -indexInFloatFromDecomp(exponent, -significand) - 1;
}
function indexToFloat(index) {
	if (index < 0) return -indexToFloat(-index - 1);
	if (index === INDEX_POSITIVE_INFINITY) return safePositiveInfinity$2;
	if (index < 16777216) return index * 2 ** -149;
	const postIndex = index - 16777216;
	const exponent = -125 + (postIndex >> 23);
	const significand = 1 + (postIndex & 8388607) / 8388608;
	return significand * 2 ** exponent;
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/FloatOnlyHelpers.js
const safeNegativeInfinity$1 = Number.NEGATIVE_INFINITY;
const safePositiveInfinity$1 = Number.POSITIVE_INFINITY;
const safeMaxValue = MAX_VALUE_32;
const maxNonIntegerValue = 8388607.5;
const onlyIntegersAfterThisValue = 8388608;
function refineConstraintsForFloatOnly(constraints) {
	return refineConstraintsForFloatingOnly(constraints, safeMaxValue, maxNonIntegerValue, onlyIntegersAfterThisValue);
}
function floatOnlyMapper(value) {
	return value === onlyIntegersAfterThisValue ? safePositiveInfinity$1 : value === -onlyIntegersAfterThisValue ? safeNegativeInfinity$1 : value;
}
function floatOnlyUnmapper(value) {
	if (typeof value !== "number") throw new Error("Unsupported type");
	return value === safePositiveInfinity$1 ? onlyIntegersAfterThisValue : value === safeNegativeInfinity$1 ? -onlyIntegersAfterThisValue : value;
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/float.js
const safeNumberIsInteger = Number.isInteger;
const safeNumberIsNaN = Number.isNaN;
const safeMathFround = Math.fround;
const safeNegativeInfinity = Number.NEGATIVE_INFINITY;
const safePositiveInfinity = Number.POSITIVE_INFINITY;
const safeNaN = NaN;
function safeFloatToIndex(f, constraintsLabel) {
	const conversionTrick = "you can convert any double to a 32-bit float by using `Math.fround(myDouble)`";
	const errorMessage = "fc.float constraints." + constraintsLabel + " must be a 32-bit float - you can convert any double to a 32-bit float by using `Math.fround(myDouble)`";
	if (safeNumberIsNaN(f) || safeMathFround(f) !== f) throw new Error(errorMessage);
	return floatToIndex(f);
}
function unmapperFloatToIndex(value) {
	if (typeof value !== "number") throw new Error("Unsupported type");
	return floatToIndex(value);
}
function numberIsNotInteger(value) {
	return !safeNumberIsInteger(value);
}
function anyFloat(constraints) {
	const { noDefaultInfinity = false, noNaN = false, minExcluded = false, maxExcluded = false, min = noDefaultInfinity ? -MAX_VALUE_32 : safeNegativeInfinity, max = noDefaultInfinity ? MAX_VALUE_32 : safePositiveInfinity } = constraints;
	const minIndexRaw = safeFloatToIndex(min, "min");
	const minIndex = minExcluded ? minIndexRaw + 1 : minIndexRaw;
	const maxIndexRaw = safeFloatToIndex(max, "max");
	const maxIndex = maxExcluded ? maxIndexRaw - 1 : maxIndexRaw;
	if (minIndex > maxIndex) throw new Error("fc.float constraints.min must be smaller or equal to constraints.max");
	if (noNaN) return integer({
		min: minIndex,
		max: maxIndex
	}).map(indexToFloat, unmapperFloatToIndex);
	const minIndexWithNaN = maxIndex > 0 ? minIndex : minIndex - 1;
	const maxIndexWithNaN = maxIndex > 0 ? maxIndex + 1 : maxIndex;
	return integer({
		min: minIndexWithNaN,
		max: maxIndexWithNaN
	}).map((index) => {
		if (index > maxIndex || index < minIndex) return safeNaN;
		else return indexToFloat(index);
	}, (value) => {
		if (typeof value !== "number") throw new Error("Unsupported type");
		if (safeNumberIsNaN(value)) return maxIndex !== maxIndexWithNaN ? maxIndexWithNaN : minIndexWithNaN;
		return floatToIndex(value);
	});
}
function float(constraints = {}) {
	if (!constraints.noInteger) return anyFloat(constraints);
	return anyFloat(refineConstraintsForFloatOnly(constraints)).map(floatOnlyMapper, floatOnlyUnmapper).filter(numberIsNotInteger);
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/maxSafeInteger.js
const safeMinSafeInteger = Number.MIN_SAFE_INTEGER;
const safeMaxSafeInteger = Number.MAX_SAFE_INTEGER;
function maxSafeInteger() {
	return new IntegerArbitrary(safeMinSafeInteger, safeMaxSafeInteger);
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/CodePointsToString.js
function codePointsToStringMapper(tab) {
	return safeJoin(tab, "");
}
function codePointsToStringUnmapper(value) {
	if (typeof value !== "string") throw new Error("Cannot unmap the passed value");
	return [...value];
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/LazyArbitrary.js
var LazyArbitrary = class extends Arbitrary {
	constructor(name) {
		super();
		this.name = name;
		this.underlying = null;
	}
	generate(mrng, biasFactor) {
		if (!this.underlying) throw new Error(`Lazy arbitrary ${JSON.stringify(this.name)} not correctly initialized`);
		return this.underlying.generate(mrng, biasFactor);
	}
	canShrinkWithoutContext(value) {
		if (!this.underlying) throw new Error(`Lazy arbitrary ${JSON.stringify(this.name)} not correctly initialized`);
		return this.underlying.canShrinkWithoutContext(value);
	}
	shrink(value, context) {
		if (!this.underlying) throw new Error(`Lazy arbitrary ${JSON.stringify(this.name)} not correctly initialized`);
		return this.underlying.shrink(value, context);
	}
};

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/letrec.js
const safeObjectCreate = Object.create;
function letrec(builder) {
	const lazyArbs = safeObjectCreate(null);
	const tie = (key) => {
		if (!safeHasOwnProperty(lazyArbs, key)) lazyArbs[key] = new LazyArbitrary(String(key));
		return lazyArbs[key];
	};
	const strictArbs = builder(tie);
	for (const key in strictArbs) {
		if (!safeHasOwnProperty(strictArbs, key)) continue;
		const lazyAtKey = lazyArbs[key];
		const lazyArb = lazyAtKey !== void 0 ? lazyAtKey : new LazyArbitrary(key);
		lazyArb.underlying = strictArbs[key];
		lazyArbs[key] = lazyArb;
	}
	return strictArbs;
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/float32Array.js
function toTypedMapper$1(data) {
	return SFloat32Array.from(data);
}
function fromTypedUnmapper$1(value) {
	if (!(value instanceof SFloat32Array)) throw new Error("Unexpected type");
	return [...value];
}
function float32Array(constraints = {}) {
	return array(float(constraints), constraints).map(toTypedMapper$1, fromTypedUnmapper$1);
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/float64Array.js
function toTypedMapper(data) {
	return SFloat64Array.from(data);
}
function fromTypedUnmapper(value) {
	if (!(value instanceof SFloat64Array)) throw new Error("Unexpected type");
	return [...value];
}
function float64Array(constraints = {}) {
	return array(double(constraints), constraints).map(toTypedMapper, fromTypedUnmapper);
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/builders/TypedIntArrayArbitraryBuilder.js
var __rest = void 0 && (void 0).__rest || function(s, e) {
	var t = {};
	for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
	}
	return t;
};
function typedIntArrayArbitraryArbitraryBuilder(constraints, defaultMin, defaultMax, TypedArrayClass, arbitraryBuilder) {
	const generatorName = TypedArrayClass.name;
	const { min = defaultMin, max = defaultMax } = constraints, arrayConstraints = __rest(constraints, ["min", "max"]);
	if (min > max) throw new Error(`Invalid range passed to ${generatorName}: min must be lower than or equal to max`);
	if (min < defaultMin) throw new Error(`Invalid min value passed to ${generatorName}: min must be greater than or equal to ${defaultMin}`);
	if (max > defaultMax) throw new Error(`Invalid max value passed to ${generatorName}: max must be lower than or equal to ${defaultMax}`);
	return array(arbitraryBuilder({
		min,
		max
	}), arrayConstraints).map((data) => TypedArrayClass.from(data), (value) => {
		if (!(value instanceof TypedArrayClass)) throw new Error("Invalid type");
		return [...value];
	});
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/int16Array.js
function int16Array(constraints = {}) {
	return typedIntArrayArbitraryArbitraryBuilder(constraints, -32768, 32767, SInt16Array, integer);
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/int32Array.js
function int32Array(constraints = {}) {
	return typedIntArrayArbitraryArbitraryBuilder(constraints, -2147483648, 2147483647, SInt32Array, integer);
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/int8Array.js
function int8Array(constraints = {}) {
	return typedIntArrayArbitraryArbitraryBuilder(constraints, -128, 127, SInt8Array, integer);
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/uint16Array.js
function uint16Array(constraints = {}) {
	return typedIntArrayArbitraryArbitraryBuilder(constraints, 0, 65535, SUint16Array, integer);
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/uint32Array.js
function uint32Array(constraints = {}) {
	return typedIntArrayArbitraryArbitraryBuilder(constraints, 0, 4294967295, SUint32Array, integer);
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/uint8Array.js
function uint8Array(constraints = {}) {
	return typedIntArrayArbitraryArbitraryBuilder(constraints, 0, 255, SUint8Array, integer);
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/uint8ClampedArray.js
function uint8ClampedArray(constraints = {}) {
	return typedIntArrayArbitraryArbitraryBuilder(constraints, 0, 255, SUint8ClampedArray, integer);
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/WithShrinkFromOtherArbitrary.js
function isSafeContext(context) {
	return context !== void 0;
}
function toGeneratorValue(value) {
	if (value.hasToBeCloned) return new Value(value.value_, { generatorContext: value.context }, () => value.value);
	return new Value(value.value_, { generatorContext: value.context });
}
function toShrinkerValue(value) {
	if (value.hasToBeCloned) return new Value(value.value_, { shrinkerContext: value.context }, () => value.value);
	return new Value(value.value_, { shrinkerContext: value.context });
}
var WithShrinkFromOtherArbitrary = class extends Arbitrary {
	constructor(generatorArbitrary, shrinkerArbitrary) {
		super();
		this.generatorArbitrary = generatorArbitrary;
		this.shrinkerArbitrary = shrinkerArbitrary;
	}
	generate(mrng, biasFactor) {
		return toGeneratorValue(this.generatorArbitrary.generate(mrng, biasFactor));
	}
	canShrinkWithoutContext(value) {
		return this.shrinkerArbitrary.canShrinkWithoutContext(value);
	}
	shrink(value, context) {
		if (!isSafeContext(context)) return this.shrinkerArbitrary.shrink(value, void 0).map(toShrinkerValue);
		if ("generatorContext" in context) return this.generatorArbitrary.shrink(value, context.generatorContext).map(toGeneratorValue);
		return this.shrinkerArbitrary.shrink(value, context.shrinkerContext).map(toShrinkerValue);
	}
};

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/builders/RestrictedIntegerArbitraryBuilder.js
function restrictedIntegerArbitraryBuilder(min, maxGenerated, max) {
	const generatorArbitrary = integer({
		min,
		max: maxGenerated
	});
	if (maxGenerated === max) return generatorArbitrary;
	const shrinkerArbitrary = integer({
		min,
		max
	});
	return new WithShrinkFromOtherArbitrary(generatorArbitrary, shrinkerArbitrary);
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/sparseArray.js
const safeMathMin = Math.min;
const safeMathMax = Math.max;
const safeArrayIsArray = SArray.isArray;
const safeObjectEntries = Object.entries;
function extractMaxIndex(indexesAndValues) {
	let maxIndex = -1;
	for (let index = 0; index !== indexesAndValues.length; ++index) maxIndex = safeMathMax(maxIndex, indexesAndValues[index][0]);
	return maxIndex;
}
function arrayFromItems(length, indexesAndValues) {
	const array$1 = SArray(length);
	for (let index = 0; index !== indexesAndValues.length; ++index) {
		const it = indexesAndValues[index];
		if (it[0] < length) array$1[it[0]] = it[1];
	}
	return array$1;
}
function sparseArray(arb, constraints = {}) {
	const { size, minNumElements = 0, maxLength = MaxLengthUpperBound, maxNumElements = maxLength, noTrailingHole, depthIdentifier } = constraints;
	const maxGeneratedNumElements = maxGeneratedLengthFromSizeForArbitrary(size, minNumElements, maxNumElements, constraints.maxNumElements !== void 0);
	const maxGeneratedLength = maxGeneratedLengthFromSizeForArbitrary(size, maxGeneratedNumElements, maxLength, constraints.maxLength !== void 0);
	if (minNumElements > maxLength) throw new Error(`The minimal number of non-hole elements cannot be higher than the maximal length of the array`);
	if (minNumElements > maxNumElements) throw new Error(`The minimal number of non-hole elements cannot be higher than the maximal number of non-holes`);
	const resultedMaxNumElements = safeMathMin(maxNumElements, maxLength);
	const resultedSizeMaxNumElements = constraints.maxNumElements !== void 0 || size !== void 0 ? size : "=";
	const maxGeneratedIndexAuthorized = safeMathMax(maxGeneratedLength - 1, 0);
	const maxIndexAuthorized = safeMathMax(maxLength - 1, 0);
	const sparseArrayNoTrailingHole = uniqueArray(tuple(restrictedIntegerArbitraryBuilder(0, maxGeneratedIndexAuthorized, maxIndexAuthorized), arb), {
		size: resultedSizeMaxNumElements,
		minLength: minNumElements,
		maxLength: resultedMaxNumElements,
		selector: (item) => item[0],
		depthIdentifier
	}).map((items) => {
		const lastIndex = extractMaxIndex(items);
		return arrayFromItems(lastIndex + 1, items);
	}, (value) => {
		if (!safeArrayIsArray(value)) throw new Error("Not supported entry type");
		if (noTrailingHole && value.length !== 0 && !(value.length - 1 in value)) throw new Error("No trailing hole");
		return safeMap(safeObjectEntries(value), (entry) => [Number(entry[0]), entry[1]]);
	});
	if (noTrailingHole || maxLength === minNumElements) return sparseArrayNoTrailingHole;
	return tuple(sparseArrayNoTrailingHole, restrictedIntegerArbitraryBuilder(minNumElements, maxGeneratedLength, maxLength)).map((data) => {
		const sparse = data[0];
		const targetLength = data[1];
		if (sparse.length >= targetLength) return sparse;
		const longerSparse = safeSlice(sparse);
		longerSparse.length = targetLength;
		return longerSparse;
	}, (value) => {
		if (!safeArrayIsArray(value)) throw new Error("Not supported entry type");
		return [value, value.length];
	});
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/ArrayToMap.js
function arrayToMapMapper(data) {
	return new Map(data);
}
function arrayToMapUnmapper(value) {
	if (typeof value !== "object" || value === null) throw new Error("Incompatible instance received: should be a non-null object");
	if (!("constructor" in value) || value.constructor !== Map) throw new Error("Incompatible instance received: should be of exact type Map");
	return Array.from(value);
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/ArrayToSet.js
function arrayToSetMapper(data) {
	return new Set(data);
}
function arrayToSetUnmapper(value) {
	if (typeof value !== "object" || value === null) throw new Error("Incompatible instance received: should be a non-null object");
	if (!("constructor" in value) || value.constructor !== Set) throw new Error("Incompatible instance received: should be of exact type Set");
	return Array.from(value);
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/builders/AnyArbitraryBuilder.js
function mapOf(ka, va, maxKeys, size, depthIdentifier) {
	return uniqueArray(tuple(ka, va), {
		maxLength: maxKeys,
		size,
		comparator: "SameValueZero",
		selector: (t) => t[0],
		depthIdentifier
	}).map(arrayToMapMapper, arrayToMapUnmapper);
}
function dictOf(ka, va, maxKeys, size, depthIdentifier, withNullPrototype) {
	return dictionary(ka, va, {
		maxKeys,
		noNullPrototype: !withNullPrototype,
		size,
		depthIdentifier
	});
}
function setOf(va, maxKeys, size, depthIdentifier) {
	return uniqueArray(va, {
		maxLength: maxKeys,
		size,
		comparator: "SameValueZero",
		depthIdentifier
	}).map(arrayToSetMapper, arrayToSetUnmapper);
}
function typedArray(constraints) {
	return oneof(int8Array(constraints), uint8Array(constraints), uint8ClampedArray(constraints), int16Array(constraints), uint16Array(constraints), int32Array(constraints), uint32Array(constraints), float32Array(constraints), float64Array(constraints));
}
function anyArbitraryBuilder(constraints) {
	const arbitrariesForBase = constraints.values;
	const depthSize = constraints.depthSize;
	const depthIdentifier = createDepthIdentifier();
	const maxDepth = constraints.maxDepth;
	const maxKeys = constraints.maxKeys;
	const size = constraints.size;
	const baseArb = oneof(...arbitrariesForBase, ...constraints.withBigInt ? [bigInt()] : [], ...constraints.withDate ? [date()] : []);
	return letrec((tie) => ({
		anything: oneof({
			maxDepth,
			depthSize,
			depthIdentifier
		}, baseArb, tie("array"), tie("object"), ...constraints.withMap ? [tie("map")] : [], ...constraints.withSet ? [tie("set")] : [], ...constraints.withObjectString ? [tie("anything").map((o) => stringify(o))] : [], ...constraints.withTypedArray ? [typedArray({
			maxLength: maxKeys,
			size
		})] : [], ...constraints.withSparseArray ? [sparseArray(tie("anything"), {
			maxNumElements: maxKeys,
			size,
			depthIdentifier
		})] : []),
		keys: constraints.withObjectString ? oneof({
			arbitrary: constraints.key,
			weight: 10
		}, {
			arbitrary: tie("anything").map((o) => stringify(o)),
			weight: 1
		}) : constraints.key,
		array: array(tie("anything"), {
			maxLength: maxKeys,
			size,
			depthIdentifier
		}),
		set: setOf(tie("anything"), maxKeys, size, depthIdentifier),
		map: oneof(mapOf(tie("keys"), tie("anything"), maxKeys, size, depthIdentifier), mapOf(tie("anything"), tie("anything"), maxKeys, size, depthIdentifier)),
		object: dictOf(tie("keys"), tie("anything"), maxKeys, size, depthIdentifier, constraints.withNullPrototype)
	})).anything;
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/fullUnicodeString.js
const safeObjectAssign = Object.assign;
function fullUnicodeString(constraints = {}) {
	const charArbitrary = fullUnicode();
	const experimentalCustomSlices = createSlicesForStringLegacy(charArbitrary, codePointsToStringUnmapper);
	const enrichedConstraints = safeObjectAssign(safeObjectAssign({}, constraints), { experimentalCustomSlices });
	return array(charArbitrary, enrichedConstraints).map(codePointsToStringMapper, codePointsToStringUnmapper);
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/UnboxedToBoxed.js
function unboxedToBoxedMapper(value) {
	switch (typeof value) {
		case "boolean": return new SBoolean(value);
		case "number": return new SNumber(value);
		case "string": return new SString(value);
		default: return value;
	}
}
function unboxedToBoxedUnmapper(value) {
	if (typeof value !== "object" || value === null || !("constructor" in value)) return value;
	return value.constructor === SBoolean || value.constructor === SNumber || value.constructor === SString ? value.valueOf() : value;
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/builders/BoxedArbitraryBuilder.js
function boxedArbitraryBuilder(arb) {
	return arb.map(unboxedToBoxedMapper, unboxedToBoxedUnmapper);
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/QualifiedObjectConstraints.js
function defaultValues(constraints, stringArbitrary) {
	return [
		boolean(),
		maxSafeInteger(),
		double(),
		stringArbitrary(constraints),
		oneof(stringArbitrary(constraints), constant(null), constant(void 0))
	];
}
function boxArbitraries(arbs) {
	return arbs.map((arb) => boxedArbitraryBuilder(arb));
}
function boxArbitrariesIfNeeded(arbs, boxEnabled) {
	return boxEnabled ? boxArbitraries(arbs).concat(arbs) : arbs;
}
function toQualifiedObjectConstraints(settings = {}) {
	function orDefault(optionalValue, defaultValue) {
		return optionalValue !== void 0 ? optionalValue : defaultValue;
	}
	const stringArbitrary = "stringUnit" in settings ? string : settings.withUnicodeString ? fullUnicodeString : string;
	const valueConstraints = {
		size: settings.size,
		unit: settings.stringUnit
	};
	return {
		key: orDefault(settings.key, stringArbitrary(valueConstraints)),
		values: boxArbitrariesIfNeeded(orDefault(settings.values, defaultValues(valueConstraints, stringArbitrary)), orDefault(settings.withBoxedValues, false)),
		depthSize: settings.depthSize,
		maxDepth: settings.maxDepth,
		maxKeys: settings.maxKeys,
		size: settings.size,
		withSet: orDefault(settings.withSet, false),
		withMap: orDefault(settings.withMap, false),
		withObjectString: orDefault(settings.withObjectString, false),
		withNullPrototype: orDefault(settings.withNullPrototype, false),
		withBigInt: orDefault(settings.withBigInt, false),
		withDate: orDefault(settings.withDate, false),
		withTypedArray: orDefault(settings.withTypedArray, false),
		withSparseArray: orDefault(settings.withSparseArray, false)
	};
}

//#endregion
//#region ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/anything.js
function anything(constraints) {
	return anyArbitraryBuilder(toQualifiedObjectConstraints(constraints));
}

//#endregion
//#region src/vocab/actor.test.ts
function actorClass() {
	return constantFrom(Application, Group, Organization, Person, Service);
}
function actorClassAndInstance() {
	return actorClass().map((cls) => [cls, new cls({})]);
}
function actor() {
	return actorClassAndInstance().map(([, instance]) => instance);
}
test("isActor()", () => {
	assert$1(property(actor(), (actor$1) => assert(isActor(actor$1))));
	assert$1(property(anything({
		withBigInt: true,
		withBoxedValues: true,
		withDate: true,
		withMap: true,
		withNullPrototype: true,
		withObjectString: true,
		withSet: true,
		withTypedArray: true,
		withSparseArray: true
	}), (nonActor) => assertFalse(isActor(nonActor))));
});
test("getActorTypeName()", () => {
	assert$1(property(actorClassAndInstance(), ([cls, instance]) => assertEquals(getActorTypeName(instance), cls.name)));
});
test("getActorClassByTypeName()", () => {
	assert$1(property(actorClassAndInstance(), ([cls, instance]) => assertStrictEquals(getActorClassByTypeName(getActorTypeName(instance)), cls)));
});
test({
	name: "getActorHandle()",
	permissions: {
		env: true,
		read: true
	},
	async fn(t) {
		esm_default.spyGlobal();
		esm_default.get("begin:https://foo.example.com/.well-known/webfinger?", {
			body: { subject: "acct:johndoe@foo.example.com" },
			headers: { "Content-Type": "application/jrd+json" }
		});
		const actorId = new URL("https://foo.example.com/@john");
		const actor$1 = new Person({
			id: actorId,
			preferredUsername: "john"
		});
		await t.step("WebFinger subject", async () => {
			assertEquals(await getActorHandle(actor$1), "@johndoe@foo.example.com");
			assertEquals(await getActorHandle(actor$1, { trimLeadingAt: true }), "johndoe@foo.example.com");
			assertEquals(await getActorHandle(actorId), "@johndoe@foo.example.com");
			assertEquals(await getActorHandle(actorId, { trimLeadingAt: true }), "johndoe@foo.example.com");
		});
		esm_default.removeRoutes();
		esm_default.get("begin:https://foo.example.com/.well-known/webfinger?", {
			body: {
				subject: "https://foo.example.com/@john",
				aliases: ["acct:john@bar.example.com", "acct:johndoe@foo.example.com"]
			},
			headers: { "Content-Type": "application/jrd+json" }
		});
		await t.step("WebFinger aliases", async () => {
			assertEquals(await getActorHandle(actor$1), "@johndoe@foo.example.com");
			assertEquals(await getActorHandle(actor$1, { trimLeadingAt: true }), "johndoe@foo.example.com");
			assertEquals(await getActorHandle(actorId), "@johndoe@foo.example.com");
			assertEquals(await getActorHandle(actorId, { trimLeadingAt: true }), "johndoe@foo.example.com");
		});
		esm_default.get("begin:https://bar.example.com/.well-known/webfinger?", {
			body: {
				subject: "acct:john@bar.example.com",
				aliases: ["https://foo.example.com/@john"]
			},
			headers: { "Content-Type": "application/jrd+json" }
		});
		await t.step("cross-origin WebFinger resources", async () => {
			assertEquals(await getActorHandle(actor$1), "@john@bar.example.com");
		});
		esm_default.removeRoutes();
		esm_default.get("begin:https://foo.example.com/.well-known/webfinger?", { status: 404 });
		await t.step("no WebFinger", async () => {
			assertEquals(await getActorHandle(actor$1), "@john@foo.example.com");
			assertRejects(() => getActorHandle(actorId), TypeError);
		});
		esm_default.hardReset();
	}
});
test("normalizeActorHandle()", () => {
	assertEquals(normalizeActorHandle("@foo@BAR.COM"), "@foo@bar.com");
	assertEquals(normalizeActorHandle("@BAZ@-.com"), "@BAZ@-.com");
	assertEquals(normalizeActorHandle("@qux@xn--maana-pta.com"), "@qux@maana.com");
	assertEquals(normalizeActorHandle("@quux@XN--MAANA-PTA.COM"), "@quux@maana.com");
	assertEquals(normalizeActorHandle("@quux@MAANA.COM"), "@quux@maana.com");
	assertEquals(normalizeActorHandle("@foo@BAR.COM", { trimLeadingAt: true }), "foo@bar.com");
	assertEquals(normalizeActorHandle("@BAZ@-.com", { trimLeadingAt: true }), "BAZ@-.com");
	assertEquals(normalizeActorHandle("@qux@xn--maana-pta.com", { trimLeadingAt: true }), "qux@maana.com");
	assertEquals(normalizeActorHandle("@quux@XN--MAANA-PTA.COM", { trimLeadingAt: true }), "quux@maana.com");
	assertEquals(normalizeActorHandle("@quux@MAANA.COM", { trimLeadingAt: true }), "quux@maana.com");
	assertEquals(normalizeActorHandle("@foo@BAR.COM", { punycode: true }), "@foo@bar.com");
	assertEquals(normalizeActorHandle("@BAZ@-.com", { punycode: true }), "@BAZ@xn----dqo34k.com");
	assertEquals(normalizeActorHandle("@qux@xn--maana-pta.com", { punycode: true }), "@qux@xn--maana-pta.com");
	assertEquals(normalizeActorHandle("@quux@XN--MAANA-PTA.COM", { punycode: true }), "@quux@xn--maana-pta.com");
	assertEquals(normalizeActorHandle("@quux@MAANA.COM", { punycode: true }), "@quux@xn--maana-pta.com");
	assertThrows(() => normalizeActorHandle(""));
	assertThrows(() => normalizeActorHandle("@"));
	assertThrows(() => normalizeActorHandle("foo"));
	assertThrows(() => normalizeActorHandle("@foo"));
	assertThrows(() => normalizeActorHandle("@@foo.com"));
	assertThrows(() => normalizeActorHandle("@foo@"));
	assertThrows(() => normalizeActorHandle("foo@bar.com@baz.com"));
	assertThrows(() => normalizeActorHandle("@foo@bar.com@baz.com"));
});

//#endregion