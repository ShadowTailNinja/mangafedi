
      import { Temporal } from "@js-temporal/polyfill";
      import { URLPattern } from "urlpattern-polyfill";
      globalThis.addEventListener = () => {};
    
import { Activity, Announce, Collection, Create, CryptographicKey, Follow, Hashtag, LanguageString, Link, Note, Object as Object$1, OrderedCollectionPage, Person, Place, Question, Source, decode, vocab_exports } from "../type-BVpqRkFR.js";
import { assertEquals } from "../assert_equals-DSbWqCm3.js";
import { assert } from "../assert-MZs1qjMx.js";
import { assertInstanceOf } from "../assert_instance_of-DHz7EHNU.js";
import "../lookup-CyI7sF0p.js";
import { mockDocumentLoader, test } from "../testing-DoQEBY_a.js";
import "../std__assert-X-_kMxKM.js";
import { assertFalse, assertRejects } from "../assert_rejects-DiIiJbZn.js";
import "../assert_is_error-BPGph1Jx.js";
import { assertNotEquals } from "../assert_not_equals-f3m3epl3.js";
import { assertThrows } from "../assert_throws-BOO88avQ.js";
import { ed25519PublicKey, rsaPublicKey1 } from "../keys-C6gRMT25.js";
import { pascalCase } from "es-toolkit";
import { parseLanguageTag } from "@phensley/language-tag";
import { Validator } from "@cfworker/json-schema";
import { readFile, readdir } from "node:fs/promises";
import { join } from "node:path";

//#region ../../node_modules/.pnpm/@jsr+std__path@1.1.0/node_modules/@jsr/std__path/_os.js
const isWindows = globalThis.Deno?.build.os === "windows" || globalThis.navigator?.platform?.startsWith("Win") || globalThis.process?.platform?.startsWith("win") || false;

//#endregion
//#region ../../node_modules/.pnpm/@jsr+std__path@1.1.0/node_modules/@jsr/std__path/_common/assert_path.js
function assertPath(path) {
	if (typeof path !== "string") throw new TypeError(`Path must be a string, received "${JSON.stringify(path)}"`);
}

//#endregion
//#region ../../node_modules/.pnpm/@jsr+std__path@1.1.0/node_modules/@jsr/std__path/_common/from_file_url.js
function assertArg$2(url) {
	url = url instanceof URL ? url : new URL(url);
	if (url.protocol !== "file:") throw new TypeError(`URL must be a file URL: received "${url.protocol}"`);
	return url;
}

//#endregion
//#region ../../node_modules/.pnpm/@jsr+std__path@1.1.0/node_modules/@jsr/std__path/posix/from_file_url.js
/**
* Converts a file URL to a path string.
*
* @example Usage
* ```ts
* import { fromFileUrl } from "@std/path/posix/from-file-url";
* import { assertEquals } from "@std/assert";
*
* assertEquals(fromFileUrl(new URL("file:///home/foo")), "/home/foo");
* ```
*
* @param url The file URL to convert.
* @returns The path string.
*/ function fromFileUrl$1(url) {
	url = assertArg$2(url);
	return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}

//#endregion
//#region ../../node_modules/.pnpm/@jsr+std__path@1.1.0/node_modules/@jsr/std__path/_common/strip_trailing_separators.js
function stripTrailingSeparators(segment, isSep) {
	if (segment.length <= 1) return segment;
	let end = segment.length;
	for (let i = segment.length - 1; i > 0; i--) if (isSep(segment.charCodeAt(i))) end = i;
	else break;
	return segment.slice(0, end);
}

//#endregion
//#region ../../node_modules/.pnpm/@jsr+std__path@1.1.0/node_modules/@jsr/std__path/_common/constants.js
const CHAR_DOT = 46;
const CHAR_FORWARD_SLASH = 47;

//#endregion
//#region ../../node_modules/.pnpm/@jsr+std__path@1.1.0/node_modules/@jsr/std__path/posix/_util.js
function isPosixPathSeparator(code) {
	return code === CHAR_FORWARD_SLASH;
}

//#endregion
//#region ../../node_modules/.pnpm/@jsr+std__path@1.1.0/node_modules/@jsr/std__path/windows/from_file_url.js
/**
* Converts a file URL to a path string.
*
* @example Usage
* ```ts
* import { fromFileUrl } from "@std/path/windows/from-file-url";
* import { assertEquals } from "@std/assert";
*
* assertEquals(fromFileUrl("file:///home/foo"), "\\home\\foo");
* assertEquals(fromFileUrl("file:///C:/Users/foo"), "C:\\Users\\foo");
* assertEquals(fromFileUrl("file://localhost/home/foo"), "\\home\\foo");
* ```
*
* @param url The file URL to convert.
* @returns The path string.
*/ function fromFileUrl$2(url) {
	url = assertArg$2(url);
	let path = decodeURIComponent(url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
	if (url.hostname !== "") path = `\\\\${url.hostname}${path}`;
	return path;
}

//#endregion
//#region ../../node_modules/.pnpm/@jsr+std__path@1.1.0/node_modules/@jsr/std__path/_common/dirname.js
function assertArg$1(path) {
	assertPath(path);
	if (path.length === 0) return ".";
}

//#endregion
//#region ../../node_modules/.pnpm/@jsr+std__path@1.1.0/node_modules/@jsr/std__path/posix/dirname.js
/**
* Return the directory path of a `path`.
*
* @example Usage
* ```ts
* import { dirname } from "@std/path/posix/dirname";
* import { assertEquals } from "@std/assert";
*
* assertEquals(dirname("/home/user/Documents/"), "/home/user");
* assertEquals(dirname("/home/user/Documents/image.png"), "/home/user/Documents");
* assertEquals(dirname("https://deno.land/std/path/mod.ts"), "https://deno.land/std/path");
* assertEquals(dirname(new URL("file:///home/user/Documents/image.png")), "/home/user/Documents");
* ```
*
* @example Working with URLs
*
* ```ts
* import { dirname } from "@std/path/posix/dirname";
* import { assertEquals } from "@std/assert";
*
* assertEquals(dirname("https://deno.land/std/path/mod.ts"), "https://deno.land/std/path");
* assertEquals(dirname("https://deno.land/std/path/mod.ts?a=b"), "https://deno.land/std/path");
* assertEquals(dirname("https://deno.land/std/path/mod.ts#header"), "https://deno.land/std/path");
* ```
*
* @param path The path to get the directory from.
* @returns The directory path.
*/ function dirname(path) {
	if (path instanceof URL) path = fromFileUrl$1(path);
	assertArg$1(path);
	let end = -1;
	let matchedNonSeparator = false;
	for (let i = path.length - 1; i >= 1; --i) if (isPosixPathSeparator(path.charCodeAt(i))) {
		if (matchedNonSeparator) {
			end = i;
			break;
		}
	} else matchedNonSeparator = true;
	if (end === -1) return isPosixPathSeparator(path.charCodeAt(0)) ? "/" : ".";
	return stripTrailingSeparators(path.slice(0, end), isPosixPathSeparator);
}

//#endregion
//#region ../../node_modules/.pnpm/@jsr+std__path@1.1.0/node_modules/@jsr/std__path/from_file_url.js
/**
* Converts a file URL to a path string.
*
* @example Usage
* ```ts
* import { fromFileUrl } from "@std/path/from-file-url";
* import { assertEquals } from "@std/assert";
*
* if (Deno.build.os === "windows") {
*   assertEquals(fromFileUrl("file:///home/foo"), "\\home\\foo");
*   assertEquals(fromFileUrl("file:///C:/Users/foo"), "C:\\Users\\foo");
*   assertEquals(fromFileUrl("file://localhost/home/foo"), "\\home\\foo");
* } else {
*   assertEquals(fromFileUrl("file:///home/foo"), "/home/foo");
* }
* ```
*
* @param url The file URL to convert to a path.
* @returns The path string.
*/ function fromFileUrl(url) {
	return isWindows ? fromFileUrl$2(url) : fromFileUrl$1(url);
}

//#endregion
//#region ../../node_modules/.pnpm/@jsr+std__path@1.1.0/node_modules/@jsr/std__path/_common/normalize.js
function assertArg(path) {
	assertPath(path);
	if (path.length === 0) return ".";
}

//#endregion
//#region ../../node_modules/.pnpm/@jsr+std__path@1.1.0/node_modules/@jsr/std__path/_common/normalize_string.js
function normalizeString(path, allowAboveRoot, separator, isPathSeparator) {
	let res = "";
	let lastSegmentLength = 0;
	let lastSlash = -1;
	let dots = 0;
	let code;
	for (let i = 0; i <= path.length; ++i) {
		if (i < path.length) code = path.charCodeAt(i);
		else if (isPathSeparator(code)) break;
		else code = CHAR_FORWARD_SLASH;
		if (isPathSeparator(code)) {
			if (lastSlash === i - 1 || dots === 1) {} else if (lastSlash !== i - 1 && dots === 2) {
				if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== CHAR_DOT || res.charCodeAt(res.length - 2) !== CHAR_DOT) {
					if (res.length > 2) {
						const lastSlashIndex = res.lastIndexOf(separator);
						if (lastSlashIndex === -1) {
							res = "";
							lastSegmentLength = 0;
						} else {
							res = res.slice(0, lastSlashIndex);
							lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
						}
						lastSlash = i;
						dots = 0;
						continue;
					} else if (res.length === 2 || res.length === 1) {
						res = "";
						lastSegmentLength = 0;
						lastSlash = i;
						dots = 0;
						continue;
					}
				}
				if (allowAboveRoot) {
					if (res.length > 0) res += `${separator}..`;
					else res = "..";
					lastSegmentLength = 2;
				}
			} else {
				if (res.length > 0) res += separator + path.slice(lastSlash + 1, i);
				else res = path.slice(lastSlash + 1, i);
				lastSegmentLength = i - lastSlash - 1;
			}
			lastSlash = i;
			dots = 0;
		} else if (code === CHAR_DOT && dots !== -1) ++dots;
		else dots = -1;
	}
	return res;
}

//#endregion
//#region ../../node_modules/.pnpm/@jsr+std__path@1.1.0/node_modules/@jsr/std__path/posix/normalize.js
/**
* Normalize the `path`, resolving `'..'` and `'.'` segments.
* Note that resolving these segments does not necessarily mean that all will be eliminated.
* A `'..'` at the top-level will be preserved, and an empty path is canonically `'.'`.
*
* @example Usage
* ```ts
* import { normalize } from "@std/path/posix/normalize";
* import { assertEquals } from "@std/assert";
*
* assertEquals(normalize("/foo/bar//baz/asdf/quux/.."), "/foo/bar/baz/asdf");
* assertEquals(normalize(new URL("file:///foo/bar//baz/asdf/quux/..")), "/foo/bar/baz/asdf/");
* ```
*
* @example Working with URLs
*
* Note: This function will remove the double slashes from a URL's scheme.
* Hence, do not pass a full URL to this function. Instead, pass the pathname of
* the URL.
*
* ```ts
* import { normalize } from "@std/path/posix/normalize";
* import { assertEquals } from "@std/assert";
*
* const url = new URL("https://deno.land");
* url.pathname = normalize("//std//assert//.//mod.ts");
* assertEquals(url.href, "https://deno.land/std/assert/mod.ts");
*
* url.pathname = normalize("std/assert/../async/retry.ts");
* assertEquals(url.href, "https://deno.land/std/async/retry.ts");
* ```
*
* @param path The path to normalize.
* @returns The normalized path.
*/ function normalize(path) {
	if (path instanceof URL) path = fromFileUrl$1(path);
	assertArg(path);
	const isAbsolute = isPosixPathSeparator(path.charCodeAt(0));
	const trailingSeparator = isPosixPathSeparator(path.charCodeAt(path.length - 1));
	path = normalizeString(path, !isAbsolute, "/", isPosixPathSeparator);
	if (path.length === 0 && !isAbsolute) path = ".";
	if (path.length > 0 && trailingSeparator) path += "/";
	if (isAbsolute) return `/${path}`;
	return path;
}

//#endregion
//#region ../../node_modules/.pnpm/@jsr+std__path@1.1.0/node_modules/@jsr/std__path/posix/join.js
/**
* Join all given a sequence of `paths`,then normalizes the resulting path.
*
* @example Usage
* ```ts
* import { join } from "@std/path/posix/join";
* import { assertEquals } from "@std/assert";
*
* assertEquals(join("/foo", "bar", "baz/asdf", "quux", ".."), "/foo/bar/baz/asdf");
* assertEquals(join(new URL("file:///foo"), "bar", "baz/asdf", "quux", ".."), "/foo/bar/baz/asdf");
* ```
*
* @example Working with URLs
* ```ts
* import { join } from "@std/path/posix/join";
* import { assertEquals } from "@std/assert";
*
* const url = new URL("https://deno.land");
* url.pathname = join("std", "path", "mod.ts");
* assertEquals(url.href, "https://deno.land/std/path/mod.ts");
*
* url.pathname = join("//std", "path/", "/mod.ts");
* assertEquals(url.href, "https://deno.land/std/path/mod.ts");
* ```
*
* @param path The path to join. This can be string or file URL.
* @param paths The paths to join.
* @returns The joined path.
*/ function join$1(path, ...paths) {
	if (path === void 0) return ".";
	if (path instanceof URL) path = fromFileUrl$1(path);
	paths = path ? [path, ...paths] : paths;
	paths.forEach((path$1) => assertPath(path$1));
	const joined = paths.filter((path$1) => path$1.length > 0).join("/");
	return joined === "" ? "." : normalize(joined);
}

//#endregion
//#region ../../node_modules/.pnpm/@jsr+std__url@1.0.0-rc.3/node_modules/@jsr/std__url/_strip.js
/**
* Strips any hash (eg. `#header`) or search parameters (eg. `?foo=bar`) from the provided URL.
*
* (Mutates the original url provided)
* @param url to be stripped.
*/ function strip(url) {
	url.hash = "";
	url.search = "";
}

//#endregion
//#region ../../node_modules/.pnpm/@jsr+std__url@1.0.0-rc.3/node_modules/@jsr/std__url/dirname.js
/**
* Returns the directory path URL of a URL or URL string.
*
* The directory path is the portion of a URL up to but excluding the final path
* segment. URL queries and hashes are ignored.
*
* @param url URL to extract the directory from.
* @returns The directory path URL of the URL.
*
* @example Usage
* ```ts
* import { dirname } from "@std/url/dirname";
* import { assertEquals } from "@std/assert";
*
* assertEquals(dirname("https://deno.land/std/path/mod.ts"), new URL("https://deno.land/std/path"));
* assertEquals(dirname(new URL("https://deno.land/std/path/mod.ts")), new URL("https://deno.land/std/path"));
* ```
*
* @deprecated Use
* {@linkcode https://jsr.io/@std/path/doc/posix/~/dirname | @std/path/posix/dirname}
* instead (examples included). `@std/url` will be removed in the future.
*/ function dirname$1(url) {
	url = new URL(url);
	strip(url);
	url.pathname = dirname(url.pathname);
	return url;
}

//#endregion
//#region ../../node_modules/.pnpm/@jsr+std__url@1.0.0-rc.3/node_modules/@jsr/std__url/join.js
/**
* Joins a base URL or URL string, and a sequence of path segments together,
* then normalizes the resulting URL.
*
* @param url Base URL to be joined with the paths and normalized.
* @param paths Array of path segments to be joined to the base URL.
* @returns A complete URL containing the base URL joined with the paths.
*
* @example Usage
*
* ```ts
* import { join } from "@std/url/join";
* import { assertEquals } from "@std/assert";
*
* assertEquals(join("https://deno.land/", "std", "path", "mod.ts").href, "https://deno.land/std/path/mod.ts");
* assertEquals(join("https://deno.land", "//std", "path/", "/mod.ts").href, "https://deno.land/std/path/mod.ts");
* ```
*
* @deprecated Use
* {@linkcode https://jsr.io/@std/path/doc/posix/~/join | @std/path/posix/join}
* instead (examples included). `@std/url` will be removed in the future.
*/ function join$2(url, ...paths) {
	url = new URL(url);
	url.pathname = join$1(url.pathname, ...paths);
	return url;
}

//#endregion
//#region ../../node_modules/.pnpm/@jsr+std__yaml@1.0.8/node_modules/@jsr/std__yaml/_chars.js
const TAB = 9;
const LINE_FEED = 10;
const CARRIAGE_RETURN = 13;
const SPACE = 32;
const EXCLAMATION = 33;
const DOUBLE_QUOTE = 34;
const SHARP = 35;
const PERCENT = 37;
const AMPERSAND = 38;
const SINGLE_QUOTE = 39;
const ASTERISK = 42;
const PLUS = 43;
const COMMA = 44;
const MINUS = 45;
const DOT = 46;
const COLON = 58;
const SMALLER_THAN = 60;
const GREATER_THAN = 62;
const QUESTION = 63;
const COMMERCIAL_AT = 64;
const LEFT_SQUARE_BRACKET = 91;
const BACKSLASH = 92;
const RIGHT_SQUARE_BRACKET = 93;
const GRAVE_ACCENT = 96;
const LEFT_CURLY_BRACKET = 123;
const VERTICAL_LINE = 124;
const RIGHT_CURLY_BRACKET = 125;
function isEOL(c) {
	return c === LINE_FEED || c === CARRIAGE_RETURN;
}
function isWhiteSpace(c) {
	return c === TAB || c === SPACE;
}
function isWhiteSpaceOrEOL(c) {
	return isWhiteSpace(c) || isEOL(c);
}
function isFlowIndicator(c) {
	return c === COMMA || c === LEFT_SQUARE_BRACKET || c === RIGHT_SQUARE_BRACKET || c === LEFT_CURLY_BRACKET || c === RIGHT_CURLY_BRACKET;
}

//#endregion
//#region ../../node_modules/.pnpm/@jsr+std__yaml@1.0.8/node_modules/@jsr/std__yaml/_type/binary.js
const BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
function resolveYamlBinary(data) {
	if (data === null) return false;
	let code;
	let bitlen = 0;
	const max = data.length;
	const map$1 = BASE64_MAP;
	for (let idx = 0; idx < max; idx++) {
		code = map$1.indexOf(data.charAt(idx));
		if (code > 64) continue;
		if (code < 0) return false;
		bitlen += 6;
	}
	return bitlen % 8 === 0;
}
function constructYamlBinary(data) {
	const input = data.replace(/[\r\n=]/g, "");
	const max = input.length;
	const map$1 = BASE64_MAP;
	const result = [];
	let bits = 0;
	for (let idx = 0; idx < max; idx++) {
		if (idx % 4 === 0 && idx) {
			result.push(bits >> 16 & 255);
			result.push(bits >> 8 & 255);
			result.push(bits & 255);
		}
		bits = bits << 6 | map$1.indexOf(input.charAt(idx));
	}
	const tailbits = max % 4 * 6;
	if (tailbits === 0) {
		result.push(bits >> 16 & 255);
		result.push(bits >> 8 & 255);
		result.push(bits & 255);
	} else if (tailbits === 18) {
		result.push(bits >> 10 & 255);
		result.push(bits >> 2 & 255);
	} else if (tailbits === 12) result.push(bits >> 4 & 255);
	return new Uint8Array(result);
}
function representYamlBinary(object) {
	const max = object.length;
	const map$1 = BASE64_MAP;
	let result = "";
	let bits = 0;
	for (let idx = 0; idx < max; idx++) {
		if (idx % 3 === 0 && idx) {
			result += map$1[bits >> 18 & 63];
			result += map$1[bits >> 12 & 63];
			result += map$1[bits >> 6 & 63];
			result += map$1[bits & 63];
		}
		bits = (bits << 8) + object[idx];
	}
	const tail = max % 3;
	if (tail === 0) {
		result += map$1[bits >> 18 & 63];
		result += map$1[bits >> 12 & 63];
		result += map$1[bits >> 6 & 63];
		result += map$1[bits & 63];
	} else if (tail === 2) {
		result += map$1[bits >> 10 & 63];
		result += map$1[bits >> 4 & 63];
		result += map$1[bits << 2 & 63];
		result += map$1[64];
	} else if (tail === 1) {
		result += map$1[bits >> 2 & 63];
		result += map$1[bits << 4 & 63];
		result += map$1[64];
		result += map$1[64];
	}
	return result;
}
function isBinary(obj) {
	return obj instanceof Uint8Array;
}
const binary = {
	tag: "tag:yaml.org,2002:binary",
	construct: constructYamlBinary,
	kind: "scalar",
	predicate: isBinary,
	represent: representYamlBinary,
	resolve: resolveYamlBinary
};

//#endregion
//#region ../../node_modules/.pnpm/@jsr+std__yaml@1.0.8/node_modules/@jsr/std__yaml/_type/bool.js
const YAML_TRUE_BOOLEANS = [
	"true",
	"True",
	"TRUE"
];
const YAML_FALSE_BOOLEANS = [
	"false",
	"False",
	"FALSE"
];
const YAML_BOOLEANS = [...YAML_TRUE_BOOLEANS, ...YAML_FALSE_BOOLEANS];
const bool = {
	tag: "tag:yaml.org,2002:bool",
	kind: "scalar",
	defaultStyle: "lowercase",
	predicate: (value) => typeof value === "boolean" || value instanceof Boolean,
	construct: (data) => YAML_TRUE_BOOLEANS.includes(data),
	resolve: (data) => YAML_BOOLEANS.includes(data),
	represent: {
		lowercase: (object) => {
			const value = object instanceof Boolean ? object.valueOf() : object;
			return value ? "true" : "false";
		},
		uppercase: (object) => {
			const value = object instanceof Boolean ? object.valueOf() : object;
			return value ? "TRUE" : "FALSE";
		},
		camelcase: (object) => {
			const value = object instanceof Boolean ? object.valueOf() : object;
			return value ? "True" : "False";
		}
	}
};

//#endregion
//#region ../../node_modules/.pnpm/@jsr+std__yaml@1.0.8/node_modules/@jsr/std__yaml/_utils.js
function isObject(value) {
	return value !== null && typeof value === "object";
}
function isNegativeZero(i) {
	return i === 0 && Number.NEGATIVE_INFINITY === 1 / i;
}
function isPlainObject(object) {
	return Object.prototype.toString.call(object) === "[object Object]";
}

//#endregion
//#region ../../node_modules/.pnpm/@jsr+std__yaml@1.0.8/node_modules/@jsr/std__yaml/_type/float.js
const YAML_FLOAT_PATTERN = /* @__PURE__ */ new RegExp("^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$");
function resolveYamlFloat(data) {
	if (!YAML_FLOAT_PATTERN.test(data) || data[data.length - 1] === "_") return false;
	return true;
}
function constructYamlFloat(data) {
	let value = data.replace(/_/g, "").toLowerCase();
	const sign = value[0] === "-" ? -1 : 1;
	if (value[0] && "+-".includes(value[0])) value = value.slice(1);
	if (value === ".inf") return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
	if (value === ".nan") return NaN;
	return sign * parseFloat(value);
}
const SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function representYamlFloat(object, style) {
	const value = object instanceof Number ? object.valueOf() : object;
	if (isNaN(value)) switch (style) {
		case "lowercase": return ".nan";
		case "uppercase": return ".NAN";
		case "camelcase": return ".NaN";
	}
	else if (Number.POSITIVE_INFINITY === value) switch (style) {
		case "lowercase": return ".inf";
		case "uppercase": return ".INF";
		case "camelcase": return ".Inf";
	}
	else if (Number.NEGATIVE_INFINITY === value) switch (style) {
		case "lowercase": return "-.inf";
		case "uppercase": return "-.INF";
		case "camelcase": return "-.Inf";
	}
	else if (isNegativeZero(value)) return "-0.0";
	const res = value.toString(10);
	return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
}
function isFloat(object) {
	if (object instanceof Number) object = object.valueOf();
	return typeof object === "number" && (object % 1 !== 0 || isNegativeZero(object));
}
const float = {
	tag: "tag:yaml.org,2002:float",
	construct: constructYamlFloat,
	defaultStyle: "lowercase",
	kind: "scalar",
	predicate: isFloat,
	represent: representYamlFloat,
	resolve: resolveYamlFloat
};

//#endregion
//#region ../../node_modules/.pnpm/@jsr+std__yaml@1.0.8/node_modules/@jsr/std__yaml/_type/int.js
function isCharCodeInRange(c, lower, upper) {
	return lower <= c && c <= upper;
}
function isHexCode(c) {
	return isCharCodeInRange(c, 48, 57) || isCharCodeInRange(c, 65, 70) || isCharCodeInRange(c, 97, 102);
}
function isOctCode(c) {
	return isCharCodeInRange(c, 48, 55);
}
function isDecCode(c) {
	return isCharCodeInRange(c, 48, 57);
}
function resolveYamlInteger(data) {
	const max = data.length;
	let index = 0;
	let hasDigits = false;
	if (!max) return false;
	let ch = data[index];
	if (ch === "-" || ch === "+") ch = data[++index];
	if (ch === "0") {
		if (index + 1 === max) return true;
		ch = data[++index];
		if (ch === "b") {
			index++;
			for (; index < max; index++) {
				ch = data[index];
				if (ch === "_") continue;
				if (ch !== "0" && ch !== "1") return false;
				hasDigits = true;
			}
			return hasDigits && ch !== "_";
		}
		if (ch === "x") {
			index++;
			for (; index < max; index++) {
				ch = data[index];
				if (ch === "_") continue;
				if (!isHexCode(data.charCodeAt(index))) return false;
				hasDigits = true;
			}
			return hasDigits && ch !== "_";
		}
		for (; index < max; index++) {
			ch = data[index];
			if (ch === "_") continue;
			if (!isOctCode(data.charCodeAt(index))) return false;
			hasDigits = true;
		}
		return hasDigits && ch !== "_";
	}
	if (ch === "_") return false;
	for (; index < max; index++) {
		ch = data[index];
		if (ch === "_") continue;
		if (!isDecCode(data.charCodeAt(index))) return false;
		hasDigits = true;
	}
	if (!hasDigits || ch === "_") return false;
	return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
}
function constructYamlInteger(data) {
	let value = data;
	if (value.includes("_")) value = value.replace(/_/g, "");
	let sign = 1;
	let ch = value[0];
	if (ch === "-" || ch === "+") {
		if (ch === "-") sign = -1;
		value = value.slice(1);
		ch = value[0];
	}
	if (value === "0") return 0;
	if (ch === "0") {
		if (value[1] === "b") return sign * parseInt(value.slice(2), 2);
		if (value[1] === "x") return sign * parseInt(value, 16);
		return sign * parseInt(value, 8);
	}
	return sign * parseInt(value, 10);
}
function isInteger(object) {
	if (object instanceof Number) object = object.valueOf();
	return typeof object === "number" && object % 1 === 0 && !isNegativeZero(object);
}
const int = {
	tag: "tag:yaml.org,2002:int",
	construct: constructYamlInteger,
	defaultStyle: "decimal",
	kind: "scalar",
	predicate: isInteger,
	represent: {
		binary(object) {
			const value = object instanceof Number ? object.valueOf() : object;
			return value >= 0 ? `0b${value.toString(2)}` : `-0b${value.toString(2).slice(1)}`;
		},
		octal(object) {
			const value = object instanceof Number ? object.valueOf() : object;
			return value >= 0 ? `0${value.toString(8)}` : `-0${value.toString(8).slice(1)}`;
		},
		decimal(object) {
			const value = object instanceof Number ? object.valueOf() : object;
			return value.toString(10);
		},
		hexadecimal(object) {
			const value = object instanceof Number ? object.valueOf() : object;
			return value >= 0 ? `0x${value.toString(16).toUpperCase()}` : `-0x${value.toString(16).toUpperCase().slice(1)}`;
		}
	},
	resolve: resolveYamlInteger
};

//#endregion
//#region ../../node_modules/.pnpm/@jsr+std__yaml@1.0.8/node_modules/@jsr/std__yaml/_type/map.js
const map = {
	tag: "tag:yaml.org,2002:map",
	resolve() {
		return true;
	},
	construct(data) {
		return data !== null ? data : {};
	},
	kind: "mapping"
};

//#endregion
//#region ../../node_modules/.pnpm/@jsr+std__yaml@1.0.8/node_modules/@jsr/std__yaml/_type/merge.js
const merge = {
	tag: "tag:yaml.org,2002:merge",
	kind: "scalar",
	resolve: (data) => data === "<<" || data === null,
	construct: (data) => data
};

//#endregion
//#region ../../node_modules/.pnpm/@jsr+std__yaml@1.0.8/node_modules/@jsr/std__yaml/_type/nil.js
const nil = {
	tag: "tag:yaml.org,2002:null",
	kind: "scalar",
	defaultStyle: "lowercase",
	predicate: (object) => object === null,
	construct: () => null,
	resolve: (data) => {
		return data === "~" || data === "null" || data === "Null" || data === "NULL";
	},
	represent: {
		lowercase: () => "null",
		uppercase: () => "NULL",
		camelcase: () => "Null"
	}
};

//#endregion
//#region ../../node_modules/.pnpm/@jsr+std__yaml@1.0.8/node_modules/@jsr/std__yaml/_type/omap.js
function resolveYamlOmap(data) {
	const objectKeys = /* @__PURE__ */ new Set();
	for (const object of data) {
		if (!isPlainObject(object)) return false;
		const keys = Object.keys(object);
		if (keys.length !== 1) return false;
		for (const key of keys) {
			if (objectKeys.has(key)) return false;
			objectKeys.add(key);
		}
	}
	return true;
}
const omap = {
	tag: "tag:yaml.org,2002:omap",
	kind: "sequence",
	resolve: resolveYamlOmap,
	construct(data) {
		return data;
	}
};

//#endregion
//#region ../../node_modules/.pnpm/@jsr+std__yaml@1.0.8/node_modules/@jsr/std__yaml/_type/pairs.js
function resolveYamlPairs(data) {
	if (data === null) return true;
	return data.every((it) => isPlainObject(it) && Object.keys(it).length === 1);
}
const pairs = {
	tag: "tag:yaml.org,2002:pairs",
	construct(data) {
		return data?.flatMap(Object.entries) ?? [];
	},
	kind: "sequence",
	resolve: resolveYamlPairs
};

//#endregion
//#region ../../node_modules/.pnpm/@jsr+std__yaml@1.0.8/node_modules/@jsr/std__yaml/_type/regexp.js
const REGEXP = /^\/(?<regexp>[\s\S]+)\/(?<modifiers>[gismuy]*)$/;
const regexp = {
	tag: "tag:yaml.org,2002:js/regexp",
	kind: "scalar",
	resolve(data) {
		if (data === null || !data.length) return false;
		if (data.charAt(0) === "/") {
			const groups = data.match(REGEXP)?.groups;
			if (!groups) return false;
			const modifiers = groups.modifiers ?? "";
			if (new Set(modifiers).size < modifiers.length) return false;
		}
		return true;
	},
	construct(data) {
		const { regexp: regexp$1 = data, modifiers = "" } = data.match(REGEXP)?.groups ?? {};
		return new RegExp(regexp$1, modifiers);
	},
	predicate: (object) => object instanceof RegExp,
	represent: (object) => object.toString()
};

//#endregion
//#region ../../node_modules/.pnpm/@jsr+std__yaml@1.0.8/node_modules/@jsr/std__yaml/_type/seq.js
const seq = {
	tag: "tag:yaml.org,2002:seq",
	kind: "sequence",
	resolve: () => true,
	construct: (data) => data !== null ? data : []
};

//#endregion
//#region ../../node_modules/.pnpm/@jsr+std__yaml@1.0.8/node_modules/@jsr/std__yaml/_type/set.js
const set = {
	tag: "tag:yaml.org,2002:set",
	kind: "mapping",
	construct: (data) => data !== null ? data : {},
	resolve: (data) => {
		if (data === null) return true;
		return Object.values(data).every((it) => it === null);
	}
};

//#endregion
//#region ../../node_modules/.pnpm/@jsr+std__yaml@1.0.8/node_modules/@jsr/std__yaml/_type/str.js
const str = {
	tag: "tag:yaml.org,2002:str",
	kind: "scalar",
	resolve: () => true,
	construct: (data) => data !== null ? data : ""
};

//#endregion
//#region ../../node_modules/.pnpm/@jsr+std__yaml@1.0.8/node_modules/@jsr/std__yaml/_type/timestamp.js
const YAML_DATE_REGEXP = /* @__PURE__ */ new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$");
const YAML_TIMESTAMP_REGEXP = /* @__PURE__ */ new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$");
function resolveYamlTimestamp(data) {
	if (data === null) return false;
	if (YAML_DATE_REGEXP.exec(data) !== null) return true;
	if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
	return false;
}
function constructYamlTimestamp(data) {
	let match = YAML_DATE_REGEXP.exec(data);
	if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);
	if (match === null) throw new Error("Cannot construct YAML timestamp: date resolve error");
	const year = +match[1];
	const month = +match[2] - 1;
	const day = +match[3];
	if (!match[4]) return new Date(Date.UTC(year, month, day));
	const hour = +match[4];
	const minute = +match[5];
	const second = +match[6];
	let fraction = 0;
	if (match[7]) {
		let partFraction = match[7].slice(0, 3);
		while (partFraction.length < 3) partFraction += "0";
		fraction = +partFraction;
	}
	let delta = null;
	if (match[9] && match[10]) {
		const tzHour = +match[10];
		const tzMinute = +(match[11] || 0);
		delta = (tzHour * 60 + tzMinute) * 6e4;
		if (match[9] === "-") delta = -delta;
	}
	const date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
	if (delta) date.setTime(date.getTime() - delta);
	return date;
}
function representYamlTimestamp(date) {
	return date.toISOString();
}
const timestamp = {
	tag: "tag:yaml.org,2002:timestamp",
	construct: constructYamlTimestamp,
	predicate(object) {
		return object instanceof Date;
	},
	kind: "scalar",
	represent: representYamlTimestamp,
	resolve: resolveYamlTimestamp
};

//#endregion
//#region ../../node_modules/.pnpm/@jsr+std__yaml@1.0.8/node_modules/@jsr/std__yaml/_type/undefined.js
const undefinedType = {
	tag: "tag:yaml.org,2002:js/undefined",
	kind: "scalar",
	resolve() {
		return true;
	},
	construct() {
		return void 0;
	},
	predicate(object) {
		return typeof object === "undefined";
	},
	represent() {
		return "";
	}
};

//#endregion
//#region ../../node_modules/.pnpm/@jsr+std__yaml@1.0.8/node_modules/@jsr/std__yaml/_schema.js
function createTypeMap(implicitTypes, explicitTypes) {
	const result = {
		fallback: /* @__PURE__ */ new Map(),
		mapping: /* @__PURE__ */ new Map(),
		scalar: /* @__PURE__ */ new Map(),
		sequence: /* @__PURE__ */ new Map()
	};
	const fallbackMap = result.fallback;
	for (const type of [...implicitTypes, ...explicitTypes]) {
		const map$1 = result[type.kind];
		map$1.set(type.tag, type);
		fallbackMap.set(type.tag, type);
	}
	return result;
}
function createSchema({ explicitTypes = [], implicitTypes = [], include }) {
	if (include) {
		implicitTypes.push(...include.implicitTypes);
		explicitTypes.push(...include.explicitTypes);
	}
	const typeMap = createTypeMap(implicitTypes, explicitTypes);
	return {
		implicitTypes,
		explicitTypes,
		typeMap
	};
}
/**
* Standard YAML's failsafe schema.
*
* @see {@link http://www.yaml.org/spec/1.2/spec.html#id2802346}
*/ const FAILSAFE_SCHEMA = createSchema({ explicitTypes: [
	str,
	seq,
	map
] });
/**
* Standard YAML's JSON schema.
*
* @see {@link http://www.yaml.org/spec/1.2/spec.html#id2803231}
*/ const JSON_SCHEMA = createSchema({
	implicitTypes: [
		nil,
		bool,
		int,
		float
	],
	include: FAILSAFE_SCHEMA
});
/**
* Standard YAML's core schema.
*
* @see {@link http://www.yaml.org/spec/1.2/spec.html#id2804923}
*/ const CORE_SCHEMA = createSchema({ include: JSON_SCHEMA });
/**
* Default YAML schema. It is not described in the YAML specification.
*/ const DEFAULT_SCHEMA = createSchema({
	explicitTypes: [
		binary,
		omap,
		pairs,
		set
	],
	implicitTypes: [timestamp, merge],
	include: CORE_SCHEMA
});
/***
* Extends JS-YAML default schema with additional JavaScript types
* It is not described in the YAML specification.
* Functions are no longer supported for security reasons.
*
* @example
* ```ts
* import { parse } from "@std/yaml";
*
* const data = parse(
*   `
*   regexp:
*     simple: !!js/regexp foobar
*     modifiers: !!js/regexp /foobar/mi
*   undefined: !!js/undefined ~
* `,
*   { schema: "extended" },
* );
* ```
*/ const EXTENDED_SCHEMA = createSchema({
	explicitTypes: [regexp, undefinedType],
	include: DEFAULT_SCHEMA
});
const SCHEMA_MAP = new Map([
	["core", CORE_SCHEMA],
	["default", DEFAULT_SCHEMA],
	["failsafe", FAILSAFE_SCHEMA],
	["json", JSON_SCHEMA],
	["extended", EXTENDED_SCHEMA]
]);

//#endregion
//#region ../../node_modules/.pnpm/@jsr+std__yaml@1.0.8/node_modules/@jsr/std__yaml/_loader_state.js
const CONTEXT_FLOW_IN = 1;
const CONTEXT_FLOW_OUT = 2;
const CONTEXT_BLOCK_IN = 3;
const CONTEXT_BLOCK_OUT = 4;
const CHOMPING_CLIP = 1;
const CHOMPING_STRIP = 2;
const CHOMPING_KEEP = 3;
const PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
const PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
const PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
const PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
const PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
const ESCAPED_HEX_LENGTHS = new Map([
	[120, 2],
	[117, 4],
	[85, 8]
]);
const SIMPLE_ESCAPE_SEQUENCES = new Map([
	[48, "\0"],
	[97, "\x07"],
	[98, "\b"],
	[116, "	"],
	[9, "	"],
	[110, "\n"],
	[118, "\v"],
	[102, "\f"],
	[114, "\r"],
	[101, "\x1B"],
	[32, " "],
	[34, "\""],
	[47, "/"],
	[92, "\\"],
	[78, ""],
	[95, "\xA0"],
	[76, "\u2028"],
	[80, "\u2029"]
]);
/**
* Converts a hexadecimal character code to its decimal value.
*/ function hexCharCodeToNumber(charCode) {
	if (48 <= charCode && charCode <= 57) return charCode - 48;
	const lc = charCode | 32;
	if (97 <= lc && lc <= 102) return lc - 97 + 10;
	return -1;
}
/**
* Converts a decimal character code to its decimal value.
*/ function decimalCharCodeToNumber(charCode) {
	if (48 <= charCode && charCode <= 57) return charCode - 48;
	return -1;
}
/**
* Converts a Unicode code point to a string.
*/ function codepointToChar(codepoint) {
	if (codepoint <= 65535) return String.fromCharCode(codepoint);
	return String.fromCharCode((codepoint - 65536 >> 10) + 55296, (codepoint - 65536 & 1023) + 56320);
}
const INDENT = 4;
const MAX_LENGTH = 75;
const DELIMITERS = "\0\r\n\u2028\u2029";
function getSnippet(buffer, position) {
	if (!buffer) return null;
	let start = position;
	let end = position;
	let head = "";
	let tail = "";
	while (start > 0 && !DELIMITERS.includes(buffer.charAt(start - 1))) {
		start--;
		if (position - start > MAX_LENGTH / 2 - 1) {
			head = " ... ";
			start += 5;
			break;
		}
	}
	while (end < buffer.length && !DELIMITERS.includes(buffer.charAt(end))) {
		end++;
		if (end - position > MAX_LENGTH / 2 - 1) {
			tail = " ... ";
			end -= 5;
			break;
		}
	}
	const snippet = buffer.slice(start, end);
	const indent = " ".repeat(INDENT);
	const caretIndent = " ".repeat(INDENT + position - start + head.length);
	return `${indent + head + snippet + tail}\n${caretIndent}^`;
}
function markToString(buffer, position, line, column) {
	let where = `at line ${line + 1}, column ${column + 1}`;
	const snippet = getSnippet(buffer, position);
	if (snippet) where += `:\n${snippet}`;
	return where;
}
var LoaderState = class {
	input;
	length;
	lineIndent = 0;
	lineStart = 0;
	position = 0;
	line = 0;
	onWarning;
	allowDuplicateKeys;
	implicitTypes;
	typeMap;
	version;
	checkLineBreaks = false;
	tagMap = /* @__PURE__ */ new Map();
	anchorMap = /* @__PURE__ */ new Map();
	tag;
	anchor;
	kind;
	result = "";
	constructor(input, { schema = DEFAULT_SCHEMA, onWarning, allowDuplicateKeys = false }) {
		this.input = input;
		this.onWarning = onWarning;
		this.allowDuplicateKeys = allowDuplicateKeys;
		this.implicitTypes = schema.implicitTypes;
		this.typeMap = schema.typeMap;
		this.length = input.length;
		this.version = null;
		this.readIndent();
	}
	skipWhitespaces() {
		let ch = this.peek();
		while (isWhiteSpace(ch)) ch = this.next();
	}
	skipComment() {
		let ch = this.peek();
		if (ch !== SHARP) return;
		ch = this.next();
		while (ch !== 0 && !isEOL(ch)) ch = this.next();
	}
	readIndent() {
		let char = this.peek();
		while (char === SPACE) {
			this.lineIndent += 1;
			char = this.next();
		}
	}
	peek(offset = 0) {
		return this.input.charCodeAt(this.position + offset);
	}
	next() {
		this.position += 1;
		return this.peek();
	}
	#createError(message) {
		const mark = markToString(this.input, this.position, this.line, this.position - this.lineStart);
		return /* @__PURE__ */ new SyntaxError(`${message} ${mark}`);
	}
	dispatchWarning(message) {
		const error = this.#createError(message);
		this.onWarning?.(error);
	}
	yamlDirectiveHandler(...args) {
		if (this.version !== null) throw this.#createError("Cannot handle YAML directive: duplication of %YAML directive");
		if (args.length !== 1) throw this.#createError("Cannot handle YAML directive: YAML directive accepts exactly one argument");
		const match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
		if (match === null) throw this.#createError("Cannot handle YAML directive: ill-formed argument");
		const major = parseInt(match[1], 10);
		const minor = parseInt(match[2], 10);
		if (major !== 1) throw this.#createError("Cannot handle YAML directive: unacceptable YAML version");
		this.version = args[0] ?? null;
		this.checkLineBreaks = minor < 2;
		if (minor !== 1 && minor !== 2) return this.dispatchWarning("Cannot handle YAML directive: unsupported YAML version");
	}
	tagDirectiveHandler(...args) {
		if (args.length !== 2) throw this.#createError(`Cannot handle tag directive: directive accepts exactly two arguments, received ${args.length}`);
		const handle = args[0];
		const prefix = args[1];
		if (!PATTERN_TAG_HANDLE.test(handle)) throw this.#createError(`Cannot handle tag directive: ill-formed handle (first argument) in "${handle}"`);
		if (this.tagMap.has(handle)) throw this.#createError(`Cannot handle tag directive: previously declared suffix for "${handle}" tag handle`);
		if (!PATTERN_TAG_URI.test(prefix)) throw this.#createError("Cannot handle tag directive: ill-formed tag prefix (second argument) of the TAG directive");
		this.tagMap.set(handle, prefix);
	}
	captureSegment(start, end, checkJson) {
		if (start < end) {
			const result = this.input.slice(start, end);
			if (checkJson) for (let position = 0; position < result.length; position++) {
				const character = result.charCodeAt(position);
				if (!(character === 9 || 32 <= character && character <= 1114111)) throw this.#createError(`Expected valid JSON character: received "${character}"`);
			}
			else if (PATTERN_NON_PRINTABLE.test(result)) throw this.#createError("Stream contains non-printable characters");
			this.result += result;
		}
	}
	readBlockSequence(nodeIndent) {
		let detected = false;
		const tag = this.tag;
		const anchor = this.anchor;
		const result = [];
		if (this.anchor !== null && typeof this.anchor !== "undefined") this.anchorMap.set(this.anchor, result);
		let ch = this.peek();
		while (ch !== 0) {
			if (ch !== MINUS) break;
			const following = this.peek(1);
			if (!isWhiteSpaceOrEOL(following)) break;
			detected = true;
			this.position++;
			if (this.skipSeparationSpace(true, -1)) {
				if (this.lineIndent <= nodeIndent) {
					result.push(null);
					ch = this.peek();
					continue;
				}
			}
			const line = this.line;
			this.composeNode({
				parentIndent: nodeIndent,
				nodeContext: CONTEXT_BLOCK_IN,
				allowToSeek: false,
				allowCompact: true
			});
			result.push(this.result);
			this.skipSeparationSpace(true, -1);
			ch = this.peek();
			if ((this.line === line || this.lineIndent > nodeIndent) && ch !== 0) throw this.#createError("Cannot read block sequence: bad indentation of a sequence entry");
			else if (this.lineIndent < nodeIndent) break;
		}
		if (detected) {
			this.tag = tag;
			this.anchor = anchor;
			this.kind = "sequence";
			this.result = result;
			return true;
		}
		return false;
	}
	mergeMappings(destination, source, overridableKeys) {
		if (!isObject(source)) throw this.#createError("Cannot merge mappings: the provided source object is unacceptable");
		for (const [key, value] of Object.entries(source)) {
			if (Object.hasOwn(destination, key)) continue;
			Object.defineProperty(destination, key, {
				value,
				writable: true,
				enumerable: true,
				configurable: true
			});
			overridableKeys.add(key);
		}
	}
	storeMappingPair(result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
		if (Array.isArray(keyNode)) {
			keyNode = Array.prototype.slice.call(keyNode);
			for (let index = 0; index < keyNode.length; index++) {
				if (Array.isArray(keyNode[index])) throw this.#createError("Cannot store mapping pair: nested arrays are not supported inside keys");
				if (typeof keyNode === "object" && isPlainObject(keyNode[index])) keyNode[index] = "[object Object]";
			}
		}
		if (typeof keyNode === "object" && isPlainObject(keyNode)) keyNode = "[object Object]";
		keyNode = String(keyNode);
		if (keyTag === "tag:yaml.org,2002:merge") if (Array.isArray(valueNode)) for (let index = 0; index < valueNode.length; index++) this.mergeMappings(result, valueNode[index], overridableKeys);
		else this.mergeMappings(result, valueNode, overridableKeys);
		else {
			if (!this.allowDuplicateKeys && !overridableKeys.has(keyNode) && Object.hasOwn(result, keyNode)) {
				this.line = startLine || this.line;
				this.position = startPos || this.position;
				throw this.#createError("Cannot store mapping pair: duplicated key");
			}
			Object.defineProperty(result, keyNode, {
				value: valueNode,
				writable: true,
				enumerable: true,
				configurable: true
			});
			overridableKeys.delete(keyNode);
		}
		return result;
	}
	readLineBreak() {
		const ch = this.peek();
		if (ch === LINE_FEED) this.position++;
		else if (ch === CARRIAGE_RETURN) {
			this.position++;
			if (this.peek() === LINE_FEED) this.position++;
		} else throw this.#createError("Cannot read line: line break not found");
		this.line += 1;
		this.lineStart = this.position;
	}
	skipSeparationSpace(allowComments, checkIndent) {
		let lineBreaks = 0;
		let ch = this.peek();
		while (ch !== 0) {
			this.skipWhitespaces();
			ch = this.peek();
			if (allowComments) {
				this.skipComment();
				ch = this.peek();
			}
			if (isEOL(ch)) {
				this.readLineBreak();
				ch = this.peek();
				lineBreaks++;
				this.lineIndent = 0;
				this.readIndent();
				ch = this.peek();
			} else break;
		}
		if (checkIndent !== -1 && lineBreaks !== 0 && this.lineIndent < checkIndent) this.dispatchWarning("deficient indentation");
		return lineBreaks;
	}
	testDocumentSeparator() {
		let ch = this.peek();
		if ((ch === MINUS || ch === DOT) && ch === this.peek(1) && ch === this.peek(2)) {
			ch = this.peek(3);
			if (ch === 0 || isWhiteSpaceOrEOL(ch)) return true;
		}
		return false;
	}
	writeFoldedLines(count) {
		if (count === 1) this.result += " ";
		else if (count > 1) this.result += "\n".repeat(count - 1);
	}
	readPlainScalar(nodeIndent, withinFlowCollection) {
		const kind = this.kind;
		const result = this.result;
		let ch = this.peek();
		if (isWhiteSpaceOrEOL(ch) || isFlowIndicator(ch) || ch === SHARP || ch === AMPERSAND || ch === ASTERISK || ch === EXCLAMATION || ch === VERTICAL_LINE || ch === GREATER_THAN || ch === SINGLE_QUOTE || ch === DOUBLE_QUOTE || ch === PERCENT || ch === COMMERCIAL_AT || ch === GRAVE_ACCENT) return false;
		let following;
		if (ch === QUESTION || ch === MINUS) {
			following = this.peek(1);
			if (isWhiteSpaceOrEOL(following) || withinFlowCollection && isFlowIndicator(following)) return false;
		}
		this.kind = "scalar";
		this.result = "";
		let captureEnd = this.position;
		let captureStart = this.position;
		let hasPendingContent = false;
		let line = 0;
		while (ch !== 0) {
			if (ch === COLON) {
				following = this.peek(1);
				if (isWhiteSpaceOrEOL(following) || withinFlowCollection && isFlowIndicator(following)) break;
			} else if (ch === SHARP) {
				const preceding = this.peek(-1);
				if (isWhiteSpaceOrEOL(preceding)) break;
			} else if (this.position === this.lineStart && this.testDocumentSeparator() || withinFlowCollection && isFlowIndicator(ch)) break;
			else if (isEOL(ch)) {
				line = this.line;
				const lineStart = this.lineStart;
				const lineIndent = this.lineIndent;
				this.skipSeparationSpace(false, -1);
				if (this.lineIndent >= nodeIndent) {
					hasPendingContent = true;
					ch = this.peek();
					continue;
				} else {
					this.position = captureEnd;
					this.line = line;
					this.lineStart = lineStart;
					this.lineIndent = lineIndent;
					break;
				}
			}
			if (hasPendingContent) {
				this.captureSegment(captureStart, captureEnd, false);
				this.writeFoldedLines(this.line - line);
				captureStart = captureEnd = this.position;
				hasPendingContent = false;
			}
			if (!isWhiteSpace(ch)) captureEnd = this.position + 1;
			ch = this.next();
		}
		this.captureSegment(captureStart, captureEnd, false);
		if (this.result) return true;
		this.kind = kind;
		this.result = result;
		return false;
	}
	readSingleQuotedScalar(nodeIndent) {
		let ch = this.peek();
		if (ch !== SINGLE_QUOTE) return false;
		this.kind = "scalar";
		this.result = "";
		this.position++;
		let captureStart = this.position;
		let captureEnd = this.position;
		ch = this.peek();
		while (ch !== 0) {
			if (ch === SINGLE_QUOTE) {
				this.captureSegment(captureStart, this.position, true);
				ch = this.next();
				if (ch === SINGLE_QUOTE) {
					captureStart = this.position;
					this.position++;
					captureEnd = this.position;
				} else return true;
			} else if (isEOL(ch)) {
				this.captureSegment(captureStart, captureEnd, true);
				this.writeFoldedLines(this.skipSeparationSpace(false, nodeIndent));
				captureStart = captureEnd = this.position;
			} else if (this.position === this.lineStart && this.testDocumentSeparator()) throw this.#createError("Unexpected end of the document within a single quoted scalar");
			else {
				this.position++;
				captureEnd = this.position;
			}
			ch = this.peek();
		}
		throw this.#createError("Unexpected end of the stream within a single quoted scalar");
	}
	readDoubleQuotedScalar(nodeIndent) {
		let ch = this.peek();
		if (ch !== DOUBLE_QUOTE) return false;
		this.kind = "scalar";
		this.result = "";
		this.position++;
		let captureEnd = this.position;
		let captureStart = this.position;
		let tmp;
		ch = this.peek();
		while (ch !== 0) {
			if (ch === DOUBLE_QUOTE) {
				this.captureSegment(captureStart, this.position, true);
				this.position++;
				return true;
			}
			if (ch === BACKSLASH) {
				this.captureSegment(captureStart, this.position, true);
				ch = this.next();
				if (isEOL(ch)) this.skipSeparationSpace(false, nodeIndent);
				else if (ch < 256 && SIMPLE_ESCAPE_SEQUENCES.has(ch)) {
					this.result += SIMPLE_ESCAPE_SEQUENCES.get(ch);
					this.position++;
				} else if ((tmp = ESCAPED_HEX_LENGTHS.get(ch) ?? 0) > 0) {
					let hexLength = tmp;
					let hexResult = 0;
					for (; hexLength > 0; hexLength--) {
						ch = this.next();
						if ((tmp = hexCharCodeToNumber(ch)) >= 0) hexResult = (hexResult << 4) + tmp;
						else throw this.#createError("Cannot read double quoted scalar: expected hexadecimal character");
					}
					this.result += codepointToChar(hexResult);
					this.position++;
				} else throw this.#createError("Cannot read double quoted scalar: unknown escape sequence");
				captureStart = captureEnd = this.position;
			} else if (isEOL(ch)) {
				this.captureSegment(captureStart, captureEnd, true);
				this.writeFoldedLines(this.skipSeparationSpace(false, nodeIndent));
				captureStart = captureEnd = this.position;
			} else if (this.position === this.lineStart && this.testDocumentSeparator()) throw this.#createError("Unexpected end of the document within a double quoted scalar");
			else {
				this.position++;
				captureEnd = this.position;
			}
			ch = this.peek();
		}
		throw this.#createError("Unexpected end of the stream within a double quoted scalar");
	}
	readFlowCollection(nodeIndent) {
		let ch = this.peek();
		let terminator;
		let isMapping = true;
		let result = {};
		if (ch === LEFT_SQUARE_BRACKET) {
			terminator = RIGHT_SQUARE_BRACKET;
			isMapping = false;
			result = [];
		} else if (ch === LEFT_CURLY_BRACKET) terminator = RIGHT_CURLY_BRACKET;
		else return false;
		if (this.anchor !== null && typeof this.anchor !== "undefined") this.anchorMap.set(this.anchor, result);
		ch = this.next();
		const tag = this.tag;
		const anchor = this.anchor;
		let readNext = true;
		let valueNode = null;
		let keyNode = null;
		let keyTag = null;
		let isExplicitPair = false;
		let isPair = false;
		let following = 0;
		let line = 0;
		const overridableKeys = /* @__PURE__ */ new Set();
		while (ch !== 0) {
			this.skipSeparationSpace(true, nodeIndent);
			ch = this.peek();
			if (ch === terminator) {
				this.position++;
				this.tag = tag;
				this.anchor = anchor;
				this.kind = isMapping ? "mapping" : "sequence";
				this.result = result;
				return true;
			}
			if (!readNext) throw this.#createError("Cannot read flow collection: missing comma between flow collection entries");
			keyTag = keyNode = valueNode = null;
			isPair = isExplicitPair = false;
			if (ch === QUESTION) {
				following = this.peek(1);
				if (isWhiteSpaceOrEOL(following)) {
					isPair = isExplicitPair = true;
					this.position++;
					this.skipSeparationSpace(true, nodeIndent);
				}
			}
			line = this.line;
			this.composeNode({
				parentIndent: nodeIndent,
				nodeContext: CONTEXT_FLOW_IN,
				allowToSeek: false,
				allowCompact: true
			});
			keyTag = this.tag || null;
			keyNode = this.result;
			this.skipSeparationSpace(true, nodeIndent);
			ch = this.peek();
			if ((isExplicitPair || this.line === line) && ch === COLON) {
				isPair = true;
				ch = this.next();
				this.skipSeparationSpace(true, nodeIndent);
				this.composeNode({
					parentIndent: nodeIndent,
					nodeContext: CONTEXT_FLOW_IN,
					allowToSeek: false,
					allowCompact: true
				});
				valueNode = this.result;
			}
			if (isMapping) this.storeMappingPair(result, overridableKeys, keyTag, keyNode, valueNode);
			else if (isPair) result.push(this.storeMappingPair({}, overridableKeys, keyTag, keyNode, valueNode));
			else result.push(keyNode);
			this.skipSeparationSpace(true, nodeIndent);
			ch = this.peek();
			if (ch === COMMA) {
				readNext = true;
				ch = this.next();
			} else readNext = false;
		}
		throw this.#createError("Cannot read flow collection: unexpected end of the stream within a flow collection");
	}
	readBlockScalar(nodeIndent) {
		let chomping = CHOMPING_CLIP;
		let didReadContent = false;
		let detectedIndent = false;
		let textIndent = nodeIndent;
		let emptyLines = 0;
		let atMoreIndented = false;
		let ch = this.peek();
		let folding = false;
		if (ch === VERTICAL_LINE) folding = false;
		else if (ch === GREATER_THAN) folding = true;
		else return false;
		this.kind = "scalar";
		this.result = "";
		let tmp = 0;
		while (ch !== 0) {
			ch = this.next();
			if (ch === PLUS || ch === MINUS) if (CHOMPING_CLIP === chomping) chomping = ch === PLUS ? CHOMPING_KEEP : CHOMPING_STRIP;
			else throw this.#createError("Cannot read block: chomping mode identifier repeated");
			else if ((tmp = decimalCharCodeToNumber(ch)) >= 0) if (tmp === 0) throw this.#createError("Cannot read block: indentation width must be greater than 0");
			else if (!detectedIndent) {
				textIndent = nodeIndent + tmp - 1;
				detectedIndent = true;
			} else throw this.#createError("Cannot read block: indentation width identifier repeated");
			else break;
		}
		if (isWhiteSpace(ch)) {
			this.skipWhitespaces();
			this.skipComment();
			ch = this.peek();
		}
		while (ch !== 0) {
			this.readLineBreak();
			this.lineIndent = 0;
			ch = this.peek();
			while ((!detectedIndent || this.lineIndent < textIndent) && ch === SPACE) {
				this.lineIndent++;
				ch = this.next();
			}
			if (!detectedIndent && this.lineIndent > textIndent) textIndent = this.lineIndent;
			if (isEOL(ch)) {
				emptyLines++;
				continue;
			}
			if (this.lineIndent < textIndent) {
				if (chomping === CHOMPING_KEEP) this.result += "\n".repeat(didReadContent ? 1 + emptyLines : emptyLines);
				else if (chomping === CHOMPING_CLIP) {
					if (didReadContent) this.result += "\n";
				}
				break;
			}
			if (folding) if (isWhiteSpace(ch)) {
				atMoreIndented = true;
				this.result += "\n".repeat(didReadContent ? 1 + emptyLines : emptyLines);
			} else if (atMoreIndented) {
				atMoreIndented = false;
				this.result += "\n".repeat(emptyLines + 1);
			} else if (emptyLines === 0) {
				if (didReadContent) this.result += " ";
			} else this.result += "\n".repeat(emptyLines);
			else this.result += "\n".repeat(didReadContent ? 1 + emptyLines : emptyLines);
			didReadContent = true;
			detectedIndent = true;
			emptyLines = 0;
			const captureStart = this.position;
			while (!isEOL(ch) && ch !== 0) ch = this.next();
			this.captureSegment(captureStart, this.position, false);
		}
		return true;
	}
	readBlockMapping(nodeIndent, flowIndent) {
		const tag = this.tag;
		const anchor = this.anchor;
		const result = {};
		const overridableKeys = /* @__PURE__ */ new Set();
		let allowCompact = false;
		let line;
		let pos;
		let keyTag = null;
		let keyNode = null;
		let valueNode = null;
		let atExplicitKey = false;
		let detected = false;
		if (this.anchor !== null && typeof this.anchor !== "undefined") this.anchorMap.set(this.anchor, result);
		let ch = this.peek();
		while (ch !== 0) {
			const following = this.peek(1);
			line = this.line;
			pos = this.position;
			if ((ch === QUESTION || ch === COLON) && isWhiteSpaceOrEOL(following)) {
				if (ch === QUESTION) {
					if (atExplicitKey) {
						this.storeMappingPair(result, overridableKeys, keyTag, keyNode, null);
						keyTag = null;
						keyNode = null;
						valueNode = null;
					}
					detected = true;
					atExplicitKey = true;
					allowCompact = true;
				} else if (atExplicitKey) {
					atExplicitKey = false;
					allowCompact = true;
				} else throw this.#createError("Cannot read block as explicit mapping pair is incomplete: a key node is missed or followed by a non-tabulated empty line");
				this.position += 1;
				ch = following;
			} else if (this.composeNode({
				parentIndent: flowIndent,
				nodeContext: CONTEXT_FLOW_OUT,
				allowToSeek: false,
				allowCompact: true
			})) if (this.line === line) {
				ch = this.peek();
				this.skipWhitespaces();
				ch = this.peek();
				if (ch === COLON) {
					ch = this.next();
					if (!isWhiteSpaceOrEOL(ch)) throw this.#createError("Cannot read block: a whitespace character is expected after the key-value separator within a block mapping");
					if (atExplicitKey) {
						this.storeMappingPair(result, overridableKeys, keyTag, keyNode, null);
						keyTag = null;
						keyNode = null;
						valueNode = null;
					}
					detected = true;
					atExplicitKey = false;
					allowCompact = false;
					keyTag = this.tag;
					keyNode = this.result;
				} else if (detected) throw this.#createError("Cannot read an implicit mapping pair: missing colon");
				else {
					this.tag = tag;
					this.anchor = anchor;
					return true;
				}
			} else if (detected) throw this.#createError("Cannot read a block mapping entry: a multiline key may not be an implicit key");
			else {
				this.tag = tag;
				this.anchor = anchor;
				return true;
			}
			else break;
			if (this.line === line || this.lineIndent > nodeIndent) {
				if (this.composeNode({
					parentIndent: nodeIndent,
					nodeContext: CONTEXT_BLOCK_OUT,
					allowToSeek: true,
					allowCompact
				})) if (atExplicitKey) keyNode = this.result;
				else valueNode = this.result;
				if (!atExplicitKey) {
					this.storeMappingPair(result, overridableKeys, keyTag, keyNode, valueNode, line, pos);
					keyTag = keyNode = valueNode = null;
				}
				this.skipSeparationSpace(true, -1);
				ch = this.peek();
			}
			if (this.lineIndent > nodeIndent && ch !== 0) throw this.#createError("Cannot read block: bad indentation of a mapping entry");
			else if (this.lineIndent < nodeIndent) break;
		}
		if (atExplicitKey) this.storeMappingPair(result, overridableKeys, keyTag, keyNode, null);
		if (detected) {
			this.tag = tag;
			this.anchor = anchor;
			this.kind = "mapping";
			this.result = result;
		}
		return detected;
	}
	readTagProperty() {
		let isVerbatim = false;
		let isNamed = false;
		let tagHandle = "";
		let tagName;
		let ch = this.peek();
		if (ch !== EXCLAMATION) return false;
		if (this.tag !== null) throw this.#createError("Cannot read tag property: duplication of a tag property");
		ch = this.next();
		if (ch === SMALLER_THAN) {
			isVerbatim = true;
			ch = this.next();
		} else if (ch === EXCLAMATION) {
			isNamed = true;
			tagHandle = "!!";
			ch = this.next();
		} else tagHandle = "!";
		let position = this.position;
		if (isVerbatim) {
			do
				ch = this.next();
			while (ch !== 0 && ch !== GREATER_THAN);
			if (this.position < this.length) {
				tagName = this.input.slice(position, this.position);
				ch = this.next();
			} else throw this.#createError("Cannot read tag property: unexpected end of stream");
		} else {
			while (ch !== 0 && !isWhiteSpaceOrEOL(ch)) {
				if (ch === EXCLAMATION) if (!isNamed) {
					tagHandle = this.input.slice(position - 1, this.position + 1);
					if (!PATTERN_TAG_HANDLE.test(tagHandle)) throw this.#createError("Cannot read tag property: named tag handle contains invalid characters");
					isNamed = true;
					position = this.position + 1;
				} else throw this.#createError("Cannot read tag property: tag suffix cannot contain an exclamation mark");
				ch = this.next();
			}
			tagName = this.input.slice(position, this.position);
			if (PATTERN_FLOW_INDICATORS.test(tagName)) throw this.#createError("Cannot read tag property: tag suffix cannot contain flow indicator characters");
		}
		if (tagName && !PATTERN_TAG_URI.test(tagName)) throw this.#createError(`Cannot read tag property: invalid characters in tag name "${tagName}"`);
		if (isVerbatim) this.tag = tagName;
		else if (this.tagMap.has(tagHandle)) this.tag = this.tagMap.get(tagHandle) + tagName;
		else if (tagHandle === "!") this.tag = `!${tagName}`;
		else if (tagHandle === "!!") this.tag = `tag:yaml.org,2002:${tagName}`;
		else throw this.#createError(`Cannot read tag property: undeclared tag handle "${tagHandle}"`);
		return true;
	}
	readAnchorProperty() {
		let ch = this.peek();
		if (ch !== AMPERSAND) return false;
		if (this.anchor !== null) throw this.#createError("Cannot read anchor property: duplicate anchor property");
		ch = this.next();
		const position = this.position;
		while (ch !== 0 && !isWhiteSpaceOrEOL(ch) && !isFlowIndicator(ch)) ch = this.next();
		if (this.position === position) throw this.#createError("Cannot read anchor property: name of an anchor node must contain at least one character");
		this.anchor = this.input.slice(position, this.position);
		return true;
	}
	readAlias() {
		if (this.peek() !== ASTERISK) return false;
		let ch = this.next();
		const position = this.position;
		while (ch !== 0 && !isWhiteSpaceOrEOL(ch) && !isFlowIndicator(ch)) ch = this.next();
		if (this.position === position) throw this.#createError("Cannot read alias: alias name must contain at least one character");
		const alias = this.input.slice(position, this.position);
		if (!this.anchorMap.has(alias)) throw this.#createError(`Cannot read alias: unidentified alias "${alias}"`);
		this.result = this.anchorMap.get(alias);
		this.skipSeparationSpace(true, -1);
		return true;
	}
	composeNode({ parentIndent, nodeContext, allowToSeek, allowCompact }) {
		let indentStatus = 1;
		let atNewLine = false;
		let hasContent = false;
		let type;
		this.tag = null;
		this.anchor = null;
		this.kind = null;
		this.result = null;
		const allowBlockScalars = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
		let allowBlockCollections = allowBlockScalars;
		const allowBlockStyles = allowBlockScalars;
		if (allowToSeek) {
			if (this.skipSeparationSpace(true, -1)) {
				atNewLine = true;
				if (this.lineIndent > parentIndent) indentStatus = 1;
				else if (this.lineIndent === parentIndent) indentStatus = 0;
				else if (this.lineIndent < parentIndent) indentStatus = -1;
			}
		}
		if (indentStatus === 1) while (this.readTagProperty() || this.readAnchorProperty()) if (this.skipSeparationSpace(true, -1)) {
			atNewLine = true;
			allowBlockCollections = allowBlockStyles;
			if (this.lineIndent > parentIndent) indentStatus = 1;
			else if (this.lineIndent === parentIndent) indentStatus = 0;
			else if (this.lineIndent < parentIndent) indentStatus = -1;
		} else allowBlockCollections = false;
		if (allowBlockCollections) allowBlockCollections = atNewLine || allowCompact;
		if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
			const cond = CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext;
			const flowIndent = cond ? parentIndent : parentIndent + 1;
			const blockIndent = this.position - this.lineStart;
			if (indentStatus === 1) if (allowBlockCollections && (this.readBlockSequence(blockIndent) || this.readBlockMapping(blockIndent, flowIndent)) || this.readFlowCollection(flowIndent)) hasContent = true;
			else {
				if (allowBlockScalars && this.readBlockScalar(flowIndent) || this.readSingleQuotedScalar(flowIndent) || this.readDoubleQuotedScalar(flowIndent)) hasContent = true;
				else if (this.readAlias()) {
					hasContent = true;
					if (this.tag !== null || this.anchor !== null) throw this.#createError("Cannot compose node: alias node should not have any properties");
				} else if (this.readPlainScalar(flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
					hasContent = true;
					if (this.tag === null) this.tag = "?";
				}
				if (this.anchor !== null) this.anchorMap.set(this.anchor, this.result);
			}
			else if (indentStatus === 0) hasContent = allowBlockCollections && this.readBlockSequence(blockIndent);
		}
		if (this.tag !== null && this.tag !== "!") if (this.tag === "?") for (let typeIndex = 0; typeIndex < this.implicitTypes.length; typeIndex++) {
			type = this.implicitTypes[typeIndex];
			if (type.resolve(this.result)) {
				this.result = type.construct(this.result);
				this.tag = type.tag;
				if (this.anchor !== null) this.anchorMap.set(this.anchor, this.result);
				break;
			}
		}
		else if (this.typeMap[this.kind ?? "fallback"].has(this.tag)) {
			const map$1 = this.typeMap[this.kind ?? "fallback"];
			type = map$1.get(this.tag);
			if (this.result !== null && type.kind !== this.kind) throw this.#createError(`Unacceptable node kind for !<${this.tag}> tag: it should be "${type.kind}", not "${this.kind}"`);
			if (!type.resolve(this.result)) throw this.#createError(`Cannot resolve a node with !<${this.tag}> explicit tag`);
			else {
				this.result = type.construct(this.result);
				if (this.anchor !== null) this.anchorMap.set(this.anchor, this.result);
			}
		} else throw this.#createError(`Cannot resolve unknown tag !<${this.tag}>`);
		return this.tag !== null || this.anchor !== null || hasContent;
	}
	readDocument() {
		const documentStart = this.position;
		let hasDirectives = false;
		this.version = null;
		this.checkLineBreaks = false;
		this.tagMap = /* @__PURE__ */ new Map();
		this.anchorMap = /* @__PURE__ */ new Map();
		let ch = this.peek();
		while (ch !== 0) {
			this.skipSeparationSpace(true, -1);
			ch = this.peek();
			if (this.lineIndent > 0 || ch !== PERCENT) break;
			hasDirectives = true;
			ch = this.next();
			let position = this.position;
			while (ch !== 0 && !isWhiteSpaceOrEOL(ch)) ch = this.next();
			const directiveName = this.input.slice(position, this.position);
			const directiveArgs = [];
			if (directiveName.length < 1) throw this.#createError("Cannot read document: directive name length must be greater than zero");
			while (ch !== 0) {
				this.skipWhitespaces();
				this.skipComment();
				ch = this.peek();
				if (isEOL(ch)) break;
				position = this.position;
				while (ch !== 0 && !isWhiteSpaceOrEOL(ch)) ch = this.next();
				directiveArgs.push(this.input.slice(position, this.position));
			}
			if (ch !== 0) this.readLineBreak();
			switch (directiveName) {
				case "YAML":
					this.yamlDirectiveHandler(...directiveArgs);
					break;
				case "TAG":
					this.tagDirectiveHandler(...directiveArgs);
					break;
				default:
					this.dispatchWarning(`unknown document directive "${directiveName}"`);
					break;
			}
			ch = this.peek();
		}
		this.skipSeparationSpace(true, -1);
		if (this.lineIndent === 0 && this.peek() === MINUS && this.peek(1) === MINUS && this.peek(2) === MINUS) {
			this.position += 3;
			this.skipSeparationSpace(true, -1);
		} else if (hasDirectives) throw this.#createError("Cannot read document: directives end mark is expected");
		this.composeNode({
			parentIndent: this.lineIndent - 1,
			nodeContext: CONTEXT_BLOCK_OUT,
			allowToSeek: false,
			allowCompact: true
		});
		this.skipSeparationSpace(true, -1);
		if (this.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(this.input.slice(documentStart, this.position))) this.dispatchWarning("non-ASCII line breaks are interpreted as content");
		if (this.position === this.lineStart && this.testDocumentSeparator()) {
			if (this.peek() === DOT) {
				this.position += 3;
				this.skipSeparationSpace(true, -1);
			}
		} else if (this.position < this.length - 1) throw this.#createError("Cannot read document: end of the stream or a document separator is expected");
		return this.result;
	}
	*readDocuments() {
		while (this.position < this.length - 1) yield this.readDocument();
	}
};

//#endregion
//#region ../../node_modules/.pnpm/@jsr+std__yaml@1.0.8/node_modules/@jsr/std__yaml/parse.js
function sanitizeInput(input) {
	input = String(input);
	if (input.length > 0) {
		if (!isEOL(input.charCodeAt(input.length - 1))) input += "\n";
		if (input.charCodeAt(0) === 65279) input = input.slice(1);
	}
	input += "\0";
	return input;
}
/**
* Parse and return a YAML string as a parsed YAML document object.
*
* Note: This does not support functions. Untrusted data is safe to parse.
*
* @example Usage
* ```ts
* import { parse } from "@std/yaml/parse";
* import { assertEquals } from "@std/assert";
*
* const data = parse(`
* id: 1
* name: Alice
* `);
*
* assertEquals(data, { id: 1, name: "Alice" });
* ```
*
* @throws {SyntaxError} Throws error on invalid YAML.
* @param content YAML string to parse.
* @param options Parsing options.
* @returns Parsed document.
*/ function parse(content, options = {}) {
	content = sanitizeInput(content);
	const state = new LoaderState(content, {
		...options,
		schema: SCHEMA_MAP.get(options.schema)
	});
	const documentGenerator = state.readDocuments();
	const document = documentGenerator.next().value;
	if (!documentGenerator.next().done) throw new SyntaxError("Found more than 1 document in the stream: expected a single document");
	return document ?? null;
}

//#endregion
//#region src/codegen/fs.ts
/**
* Recursively read a directory, yielding the paths of all files.  File paths
* are relative to the directory, and directories are not yielded.
* @param dir The directory to read.
* @returns An async iterable of file paths.
*/
async function* readDirRecursive(dir) {
	for (const entry of await readdir(dir, { withFileTypes: true })) if (entry.isDirectory()) {
		const path = join(dir, entry.name);
		for await (const subentry of readDirRecursive(path)) yield join(entry.name, subentry);
	} else yield entry.name;
}

//#endregion
//#region src/codegen/schema.ts
/**
* An error that occurred while loading a schema file.
*/
var SchemaError = class extends Error {
	/**
	* The path of the schema file.
	*/
	path;
	/**
	* Constructs a new `SchemaError`.
	* @param path The path of the schema file.
	* @param message The error message.
	*/
	constructor(path, message) {
		super(message);
		this.path = path;
	}
};
async function loadSchemaValidator() {
	const thisFile = new URL(import.meta.url);
	const schemaFile = join$2(dirname$1(thisFile), "schema.yaml");
	let content;
	if (schemaFile.protocol !== "file:") {
		const response = await fetch(schemaFile);
		content = await response.text();
	} else content = await readFile(fromFileUrl(schemaFile), { encoding: "utf-8" });
	const schemaObject = parse(content);
	return new Validator(schemaObject);
}
let schemaValidator = void 0;
async function loadSchema(path) {
	const content = await readFile(path, { encoding: "utf-8" });
	const schema = parse(content);
	if (schemaValidator == null) schemaValidator = await loadSchemaValidator();
	const result = schemaValidator.validate(schema);
	const errors = [];
	if (result.valid) return schema;
	for (const e of result.errors) errors.push(new SchemaError(path, `${path}:${e.instanceLocation}: ${e.error}`));
	throw new AggregateError(errors);
}
/**
* Loads all schema files in the directory.
* @param dir The path of the directory to load schema files from.
* @returns A map from the qualified URI of a type to its {@link SchemaFile}.
* @throws {@link AggregateError} if any schema file is invalid.  It contains
*         all {@link SchemaError}s of the invalid schema files.
*/
async function loadSchemaFiles(dir) {
	if (typeof dir !== "string") throw new TypeError("Expected a directory path in string");
	const result = {};
	const errors = [];
	for await (const relPath of readDirRecursive(dir)) {
		if (!relPath.match(/\.ya?ml$/i)) continue;
		if (relPath.match(/(^|[/\\])schema.yaml$/i)) continue;
		const path = join(dir, relPath);
		let schema;
		try {
			schema = await loadSchema(path);
		} catch (e) {
			if (e instanceof AggregateError && e.errors.length > 0 && e.errors[0] instanceof SchemaError) {
				errors.push(...e.errors);
				continue;
			}
			throw e;
		}
		result[schema.uri] = schema;
	}
	if (errors.length > 0) throw new AggregateError(errors);
	const entries = Object.entries(result);
	entries.sort(([a], [b]) => a < b ? -1 : a > b ? 1 : 0);
	return Object.fromEntries(entries);
}

//#endregion
//#region src/codegen/type.ts
const scalarTypes = {
	"http://www.w3.org/2001/XMLSchema#boolean": {
		name: "boolean",
		typeGuard(v) {
			return `typeof ${v} === "boolean"`;
		},
		encoder(v) {
			return `{ "@value": ${v} }`;
		},
		compactEncoder(v) {
			return v;
		},
		dataCheck(v) {
			return `typeof ${v} === "object" && "@value" in ${v}
        && typeof ${v}["@value"] === "boolean"`;
		},
		decoder(v) {
			return `${v}["@value"]`;
		}
	},
	"http://www.w3.org/2001/XMLSchema#integer": {
		name: "number",
		typeGuard(v) {
			return `typeof ${v} === "number" && Number.isInteger(${v})`;
		},
		encoder(v) {
			return `{
        "@type": "http://www.w3.org/2001/XMLSchema#integer",
        "@value": ${v},
      }`;
		},
		compactEncoder(v) {
			return v;
		},
		dataCheck(v) {
			return `typeof ${v} === "object" && "@type" in ${v}
        && ${v}["@type"] === "http://www.w3.org/2001/XMLSchema#integer"
        && "@value" in ${v} && typeof ${v}["@value"] === "number"`;
		},
		decoder(v) {
			return `${v}["@value"] as number`;
		}
	},
	"http://www.w3.org/2001/XMLSchema#nonNegativeInteger": {
		name: "number",
		typeGuard(v) {
			return `typeof ${v} === "number" && Number.isInteger(${v}) && ${v} >= 0`;
		},
		encoder(v) {
			return `{
        "@type": "http://www.w3.org/2001/XMLSchema#nonNegativeInteger",
        "@value": ${v},
      }`;
		},
		compactEncoder(v) {
			return v;
		},
		dataCheck(v) {
			return `typeof ${v} === "object" && "@type" in ${v}
        && ${v}["@type"] === "http://www.w3.org/2001/XMLSchema#nonNegativeInteger"
        && "@value" in ${v} && typeof ${v}["@value"] === "number"`;
		},
		decoder(v) {
			return `${v}["@value"]`;
		}
	},
	"http://www.w3.org/2001/XMLSchema#float": {
		name: "number",
		typeGuard(v) {
			return `typeof ${v} === "number" && !Number.isNaN(${v})`;
		},
		encoder(v) {
			return `{
        "@type": "http://www.w3.org/2001/XMLSchema#float",
        "@value": ${v},
      }`;
		},
		compactEncoder(v) {
			return v;
		},
		dataCheck(v) {
			return `typeof ${v} === "object" && "@type" in ${v}
        && ${v}["@type"] === "http://www.w3.org/2001/XMLSchema#float"
        && "@value" in ${v} && typeof ${v}["@value"] === "number"`;
		},
		decoder(v) {
			return `${v}["@value"]`;
		}
	},
	"http://www.w3.org/2001/XMLSchema#string": {
		name: "string",
		typeGuard(v) {
			return `typeof ${v} === "string"`;
		},
		encoder(v) {
			return `{ "@value": ${v} }`;
		},
		compactEncoder(v) {
			return v;
		},
		dataCheck(v) {
			return `typeof ${v} === "object" && "@value" in ${v}
        && typeof ${v}["@value"] === "string" && !("@language" in ${v})`;
		},
		decoder(v) {
			return `${v}["@value"]`;
		}
	},
	"http://www.w3.org/2001/XMLSchema#anyURI": {
		name: "URL",
		typeGuard(v) {
			return `${v} instanceof URL`;
		},
		encoder(v) {
			return `{ "@id": ${v}.href }`;
		},
		compactEncoder(v) {
			return `${v}.href`;
		},
		dataCheck(v) {
			return `typeof ${v} === "object" && "@id" in ${v}
        && typeof ${v}["@id"] === "string"
        && ${v}["@id"] !== ""`;
		},
		decoder(v, baseUrlVar) {
			return `${v}["@id"].startsWith("at://")
        ? new URL("at://" +
          encodeURIComponent(
            ${v}["@id"].includes("/", 5)
              ? ${v}["@id"].slice(5, ${v}["@id"].indexOf("/", 5))
              : ${v}["@id"].slice(5)
          ) +
          (
            ${v}["@id"].includes("/", 5)
              ? ${v}["@id"].slice(${v}["@id"].indexOf("/", 5))
              : ""
          )
        )
        : URL.canParse(${v}["@id"]) && ${baseUrlVar}
          ? new URL(${v}["@id"])
          : new URL(${v}["@id"], ${baseUrlVar})`;
		}
	},
	"http://www.w3.org/1999/02/22-rdf-syntax-ns#langString": {
		name: "LanguageString",
		typeGuard(v) {
			return `${v} instanceof LanguageString`;
		},
		encoder(v) {
			return `{
        "@value": ${v}.toString(),
        "@language": ${v}.language.compact(),
      }`;
		},
		dataCheck(v) {
			return `typeof ${v} === "object" && "@language" in ${v} && "@value" in ${v}
        && typeof ${v}["@language"] === "string"
        && typeof ${v}["@value"] === "string"`;
		},
		decoder(v) {
			return `new LanguageString(${v}["@value"], ${v}["@language"])`;
		}
	},
	"http://www.w3.org/2001/XMLSchema#dateTime": {
		name: "Temporal.Instant",
		typeGuard(v) {
			return `${v} instanceof Temporal.Instant`;
		},
		encoder(v) {
			return `{
        "@type": "http://www.w3.org/2001/XMLSchema#dateTime",
        "@value": ${v}.toString(),
      }`;
		},
		compactEncoder(v) {
			return `${v}.toString()`;
		},
		dataCheck(v) {
			return `typeof ${v} === "object" && "@type" in ${v}
        && "@value" in ${v} && typeof ${v}["@value"] === "string"
        && ${v}["@type"] === "http://www.w3.org/2001/XMLSchema#dateTime"
        // Check if the value is a valid RFC 3339 date-time string
        && new Date(${v}["@value"]).toString() !== "Invalid Date"
        `;
		},
		decoder(v) {
			return `Temporal.Instant.from(
        ${v}["@value"].substring(19).match(/[Z+-]/)
          ? ${v}["@value"]
          : ${v}["@value"] + "Z"
      )`;
		}
	},
	"http://www.w3.org/2001/XMLSchema#duration": {
		name: "Temporal.Duration",
		typeGuard(v) {
			return `${v} instanceof Temporal.Duration`;
		},
		encoder(v) {
			return `{
        "@type": "http://www.w3.org/2001/XMLSchema#duration",
        "@value": ${v}.toString(),
      }`;
		},
		compactEncoder(v) {
			return `${v}.toString()`;
		},
		dataCheck(v) {
			return `typeof ${v} === "object" && "@type" in ${v}
        && "@value" in ${v} && typeof ${v}["@value"] === "string"
        && ${v}["@type"] === "http://www.w3.org/2001/XMLSchema#duration"`;
		},
		decoder(v) {
			return `Temporal.Duration.from(${v}["@value"])`;
		}
	},
	"https://w3id.org/security#cryptosuiteString": {
		name: "\"eddsa-jcs-2022\"",
		typeGuard(v) {
			return `${v} == "eddsa-jcs-2022"`;
		},
		encoder(v) {
			return `{ "@value": ${v} }`;
		},
		compactEncoder(v) {
			return v;
		},
		dataCheck(v) {
			return `typeof ${v} === "object" && "@value" in ${v}
        && !("@language" in ${v}) && ${v}["@value"] === "eddsa-jcs-2022"`;
		},
		decoder(v) {
			return `${v}["@value"]`;
		}
	},
	"https://w3id.org/security#multibase": {
		name: "Uint8Array",
		typeGuard(v) {
			return `${v} instanceof Uint8Array`;
		},
		encoder(v) {
			return `{
        "@type": "https://w3id.org/security#multibase",
        "@value": new TextDecoder().decode(encodeMultibase("base58btc", ${v})),
      }`;
		},
		compactEncoder(v) {
			return `new TextDecoder().decode(encodeMultibase("base58btc", ${v}))`;
		},
		dataCheck(v) {
			return `typeof ${v} === "object" && "@value" in ${v}
        && typeof ${v}["@value"] === "string"`;
		},
		decoder(v) {
			return `decodeMultibase(${v}["@value"])`;
		}
	},
	"fedify:langTag": {
		name: "LanguageTag",
		typeGuard(v) {
			return `${v} instanceof LanguageTag`;
		},
		encoder(v) {
			return `{ "@value": ${v}.compact() }`;
		},
		compactEncoder(v) {
			return `${v}.compact()`;
		},
		dataCheck(v) {
			return `typeof ${v} === "object" && "@value" in ${v}
        && typeof ${v}["@value"] === "string" && !("@language" in ${v})`;
		},
		decoder(v) {
			return `parseLanguageTag(${v}["@value"])`;
		}
	},
	"fedify:url": {
		name: "URL",
		typeGuard(v) {
			return `${v} instanceof URL`;
		},
		encoder(v) {
			return `{ "@value": ${v}.href }`;
		},
		compactEncoder(v) {
			return `${v}.href`;
		},
		dataCheck(v) {
			return `typeof ${v} === "object" && "@value" in ${v}
        && typeof ${v}["@value"] === "string"
        && ${v}["@value"] !== "" && ${v}["@value"] !== "/"`;
		},
		decoder(v) {
			return `new URL(${v}["@value"])`;
		}
	},
	"fedify:publicKey": {
		name: "CryptoKey",
		typeGuard(v) {
			return `
        // @ts-ignore: CryptoKey exists in the global scope.
        ${v} instanceof CryptoKey
      `;
		},
		encoder(v) {
			return `{ "@value": await exportSpki(${v}) }`;
		},
		compactEncoder(v) {
			return `await exportSpki(${v})`;
		},
		dataCheck(v) {
			return `typeof ${v} === "object" && "@value" in ${v}
        && typeof ${v}["@value"] === "string"`;
		},
		decoder(v) {
			return `await importPem(${v}["@value"])`;
		}
	},
	"fedify:multibaseKey": {
		name: "CryptoKey",
		typeGuard(v) {
			return `
        // @ts-ignore: CryptoKey exists in the global scope.
        ${v} instanceof CryptoKey
      `;
		},
		encoder(v) {
			return `{
        "@type": "https://w3id.org/security#multibase",
        "@value": await exportMultibaseKey(${v}),
      }`;
		},
		compactEncoder(v) {
			return `await exportMultibaseKey(${v})`;
		},
		dataCheck(v) {
			return `typeof ${v} === "object" && "@value" in ${v}
        && typeof ${v}["@value"] === "string"`;
		},
		decoder(v) {
			return `await importMultibaseKey(${v}["@value"])`;
		}
	},
	"fedify:proofPurpose": {
		name: "\"assertionMethod\" | \"authentication\" | \"capabilityInvocation\" | \"capabilityDelegation\" | \"keyAgreement\"",
		typeGuard(v) {
			return `${v} === "assertionMethod" || ${v} === "authentication" ||
        ${v} === "capabilityInvocation" || ${v} === "capabilityDelegation" ||
        ${v} === "keyAgreement"`;
		},
		encoder(v) {
			return `{
        "@id": "https://w3id.org/security#" + ${v},
      }`;
		},
		compactEncoder(v) {
			return v;
		},
		dataCheck(v) {
			return `typeof ${v} === "object" && "@id" in ${v}
        && typeof ${v}["@id"] === "string"
        && ${v}["@id"].startsWith("https://w3id.org/security#")
        && [
          "assertionMethod", "authentication", "capabilityInvocation",
          "capabilityDelegation", "keyAgreement",
        ].includes(${v}["@id"].substring(26))`;
		},
		decoder(v) {
			return `${v}["@id"].substring(26)`;
		}
	},
	"fedify:units": {
		name: "\"cm\" | \"feet\" | \"inches\" | \"km\" | \"m\" | \"miles\"",
		typeGuard(v) {
			return `${v} == "cm" || ${v} == "feet" || ${v} == "inches" || ${v} == "km" || ${v} == "m" || ${v} == "miles"`;
		},
		encoder(v) {
			return `{ "@value": ${v} }`;
		},
		compactEncoder(v) {
			return v;
		},
		dataCheck(v) {
			return `typeof ${v} === "object" && "@value" in ${v}
      && (${v}["@value"] == "cm" || ${v}["@value"] == "feet" || ${v}["@value"] == "inches" || ${v}["@value"] == "km" || ${v}["@value"] == "m" || ${v}["@value"] == "miles")`;
		},
		decoder(v) {
			return `${v}["@value"]`;
		}
	}
};
function isScalarType(typeUri, types$1) {
	if (typeUri in scalarTypes) return true;
	else if (typeUri in types$1) return !types$1[typeUri].entity;
	throw new Error(`Unknown type: ${typeUri}`);
}
function areAllScalarTypes(typeUris, types$1) {
	return typeUris.every((typeUri) => isScalarType(typeUri, types$1));
}

//#endregion
//#region src/vocab/vocab.test.ts
test("new Object()", () => {
	const obj = new Object$1({
		name: "Test",
		contents: [new LanguageString("Hello", "en"), new LanguageString("你好", "zh")]
	});
	assertEquals(obj.name, "Test");
	assertEquals(obj.contents[0], new LanguageString("Hello", "en"));
	assertEquals(obj.contents[1], new LanguageString("你好", "zh"));
	assertThrows(() => new Object$1({ id: 123 }), TypeError, "The id must be a URL.");
	assertThrows(() => new Object$1({
		name: "singular",
		names: ["plural"]
	}), TypeError, "Cannot initialize both name and names at the same time.");
	assertThrows(() => new Object$1({ name: 123 }), TypeError, "The name must be of type string | LanguageString.");
	assertThrows(() => new Object$1({ names: "foo" }), TypeError, "The names must be an array of type string | LanguageString.");
	assertThrows(() => new Object$1({ names: ["foo", 123] }), TypeError, "The names must be an array of type string | LanguageString.");
});
test("Object.clone()", () => {
	const obj = new Object$1({
		id: new URL("https://example.com/"),
		name: "Test",
		contents: [new LanguageString("Hello", "en"), new LanguageString("你好", "zh")]
	});
	const clone = obj.clone({ content: "Modified" });
	assertInstanceOf(clone, Object$1);
	assertEquals(clone.id, new URL("https://example.com/"));
	assertEquals(clone.name, "Test");
	assertEquals(clone.content, "Modified");
	const cloned2 = obj.clone({ id: new URL("https://example.com/modified") });
	assertInstanceOf(cloned2, Object$1);
	assertEquals(cloned2.id, new URL("https://example.com/modified"));
	assertEquals(cloned2.name, "Test");
	assertEquals(cloned2.contents, [new LanguageString("Hello", "en"), new LanguageString("你好", "zh")]);
	assertThrows(() => obj.clone({ id: 123 }), TypeError, "The id must be a URL.");
	assertThrows(() => obj.clone({
		name: "singular",
		names: ["plural"]
	}), TypeError, "Cannot update both name and names at the same time.");
	assertThrows(() => obj.clone({ name: 123 }), TypeError, "The name must be of type string | LanguageString.");
	assertThrows(() => obj.clone({ names: "foo" }), TypeError, "The names must be an array of type string | LanguageString.");
	assertThrows(() => obj.clone({ names: ["foo", 123] }), TypeError, "The names must be an array of type string | LanguageString.");
});
test("Object.fromJsonLd()", async () => {
	const obj = await Object$1.fromJsonLd({
		"@context": "https://www.w3.org/ns/activitystreams",
		"type": "Object",
		"name": "Test",
		"contentMap": {
			"en": "Hello",
			"zh": "你好"
		},
		"source": {
			"content": "Hello",
			"mediaType": "text/plain"
		},
		"published": "2025-01-01 12:34:56"
	}, {
		documentLoader: mockDocumentLoader,
		contextLoader: mockDocumentLoader
	});
	assertInstanceOf(obj, Object$1);
	assertEquals(obj.name, "Test");
	assertEquals(obj.contents, [new LanguageString("Hello", "en"), new LanguageString("你好", "zh")]);
	assertInstanceOf(obj.source, Source);
	assertEquals(obj.source.content, "Hello");
	assertEquals(obj.source.mediaType, "text/plain");
	assertEquals(obj.published, Temporal.Instant.from("2025-01-01T12:34:56Z"));
	const createJsonLd = {
		"@context": "https://www.w3.org/ns/activitystreams",
		"type": "Create",
		"name": "Test",
		"contentMap": {
			"en": "Hello",
			"zh": "你好"
		},
		"object": {
			"type": "Note",
			"content": "Content"
		}
	};
	const create = await Object$1.fromJsonLd(createJsonLd, {
		documentLoader: mockDocumentLoader,
		contextLoader: mockDocumentLoader
	});
	assertInstanceOf(create, Create);
	assertEquals(create.name, "Test");
	assertEquals(create.contents, [new LanguageString("Hello", "en"), new LanguageString("你好", "zh")]);
	assertEquals(await create.toJsonLd(), createJsonLd);
	const note = await create.getObject();
	assertInstanceOf(note, Note);
	assertEquals(note.content, "Content");
	const empty = await Object$1.fromJsonLd({});
	assertInstanceOf(empty, Object$1);
	await assertRejects(() => Object$1.fromJsonLd(null), TypeError, "Invalid JSON-LD: null.");
	await assertRejects(() => Object$1.fromJsonLd(void 0), TypeError, "Invalid JSON-LD: undefined.");
});
test("Object.toJsonLd()", async () => {
	const obj = new Object$1({
		name: "Test",
		contents: [new LanguageString("Hello", "en"), new LanguageString("你好", "zh")]
	});
	assertEquals(await obj.toJsonLd({
		format: "expand",
		contextLoader: mockDocumentLoader
	}), [{
		"@type": ["https://www.w3.org/ns/activitystreams#Object"],
		"https://www.w3.org/ns/activitystreams#name": [{ "@value": "Test" }],
		"https://www.w3.org/ns/activitystreams#content": [{
			"@value": "Hello",
			"@language": "en"
		}, {
			"@value": "你好",
			"@language": "zh"
		}]
	}]);
	assertEquals(await obj.toJsonLd({ contextLoader: mockDocumentLoader }), {
		"@context": [
			"https://www.w3.org/ns/activitystreams",
			"https://w3id.org/security/data-integrity/v1",
			{
				fedibird: "http://fedibird.com/ns#",
				sensitive: "as:sensitive",
				emojiReactions: {
					"@id": "fedibird:emojiReactions",
					"@type": "@id"
				}
			}
		],
		type: "Object",
		name: "Test",
		contentMap: {
			en: "Hello",
			zh: "你好"
		}
	});
});
test("Note.toJsonLd()", async () => {
	const note = new Note({ tags: [new Hashtag({
		name: "#Fedify",
		href: new URL("https://fedify.dev/")
	})] });
	assertEquals(await note.toJsonLd({ contextLoader: mockDocumentLoader }), {
		"@context": [
			"https://www.w3.org/ns/activitystreams",
			"https://w3id.org/security/data-integrity/v1",
			{
				Emoji: "toot:Emoji",
				Hashtag: "as:Hashtag",
				_misskey_quote: "misskey:_misskey_quote",
				fedibird: "http://fedibird.com/ns#",
				misskey: "https://misskey-hub.net/ns#",
				quoteUri: "fedibird:quoteUri",
				quoteUrl: "as:quoteUrl",
				sensitive: "as:sensitive",
				toot: "http://joinmastodon.org/ns#",
				emojiReactions: {
					"@id": "fedibird:emojiReactions",
					"@type": "@id"
				}
			}
		],
		tag: {
			"@context": ["https://www.w3.org/ns/activitystreams", { Hashtag: "as:Hashtag" }],
			href: "https://fedify.dev/",
			name: "#Fedify",
			type: "Hashtag"
		},
		type: "Note"
	});
	const noteWithName = note.clone({ name: "Test" });
	assertEquals(await noteWithName.toJsonLd({ contextLoader: mockDocumentLoader }), await noteWithName.toJsonLd({
		contextLoader: mockDocumentLoader,
		format: "compact"
	}));
});
test("Activity.fromJsonLd()", async () => {
	const follow = await Activity.fromJsonLd({
		"@context": "https://www.w3.org/ns/activitystreams",
		id: "https://activitypub.academy/80c50305-7405-4e38-809f-697647a1f679",
		type: "Follow",
		actor: "https://activitypub.academy/users/egulia_anbeiss",
		object: "https://example.com/users/hongminhee"
	}, {
		documentLoader: mockDocumentLoader,
		contextLoader: mockDocumentLoader
	});
	assertInstanceOf(follow, Follow);
	assertEquals(follow.id, new URL("https://activitypub.academy/80c50305-7405-4e38-809f-697647a1f679"));
	assertEquals(follow.actorId, new URL("https://activitypub.academy/users/egulia_anbeiss"));
	assertEquals(follow.objectId, new URL("https://example.com/users/hongminhee"));
	const create = await Activity.fromJsonLd({
		"@context": ["https://www.w3.org/ns/activitystreams", "https://w3id.org/security/data-integrity/v1"],
		type: "Create",
		actor: "https://server.example/users/alice",
		object: {
			type: "Note",
			content: "Hello world"
		},
		proof: {
			type: "DataIntegrityProof",
			cryptosuite: "eddsa-jcs-2022",
			verificationMethod: "https://server.example/users/alice#ed25519-key",
			proofPurpose: "assertionMethod",
			proofValue: "z3sXaxjKs4M3BRicwWA9peyNPJvJqxtGsDmpt1jjoHCjgeUf71TRFz56osPSfDErszyLp5Ks1EhYSgpDaNM977Rg2",
			created: "2023-02-24T23:36:38Z"
		}
	}, {
		documentLoader: mockDocumentLoader,
		contextLoader: mockDocumentLoader
	});
	const proofs = [];
	for await (const proof of create.getProofs()) proofs.push(proof);
	assertEquals(proofs.length, 1);
	assertEquals(proofs[0].cryptosuite, "eddsa-jcs-2022");
	assertEquals(proofs[0].verificationMethodId, new URL("https://server.example/users/alice#ed25519-key"));
	assertEquals(proofs[0].proofPurpose, "assertionMethod");
	assertEquals(proofs[0].proofValue, decode("z3sXaxjKs4M3BRicwWA9peyNPJvJqxtGsDmpt1jjoHCjgeUf71TRFz56osPSfDErszyLp5Ks1EhYSgpDaNM977Rg2"));
	assertEquals(proofs[0].created, Temporal.Instant.from("2023-02-24T23:36:38Z"));
});
test({
	name: "Activity.getObject()",
	permissions: {
		env: true,
		read: true
	},
	async fn() {
		const activity = new Activity({ object: new URL("https://example.com/announce") });
		const announce = await activity.getObject({
			documentLoader: mockDocumentLoader,
			contextLoader: mockDocumentLoader
		});
		assertInstanceOf(announce, Announce);
		assertEquals(announce.id, new URL("https://example.com/announce"));
		const object = await announce.getObject();
		assertInstanceOf(object, Object$1);
		assertEquals(object.id, new URL("https://example.com/object"));
		assertEquals(object.name, "Fetched object");
		const jsonLd = await activity.toJsonLd();
		assertEquals(jsonLd, {
			"@context": [
				"https://w3id.org/identity/v1",
				"https://www.w3.org/ns/activitystreams",
				"https://w3id.org/security/v1",
				"https://w3id.org/security/data-integrity/v1"
			],
			type: "Activity",
			object: {
				id: "https://example.com/announce",
				type: "Announce",
				object: {
					type: "Object",
					id: "https://example.com/object",
					name: "Fetched object"
				}
			}
		});
		const activity2 = new Activity({ object: new URL("https://example.com/not-found") });
		assertEquals(await activity2.getObject({ suppressError: true }), null);
		const activity3 = await Activity.fromJsonLd({
			"@context": "https://www.w3.org/ns/activitystreams",
			type: "Create",
			object: {
				"@context": "https://www.w3.org/ns/activitystreams",
				type: "Note",
				content: "Hello world"
			}
		});
		const object3 = await activity3.getObject();
		assertInstanceOf(object3, Note);
		assertEquals(await object3.toJsonLd(), {
			"@context": "https://www.w3.org/ns/activitystreams",
			type: "Note",
			content: "Hello world"
		});
	}
});
test({
	name: "Activity.getObjects()",
	permissions: {
		env: true,
		read: true
	},
	async fn() {
		const activity = new Activity({ objects: [new URL("https://example.com/object"), new Object$1({ name: "Second object" })] });
		const objects = await Array.fromAsync(activity.getObjects({
			documentLoader: mockDocumentLoader,
			contextLoader: mockDocumentLoader
		}));
		assertEquals(objects.length, 2);
		assertInstanceOf(objects[0], Object$1);
		assertEquals(objects[0].id, new URL("https://example.com/object"));
		assertEquals(objects[0].name, "Fetched object");
		assertInstanceOf(objects[1], Object$1);
		assertEquals(objects[1].name, "Second object");
		const activity2 = new Activity({ objects: [new URL("https://example.com/not-found"), new Object$1({ name: "Second object" })] });
		const objects2 = await Array.fromAsync(activity2.getObjects({ suppressError: true }));
		assertEquals(objects2.length, 1);
		assertInstanceOf(objects2[0], Object$1);
		assertEquals(objects2[0].name, "Second object");
	}
});
test("Activity.clone()", async () => {
	const activity = new Activity({
		actor: new Person({ name: "John Doe" }),
		object: new Object$1({ name: "Test" }),
		name: "Test",
		summary: "Test"
	});
	const clone = activity.clone({
		object: new Object$1({ name: "Modified" }),
		summary: "Modified"
	});
	assertEquals((await activity.getActor())?.name, "John Doe");
	assertEquals((await clone.getActor())?.name, "John Doe");
	assertEquals((await activity.getObject())?.name, "Test");
	assertEquals((await clone.getObject())?.name, "Modified");
	assertEquals(activity.name, "Test");
	assertEquals(clone.name, "Test");
	assertEquals(activity.summary, "Test");
	assertEquals(clone.summary, "Modified");
	assertThrows(() => activity.clone({
		summary: "singular",
		summaries: ["plural"]
	}), TypeError, "Cannot update both summary and summaries at the same time.");
});
test("Question.voters", async () => {
	const question = new Question({ voters: 123 });
	const json = await question.toJsonLd({ format: "compact" });
	assert(typeof json === "object" && json != null);
	assert("votersCount" in json);
	assertEquals(json["votersCount"], 123);
});
test({
	name: "Deno.inspect(Object)",
	ignore: !("Deno" in globalThis),
	fn() {
		const obj = new Object$1({
			id: new URL("https://example.com/"),
			attribution: new URL("https://example.com/foo"),
			name: "Test",
			contents: [new LanguageString("Hello", "en"), new LanguageString("你好", "zh")]
		});
		assertEquals(Deno.inspect(obj, {
			colors: false,
			sorted: true,
			compact: false
		}), "Deno" in globalThis ? "Object {\n  attribution: URL \"https://example.com/foo\",\n  contents: [\n    <en> \"Hello\",\n    <zh> \"你好\"\n  ],\n  id: URL \"https://example.com/\",\n  name: \"Test\"\n}" : "Object {\n  attribution: URL 'https://example.com/foo',\n  contents: [\n    <en> 'Hello',\n    <zh> '你好'\n  ],\n  id: URL 'https://example.com/',\n  name: 'Test'\n}");
	}
});
test("Person.fromJsonLd()", async () => {
	const person = await Person.fromJsonLd({
		"@context": ["https://www.w3.org/ns/activitystreams", "https://w3id.org/security/v1"],
		"id": "https://todon.eu/users/hongminhee",
		"publicKey": {
			"id": "https://todon.eu/users/hongminhee#main-key",
			"owner": "https://todon.eu/users/hongminhee",
			"publicKeyPem": "-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxsRuvCkgJtflBTl4OVsm\nnt/J1mQfZasfJtN33dcZ3d1lJroxmgmMu69zjGEAwkNbMQaWNLqC4eogkJaeJ4RR\n5MHYXkL9nNilVoTkjX5BVit3puzs7XJ7WQnKQgQMI+ezn24GHsZ/v1JIo77lerX5\nk4HNwTNVt+yaZVQWaOMR3+6FwziQR6kd0VuG9/a9dgAnz2cEoORRC1i4W7IZaB1s\nZnh1WbHbevlGd72HSXll5rocPIHn8gq6xpBgpHwRphlRsgn4KHaJ6brXDIJjrnQh\nIe/YUBOGj/ImSEXhRwlFerKsoAVnZ0Hwbfa46qk44TAt8CyoPMWmpK6pt0ng4pQ2\nuwIDAQAB\n-----END PUBLIC KEY-----\n"
		}
	}, {
		documentLoader: mockDocumentLoader,
		contextLoader: mockDocumentLoader,
		baseUrl: new URL("https://todon.eu/")
	});
	assertEquals(person.publicKeyId, new URL("https://todon.eu/users/hongminhee#main-key"));
	const publicKey = await person.getPublicKey({ documentLoader: mockDocumentLoader });
	assertInstanceOf(publicKey, CryptographicKey);
	assertEquals(publicKey?.ownerId, new URL("https://todon.eu/users/hongminhee"));
	const person2 = await Person.fromJsonLd({
		"@context": ["https://www.w3.org/ns/activitystreams", { alsoKnownAs: {
			"@id": "as:alsoKnownAs",
			"@type": "@id"
		} }],
		"type": "Person",
		"alsoKnownAs": "at://did:plc:x7xdowahlhm5xulzqw4ehv6q"
	});
	assertEquals(person2.aliasId, new URL("at://did%3Aplc%3Ax7xdowahlhm5xulzqw4ehv6q"));
});
test("Person.toJsonLd()", async () => {
	const person = new Person({ aliases: [new URL("https://example.com/alias")] });
	assertEquals(await person.toJsonLd(), {
		"@context": [
			"https://www.w3.org/ns/activitystreams",
			"https://w3id.org/security/v1",
			"https://w3id.org/security/data-integrity/v1",
			"https://www.w3.org/ns/did/v1",
			"https://w3id.org/security/multikey/v1",
			{
				PropertyValue: "schema:PropertyValue",
				alsoKnownAs: {
					"@id": "as:alsoKnownAs",
					"@type": "@id"
				},
				movedTo: {
					"@id": "as:movedTo",
					"@type": "@id"
				},
				discoverable: "toot:discoverable",
				featured: {
					"@id": "toot:featured",
					"@type": "@id"
				},
				featuredTags: {
					"@id": "toot:featuredTags",
					"@type": "@id"
				},
				indexable: "toot:indexable",
				_misskey_followedMessage: "misskey:_misskey_followedMessage",
				isCat: "misskey:isCat",
				manuallyApprovesFollowers: "as:manuallyApprovesFollowers",
				memorial: "toot:memorial",
				misskey: "https://misskey-hub.net/ns#",
				schema: "http://schema.org#",
				suspended: "toot:suspended",
				toot: "http://joinmastodon.org/ns#",
				value: "schema:value",
				Emoji: "toot:Emoji"
			}
		],
		alsoKnownAs: "https://example.com/alias",
		type: "Person"
	});
});
test("Collection.fromJsonLd()", async () => {
	const collection = await Collection.fromJsonLd({
		"@context": ["https://www.w3.org/ns/activitystreams", "https://w3id.org/fep/5711"],
		"type": "Collection",
		"id": "https://example.com/collection/jzc50wc28l",
		"inboxOf": "https://example.com/person/bup9a8eqm"
	});
	assertEquals(collection.id, new URL("https://example.com/collection/jzc50wc28l"));
	assertEquals(collection.inboxOfId, new URL("https://example.com/person/bup9a8eqm"));
});
test("Note.quoteUrl", async () => {
	const note = new Note({ quoteUrl: new URL("https://example.com/object") });
	const expected = {
		"@context": [
			"https://www.w3.org/ns/activitystreams",
			"https://w3id.org/security/data-integrity/v1",
			{
				Emoji: "toot:Emoji",
				Hashtag: "as:Hashtag",
				_misskey_quote: "misskey:_misskey_quote",
				fedibird: "http://fedibird.com/ns#",
				misskey: "https://misskey-hub.net/ns#",
				quoteUri: "fedibird:quoteUri",
				quoteUrl: "as:quoteUrl",
				sensitive: "as:sensitive",
				toot: "http://joinmastodon.org/ns#",
				emojiReactions: {
					"@id": "fedibird:emojiReactions",
					"@type": "@id"
				}
			}
		],
		_misskey_quote: "https://example.com/object",
		quoteUri: "https://example.com/object",
		quoteUrl: "https://example.com/object",
		type: "Note"
	};
	assertEquals(await note.toJsonLd(), expected);
	assertEquals(await note.toJsonLd({ format: "compact" }), expected);
	const jsonLd = {
		"@context": ["https://www.w3.org/ns/activitystreams", {
			_misskey_quote: "misskey:_misskey_quote",
			fedibird: "http://fedibird.com/ns#",
			misskey: "https://misskey-hub.net/ns#",
			quoteUri: "fedibird:quoteUri",
			quoteUrl: "as:quoteUrl"
		}],
		type: "Note",
		quoteUrl: "https://example.com/object",
		_misskey_quote: "https://example.com/object2",
		quoteUri: "https://example.com/object3"
	};
	const loaded = await Note.fromJsonLd(jsonLd);
	assertEquals(loaded.quoteUrl, new URL("https://example.com/object"));
	delete jsonLd.quoteUrl;
	const loaded2 = await Note.fromJsonLd(jsonLd);
	assertEquals(loaded2.quoteUrl, new URL("https://example.com/object2"));
	delete jsonLd._misskey_quote;
	const loaded3 = await Note.fromJsonLd(jsonLd);
	assertEquals(loaded3.quoteUrl, new URL("https://example.com/object3"));
});
test("Key.publicKey", async () => {
	const jwk = {
		kty: "RSA",
		alg: "RS256",
		n: "xsRuvCkgJtflBTl4OVsmnt_J1mQfZasfJtN33dcZ3d1lJroxmgmMu69zjGEAwkNbMQaWNLqC4eogkJaeJ4RR5MHYXkL9nNilVoTkjX5BVit3puzs7XJ7WQnKQgQMI-ezn24GHsZ_v1JIo77lerX5k4HNwTNVt-yaZVQWaOMR3-6FwziQR6kd0VuG9_a9dgAnz2cEoORRC1i4W7IZaB1sZnh1WbHbevlGd72HSXll5rocPIHn8gq6xpBgpHwRphlRsgn4KHaJ6brXDIJjrnQhIe_YUBOGj_ImSEXhRwlFerKsoAVnZ0Hwbfa46qk44TAt8CyoPMWmpK6pt0ng4pQ2uw",
		e: "AQAB",
		key_ops: ["verify"],
		ext: true
	};
	const key = new CryptographicKey({ publicKey: await crypto.subtle.importKey("jwk", jwk, {
		name: "RSASSA-PKCS1-v1_5",
		hash: "SHA-256"
	}, true, ["verify"]) });
	const jsonLd = await key.toJsonLd({ contextLoader: mockDocumentLoader });
	assertEquals(jsonLd, {
		"@context": "https://w3id.org/security/v1",
		publicKeyPem: "-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxsRuvCkgJtflBTl4OVsm\nnt/J1mQfZasfJtN33dcZ3d1lJroxmgmMu69zjGEAwkNbMQaWNLqC4eogkJaeJ4RR\n5MHYXkL9nNilVoTkjX5BVit3puzs7XJ7WQnKQgQMI+ezn24GHsZ/v1JIo77lerX5\nk4HNwTNVt+yaZVQWaOMR3+6FwziQR6kd0VuG9/a9dgAnz2cEoORRC1i4W7IZaB1s\nZnh1WbHbevlGd72HSXll5rocPIHn8gq6xpBgpHwRphlRsgn4KHaJ6brXDIJjrnQh\nIe/YUBOGj/ImSEXhRwlFerKsoAVnZ0Hwbfa46qk44TAt8CyoPMWmpK6pt0ng4pQ2\nuwIDAQAB\n-----END PUBLIC KEY-----\n",
		type: "CryptographicKey"
	});
	const loadedKey = await CryptographicKey.fromJsonLd(jsonLd, {
		documentLoader: mockDocumentLoader,
		contextLoader: mockDocumentLoader
	});
	assertNotEquals(loadedKey.publicKey, null);
	assertEquals(await crypto.subtle.exportKey("jwk", loadedKey.publicKey), jwk);
});
test("Place.fromJsonLd()", async () => {
	const place = await Place.fromJsonLd({
		"@context": "https://www.w3.org/ns/activitystreams",
		type: "Place",
		name: "Fresno Area",
		latitude: 36.75,
		longitude: 119.7667,
		radius: 15,
		units: "miles"
	}, {
		documentLoader: mockDocumentLoader,
		contextLoader: mockDocumentLoader
	});
	assertInstanceOf(place, Place);
	assertEquals(place.name, "Fresno Area");
	assertEquals(place.latitude, 36.75);
	assertEquals(place.longitude, 119.7667);
	assertEquals(place.radius, 15);
	assertEquals(place.units, "miles");
	let jsonLd = await place.toJsonLd({ contextLoader: mockDocumentLoader });
	assertEquals(jsonLd, {
		"@context": "https://www.w3.org/ns/activitystreams",
		type: "Place",
		name: "Fresno Area",
		latitude: 36.75,
		longitude: 119.7667,
		radius: 15,
		units: "miles"
	});
	jsonLd = await place.toJsonLd({
		format: "compact",
		contextLoader: mockDocumentLoader
	});
	assertEquals(jsonLd, {
		"@context": ["https://www.w3.org/ns/activitystreams", "https://w3id.org/security/data-integrity/v1"],
		type: "Place",
		name: "Fresno Area",
		latitude: 36.75,
		longitude: 119.7667,
		radius: 15,
		units: "miles"
	});
});
test("Actor.getOutbox()", async () => {
	const person = new Person({ outbox: new URL("https://example.com/orderedcollectionpage") });
	const outbox = await person.getOutbox({ documentLoader: mockDocumentLoader });
	assertInstanceOf(outbox, OrderedCollectionPage);
	assertEquals(outbox.totalItems, 1);
});
test("Link.fromJsonLd()", async () => {
	const link = await Link.fromJsonLd({
		"@context": "https://www.w3.org/ns/activitystreams",
		"type": "Link",
		"rel": "canonical",
		"href": "at://did:plc:ia76kvnndjutgedggx2ibrem/app.bsky.feed.post/3lyxjjs27jkqg"
	});
	assertEquals(link.rel, "canonical");
	assertEquals(link.href, new URL("at://did%3Aplc%3Aia76kvnndjutgedggx2ibrem/app.bsky.feed.post/3lyxjjs27jkqg"));
	const link2 = await Link.fromJsonLd({
		"@context": "https://www.w3.org/ns/activitystreams",
		"type": "Link",
		"href": "at://bnewbold.bsky.team/app.bsky.feed.post/3jwdwj2ctlk26"
	});
	assertEquals(link2.href, new URL("at://bnewbold.bsky.team/app.bsky.feed.post/3jwdwj2ctlk26"));
	const link3 = await Link.fromJsonLd({
		"@context": "https://www.w3.org/ns/activitystreams",
		"type": "Link",
		"href": "at://did:plc:ia76kvnndjutgedggx2ibrem"
	});
	assertEquals(link3.href, new URL("at://did%3Aplc%3Aia76kvnndjutgedggx2ibrem"));
});
test("Person.fromJsonLd() with relative URLs", async () => {
	const json = {
		"@context": ["https://www.w3.org/ns/activitystreams", "https://w3id.org/security/v1"],
		id: "https://example.com/ap/actors/019382d3-63d7-7cf7-86e8-91e2551c306c",
		type: "Person",
		name: "Test User",
		icon: {
			type: "Image",
			url: "/avatars/test-avatar.jpg"
		}
	};
	const person = await Person.fromJsonLd(json, {
		documentLoader: mockDocumentLoader,
		contextLoader: mockDocumentLoader
	});
	const icon = await person.getIcon();
	assertEquals(icon?.url, new URL("https://example.com/avatars/test-avatar.jpg"));
	const json2 = {
		"@context": ["https://www.w3.org/ns/activitystreams", "https://w3id.org/security/v1"],
		id: "https://example.com/ap/actors/019382d3-63d7-7cf7-86e8-91e2551c306c",
		type: "Person",
		name: "Test User",
		icon: {
			id: "https://media.example.com/avatars/test-avatar.jpg",
			type: "Image",
			url: "/avatars/test-avatar.jpg"
		}
	};
	const person2 = await Person.fromJsonLd(json2, {
		documentLoader: mockDocumentLoader,
		contextLoader: mockDocumentLoader
	});
	const icon2 = await person2.getIcon();
	assertEquals(icon2?.url, new URL("https://media.example.com/avatars/test-avatar.jpg"));
});
test("Person.fromJsonLd() with relative URLs and baseUrl", async () => {
	const json = {
		"@context": ["https://www.w3.org/ns/activitystreams", "https://w3id.org/security/v1"],
		"id": "https://example.com/ap/actors/019382d3-63d7-7cf7-86e8-91e2551c306c",
		"type": "Person",
		"name": "Test User",
		"icon": {
			"type": "Image",
			"url": "/avatars/test-avatar.jpg"
		}
	};
	const personWithBase = await Person.fromJsonLd(json, {
		documentLoader: mockDocumentLoader,
		contextLoader: mockDocumentLoader,
		baseUrl: new URL("https://example.com")
	});
	const icon = await personWithBase.getIcon();
	assertEquals(icon?.url, new URL("https://example.com/avatars/test-avatar.jpg"));
});
test("FEP-fe34: Trust tracking in object construction", async () => {
	const note = new Note({
		id: new URL("https://example.com/note"),
		content: "Hello World"
	});
	const create = new Create({
		id: new URL("https://example.com/create"),
		actor: new URL("https://example.com/actor"),
		object: note
	});
	assertEquals(create.objectId, new URL("https://example.com/note"));
	const result = await create.getObject();
	assertEquals(result, note);
	assertEquals(result?.content, "Hello World");
});
test("FEP-fe34: Trust tracking in object cloning", () => {
	const originalNote = new Note({
		id: new URL("https://example.com/note"),
		content: "Original content"
	});
	const create = new Create({
		id: new URL("https://example.com/create"),
		actor: new URL("https://example.com/actor"),
		object: originalNote
	});
	const newNote = new Note({
		id: new URL("https://example.com/new-note"),
		content: "New content"
	});
	const clonedCreate = create.clone({ object: newNote });
	assertEquals(clonedCreate.objectId, new URL("https://example.com/new-note"));
});
test("FEP-fe34: crossOrigin ignore behavior (default)", async () => {
	const crossOriginDocumentLoader = async (url) => {
		if (url === "https://different-origin.com/note") return {
			documentUrl: url,
			contextUrl: null,
			document: {
				"@context": "https://www.w3.org/ns/activitystreams",
				"@type": "Note",
				"@id": "https://malicious.com/fake-note",
				"content": "This is a spoofed note"
			}
		};
		throw new Error("Document not found");
	};
	const create = new Create({
		id: new URL("https://example.com/create"),
		actor: new URL("https://example.com/actor"),
		object: new URL("https://different-origin.com/note")
	});
	const result = await create.getObject({ documentLoader: crossOriginDocumentLoader });
	assertEquals(result, null);
});
test("FEP-fe34: crossOrigin throw behavior", async () => {
	const crossOriginDocumentLoader = async (url) => {
		if (url === "https://different-origin.com/note") return {
			documentUrl: url,
			contextUrl: null,
			document: {
				"@context": "https://www.w3.org/ns/activitystreams",
				"@type": "Note",
				"@id": "https://malicious.com/fake-note",
				"content": "This is a spoofed note"
			}
		};
		throw new Error("Document not found");
	};
	const create = new Create({
		id: new URL("https://example.com/create"),
		actor: new URL("https://example.com/actor"),
		object: new URL("https://different-origin.com/note")
	});
	await assertRejects(() => create.getObject({
		documentLoader: crossOriginDocumentLoader,
		crossOrigin: "throw"
	}), Error, "The object's @id (https://malicious.com/fake-note) has a different origin than the document URL (https://different-origin.com/note)");
});
test("FEP-fe34: crossOrigin trust behavior", async () => {
	const crossOriginDocumentLoader = async (url) => {
		if (url === "https://different-origin.com/note") return {
			documentUrl: url,
			contextUrl: null,
			document: {
				"@context": "https://www.w3.org/ns/activitystreams",
				"@type": "Note",
				"@id": "https://malicious.com/fake-note",
				"content": "This is a spoofed note"
			}
		};
		throw new Error("Document not found");
	};
	const create = new Create({
		id: new URL("https://example.com/create"),
		actor: new URL("https://example.com/actor"),
		object: new URL("https://different-origin.com/note")
	});
	const result = await create.getObject({
		documentLoader: crossOriginDocumentLoader,
		crossOrigin: "trust"
	});
	assertInstanceOf(result, Note);
	assertEquals(result?.id, new URL("https://malicious.com/fake-note"));
	assertEquals(result?.content, "This is a spoofed note");
});
test("FEP-fe34: Same origin objects are trusted", async () => {
	const sameOriginDocumentLoader = async (url) => {
		if (url === "https://example.com/note") return {
			documentUrl: url,
			contextUrl: null,
			document: {
				"@context": "https://www.w3.org/ns/activitystreams",
				"@type": "Note",
				"@id": "https://example.com/note",
				"content": "This is a legitimate note"
			}
		};
		throw new Error("Document not found");
	};
	const create = new Create({
		id: new URL("https://example.com/create"),
		actor: new URL("https://example.com/actor"),
		object: new URL("https://example.com/note")
	});
	const result = await create.getObject({ documentLoader: sameOriginDocumentLoader });
	assertInstanceOf(result, Note);
	assertEquals(result?.id, new URL("https://example.com/note"));
	assertEquals(result?.content, "This is a legitimate note");
});
test("FEP-fe34: Embedded cross-origin objects from JSON-LD are ignored by default", async () => {
	const createDocumentLoader = async (url) => {
		if (url === "https://example.com/create") return {
			documentUrl: url,
			contextUrl: null,
			document: {
				"@context": "https://www.w3.org/ns/activitystreams",
				"@type": "Create",
				"@id": "https://example.com/create",
				"actor": "https://example.com/actor",
				"object": {
					"@type": "Note",
					"@id": "https://different-origin.com/note",
					"content": "Embedded note from JSON-LD"
				}
			}
		};
		throw new Error("Document not found");
	};
	const create = await Create.fromJsonLd(await createDocumentLoader("https://example.com/create").then((r) => r.document), { documentLoader: createDocumentLoader });
	const objectDocumentLoader = async (url) => {
		if (url === "https://different-origin.com/note") return {
			documentUrl: url,
			contextUrl: null,
			document: {
				"@context": "https://www.w3.org/ns/activitystreams",
				"@type": "Note",
				"@id": "https://different-origin.com/note",
				"content": "Legitimate note from origin"
			}
		};
		throw new Error("Document not found");
	};
	const result = await create.getObject({ documentLoader: objectDocumentLoader });
	assertInstanceOf(result, Note);
	assertEquals(result?.content, "Legitimate note from origin");
});
test("FEP-fe34: Constructor vs JSON-LD parsing trust difference", async () => {
	const constructorCreate = new Create({
		id: new URL("https://example.com/create"),
		actor: new URL("https://example.com/actor"),
		object: new Note({
			id: new URL("https://different-origin.com/note"),
			content: "Constructor embedded note"
		})
	});
	const constructorResult = await constructorCreate.getObject();
	assertEquals(constructorResult?.content, "Constructor embedded note");
	const jsonLdCreate = await Create.fromJsonLd({
		"@context": "https://www.w3.org/ns/activitystreams",
		"@type": "Create",
		"@id": "https://example.com/create",
		"actor": "https://example.com/actor",
		"object": {
			"@type": "Note",
			"@id": "https://different-origin.com/note",
			"content": "JSON-LD embedded note"
		}
	});
	const documentLoader = async (url) => {
		if (url === "https://different-origin.com/note") return {
			documentUrl: url,
			contextUrl: null,
			document: {
				"@context": "https://www.w3.org/ns/activitystreams",
				"@type": "Note",
				"@id": "https://different-origin.com/note",
				"content": "Fetched from origin"
			}
		};
		throw new Error("Document not found");
	};
	const jsonLdResult = await jsonLdCreate.getObject({ documentLoader });
	assertEquals(jsonLdResult?.content, "Fetched from origin");
});
test("FEP-fe34: Array properties respect cross-origin policy", async () => {
	const crossOriginDocumentLoader = async (url) => {
		if (url === "https://different-origin.com/note1") return {
			documentUrl: url,
			contextUrl: null,
			document: {
				"@context": "https://www.w3.org/ns/activitystreams",
				"@type": "Note",
				"@id": "https://malicious.com/fake-note1",
				"content": "Fake note 1"
			}
		};
		else if (url === "https://example.com/note2") return {
			documentUrl: url,
			contextUrl: null,
			document: {
				"@context": "https://www.w3.org/ns/activitystreams",
				"@type": "Note",
				"@id": "https://example.com/note2",
				"content": "Legitimate note 2"
			}
		};
		throw new Error("Document not found");
	};
	const collection = new Collection({
		id: new URL("https://example.com/collection"),
		items: [new URL("https://different-origin.com/note1"), new URL("https://example.com/note2")]
	});
	const items = [];
	for await (const item of collection.getItems({ documentLoader: crossOriginDocumentLoader })) items.push(item);
	assertEquals(items.length, 1);
	assertInstanceOf(items[0], Note);
	assertEquals(items[0].content, "Legitimate note 2");
});
test("FEP-fe34: Array properties with crossOrigin trust option", async () => {
	const crossOriginDocumentLoader = async (url) => {
		if (url === "https://different-origin.com/note1") return {
			documentUrl: url,
			contextUrl: null,
			document: {
				"@context": "https://www.w3.org/ns/activitystreams",
				"@type": "Note",
				"@id": "https://malicious.com/fake-note1",
				"content": "Fake note 1"
			}
		};
		else if (url === "https://example.com/note2") return {
			documentUrl: url,
			contextUrl: null,
			document: {
				"@context": "https://www.w3.org/ns/activitystreams",
				"@type": "Note",
				"@id": "https://example.com/note2",
				"content": "Legitimate note 2"
			}
		};
		throw new Error("Document not found");
	};
	const collection = new Collection({
		id: new URL("https://example.com/collection"),
		items: [new URL("https://different-origin.com/note1"), new URL("https://example.com/note2")]
	});
	const items = [];
	for await (const item of collection.getItems({
		documentLoader: crossOriginDocumentLoader,
		crossOrigin: "trust"
	})) items.push(item);
	assertEquals(items.length, 2);
	assertInstanceOf(items[0], Note);
	assertInstanceOf(items[1], Note);
	assertEquals(items[0].content, "Fake note 1");
	assertEquals(items[1].content, "Legitimate note 2");
});
test("FEP-fe34: Embedded objects in arrays from JSON-LD respect cross-origin policy", async () => {
	const collectionDocumentLoader = async (url) => {
		if (url === "https://example.com/collection") return {
			documentUrl: url,
			contextUrl: null,
			document: {
				"@context": "https://www.w3.org/ns/activitystreams",
				"@type": "Collection",
				"@id": "https://example.com/collection",
				"items": [{
					"@type": "Note",
					"@id": "https://example.com/trusted-note",
					"content": "Trusted embedded note from JSON-LD"
				}, {
					"@type": "Note",
					"@id": "https://different-origin.com/untrusted-note",
					"content": "Untrusted embedded note from JSON-LD"
				}]
			}
		};
		throw new Error("Document not found");
	};
	const collection = await Collection.fromJsonLd(await collectionDocumentLoader("https://example.com/collection").then((r) => r.document), { documentLoader: collectionDocumentLoader });
	const itemDocumentLoader = async (url) => {
		if (url === "https://example.com/trusted-note") return {
			documentUrl: url,
			contextUrl: null,
			document: {
				"@context": "https://www.w3.org/ns/activitystreams",
				"@type": "Note",
				"@id": "https://example.com/trusted-note",
				"content": "Trusted note from origin"
			}
		};
		else if (url === "https://different-origin.com/untrusted-note") return {
			documentUrl: url,
			contextUrl: null,
			document: {
				"@context": "https://www.w3.org/ns/activitystreams",
				"@type": "Note",
				"@id": "https://different-origin.com/untrusted-note",
				"content": "Legitimate note from actual origin"
			}
		};
		throw new Error("Document not found");
	};
	const items = [];
	for await (const item of collection.getItems({ documentLoader: itemDocumentLoader })) items.push(item);
	assertEquals(items.length, 2);
	assertInstanceOf(items[0], Note);
	assertEquals(items[0].content, "Trusted embedded note from JSON-LD");
	assertInstanceOf(items[1], Note);
	assertEquals(items[1].content, "Legitimate note from actual origin");
});
function getAllProperties(type, types$1) {
	const props = type.properties;
	if (type.extends != null) props.push(...getAllProperties(types$1[type.extends], types$1));
	return props;
}
const sampleValues = {
	"http://www.w3.org/2001/XMLSchema#boolean": true,
	"http://www.w3.org/2001/XMLSchema#integer": -123,
	"http://www.w3.org/2001/XMLSchema#nonNegativeInteger": 123,
	"http://www.w3.org/2001/XMLSchema#float": 12.34,
	"http://www.w3.org/2001/XMLSchema#string": "hello",
	"http://www.w3.org/2001/XMLSchema#anyURI": new URL("https://example.com/"),
	"http://www.w3.org/1999/02/22-rdf-syntax-ns#langString": new LanguageString("hello", "en"),
	"http://www.w3.org/2001/XMLSchema#dateTime": Temporal.Instant.from("2024-03-03T08:30:06.796196096Z"),
	"http://www.w3.org/2001/XMLSchema#duration": Temporal.Duration.from({ hours: 1 }),
	"https://w3id.org/security#cryptosuiteString": "eddsa-jcs-2022",
	"https://w3id.org/security#multibase": new Uint8Array([
		143,
		155,
		90,
		201,
		20,
		23,
		208,
		209,
		136,
		190,
		250,
		133,
		143,
		116,
		68,
		152,
		29,
		200,
		121,
		218,
		186,
		80,
		152,
		60,
		67,
		235,
		207,
		114,
		95,
		56,
		88,
		17,
		159,
		35,
		197,
		191,
		132,
		35,
		118,
		162,
		29,
		83,
		192,
		190,
		26,
		170,
		150,
		110,
		48,
		101,
		89,
		118,
		240,
		176,
		219,
		120,
		13,
		245,
		193,
		173,
		63,
		189,
		243,
		7
	]),
	"fedify:langTag": parseLanguageTag("en"),
	"fedify:url": new URL("https://fedify.dev/"),
	"fedify:publicKey": rsaPublicKey1.publicKey,
	"fedify:multibaseKey": ed25519PublicKey.publicKey,
	"fedify:proofPurpose": "assertionMethod",
	"fedify:units": "m"
};
const types = navigator?.userAgent === "Cloudflare-Workers" ? {} : await loadSchemaFiles(import.meta.dirname);
for (const typeUri in types) {
	const type = types[typeUri];
	const cls = vocab_exports[type.name];
	sampleValues[typeUri] = new cls({
		"@id": "https://example.com/",
		"@type": typeUri
	});
}
for (const typeUri in types) {
	const type = types[typeUri];
	const cls = vocab_exports[type.name];
	const allProperties = getAllProperties(type, types);
	const initValues = globalThis.Object.fromEntries(allProperties.map((property) => !property.functional ? [property.pluralName, property.range.map((t) => sampleValues[t])] : [property.singularName, sampleValues[property.range[0]]]));
	test(`new ${type.name}() [auto]`, async () => {
		const instance = new cls(initValues);
		for (const property of allProperties) {
			if (areAllScalarTypes(property.range, types)) {
				if (property.functional || property.singularAccessor) assertEquals(instance[property.singularName], sampleValues[property.range[0]]);
				if (!property.functional) assertEquals(instance[property.pluralName], property.range.map((t) => sampleValues[t]));
			} else {
				if (property.functional || property.singularAccessor) {
					assertEquals(await instance[`get${pascalCase(property.singularName)}`].call(instance, { documentLoader: mockDocumentLoader }), sampleValues[property.range[0]]);
					assertEquals(instance[`${property.singularName}Id`], sampleValues[property.range[0]].id);
				}
				if (!property.functional) {
					assertEquals(await Array.fromAsync(instance[`get${pascalCase(property.pluralName)}`].call(instance, { documentLoader: mockDocumentLoader })), property.range.map((t) => sampleValues[t]));
					assertEquals(instance[`${property.singularName}Ids`], property.range.map((t) => sampleValues[t].id).filter((i) => i != null));
				}
			}
			const empty = new cls({});
			for (const property$1 of allProperties) if (areAllScalarTypes(property$1.range, types)) {
				if (property$1.functional || property$1.singularAccessor) assertEquals(empty[property$1.singularName], null);
				if (!property$1.functional) assertEquals(empty[property$1.pluralName], []);
			} else {
				if (property$1.functional || property$1.singularAccessor) {
					assertEquals(await empty[`get${pascalCase(property$1.singularName)}`].call(empty, { documentLoader: mockDocumentLoader }), null);
					assertEquals(empty[`${property$1.singularName}Id`], null);
				}
				if (!property$1.functional) {
					assertEquals(await Array.fromAsync(empty[`get${pascalCase(property$1.pluralName)}`].call(empty, { documentLoader: mockDocumentLoader })), []);
					assertEquals(empty[`${property$1.singularName}Ids`], []);
				}
			}
		}
		for (const property of allProperties) if (!property.functional && property.singularAccessor) assertThrows(() => new cls({
			[property.singularName]: sampleValues[property.range[0]],
			[property.pluralName]: property.range.map((t) => sampleValues[t])
		}), TypeError);
		const instance2 = new cls({
			id: new URL("https://example.com/"),
			...globalThis.Object.fromEntries(allProperties.filter((p) => !areAllScalarTypes(p.range, types)).map((p) => p.functional ? [p.singularName, new URL("https://example.com/test")] : [p.pluralName, [new URL("https://example.com/test")]]))
		});
		for (const property of allProperties) {
			if (areAllScalarTypes(property.range, types)) continue;
			if (property.functional || property.singularAccessor) assertEquals(instance2[`${property.singularName}Id`], new URL("https://example.com/test"));
			if (!property.functional) assertEquals(instance2[`${property.singularName}Ids`], [new URL("https://example.com/test")]);
		}
		assertThrows(() => new cls({ id: 123 }), TypeError, "The id must be a URL.");
		for (const property of allProperties) {
			const wrongValues = globalThis.Object.fromEntries(globalThis.Object.entries(initValues));
			if (property.functional) wrongValues[property.singularName] = {};
			else wrongValues[property.pluralName] = [{}];
			assertThrows(() => new cls(wrongValues), TypeError);
		}
	});
	test(`${type.name}.clone() [auto]`, () => {
		const instance = new cls({});
		for (const property of allProperties) if (!property.functional && property.singularAccessor) assertThrows(() => instance.clone({
			[property.singularName]: sampleValues[property.range[0]],
			[property.pluralName]: property.range.map((t) => sampleValues[t])
		}), TypeError);
		assertThrows(() => instance.clone({ id: 123 }), TypeError, "The id must be a URL.");
		for (const property of allProperties) {
			const wrongValues = globalThis.Object.fromEntries(globalThis.Object.entries(initValues));
			if (property.functional) wrongValues[property.singularName] = {};
			else wrongValues[property.pluralName] = [{}];
			assertThrows(() => instance.clone(wrongValues), TypeError);
		}
	});
	for (const property of allProperties) {
		if (areAllScalarTypes(property.range, types)) continue;
		const docLoader = async (url) => {
			if (url !== `https://example.com/test`) throw new Error("Not Found");
			return {
				documentUrl: url,
				contextUrl: null,
				document: await sampleValues[property.range[0]].toJsonLd({ contextLoader: mockDocumentLoader })
			};
		};
		if (property.functional || property.singularAccessor) test(`${type.name}.get${pascalCase(property.singularName)}() [auto]`, async () => {
			const instance = new cls({ [property.singularName]: new URL("https://example.com/test") });
			const value = await instance[`get${pascalCase(property.singularName)}`].call(instance, { documentLoader: docLoader });
			assertEquals(value, sampleValues[property.range[0]]);
			if (property.untyped) return;
			const wrongRef = new cls({ [property.singularName]: new URL("https://example.com/wrong-type") });
			await assertRejects(() => wrongRef[`get${pascalCase(property.singularName)}`].call(wrongRef, { documentLoader: mockDocumentLoader }), TypeError);
		});
		if (!property.functional) test(`${type.name}.get${pascalCase(property.pluralName)}() [auto]`, async () => {
			const instance = new cls({ [property.pluralName]: [new URL("https://example.com/test")] });
			const value = instance[`get${pascalCase(property.pluralName)}`].call(instance, { documentLoader: docLoader });
			assertEquals(await Array.fromAsync(value), [sampleValues[property.range[0]]]);
			if (property.untyped) return;
			const wrongRef = new cls({ [property.pluralName]: [new URL("https://example.com/wrong-type")] });
			await assertRejects(() => Array.fromAsync(wrongRef[`get${pascalCase(property.pluralName)}`].call(wrongRef, { documentLoader: mockDocumentLoader })), TypeError);
		});
	}
	test(`${type.name}.fromJsonLd() [auto]`, async () => {
		const instance = await cls.fromJsonLd({
			"@id": "https://example.com/",
			"@type": typeUri
		}, {
			documentLoader: mockDocumentLoader,
			contextLoader: mockDocumentLoader
		});
		assertInstanceOf(instance, cls);
		assertEquals(instance.id, new URL("https://example.com/"));
		assertEquals(await instance.toJsonLd(), {
			"@id": "https://example.com/",
			"@type": typeUri
		});
		assertEquals(await instance.toJsonLd({
			format: "compact",
			contextLoader: mockDocumentLoader
		}), {
			"@context": type.defaultContext,
			"id": "https://example.com/",
			"type": type.compactName ?? (type.name === "DataIntegrityProof" ? type.name : type.uri)
		});
		if (type.extends != null) await assertRejects(() => cls.fromJsonLd({
			"@id": "https://example.com/",
			"@type": "https://example.com/"
		}), TypeError);
		await assertRejects(() => cls.fromJsonLd(null), TypeError);
		await assertRejects(() => cls.fromJsonLd(void 0), TypeError);
	});
	test(`${type.name}.toJsonLd() [auto]`, async () => {
		const instance = new cls({
			id: new URL("https://example.com/"),
			...initValues
		});
		const jsonLd = await instance.toJsonLd({ contextLoader: mockDocumentLoader });
		assertEquals(jsonLd["@context"], type.defaultContext);
		assertEquals(jsonLd.id, "https://example.com/");
		const restored = await cls.fromJsonLd(jsonLd, {
			documentLoader: mockDocumentLoader,
			contextLoader: mockDocumentLoader
		});
		assertEquals(restored, instance);
		assertEquals(await restored.toJsonLd({ contextLoader: mockDocumentLoader }), jsonLd);
		const jsonLd2 = await instance.toJsonLd({
			contextLoader: mockDocumentLoader,
			format: "compact",
			context: "https://www.w3.org/ns/activitystreams"
		});
		assertEquals(jsonLd2["@context"], "https://www.w3.org/ns/activitystreams");
		assertEquals(jsonLd2.id, "https://example.com/");
		const restored2 = await cls.fromJsonLd(jsonLd2, {
			documentLoader: mockDocumentLoader,
			contextLoader: mockDocumentLoader
		});
		assertEquals(restored2, instance);
		const expanded = await instance.toJsonLd({
			contextLoader: mockDocumentLoader,
			format: "expand"
		});
		const restored3 = await cls.fromJsonLd(expanded, {
			documentLoader: mockDocumentLoader,
			contextLoader: mockDocumentLoader
		});
		assertEquals(restored3, instance);
		const instance2 = new cls({
			id: new URL("https://example.com/"),
			...initValues,
			...globalThis.Object.fromEntries(allProperties.filter((p) => !areAllScalarTypes(p.range, types)).map((p) => p.functional ? [p.singularName, new URL("https://example.com/test")] : [p.pluralName, [new URL("https://example.com/test")]]))
		});
		const jsonLd3 = await instance2.toJsonLd({ contextLoader: mockDocumentLoader });
		const restored4 = await cls.fromJsonLd(jsonLd3, {
			documentLoader: mockDocumentLoader,
			contextLoader: mockDocumentLoader
		});
		assertEquals(restored4, instance2);
		assertRejects(() => instance.toJsonLd({ context: "https://www.w3.org/ns/activitystreams" }), TypeError);
		assertRejects(() => instance.toJsonLd({
			format: "expand",
			context: "https://www.w3.org/ns/activitystreams"
		}), TypeError);
	});
	if ("Deno" in globalThis) {
		const { assertSnapshot } = await import("@std/testing/snapshot").catch(() => ({ assertSnapshot: () => Promise.resolve() }));
		test(`Deno.inspect(${type.name}) [auto]`, async (t) => {
			const empty = new cls({});
			assertEquals(Deno.inspect(empty), `${type.name} {}`);
			const instance = new cls({
				id: new URL("https://example.com/"),
				...initValues
			});
			await assertSnapshot(t, Deno.inspect(instance));
			const instance2 = instance.clone(globalThis.Object.fromEntries(type.properties.filter((p) => !areAllScalarTypes(p.range, types)).map((p) => p.functional ? [p.singularName, new URL("https://example.com/")] : [p.pluralName, [new URL("https://example.com/")]])));
			await assertSnapshot(t, Deno.inspect(instance2));
			const instance3 = instance.clone(globalThis.Object.fromEntries(type.properties.filter((p) => !p.functional).map((p) => {
				assertFalse(p.functional);
				return [p.pluralName, [sampleValues[p.range[0]], sampleValues[p.range[0]]]];
			})));
			await assertSnapshot(t, Deno.inspect(instance3));
		});
	}
	test(`${type.name}.typeId`, () => {
		assertEquals(cls.typeId, new URL(type.uri));
	});
}

//#endregion