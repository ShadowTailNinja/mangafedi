
      import { Temporal } from "@js-temporal/polyfill";
      import { URLPattern } from "urlpattern-polyfill";
      globalThis.addEventListener = () => {};
    
import { UrlError, createRequest, getRemoteDocument, logRequest, validatePublicUrl } from "./type-BVpqRkFR.js";
import { validateCryptoKey } from "./key-DrXt0cYP.js";
import { doubleKnock } from "./http-DplZ1SHu.js";
import { getLogger } from "@logtape/logtape";

//#region src/runtime/authdocloader.ts
const logger = getLogger([
	"fedify",
	"runtime",
	"docloader"
]);
/**
* Gets an authenticated {@link DocumentLoader} for the given identity.
* Note that an authenticated document loader intentionally does not cache
* the fetched documents.
* @param identity The identity to get the document loader for.
*                 The actor's key pair.
* @param options The options for the document loader.
* @returns The authenticated document loader.
* @throws {TypeError} If the key is invalid or unsupported.
* @since 0.4.0
*/
function getAuthenticatedDocumentLoader(identity, { allowPrivateAddress, userAgent, specDeterminer, tracerProvider } = {}) {
	validateCryptoKey(identity.privateKey);
	async function load(url, options) {
		if (!allowPrivateAddress) try {
			await validatePublicUrl(url);
		} catch (error) {
			if (error instanceof UrlError) logger.error("Disallowed private URL: {url}", {
				url,
				error
			});
			throw error;
		}
		const originalRequest = createRequest(url, { userAgent });
		const response = await doubleKnock(originalRequest, identity, {
			specDeterminer,
			log: logRequest,
			tracerProvider,
			signal: options?.signal
		});
		return getRemoteDocument(url, response, load);
	}
	return load;
}

//#endregion
export { getAuthenticatedDocumentLoader };