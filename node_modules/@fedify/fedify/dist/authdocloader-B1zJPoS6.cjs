
          const { Temporal } = require("@js-temporal/polyfill");
          const { URLPattern } = require("urlpattern-polyfill");
        
const require_chunk = require('./chunk-DqRYRqnO.cjs');
const require_docloader = require('./docloader-CNsCwkxG.cjs');
const require_key = require('./key-Cdysd1b9.cjs');
const require_http = require('./http-CcPpEG46.cjs');
const __logtape_logtape = require_chunk.__toESM(require("@logtape/logtape"));

//#region src/runtime/authdocloader.ts
const logger = (0, __logtape_logtape.getLogger)([
	"fedify",
	"runtime",
	"docloader"
]);
/**
* Gets an authenticated {@link DocumentLoader} for the given identity.
* Note that an authenticated document loader intentionally does not cache
* the fetched documents.
* @param identity The identity to get the document loader for.
*                 The actor's key pair.
* @param options The options for the document loader.
* @returns The authenticated document loader.
* @throws {TypeError} If the key is invalid or unsupported.
* @since 0.4.0
*/
function getAuthenticatedDocumentLoader(identity, { allowPrivateAddress, userAgent, specDeterminer, tracerProvider } = {}) {
	require_key.validateCryptoKey(identity.privateKey);
	async function load(url, options) {
		if (!allowPrivateAddress) try {
			await require_docloader.validatePublicUrl(url);
		} catch (error) {
			if (error instanceof require_docloader.UrlError) logger.error("Disallowed private URL: {url}", {
				url,
				error
			});
			throw error;
		}
		const originalRequest = require_docloader.createRequest(url, { userAgent });
		const response = await require_http.doubleKnock(originalRequest, identity, {
			specDeterminer,
			log: require_docloader.logRequest,
			tracerProvider,
			signal: options?.signal
		});
		return require_docloader.getRemoteDocument(url, response, load);
	}
	return load;
}

//#endregion
Object.defineProperty(exports, 'getAuthenticatedDocumentLoader', {
  enumerable: true,
  get: function () {
    return getAuthenticatedDocumentLoader;
  }
});