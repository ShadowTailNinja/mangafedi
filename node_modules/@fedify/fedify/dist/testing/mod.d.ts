import { Temporal } from "@js-temporal/polyfill";
import { URLPattern } from "urlpattern-polyfill";
globalThis.addEventListener = () => {};
import { Span, TracerProvider } from "@opentelemetry/api";
import { LanguageTag } from "@phensley/language-tag";

//#region src/runtime/docloader.d.ts
/**
 * A remote JSON-LD document and its context fetched by
 * a {@link DocumentLoader}.
 */
interface RemoteDocument {
  /**
   * The URL of the context document.
   */
  contextUrl: string | null;
  /**
   * The fetched JSON-LD document.
   */
  document: unknown;
  /**
   * The URL of the fetched document.
   */
  documentUrl: string;
}
/**
 * Options for {@link DocumentLoader}.
 * @since 1.8.0
 */
interface DocumentLoaderOptions {
  /**
   * An `AbortSignal` for cancellation.
   * @since 1.8.0
   */
  signal?: AbortSignal;
}
/**
 * A JSON-LD document loader that fetches documents from the Web.
 * @param url The URL of the document to load.
 * @param options The options for the document loader.
 * @returns The loaded remote document.
 */
type DocumentLoader = (url: string, options?: DocumentLoaderOptions) => Promise<RemoteDocument>;
/**
 * A factory function that creates a {@link DocumentLoader} with options.
 * @param options The options for the document loader.
 * @returns The document loader.
 * @since 1.4.0
 */

/**
 * Options for making `User-Agent` string.
 * @see {@link getUserAgent}
 * @since 1.3.0
 */
interface GetUserAgentOptions {
  /**
   * An optional software name and version, e.g., `"Hollo/1.0.0"`.
   */
  software?: string | null;
  /**
   * An optional URL to append to the user agent string.
   * Usually the URL of the ActivityPub instance.
   */
  url?: string | URL | null;
}
/**
 * Gets the user agent string for the given application and URL.
 * @param options The options for making the user agent string.
 * @returns The user agent string.
 * @since 1.3.0
 */
//#endregion
//#region src/nodeinfo/semver.d.ts
/**
 * A SemVer object parsed into its constituent parts.
 * @since 1.2.0
 */
interface SemVer {
  /** The major version */
  major: number;
  /** The minor version */
  minor: number;
  /** The patch version */
  patch: number;
  /**
   * The prerelease version
   *
   * @default {[]}
   */
  prerelease?: (string | number)[];
  /**
   * The build metadata
   *
   * @default {[]}
   */
  build?: string[];
}
//#endregion
//#region src/nodeinfo/types.d.ts
/**
 * The type of the result of parsing JSON.
 */
type JsonValue = {
  [key: string]: JsonValue | undefined;
} | JsonValue[] | string | number | boolean | null;
/**
 * A NodeInfo object as defined in the NodeInfo 2.1 schema.
 */
interface NodeInfo {
  /**
   * Metadata about server software in use.
   */
  software: Software;
  /**
   * The protocols supported on this server.  At least one protocol must be
   * supported.
   */
  protocols: Protocol[];
  /**
   * The third party sites this server can connect to via their application API.
   */
  services?: Services;
  /**
   * Whether this server allows open self-registration.  Defaults to `false`.
   */
  openRegistrations?: boolean;
  /**
   * Usage statistics for this server.
   */
  usage: Usage;
  /**
   * Free form key value pairs for software specific values.
   * Clients should not rely on any specific key present.
   */
  metadata?: Record<string, JsonValue>;
}
/**
 * Metadata about server software in use.
 */
interface Software {
  /**
   * The canonical name of this server software.  This must comply with
   * pattern `/^[a-z0-9-]+$/`.
   */
  name: string;
  /**
   * The version of this server software.
   * @see {@link parseSemVer}
   */
  version: SemVer;
  /**
   * The URL of the source code repository of this server software.
   */
  repository?: URL;
  /**
   * The URL of the homepage of this server software.
   */
  homepage?: URL;
}
/**
 * The protocols supported on this server.
 */
type Protocol = "activitypub" | "buddycloud" | "dfrn" | "diaspora" | "libertree" | "ostatus" | "pumpio" | "tent" | "xmpp" | "zot";
/**
 * The third party sites this server can connect to via their application API.
 */
interface Services {
  /**
   * The third party sites this server can retrieve messages from for combined
   * display with regular traffic.
   */
  inbound?: InboundService[];
  /**
   * The third party sites this server can publish messages to on the behalf
   * of a user.
   */
  outbound?: OutboundService[];
}
/**
 * The third party sites this server can retrieve messages from for combined
 * display with regular traffic.
 */
type InboundService = "atom1.0" | "gnusocial" | "imap" | "pnut" | "pop3" | "pumpio" | "rss2.0" | "twitter";
/**
 * The third party sites this server can publish messages to on the behalf
 * of a user.
 */
type OutboundService = "atom1.0" | "blogger" | "buddycloud" | "diaspora" | "dreamwidth" | "drupal" | "facebook" | "friendica" | "gnusocial" | "google" | "insanejournal" | "libertree" | "linkedin" | "livejournal" | "mediagoblin" | "myspace" | "pinterest" | "pnut" | "posterous" | "pumpio" | "redmatrix" | "rss2.0" | "smtp" | "tent" | "tumblr" | "twitter" | "wordpress" | "xmpp";
/**
 * Usage statistics for this server.
 */
interface Usage {
  /**
   * Statistics about the users of this server.
   */
  users: {
    /**
     * The total amount of on this server registered users.  This number
     * has to be an integer greater than or equal to zero.
     */
    total?: number;
    /**
     * The amount of users that signed in at least once in the last 180 days.
     * This number has to be an integer greater than or equal to zero.
     */
    activeHalfyear?: number;
    /**
     * The amount of users that signed in at least once in the last 30 days.
     * This number has to be an integer greater than or equal to zero.
     */
    activeMonth?: number;
  };
  /**
   * The amount of posts that were made by users that are registered on this
   * server.  This number has to be an integer greater than or equal to zero.
   */
  localPosts: number;
  /**
   * The amount of comments that were made by users that are registered on this
   * server.  This number has to be an integer greater than or equal to zero.
   */
  localComments: number;
}
/**
 * Converts a {@link NodeInfo} object to a JSON value.
 * @param nodeInfo The {@link NodeInfo} object to convert.
 * @returns The JSON value that complies with the NodeInfo schema.
 * @throws {TypeError} If the {@link NodeInfo} object is invalid.
 */
//#endregion
//#region src/nodeinfo/client.d.ts
/**
 * Options for {@link getNodeInfo} function.
 * @since 1.2.0
 */
interface GetNodeInfoOptions {
  /**
   * Whether to directly fetch the NodeInfo document from the given URL.
   * Otherwise, the NodeInfo document will be fetched from the `.well-known`
   * location of the given URL.
   *
   * Turned off by default.
   */
  direct?: boolean;
  /**
   * How strictly to parse the NodeInfo document.
   *
   *  -  `"strict"`: Parse the NodeInfo document strictly.  If the document is
   *     invalid, `undefined` is returned.  This is the default.
   *  -  `"best-effort"`: Try to parse the NodeInfo document even if it is
   *     invalid.
   *  -  `"none"`: Do not parse the NodeInfo document.  The function will return
   *     the raw JSON value.
   */
  parse?: "strict" | "best-effort" | "none";
  /**
   * The options for making `User-Agent` header.
   * If a string is given, it is used as the `User-Agent` header value.
   * If an object is given, it is passed to {@link getUserAgent} to generate
   * the `User-Agent` header value.
   * @since 1.3.0
   */
  userAgent?: GetUserAgentOptions | string;
}
/**
 * Fetches a NodeInfo document from the given URL.
 * @param url The base URL of the server.  If `options.direct` is turned off
 *            (default), the NodeInfo document will be fetched from
 *            the `.well-known` location of this URL (hence the only origin
 *            of the URL is used).  If `options.direct` is turned on,
 *            the NodeInfo document will be fetched from the given URL.
 * @param options Options for fetching the NodeInfo document.
 * @returns The NodeInfo document if it could be fetched successfully.
 *          Otherwise, `undefined` is returned.
 * @since 1.2.0
 */
//#endregion
//#region src/runtime/langstr.d.ts
/**
 * A language-tagged string which corresponds to the `rdf:langString` type.
 */
declare class LanguageString extends String {
  readonly language: LanguageTag;
  /**
   * Constructs a new `LanguageString`.
   * @param value A string value written in the given language.
   * @param language The language of the string.  If a string is given, it will
   *                 be parsed as a `LanguageTag`.
   */
  constructor(value: string, language: LanguageTag | string);
}
//#endregion
//#region src/vocab/vocab.d.ts
/** Describes an object of any kind. The Object type serves as the base type for
 * most of the other kinds of objects defined in the Activity Vocabulary,
 * including other Core types such as {@link Activity},
 * {@link IntransitiveActivity}, {@link Collection} and
 * {@link OrderedCollection}.
 */
declare class Object$1 {
  #private;
  readonly id: URL | null;
  protected get _documentLoader(): DocumentLoader | undefined;
  protected get _contextLoader(): DocumentLoader | undefined;
  protected get _tracerProvider(): TracerProvider | undefined;
  protected get _warning(): {
    category: string[];
    message: string;
    values?: Record<string, unknown>;
  } | undefined;
  protected get _cachedJsonLd(): unknown | undefined;
  protected set _cachedJsonLd(value: unknown | undefined);
  /**
   * The type URI of {@link Object}: `https://www.w3.org/ns/activitystreams#Object`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Object with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Object$1;
  /**
   * Similar to
   * {@link Object.getAttachments},
   * but returns their `@id`s instead of the objects themselves.
   */
  get attachmentIds(): URL[];
  /** Identifies a resource attached or related to an object that potentially
   * requires special handling.  The intent is to provide a model that is at
   * least semantically similar to attachments in email.
   */
  getAttachments(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Object$1 | Link | PropertyValue>;
  /**
   * Similar to
   * {@link Object.getAttribution},
   * but returns its `@id` URL instead of the object itself.
   */
  get attributionId(): URL | null;
  /** Identifies one or more entities to which this object is attributed.
   * The attributed entities might not be Actors.  For instance,
   * an object might be attributed to the completion of another activity.
   */
  getAttribution(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Application | Group | Organization | Person | Service | null>;
  /**
   * Similar to
   * {@link Object.getAttributions},
   * but returns their `@id`s instead of the objects themselves.
   */
  get attributionIds(): URL[];
  /** Identifies one or more entities to which this object is attributed.
   * The attributed entities might not be Actors.  For instance,
   * an object might be attributed to the completion of another activity.
   */
  getAttributions(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Application | Group | Organization | Person | Service>;
  /**
   * Similar to
   * {@link Object.getAudience},
   * but returns its `@id` URL instead of the object itself.
   */
  get audienceId(): URL | null;
  /** Identifies one or more entities that represent the total population of
   * entities for which the object can considered to be relevant.
   */
  getAudience(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Object$1 | null>;
  /**
   * Similar to
   * {@link Object.getAudiences},
   * but returns their `@id`s instead of the objects themselves.
   */
  get audienceIds(): URL[];
  /** Identifies one or more entities that represent the total population of
   * entities for which the object can considered to be relevant.
   */
  getAudiences(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Object$1>;
  /** The content or textual representation of the Object encoded as a JSON
   * string.  By default, the value of `content` is HTML.  The `mediaType`
   * property can be used in the object to indicate a different content type.
   *
   * The content MAY be expressed using multiple language-tagged values.
   */
  get content(): string | LanguageString | null;
  /** The content or textual representation of the Object encoded as a JSON
   * string.  By default, the value of `content` is HTML.  The `mediaType`
   * property can be used in the object to indicate a different content type.
   *
   * The content MAY be expressed using multiple language-tagged values.
   */
  get contents(): ((string | LanguageString))[];
  /**
   * Similar to
   * {@link Object.getContexts},
   * but returns their `@id`s instead of the objects themselves.
   */
  get contextIds(): URL[];
  /** Identifies the context within which the object exists or an activity was
   * performed.
   *
   * The notion of "context" used is intentionally vague.  The intended function
   * is to serve as a means of grouping objects and activities that share
   * a common originating context or purpose.  An example could be all activities
   * relating to a common project or event.
   */
  getContexts(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Object$1 | Link>;
  /** A simple, human-readable, plain-text name for the object. HTML markup MUST
   * NOT be included. The name MAY be expressed using multiple language-tagged
   * values.
   */
  get name(): string | LanguageString | null;
  /** A simple, human-readable, plain-text name for the object. HTML markup MUST
   * NOT be included. The name MAY be expressed using multiple language-tagged
   * values.
   */
  get names(): ((string | LanguageString))[];
  /** The date and time describing the actual or expected ending time of
   * the object.  When used with an {@link Activity} object, for instance,
   * the `endTime`` property specifies the moment the activity concluded
   * or is expected to conclude.
   */
  get endTime(): Temporal.Instant | null;
  /**
   * Similar to
   * {@link Object.getGenerators},
   * but returns their `@id`s instead of the objects themselves.
   */
  get generatorIds(): URL[];
  /** Identifies the entity (e.g. an application) that generated the object.
   */
  getGenerators(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Object$1 | Link>;
  /**
   * Similar to
   * {@link Object.getIcon},
   * but returns its `@id` URL instead of the object itself.
   */
  get iconId(): URL | null;
  /** Indicates an entity that describes an icon for this object.
   * The image should have an aspect ratio of one (horizontal) to one
   * (vertical) and should be suitable for presentation at a small size.
   */
  getIcon(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Image | null>;
  /**
   * Similar to
   * {@link Object.getIcons},
   * but returns their `@id`s instead of the objects themselves.
   */
  get iconIds(): URL[];
  /** Indicates an entity that describes an icon for this object.
   * The image should have an aspect ratio of one (horizontal) to one
   * (vertical) and should be suitable for presentation at a small size.
   */
  getIcons(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Image>;
  /**
   * Similar to
   * {@link Object.getImage},
   * but returns its `@id` URL instead of the object itself.
   */
  get imageId(): URL | null;
  /** Indicates an entity that describes an image for this object.
   * Unlike the icon property, there are no aspect ratio or display size
   * limitations assumed.
   */
  getImage(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Image | null>;
  /**
   * Similar to
   * {@link Object.getImages},
   * but returns their `@id`s instead of the objects themselves.
   */
  get imageIds(): URL[];
  /** Indicates an entity that describes an image for this object.
   * Unlike the icon property, there are no aspect ratio or display size
   * limitations assumed.
   */
  getImages(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Image>;
  /**
   * Similar to
   * {@link Object.getReplyTarget},
   * but returns its `@id` URL instead of the object itself.
   */
  get replyTargetId(): URL | null;
  /** Indicates one or more entities for which this object is considered
   * a response.
   */
  getReplyTarget(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Object$1 | Link | null>;
  /**
   * Similar to
   * {@link Object.getReplyTargets},
   * but returns their `@id`s instead of the objects themselves.
   */
  get replyTargetIds(): URL[];
  /** Indicates one or more entities for which this object is considered
   * a response.
   */
  getReplyTargets(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Object$1 | Link>;
  /**
   * Similar to
   * {@link Object.getLocation},
   * but returns its `@id` URL instead of the object itself.
   */
  get locationId(): URL | null;
  /** Indicates one or more physical or logical locations associated with
   * the object.
   */
  getLocation(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Object$1 | Link | null>;
  /**
   * Similar to
   * {@link Object.getLocations},
   * but returns their `@id`s instead of the objects themselves.
   */
  get locationIds(): URL[];
  /** Indicates one or more physical or logical locations associated with
   * the object.
   */
  getLocations(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Object$1 | Link>;
  /**
   * Similar to
   * {@link Object.getPreview},
   * but returns its `@id` URL instead of the object itself.
   */
  get previewId(): URL | null;
  /** Identifies an entity that provides a preview of this object.
   */
  getPreview(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Link | Object$1 | null>;
  /**
   * Similar to
   * {@link Object.getPreviews},
   * but returns their `@id`s instead of the objects themselves.
   */
  get previewIds(): URL[];
  /** Identifies an entity that provides a preview of this object.
   */
  getPreviews(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Link | Object$1>;
  /** The date and time at which the object was published.
   */
  get published(): Temporal.Instant | null;
  /**
   * Similar to
   * {@link Object.getReplies},
   * but returns its `@id` URL instead of the object itself.
   */
  get repliesId(): URL | null;
  /** Identifies a {@link Collection} containing objects considered to be
   * responses to this object.
   */
  getReplies(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Object.getShares},
   * but returns its `@id` URL instead of the object itself.
   */
  get sharesId(): URL | null;
  /** Every object *may* have a `shares` collection. This is a list of all
   * {@link Announce} activities with this object as the `object` property,
   * added as a [side effect]. The `shares` collection *must* be either
   * an {@link OrderedCollection} or a {@link Collection} and *may* be filtered
   * on privileges of an authenticated user or as appropriate
   * when no authentication is given.
   *
   * [side effect]: https://www.w3.org/TR/activitypub/#announce-activity-inbox
   */
  getShares(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Object.getLikes},
   * but returns its `@id` URL instead of the object itself.
   */
  get likesId(): URL | null;
  /** Every object *may* have a `likes` collection. This is a list of all
   * {@link Like} activities with this object as the `object` property,
   * added as a [side effect]. The `likes` collection *must* be either
   * an {@link OrderedCollection} or a {@link Collection} and *may* be filtered
   * on privileges of an authenticated user or as appropriate
   * when no authentication is given.
   *
   * [side effect]: https://www.w3.org/TR/activitypub/#announce-activity-inbox
   */
  getLikes(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Object.getEmojiReactions},
   * but returns its `@id` URL instead of the object itself.
   */
  get emojiReactionsId(): URL | null;
  /** Identifies a {@link Collection} containing objects considered to be
   * emoji reactions to this object.
   */
  getEmojiReactions(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /** The date and time describing the actual or expected starting time of
   * the object.  When used with an {@link Activity} object, for instance,
   * the `startTime` property specifies the moment the activity began or
   * is scheduled to begin.
   */
  get startTime(): Temporal.Instant | null;
  /** A natural language summarization of the object encoded as HTML.
   * Multiple language tagged summaries MAY be provided.
   */
  get summary(): string | LanguageString | null;
  /** A natural language summarization of the object encoded as HTML.
   * Multiple language tagged summaries MAY be provided.
   */
  get summaries(): ((string | LanguageString))[];
  /**
   * Similar to
   * {@link Object.getTags},
   * but returns their `@id`s instead of the objects themselves.
   */
  get tagIds(): URL[];
  /** One or more "tags" that have been associated with an objects.
   * A tag can be any kind of Object.  The key difference between `attachment`
   * and `tag` is that the former implies association by inclusion,
   * while the latter implies associated by reference.
   */
  getTags(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Object$1 | Link>;
  /** The date and time at which the object was updated.
   */
  get updated(): Temporal.Instant | null;
  /** Identifies one or more links to representations of the object.
   */
  get url(): URL | Link | null;
  /** Identifies one or more links to representations of the object.
   */
  get urls(): ((URL | Link))[];
  /**
   * Similar to
   * {@link Object.getTo},
   * but returns its `@id` URL instead of the object itself.
   */
  get toId(): URL | null;
  /** Identifies an entity considered to be part of the public primary audience
   * of an Object.
   */
  getTo(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Object$1 | null>;
  /**
   * Similar to
   * {@link Object.getTos},
   * but returns their `@id`s instead of the objects themselves.
   */
  get toIds(): URL[];
  /** Identifies an entity considered to be part of the public primary audience
   * of an Object.
   */
  getTos(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Object$1>;
  /**
   * Similar to
   * {@link Object.getBto},
   * but returns its `@id` URL instead of the object itself.
   */
  get btoId(): URL | null;
  /** Identifies an Object that is part of the private primary audience of
   * this Object.
   */
  getBto(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Object$1 | null>;
  /**
   * Similar to
   * {@link Object.getBtos},
   * but returns their `@id`s instead of the objects themselves.
   */
  get btoIds(): URL[];
  /** Identifies an Object that is part of the private primary audience of
   * this Object.
   */
  getBtos(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Object$1>;
  /**
   * Similar to
   * {@link Object.getCc},
   * but returns its `@id` URL instead of the object itself.
   */
  get ccId(): URL | null;
  /** Identifies an Object that is part of the public secondary audience of
   * this Object.
   */
  getCc(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Object$1 | null>;
  /**
   * Similar to
   * {@link Object.getCcs},
   * but returns their `@id`s instead of the objects themselves.
   */
  get ccIds(): URL[];
  /** Identifies an Object that is part of the public secondary audience of
   * this Object.
   */
  getCcs(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Object$1>;
  /**
   * Similar to
   * {@link Object.getBcc},
   * but returns its `@id` URL instead of the object itself.
   */
  get bccId(): URL | null;
  /** Identifies one or more Objects that are part of the private secondary
   * audience of this Object.
   */
  getBcc(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Object$1 | null>;
  /**
   * Similar to
   * {@link Object.getBccs},
   * but returns their `@id`s instead of the objects themselves.
   */
  get bccIds(): URL[];
  /** Identifies one or more Objects that are part of the private secondary
   * audience of this Object.
   */
  getBccs(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Object$1>;
  /** When used on an {@link Object}, identifies the MIME media type of the value
   * of the `content` property.  If not specified, the `content` property is
   * assumed to contain `text/html` content.
   */
  get mediaType(): string | null;
  /** When the object describes a time-bound resource, such as an audio or video,
   * a meeting, etc, the `duration` property indicates the object's approximate
   * duration.  The value MUST be expressed as an `xsd:duration` as defined by
   * W3C XML Schema Definition Language (XSD) 1.1 Part 2: DataTypes, section
   * 3.3.6 (e.g. a period of 5 seconds is represented as `PT5S`).
   */
  get duration(): Temporal.Duration | null;
  /** Whether it contains any sensitive contents.
   */
  get sensitive(): boolean | null;
  /** The `source` property is intended to convey some sort of source from which
   * the `content` markup was derived, as a form of provenance, or to support
   * future editing by clients.  In general, clients do the conversion from
   * `source` to `content`, not the other way around.
   */
  get source(): Source | null;
  /**
   * Similar to
   * {@link Object.getProof},
   * but returns its `@id` URL instead of the object itself.
   */
  get proofId(): URL | null;
  /** A cryptographic proof that can be used to verify the integrity of an object.
   */
  getProof(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<DataIntegrityProof | null>;
  /**
   * Similar to
   * {@link Object.getProofs},
   * but returns their `@id`s instead of the objects themselves.
   */
  get proofIds(): URL[];
  /** A cryptographic proof that can be used to verify the integrity of an object.
   */
  getProofs(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<DataIntegrityProof>;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Object$1>;
  protected static __fromJsonLd__Object__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Object$1>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Represents a custom emoji.
 */

/** An Activity is a subtype of {@link Object} that describes some form of action
 * that may happen, is currently happening, or has already happened.
 * The {@link Activity} type itself serves as an abstract base type for all types
 * of activities.  It is important to note that the {@link Activity} type itself
 * does not carry any specific semantics about the kind of action being taken.
 */
declare class Activity extends Object$1 {
  #private;
  /**
   * The type URI of {@link Activity}: `https://www.w3.org/ns/activitystreams#Activity`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Activity with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Activity;
  /**
   * Similar to
   * {@link Activity.getActor},
   * but returns its `@id` URL instead of the object itself.
   */
  get actorId(): URL | null;
  /** Describes one or more entities that either performed or are expected to
   * perform the activity.  Any single activity can have multiple actors.
   * The actor MAY be specified using an indirect {@link Link}.
   */
  getActor(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Application | Group | Organization | Person | Service | null>;
  /**
   * Similar to
   * {@link Activity.getActors},
   * but returns their `@id`s instead of the objects themselves.
   */
  get actorIds(): URL[];
  /** Describes one or more entities that either performed or are expected to
   * perform the activity.  Any single activity can have multiple actors.
   * The actor MAY be specified using an indirect {@link Link}.
   */
  getActors(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Application | Group | Organization | Person | Service>;
  /**
   * Similar to
   * {@link Activity.getObject},
   * but returns its `@id` URL instead of the object itself.
   */
  get objectId(): URL | null;
  /** When used within an {@link Activity}, describes the direct object of
   * the activity.  For instance, in the activity "John added a movie to his
   * wishlist", the object of the activity is the movie added.
   */
  getObject(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Object$1 | null>;
  /**
   * Similar to
   * {@link Activity.getObjects},
   * but returns their `@id`s instead of the objects themselves.
   */
  get objectIds(): URL[];
  /** When used within an {@link Activity}, describes the direct object of
   * the activity.  For instance, in the activity "John added a movie to his
   * wishlist", the object of the activity is the movie added.
   */
  getObjects(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Object$1>;
  /**
   * Similar to
   * {@link Activity.getTarget},
   * but returns its `@id` URL instead of the object itself.
   */
  get targetId(): URL | null;
  /** Describes the indirect object, or target, of the activity.  The precise
   * meaning of the target is largely dependent on the type of action being
   * described but will often be the object of the English preposition "to".
   * For instance, in the activity "John added a movie to his wishlist",
   * the target of the activity is John's wishlist.  An activity can have more
   * than one target.
   */
  getTarget(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Object$1 | null>;
  /**
   * Similar to
   * {@link Activity.getTargets},
   * but returns their `@id`s instead of the objects themselves.
   */
  get targetIds(): URL[];
  /** Describes the indirect object, or target, of the activity.  The precise
   * meaning of the target is largely dependent on the type of action being
   * described but will often be the object of the English preposition "to".
   * For instance, in the activity "John added a movie to his wishlist",
   * the target of the activity is John's wishlist.  An activity can have more
   * than one target.
   */
  getTargets(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Object$1>;
  /**
   * Similar to
   * {@link Activity.getResult},
   * but returns its `@id` URL instead of the object itself.
   */
  get resultId(): URL | null;
  /** Describes the result of the activity.  For instance, if a particular action
   * results in the creation of a new resource, the result property can be used
   * to describe that new resource.
   */
  getResult(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Object$1 | null>;
  /**
   * Similar to
   * {@link Activity.getResults},
   * but returns their `@id`s instead of the objects themselves.
   */
  get resultIds(): URL[];
  /** Describes the result of the activity.  For instance, if a particular action
   * results in the creation of a new resource, the result property can be used
   * to describe that new resource.
   */
  getResults(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Object$1>;
  /**
   * Similar to
   * {@link Activity.getOrigin},
   * but returns its `@id` URL instead of the object itself.
   */
  get originId(): URL | null;
  /** Describes an indirect object of the activity from which the activity is
   * directed.  The precise meaning of the origin is the object of the English
   * preposition "from". For instance, in the activity "John moved an item to
   * List B from List A", the origin of the activity is "List A".
   */
  getOrigin(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Object$1 | null>;
  /**
   * Similar to
   * {@link Activity.getOrigins},
   * but returns their `@id`s instead of the objects themselves.
   */
  get originIds(): URL[];
  /** Describes an indirect object of the activity from which the activity is
   * directed.  The precise meaning of the origin is the object of the English
   * preposition "from". For instance, in the activity "John moved an item to
   * List B from List A", the origin of the activity is "List A".
   */
  getOrigins(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Object$1>;
  /**
   * Similar to
   * {@link Activity.getInstrument},
   * but returns its `@id` URL instead of the object itself.
   */
  get instrumentId(): URL | null;
  /** Identifies one or more objects used (or to be used) in the completion of
   * an {@link Activity}.
   */
  getInstrument(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Object$1 | null>;
  /**
   * Similar to
   * {@link Activity.getInstruments},
   * but returns their `@id`s instead of the objects themselves.
   */
  get instrumentIds(): URL[];
  /** Identifies one or more objects used (or to be used) in the completion of
   * an {@link Activity}.
   */
  getInstruments(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Object$1>;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Activity>;
  protected static __fromJsonLd__Activity__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Activity>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Represents an emoji reaction.  See also [FEP-c0e0](https://w3id.org/fep/c0e0).
 */

/** A pair of property name and value.
 */
declare class PropertyValue {
  #private;
  readonly id: URL | null;
  protected get _documentLoader(): DocumentLoader | undefined;
  protected get _contextLoader(): DocumentLoader | undefined;
  protected get _tracerProvider(): TracerProvider | undefined;
  protected get _warning(): {
    category: string[];
    message: string;
    values?: Record<string, unknown>;
  } | undefined;
  protected get _cachedJsonLd(): unknown | undefined;
  protected set _cachedJsonLd(value: unknown | undefined);
  /**
   * The type URI of {@link PropertyValue}: `http://schema.org#PropertyValue`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of PropertyValue with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    name?: string | LanguageString | null;
    value?: string | LanguageString | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    name?: string | LanguageString | null;
    value?: string | LanguageString | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): PropertyValue;
  /** The name of a property.
   */
  get name(): string | LanguageString | null;
  /** The value of a property.
   */
  get value(): string | LanguageString | null;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<PropertyValue>;
  protected static __fromJsonLd__PropertyValue__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<PropertyValue>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Means of communicating or interacting with the DID subject or associated
 * entities via one or more service endpoints. Examples include discovery
 * services, agent services, social networking services, file storage services,
 * and verifiable credential repository services.
 */
declare class DidService {
  #private;
  readonly id: URL | null;
  protected get _documentLoader(): DocumentLoader | undefined;
  protected get _contextLoader(): DocumentLoader | undefined;
  protected get _tracerProvider(): TracerProvider | undefined;
  protected get _warning(): {
    category: string[];
    message: string;
    values?: Record<string, unknown>;
  } | undefined;
  protected get _cachedJsonLd(): unknown | undefined;
  protected set _cachedJsonLd(value: unknown | undefined);
  /**
   * The type URI of {@link DidService}: `https://www.w3.org/ns/did#Service`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of DidService with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    endpoint?: URL | null;
    endpoints?: (URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    endpoint?: URL | null;
    endpoints?: (URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): DidService;
  /** A network address, such as an HTTP URL, at which services operate on behalf
   * of a DID subject.
   */
  get endpoint(): URL | null;
  /** A network address, such as an HTTP URL, at which services operate on behalf
   * of a DID subject.
   */
  get endpoints(): (URL)[];
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<DidService>;
  protected static __fromJsonLd__DidService__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<DidService>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** "Export Actor" service.
 */

/** A proof that can be added to any activity or object, allowing recipients to
 * verify the identity of the actor and the integrity of the data.
 */
declare class DataIntegrityProof {
  #private;
  readonly id: URL | null;
  protected get _documentLoader(): DocumentLoader | undefined;
  protected get _contextLoader(): DocumentLoader | undefined;
  protected get _tracerProvider(): TracerProvider | undefined;
  protected get _warning(): {
    category: string[];
    message: string;
    values?: Record<string, unknown>;
  } | undefined;
  protected get _cachedJsonLd(): unknown | undefined;
  protected set _cachedJsonLd(value: unknown | undefined);
  /**
   * The type URI of {@link DataIntegrityProof}: `https://w3id.org/security#DataIntegrityProof`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of DataIntegrityProof with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    cryptosuite?: "eddsa-jcs-2022" | null;
    verificationMethod?: Multikey | URL | null;
    proofPurpose?: "assertionMethod" | "authentication" | "capabilityInvocation" | "capabilityDelegation" | "keyAgreement" | null;
    proofValue?: Uint8Array | null;
    created?: Temporal.Instant | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    cryptosuite?: "eddsa-jcs-2022" | null;
    verificationMethod?: Multikey | URL | null;
    proofPurpose?: "assertionMethod" | "authentication" | "capabilityInvocation" | "capabilityDelegation" | "keyAgreement" | null;
    proofValue?: Uint8Array | null;
    created?: Temporal.Instant | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): DataIntegrityProof;
  /** The cryptographic suite used to create the proof.
   */
  get cryptosuite(): "eddsa-jcs-2022" | null;
  /**
   * Similar to
   * {@link DataIntegrityProof.getVerificationMethod},
   * but returns its `@id` URL instead of the object itself.
   */
  get verificationMethodId(): URL | null;
  /** A key owned by an actor according to [FEP-521a: Representing actor's public
   * keys][1].
   *
   * [1]: https://w3id.org/fep/521a
   */
  getVerificationMethod(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Multikey | null>;
  /** The reason the proof was created.
   *
   * - `"assertionMethod"`
   * - `"authentication"`
   * - `"capabilityInvocation"`
   * - `"capabilityDelegation"`
   * - `"keyAgreement"`
   */
  get proofPurpose(): "assertionMethod" | "authentication" | "capabilityInvocation" | "capabilityDelegation" | "keyAgreement" | null;
  /** The proof value.
   */
  get proofValue(): Uint8Array | null;
  /** The date and time the proof was created.
   */
  get created(): Temporal.Instant | null;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<DataIntegrityProof>;
  protected static __fromJsonLd__DataIntegrityProof__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<DataIntegrityProof>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** A key owned by an actor.
 */
declare class CryptographicKey {
  #private;
  readonly id: URL | null;
  protected get _documentLoader(): DocumentLoader | undefined;
  protected get _contextLoader(): DocumentLoader | undefined;
  protected get _tracerProvider(): TracerProvider | undefined;
  protected get _warning(): {
    category: string[];
    message: string;
    values?: Record<string, unknown>;
  } | undefined;
  protected get _cachedJsonLd(): unknown | undefined;
  protected set _cachedJsonLd(value: unknown | undefined);
  /**
   * The type URI of {@link CryptographicKey}: `https://w3id.org/security#Key`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of CryptographicKey with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    owner?: Application | Group | Organization | Person | Service | URL | null;
    publicKey?: CryptoKey | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    owner?: Application | Group | Organization | Person | Service | URL | null;
    publicKey?: CryptoKey | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): CryptographicKey;
  /**
   * Similar to
   * {@link CryptographicKey.getOwner},
   * but returns its `@id` URL instead of the object itself.
   */
  get ownerId(): URL | null;
  /** An actor who owns this key.
   */
  getOwner(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Application | Group | Organization | Person | Service | null>;
  /** A PEM-encoded public key.
   */
  get publicKey(): CryptoKey | null;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<CryptographicKey>;
  protected static __fromJsonLd__CryptographicKey__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<CryptographicKey>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Represents a key owned by an actor according to [FEP-521a: Representing
 * actor's public keys.][1]
 *
 * [1]: https://w3id.org/fep/521a
 */
declare class Multikey {
  #private;
  readonly id: URL | null;
  protected get _documentLoader(): DocumentLoader | undefined;
  protected get _contextLoader(): DocumentLoader | undefined;
  protected get _tracerProvider(): TracerProvider | undefined;
  protected get _warning(): {
    category: string[];
    message: string;
    values?: Record<string, unknown>;
  } | undefined;
  protected get _cachedJsonLd(): unknown | undefined;
  protected set _cachedJsonLd(value: unknown | undefined);
  /**
   * The type URI of {@link Multikey}: `https://w3id.org/security#Multikey`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Multikey with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    controller?: Application | Group | Organization | Person | Service | URL | null;
    publicKey?: CryptoKey | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    controller?: Application | Group | Organization | Person | Service | URL | null;
    publicKey?: CryptoKey | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Multikey;
  /**
   * Similar to
   * {@link Multikey.getController},
   * but returns its `@id` URL instead of the object itself.
   */
  get controllerId(): URL | null;
  /** An actor who owns this key.
   */
  getController(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Application | Group | Organization | Person | Service | null>;
  /** A [Multibase]-encoded value of a [Multicodec] prefix and the key.
   *
   * [Multibase]: https://www.w3.org/TR/vc-data-integrity/#multibase-0
   * [Multicodec]: https://github.com/multiformats/multicodec/
   */
  get publicKey(): CryptoKey | null;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Multikey>;
  protected static __fromJsonLd__Multikey__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Multikey>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Indicates that the `actor` accepts the `object`.  The `target` property can be
 * used in certain circumstances to indicate the context into which the `object`
 * has been accepted.
 */

/** Describes a software application.
 */
declare class Application extends Object$1 {
  #private;
  /**
   * The type URI of {@link Application}: `https://www.w3.org/ns/activitystreams#Application`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Application with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    preferredUsername?: string | LanguageString | null;
    preferredUsernames?: ((string | LanguageString))[];
    publicKey?: CryptographicKey | URL | null;
    publicKeys?: (CryptographicKey | URL)[];
    assertionMethod?: Multikey | URL | null;
    assertionMethods?: (Multikey | URL)[];
    manuallyApprovesFollowers?: boolean | null;
    inbox?: OrderedCollection | OrderedCollectionPage | URL | null;
    outbox?: OrderedCollection | OrderedCollectionPage | URL | null;
    following?: Collection | URL | null;
    followers?: Collection | URL | null;
    liked?: Collection | URL | null;
    featured?: Collection | URL | null;
    featuredTags?: Collection | URL | null;
    streams?: (Collection | URL)[];
    endpoints?: Endpoints | null;
    discoverable?: boolean | null;
    suspended?: boolean | null;
    memorial?: boolean | null;
    indexable?: boolean | null;
    successor?: Application | Group | Organization | Person | Service | URL | null;
    alias?: Application | Group | Organization | Person | Service | URL | null;
    aliases?: (Application | Group | Organization | Person | Service | URL)[];
    service?: DidService | URL | null;
    services?: (DidService | URL)[];
    followedMessage?: string | null;
    cat?: boolean | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    preferredUsername?: string | LanguageString | null;
    preferredUsernames?: ((string | LanguageString))[];
    publicKey?: CryptographicKey | URL | null;
    publicKeys?: (CryptographicKey | URL)[];
    assertionMethod?: Multikey | URL | null;
    assertionMethods?: (Multikey | URL)[];
    manuallyApprovesFollowers?: boolean | null;
    inbox?: OrderedCollection | OrderedCollectionPage | URL | null;
    outbox?: OrderedCollection | OrderedCollectionPage | URL | null;
    following?: Collection | URL | null;
    followers?: Collection | URL | null;
    liked?: Collection | URL | null;
    featured?: Collection | URL | null;
    featuredTags?: Collection | URL | null;
    streams?: (Collection | URL)[];
    endpoints?: Endpoints | null;
    discoverable?: boolean | null;
    suspended?: boolean | null;
    memorial?: boolean | null;
    indexable?: boolean | null;
    successor?: Application | Group | Organization | Person | Service | URL | null;
    alias?: Application | Group | Organization | Person | Service | URL | null;
    aliases?: (Application | Group | Organization | Person | Service | URL)[];
    service?: DidService | URL | null;
    services?: (DidService | URL)[];
    followedMessage?: string | null;
    cat?: boolean | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Application;
  /** A short username which may be used to refer to the actor,
   * with no uniqueness guarantees.
   */
  get preferredUsername(): string | LanguageString | null;
  /** A short username which may be used to refer to the actor,
   * with no uniqueness guarantees.
   */
  get preferredUsernames(): ((string | LanguageString))[];
  /**
   * Similar to
   * {@link Application.getPublicKey},
   * but returns its `@id` URL instead of the object itself.
   */
  get publicKeyId(): URL | null;
  /** A public part of the key pair owned by this actor.
   */
  getPublicKey(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<CryptographicKey | null>;
  /**
   * Similar to
   * {@link Application.getPublicKeys},
   * but returns their `@id`s instead of the objects themselves.
   */
  get publicKeyIds(): URL[];
  /** A public part of the key pair owned by this actor.
   */
  getPublicKeys(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<CryptographicKey>;
  /**
   * Similar to
   * {@link Application.getAssertionMethod},
   * but returns its `@id` URL instead of the object itself.
   */
  get assertionMethodId(): URL | null;
  /** Represents this actor's public keys.  It serves as equivalent to
   * the `publicKeys` property, but is used for [FEP-521a] compliance.
   *
   * [FEP-521a]: https://w3id.org/fep/521a
   */
  getAssertionMethod(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Multikey | null>;
  /**
   * Similar to
   * {@link Application.getAssertionMethods},
   * but returns their `@id`s instead of the objects themselves.
   */
  get assertionMethodIds(): URL[];
  /** Represents this actor's public keys.  It serves as equivalent to
   * the `publicKeys` property, but is used for [FEP-521a] compliance.
   *
   * [FEP-521a]: https://w3id.org/fep/521a
   */
  getAssertionMethods(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Multikey>;
  /** When `true`, conveys that for this actor, follow requests are not usually
   * automatically approved, but instead are examined by a person who may accept
   * or reject the request, at some time in the future.  Setting of `false`
   * conveys no information and may be ignored.  This information is typically
   * used to affect display of accounts, such as showing an account as private or
   * locked.
   */
  get manuallyApprovesFollowers(): boolean | null;
  /**
   * Similar to
   * {@link Application.getInbox},
   * but returns its `@id` URL instead of the object itself.
   */
  get inboxId(): URL | null;
  /** The inbox stream contains all activities received by the actor.  The server
   * SHOULD filter content according to the requester's permission.  In general,
   * the owner of an inbox is likely to be able to access all of their inbox
   * contents.  Depending on access control, some other content may be public,
   * whereas other content may require authentication for non-owner users,
   * if they can access the inbox at all.
   *
   * The server MUST perform de-duplication of activities returned by the inbox.
   * Duplication can occur if an activity is addressed both to an actor's
   * followers, and a specific actor who also follows the recipient actor,
   * and the server has failed to de-duplicate the recipients list.
   * Such deduplication MUST be performed by comparing the `id` of the activities
   * and dropping any activities already seen.
   */
  getInbox(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<OrderedCollection | OrderedCollectionPage | null>;
  /**
   * Similar to
   * {@link Application.getOutbox},
   * but returns its `@id` URL instead of the object itself.
   */
  get outboxId(): URL | null;
  /** The outbox stream contains activities the user has published,
   * subject to the ability of the requestor to retrieve the activity
   * (that is, the contents of the outbox are filtered by the permissions of
   * the person reading it).  If a user submits a request without
   * [Authorization](https://www.w3.org/TR/activitypub/#authorization)
   * the server should respond with all of the
   * [Public](https://www.w3.org/TR/activitypub/#public-addressing) posts.
   * This could potentially be all relevant objects published by the user,
   * though the number of available items is left to the discretion of those
   * implementing and deploying the server.
   */
  getOutbox(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<OrderedCollection | OrderedCollectionPage | null>;
  /**
   * Similar to
   * {@link Application.getFollowing},
   * but returns its `@id` URL instead of the object itself.
   */
  get followingId(): URL | null;
  /** This is a list of everybody that the actor has followed, added as a
   * [side effect](https://www.w3.org/TR/activitypub/#follow-activity-outbox).
   * The `following` collection MUST be either an {@link OrderedCollection}
   * or a {@link Collection} and MAY be filtered on privileges of
   * an authenticated user or as appropriate when no authentication is given.
   */
  getFollowing(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Application.getFollowers},
   * but returns its `@id` URL instead of the object itself.
   */
  get followersId(): URL | null;
  /** This is a list of everyone who has sent a {@link Follow} activity
   * for the actor, added as a
   * [side effect](https://www.w3.org/TR/activitypub/#follow-activity-outbox).
   * This is where one would find a list of all the actors that are following
   * the actor.  The `followers` collection MUST be either
   * an {@link OrderedCollection} or a {@link Collection} and MAY be filtered on
   * privileges of an authenticated user or as appropriate when no authentication
   * is given.
   */
  getFollowers(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Application.getLiked},
   * but returns its `@id` URL instead of the object itself.
   */
  get likedId(): URL | null;
  /** This is a list of every object from all of the actor's {@link Like}
   * activities, added as a
   * [side effect](https://www.w3.org/TR/activitypub/#like-activity-outbox).
   * The `liked` collection MUST be either an {@link OrderedCollection} or
   * a {@link Collection} and MAY be filtered on privileges of an authenticated
   * user or as appropriate when no authentication is given.
   */
  getLiked(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Application.getFeatured},
   * but returns its `@id` URL instead of the object itself.
   */
  get featuredId(): URL | null;
  /** What is known in Mastodon as "pinned statuses", or statuses that are always
   * featured at the top of people's profiles, is implemented using an extra
   * property `featured` on the actor object that points to a {@link Collection}
   * of objects.
   */
  getFeatured(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Application.getFeaturedTags},
   * but returns its `@id` URL instead of the object itself.
   */
  get featuredTagsId(): URL | null;
  /** What is known in Mastodon as "featured hashtags", hashtags that are featured
   * at people's profiles, is implemented using an extra property `featuredTags`
   * on the actor object that points to a {@link Collection} of {@link Hashtag}
   * objects specifically.
   */
  getFeaturedTags(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Application.getStreams},
   * but returns their `@id`s instead of the objects themselves.
   */
  get streamIds(): URL[];
  /** A list of supplementary Collections which may be of interest.
   */
  getStreams(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Collection>;
  /** A JSON object which maps additional (typically server/domain-wide) endpoints
   * which may be useful either for this actor or someone referencing this actor.
   * This mapping may be nested inside the actor document as the value or may be
   * a link to a JSON-LD document with these properties.
   */
  get endpoints(): Endpoints | null;
  /** Allows users to opt-in or opt-out of discoverability features like
   * the profile directory.  This flag may also be used as an indicator of
   * the user's preferences toward being included in external discovery services,
   * such as search engines or other indexing tools.
   */
  get discoverable(): boolean | null;
  /** Reports whether a user was locally suspended, for better handling of
   * these accounts.
   */
  get suspended(): boolean | null;
  /** Whether the actor is in-memorial state.
   */
  get memorial(): boolean | null;
  /** Whether the actor allows to be indexed.
   */
  get indexable(): boolean | null;
  /**
   * Similar to
   * {@link Application.getSuccessor},
   * but returns its `@id` URL instead of the object itself.
   */
  get successorId(): URL | null;
  /** Signifies that an actor has been moved to a different ID. Used in Mastodon-style data portability with the {@link Move} activity; see [ActivityPub Data Portability/Move Action](https://swicg.github.io/activitypub-data-portability/#move-action) for more details.
   */
  getSuccessor(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Application | Group | Organization | Person | Service | null>;
  /**
   * Similar to
   * {@link Application.getAlias},
   * but returns its `@id` URL instead of the object itself.
   */
  get aliasId(): URL | null;
  /** The `aliases` (`alsoKnownAs`) property is used to specify alternative names
   * or aliases for an entity.  It can be used to provide additional identifiers
   * or labels for an entity, which can be useful in scenarios where an entity
   * may have multiple names or aliases.
   */
  getAlias(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Application | Group | Organization | Person | Service | null>;
  /**
   * Similar to
   * {@link Application.getAliases},
   * but returns their `@id`s instead of the objects themselves.
   */
  get aliasIds(): URL[];
  /** The `aliases` (`alsoKnownAs`) property is used to specify alternative names
   * or aliases for an entity.  It can be used to provide additional identifiers
   * or labels for an entity, which can be useful in scenarios where an entity
   * may have multiple names or aliases.
   */
  getAliases(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Application | Group | Organization | Person | Service>;
  /**
   * Similar to
   * {@link Application.getService},
   * but returns its `@id` URL instead of the object itself.
   */
  get serviceId(): URL | null;
  /** Means of communicating or interacting with the DID subject or associated
   * entities via one or more service endpoints. Examples include discovery
   * services, agent services, social networking services, file storage services,
   * and verifiable credential repository services.
   */
  getService(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<DidService | null>;
  /**
   * Similar to
   * {@link Application.getServices},
   * but returns their `@id`s instead of the objects themselves.
   */
  get serviceIds(): URL[];
  /** Means of communicating or interacting with the DID subject or associated
   * entities via one or more service endpoints. Examples include discovery
   * services, agent services, social networking services, file storage services,
   * and verifiable credential repository services.
   */
  getServices(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<DidService>;
  /** This value is used for `Actor` type objects to show message on followed.
   */
  get followedMessage(): string | null;
  /** Used on actors to indicate that they in some way identify as a cat,
   * expressed as a boolean value. If this property is set to `true`,
   * displaying the actor or their notes will have some special effects
   * attached in some clients.
   */
  get cat(): boolean | null;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Application>;
  protected static __fromJsonLd__Application__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Application>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Instances of `IntransitiveActivity` are a subtype of {@link Activity}
 * representing intransitive actions.  The `object` property is therefore
 * inappropriate for these activities.
 */

/** Represents a document of any kind.
 */
declare class Document extends Object$1 {
  #private;
  /**
   * The type URI of {@link Document}: `https://www.w3.org/ns/activitystreams#Document`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Document with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    width?: number | null;
    height?: number | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    width?: number | null;
    height?: number | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Document;
  /** Specifies a hint as to the rendering width in
   * device-independent pixels of the linked resource.
   */
  get width(): number | null;
  /** Specifies a hint as to the rendering height in
   * device-independent pixels of the linked resource.
   */
  get height(): number | null;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Document>;
  protected static __fromJsonLd__Document__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Document>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Represents an audio document of any kind.
 */

/** A `Collection` is a subtype of {@link Object} that represents ordered or
 * unordered sets of {@link Object} or {@link Link} instances.
 *
 * Refer to the Activity Streams 2.0 Core specification for a complete
 * description of the Collection type.
 */
declare class Collection extends Object$1 {
  #private;
  /**
   * The type URI of {@link Collection}: `https://www.w3.org/ns/activitystreams#Collection`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Collection with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    totalItems?: number | null;
    current?: CollectionPage | URL | null;
    first?: CollectionPage | URL | null;
    last?: CollectionPage | URL | null;
    items?: (Object$1 | Link | URL)[];
    likesOf?: Object$1 | URL | null;
    sharesOf?: Object$1 | URL | null;
    repliesOf?: Object$1 | URL | null;
    inboxOf?: Object$1 | URL | null;
    outboxOf?: Object$1 | URL | null;
    followersOf?: Object$1 | URL | null;
    followingOf?: Object$1 | URL | null;
    likedOf?: Object$1 | URL | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    totalItems?: number | null;
    current?: CollectionPage | URL | null;
    first?: CollectionPage | URL | null;
    last?: CollectionPage | URL | null;
    items?: (Object$1 | Link | URL)[];
    likesOf?: Object$1 | URL | null;
    sharesOf?: Object$1 | URL | null;
    repliesOf?: Object$1 | URL | null;
    inboxOf?: Object$1 | URL | null;
    outboxOf?: Object$1 | URL | null;
    followersOf?: Object$1 | URL | null;
    followingOf?: Object$1 | URL | null;
    likedOf?: Object$1 | URL | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Collection;
  /** A non-negative integer specifying the total number of objects contained by
   * the logical view of the collection. This number might not reflect the actual
   * number of items serialized within the {@link Collection} object instance.
   */
  get totalItems(): number | null;
  /**
   * Similar to
   * {@link Collection.getCurrent},
   * but returns its `@id` URL instead of the object itself.
   */
  get currentId(): URL | null;
  /** In a paged {@link Collection}, indicates the page that contains
   * the most recently updated member items.
   */
  getCurrent(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<CollectionPage | null>;
  /**
   * Similar to
   * {@link Collection.getFirst},
   * but returns its `@id` URL instead of the object itself.
   */
  get firstId(): URL | null;
  /** In a paged {@link Collection}, indicates the furthest preceding page of
   * items in the collection.
   */
  getFirst(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<CollectionPage | null>;
  /**
   * Similar to
   * {@link Collection.getLast},
   * but returns its `@id` URL instead of the object itself.
   */
  get lastId(): URL | null;
  /** In a paged {@link Collection}, indicates the furthest proceeding page of
   * the collection.
   */
  getLast(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<CollectionPage | null>;
  /**
   * Similar to
   * {@link Collection.getItems},
   * but returns their `@id`s instead of the objects themselves.
   */
  get itemIds(): URL[];
  /** Identifies the items contained in a collection.  The items might be ordered
   * or unordered.
   */
  getItems(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Object$1 | Link>;
  /**
   * Similar to
   * {@link Collection.getLikesOf},
   * but returns its `@id` URL instead of the object itself.
   */
  get likesOfId(): URL | null;
  /** Defines an object for which the collection is the value of the likes property.
   */
  getLikesOf(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Object$1 | null>;
  /**
   * Similar to
   * {@link Collection.getSharesOf},
   * but returns its `@id` URL instead of the object itself.
   */
  get sharesOfId(): URL | null;
  /** Defines an object for which the collection is the value of the shares property.
   */
  getSharesOf(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Object$1 | null>;
  /**
   * Similar to
   * {@link Collection.getRepliesOf},
   * but returns its `@id` URL instead of the object itself.
   */
  get repliesOfId(): URL | null;
  /** Defines an object for which the collection is the value of the replies property.
   */
  getRepliesOf(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Object$1 | null>;
  /**
   * Similar to
   * {@link Collection.getInboxOf},
   * but returns its `@id` URL instead of the object itself.
   */
  get inboxOfId(): URL | null;
  /** Defines an actor for which the collection is the value of the inbox property.
   */
  getInboxOf(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Object$1 | null>;
  /**
   * Similar to
   * {@link Collection.getOutboxOf},
   * but returns its `@id` URL instead of the object itself.
   */
  get outboxOfId(): URL | null;
  /** Defines an actor for which the collection is the value of the outbox property.
   */
  getOutboxOf(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Object$1 | null>;
  /**
   * Similar to
   * {@link Collection.getFollowersOf},
   * but returns its `@id` URL instead of the object itself.
   */
  get followersOfId(): URL | null;
  /** Defines an actor for which the collection is the value of the followers property.
   */
  getFollowersOf(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Object$1 | null>;
  /**
   * Similar to
   * {@link Collection.getFollowingOf},
   * but returns its `@id` URL instead of the object itself.
   */
  get followingOfId(): URL | null;
  /** Defines an actor for which the collection is the value of the following property.
   */
  getFollowingOf(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Object$1 | null>;
  /**
   * Similar to
   * {@link Collection.getLikedOf},
   * but returns its `@id` URL instead of the object itself.
   */
  get likedOfId(): URL | null;
  /** Defines an actor for which the collection is the value of the liked property.
   */
  getLikedOf(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Object$1 | null>;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Collection>;
  protected static __fromJsonLd__Collection__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Collection>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Used to represent distinct subsets of items from a `Collection`.
 * Refer to the Activity Streams 2.0 Core for a complete description of
 * the `CollectionPage` object.
 */
declare class CollectionPage extends Collection {
  #private;
  /**
   * The type URI of {@link CollectionPage}: `https://www.w3.org/ns/activitystreams#CollectionPage`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of CollectionPage with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    totalItems?: number | null;
    current?: CollectionPage | URL | null;
    first?: CollectionPage | URL | null;
    last?: CollectionPage | URL | null;
    items?: (Object$1 | Link | URL)[];
    likesOf?: Object$1 | URL | null;
    sharesOf?: Object$1 | URL | null;
    repliesOf?: Object$1 | URL | null;
    inboxOf?: Object$1 | URL | null;
    outboxOf?: Object$1 | URL | null;
    followersOf?: Object$1 | URL | null;
    followingOf?: Object$1 | URL | null;
    likedOf?: Object$1 | URL | null;
    partOf?: Collection | URL | null;
    next?: CollectionPage | URL | null;
    prev?: CollectionPage | URL | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    totalItems?: number | null;
    current?: CollectionPage | URL | null;
    first?: CollectionPage | URL | null;
    last?: CollectionPage | URL | null;
    items?: (Object$1 | Link | URL)[];
    likesOf?: Object$1 | URL | null;
    sharesOf?: Object$1 | URL | null;
    repliesOf?: Object$1 | URL | null;
    inboxOf?: Object$1 | URL | null;
    outboxOf?: Object$1 | URL | null;
    followersOf?: Object$1 | URL | null;
    followingOf?: Object$1 | URL | null;
    likedOf?: Object$1 | URL | null;
    partOf?: Collection | URL | null;
    next?: CollectionPage | URL | null;
    prev?: CollectionPage | URL | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): CollectionPage;
  /**
   * Similar to
   * {@link CollectionPage.getPartOf},
   * but returns its `@id` URL instead of the object itself.
   */
  get partOfId(): URL | null;
  /** Identifies the {@link Collection} to which a {@link CollectionPage} objects
   * items belong.
   */
  getPartOf(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link CollectionPage.getNext},
   * but returns its `@id` URL instead of the object itself.
   */
  get nextId(): URL | null;
  /** In a paged {@link Collection}, indicates the next page of items.
   */
  getNext(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<CollectionPage | null>;
  /**
   * Similar to
   * {@link CollectionPage.getPrev},
   * but returns its `@id` URL instead of the object itself.
   */
  get prevId(): URL | null;
  /** In a paged {@link Collection}, identifies the previous page of items.
   */
  getPrev(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<CollectionPage | null>;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<CollectionPage>;
  protected static __fromJsonLd__CollectionPage__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<CollectionPage>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Indicates that the `actor` has created the `object`.
 */

/** Contents of {@link Actor}'s `endpoints`.
 */
declare class Endpoints {
  #private;
  readonly id: URL | null;
  protected get _documentLoader(): DocumentLoader | undefined;
  protected get _contextLoader(): DocumentLoader | undefined;
  protected get _tracerProvider(): TracerProvider | undefined;
  protected get _warning(): {
    category: string[];
    message: string;
    values?: Record<string, unknown>;
  } | undefined;
  protected get _cachedJsonLd(): unknown | undefined;
  protected set _cachedJsonLd(value: unknown | undefined);
  /**
   * The type URI of {@link Endpoints}: `https://www.w3.org/ns/activitystreams#Endpoints`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Endpoints with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    proxyUrl?: URL | null;
    oauthAuthorizationEndpoint?: URL | null;
    oauthTokenEndpoint?: URL | null;
    provideClientKey?: URL | null;
    signClientKey?: URL | null;
    sharedInbox?: URL | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    proxyUrl?: URL | null;
    oauthAuthorizationEndpoint?: URL | null;
    oauthTokenEndpoint?: URL | null;
    provideClientKey?: URL | null;
    signClientKey?: URL | null;
    sharedInbox?: URL | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Endpoints;
  /** Endpoint URI so this actor's clients may access remote ActivityStreams
   * objects which require authentication to access.  To use this endpoint,
   * the client posts an `x-www-form-urlencoded` `id` parameter with the value
   * being the `id` of the requested ActivityStreams object.
   */
  get proxyUrl(): URL | null;
  /** If OAuth 2.0 bearer tokens [RFC 6749] [RFC 6750] are being used for
   * authenticating [client to server
   * interactions](https://www.w3.org/TR/activitypub/#client-to-server-interactions),
   * this endpoint specifies a URI at which a browser-authenticated user may
   * obtain a new authorization grant.
   */
  get oauthAuthorizationEndpoint(): URL | null;
  /** If OAuth 2.0 bearer tokens [RFC 6749] [RFC 6750] are being used for
   * authenticating [client to server
   * interactions](https://www.w3.org/TR/activitypub/#client-to-server-interactions),
   * this endpoint specifies a URI at which a client may acquire an access token.
   */
  get oauthTokenEndpoint(): URL | null;
  /** If Linked Data Signatures and HTTP Signatures are being used for
   * authentication and authorization, this endpoint specifies a URI at which
   * browser-authenticated users may authorize a client's public key for [client
   * to server interactions](https://www.w3.org/TR/activitypub/#client-to-server-interactions).
   */
  get provideClientKey(): URL | null;
  /** If Linked Data Signatures and HTTP Signatures are being used for
   * authentication and authorization, this endpoint specifies a URI at which
   * a client key may be signed by the actor's key for a time window to act on
   * behalf of the actor in interacting with foreign servers.
   */
  get signClientKey(): URL | null;
  /** An optional endpoint [used for wide delivery of publicly addressed
   * activities and activities sent to
   * followers](https://www.w3.org/TR/activitypub/#shared-inbox-delivery).
   * `sharedInbox` endpoints SHOULD also be publicly readable
   * {@link OrderedCollection} objects containing objects addressed to the
   * [Public](https://www.w3.org/TR/activitypub/#public-addressing) special
   * collection.  Reading from the `sharedInbox` endpoint MUST NOT present
   * objects which are not addressed to the `Public`` endpoint.
   */
  get sharedInbox(): URL | null;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Endpoints>;
  protected static __fromJsonLd__Endpoints__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Endpoints>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Represents any kind of event.
 */

/** Represents a formal or informal collective of Actors.
 */
declare class Group extends Object$1 {
  #private;
  /**
   * The type URI of {@link Group}: `https://www.w3.org/ns/activitystreams#Group`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Group with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    preferredUsername?: string | LanguageString | null;
    preferredUsernames?: ((string | LanguageString))[];
    publicKey?: CryptographicKey | URL | null;
    publicKeys?: (CryptographicKey | URL)[];
    assertionMethod?: Multikey | URL | null;
    assertionMethods?: (Multikey | URL)[];
    manuallyApprovesFollowers?: boolean | null;
    inbox?: OrderedCollection | OrderedCollectionPage | URL | null;
    outbox?: OrderedCollection | OrderedCollectionPage | URL | null;
    following?: Collection | URL | null;
    followers?: Collection | URL | null;
    liked?: Collection | URL | null;
    featured?: Collection | URL | null;
    featuredTags?: Collection | URL | null;
    streams?: (Collection | URL)[];
    endpoints?: Endpoints | null;
    discoverable?: boolean | null;
    suspended?: boolean | null;
    memorial?: boolean | null;
    indexable?: boolean | null;
    successor?: Application | Group | Organization | Person | Service | URL | null;
    alias?: Application | Group | Organization | Person | Service | URL | null;
    aliases?: (Application | Group | Organization | Person | Service | URL)[];
    service?: DidService | URL | null;
    services?: (DidService | URL)[];
    followedMessage?: string | null;
    cat?: boolean | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    preferredUsername?: string | LanguageString | null;
    preferredUsernames?: ((string | LanguageString))[];
    publicKey?: CryptographicKey | URL | null;
    publicKeys?: (CryptographicKey | URL)[];
    assertionMethod?: Multikey | URL | null;
    assertionMethods?: (Multikey | URL)[];
    manuallyApprovesFollowers?: boolean | null;
    inbox?: OrderedCollection | OrderedCollectionPage | URL | null;
    outbox?: OrderedCollection | OrderedCollectionPage | URL | null;
    following?: Collection | URL | null;
    followers?: Collection | URL | null;
    liked?: Collection | URL | null;
    featured?: Collection | URL | null;
    featuredTags?: Collection | URL | null;
    streams?: (Collection | URL)[];
    endpoints?: Endpoints | null;
    discoverable?: boolean | null;
    suspended?: boolean | null;
    memorial?: boolean | null;
    indexable?: boolean | null;
    successor?: Application | Group | Organization | Person | Service | URL | null;
    alias?: Application | Group | Organization | Person | Service | URL | null;
    aliases?: (Application | Group | Organization | Person | Service | URL)[];
    service?: DidService | URL | null;
    services?: (DidService | URL)[];
    followedMessage?: string | null;
    cat?: boolean | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Group;
  /** A short username which may be used to refer to the actor,
   * with no uniqueness guarantees.
   */
  get preferredUsername(): string | LanguageString | null;
  /** A short username which may be used to refer to the actor,
   * with no uniqueness guarantees.
   */
  get preferredUsernames(): ((string | LanguageString))[];
  /**
   * Similar to
   * {@link Group.getPublicKey},
   * but returns its `@id` URL instead of the object itself.
   */
  get publicKeyId(): URL | null;
  /** A public part of the key pair owned by this actor.
   */
  getPublicKey(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<CryptographicKey | null>;
  /**
   * Similar to
   * {@link Group.getPublicKeys},
   * but returns their `@id`s instead of the objects themselves.
   */
  get publicKeyIds(): URL[];
  /** A public part of the key pair owned by this actor.
   */
  getPublicKeys(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<CryptographicKey>;
  /**
   * Similar to
   * {@link Group.getAssertionMethod},
   * but returns its `@id` URL instead of the object itself.
   */
  get assertionMethodId(): URL | null;
  /** Represents this actor's public keys.  It serves as equivalent to
   * the `publicKeys` property, but is used for [FEP-521a] compliance.
   *
   * [FEP-521a]: https://w3id.org/fep/521a
   */
  getAssertionMethod(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Multikey | null>;
  /**
   * Similar to
   * {@link Group.getAssertionMethods},
   * but returns their `@id`s instead of the objects themselves.
   */
  get assertionMethodIds(): URL[];
  /** Represents this actor's public keys.  It serves as equivalent to
   * the `publicKeys` property, but is used for [FEP-521a] compliance.
   *
   * [FEP-521a]: https://w3id.org/fep/521a
   */
  getAssertionMethods(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Multikey>;
  /** When `true`, conveys that for this actor, follow requests are not usually
   * automatically approved, but instead are examined by a person who may accept
   * or reject the request, at some time in the future.  Setting of `false`
   * conveys no information and may be ignored.  This information is typically
   * used to affect display of accounts, such as showing an account as private or
   * locked.
   */
  get manuallyApprovesFollowers(): boolean | null;
  /**
   * Similar to
   * {@link Group.getInbox},
   * but returns its `@id` URL instead of the object itself.
   */
  get inboxId(): URL | null;
  /** The inbox stream contains all activities received by the actor.  The server
   * SHOULD filter content according to the requester's permission.  In general,
   * the owner of an inbox is likely to be able to access all of their inbox
   * contents.  Depending on access control, some other content may be public,
   * whereas other content may require authentication for non-owner users,
   * if they can access the inbox at all.
   *
   * The server MUST perform de-duplication of activities returned by the inbox.
   * Duplication can occur if an activity is addressed both to an actor's
   * followers, and a specific actor who also follows the recipient actor,
   * and the server has failed to de-duplicate the recipients list.
   * Such deduplication MUST be performed by comparing the `id` of the activities
   * and dropping any activities already seen.
   */
  getInbox(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<OrderedCollection | OrderedCollectionPage | null>;
  /**
   * Similar to
   * {@link Group.getOutbox},
   * but returns its `@id` URL instead of the object itself.
   */
  get outboxId(): URL | null;
  /** The outbox stream contains activities the user has published,
   * subject to the ability of the requestor to retrieve the activity
   * (that is, the contents of the outbox are filtered by the permissions of
   * the person reading it).  If a user submits a request without
   * [Authorization](https://www.w3.org/TR/activitypub/#authorization)
   * the server should respond with all of the
   * [Public](https://www.w3.org/TR/activitypub/#public-addressing) posts.
   * This could potentially be all relevant objects published by the user,
   * though the number of available items is left to the discretion of those
   * implementing and deploying the server.
   */
  getOutbox(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<OrderedCollection | OrderedCollectionPage | null>;
  /**
   * Similar to
   * {@link Group.getFollowing},
   * but returns its `@id` URL instead of the object itself.
   */
  get followingId(): URL | null;
  /** This is a list of everybody that the actor has followed, added as a
   * [side effect](https://www.w3.org/TR/activitypub/#follow-activity-outbox).
   * The `following` collection MUST be either an {@link OrderedCollection}
   * or a {@link Collection} and MAY be filtered on privileges of
   * an authenticated user or as appropriate when no authentication is given.
   */
  getFollowing(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Group.getFollowers},
   * but returns its `@id` URL instead of the object itself.
   */
  get followersId(): URL | null;
  /** This is a list of everyone who has sent a {@link Follow} activity
   * for the actor, added as a
   * [side effect](https://www.w3.org/TR/activitypub/#follow-activity-outbox).
   * This is where one would find a list of all the actors that are following
   * the actor.  The `followers` collection MUST be either
   * an {@link OrderedCollection} or a {@link Collection} and MAY be filtered on
   * privileges of an authenticated user or as appropriate when no authentication
   * is given.
   */
  getFollowers(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Group.getLiked},
   * but returns its `@id` URL instead of the object itself.
   */
  get likedId(): URL | null;
  /** This is a list of every object from all of the actor's {@link Like}
   * activities, added as a
   * [side effect](https://www.w3.org/TR/activitypub/#like-activity-outbox).
   * The `liked` collection MUST be either an {@link OrderedCollection} or
   * a {@link Collection} and MAY be filtered on privileges of an authenticated
   * user or as appropriate when no authentication is given.
   */
  getLiked(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Group.getFeatured},
   * but returns its `@id` URL instead of the object itself.
   */
  get featuredId(): URL | null;
  /** What is known in Mastodon as "pinned statuses", or statuses that are always
   * featured at the top of people's profiles, is implemented using an extra
   * property `featured` on the actor object that points to a {@link Collection}
   * of objects.
   */
  getFeatured(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Group.getFeaturedTags},
   * but returns its `@id` URL instead of the object itself.
   */
  get featuredTagsId(): URL | null;
  /** What is known in Mastodon as "featured hashtags", hashtags that are featured
   * at people's profiles, is implemented using an extra property `featuredTags`
   * on the actor object that points to a {@link Collection} of {@link Hashtag}
   * objects specifically.
   */
  getFeaturedTags(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Group.getStreams},
   * but returns their `@id`s instead of the objects themselves.
   */
  get streamIds(): URL[];
  /** A list of supplementary Collections which may be of interest.
   */
  getStreams(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Collection>;
  /** A JSON object which maps additional (typically server/domain-wide) endpoints
   * which may be useful either for this actor or someone referencing this actor.
   * This mapping may be nested inside the actor document as the value or may be
   * a link to a JSON-LD document with these properties.
   */
  get endpoints(): Endpoints | null;
  /** Allows users to opt-in or opt-out of discoverability features like
   * the profile directory.  This flag may also be used as an indicator of
   * the user's preferences toward being included in external discovery services,
   * such as search engines or other indexing tools.
   */
  get discoverable(): boolean | null;
  /** Reports whether a user was locally suspended, for better handling of
   * these accounts.
   */
  get suspended(): boolean | null;
  /** Whether the actor is in-memorial state.
   */
  get memorial(): boolean | null;
  /** Whether the actor allows to be indexed.
   */
  get indexable(): boolean | null;
  /**
   * Similar to
   * {@link Group.getSuccessor},
   * but returns its `@id` URL instead of the object itself.
   */
  get successorId(): URL | null;
  /** Signifies that an actor has been moved to a different ID. Used in Mastodon-style data portability with the {@link Move} activity; see [ActivityPub Data Portability/Move Action](https://swicg.github.io/activitypub-data-portability/#move-action) for more details.
   */
  getSuccessor(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Application | Group | Organization | Person | Service | null>;
  /**
   * Similar to
   * {@link Group.getAlias},
   * but returns its `@id` URL instead of the object itself.
   */
  get aliasId(): URL | null;
  /** The `aliases` (`alsoKnownAs`) property is used to specify alternative names
   * or aliases for an entity.  It can be used to provide additional identifiers
   * or labels for an entity, which can be useful in scenarios where an entity
   * may have multiple names or aliases.
   */
  getAlias(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Application | Group | Organization | Person | Service | null>;
  /**
   * Similar to
   * {@link Group.getAliases},
   * but returns their `@id`s instead of the objects themselves.
   */
  get aliasIds(): URL[];
  /** The `aliases` (`alsoKnownAs`) property is used to specify alternative names
   * or aliases for an entity.  It can be used to provide additional identifiers
   * or labels for an entity, which can be useful in scenarios where an entity
   * may have multiple names or aliases.
   */
  getAliases(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Application | Group | Organization | Person | Service>;
  /**
   * Similar to
   * {@link Group.getService},
   * but returns its `@id` URL instead of the object itself.
   */
  get serviceId(): URL | null;
  /** Means of communicating or interacting with the DID subject or associated
   * entities via one or more service endpoints. Examples include discovery
   * services, agent services, social networking services, file storage services,
   * and verifiable credential repository services.
   */
  getService(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<DidService | null>;
  /**
   * Similar to
   * {@link Group.getServices},
   * but returns their `@id`s instead of the objects themselves.
   */
  get serviceIds(): URL[];
  /** Means of communicating or interacting with the DID subject or associated
   * entities via one or more service endpoints. Examples include discovery
   * services, agent services, social networking services, file storage services,
   * and verifiable credential repository services.
   */
  getServices(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<DidService>;
  /** This value is used for `Actor` type objects to show message on followed.
   */
  get followedMessage(): string | null;
  /** Used on actors to indicate that they in some way identify as a cat,
   * expressed as a boolean value. If this property is set to `true`,
   * displaying the actor or their notes will have some special effects
   * attached in some clients.
   */
  get cat(): boolean | null;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Group>;
  protected static __fromJsonLd__Group__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Group>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** A Link is an indirect, qualified reference to a resource identified by a URL.
 * The fundamental model for links is established by RFC 5988. Many of the
 * properties defined by the Activity Vocabulary allow values that are either
 * instances of {@link Object} or {@link Link}. When a {@link Link} is used,
 * it establishes a qualified relation connecting the subject (the containing
 * object) to the resource identified by the `href`. Properties of
 * the {@link Link} are properties of the reference as opposed to properties of
 * the resource.
 */
declare class Link {
  #private;
  readonly id: URL | null;
  protected get _documentLoader(): DocumentLoader | undefined;
  protected get _contextLoader(): DocumentLoader | undefined;
  protected get _tracerProvider(): TracerProvider | undefined;
  protected get _warning(): {
    category: string[];
    message: string;
    values?: Record<string, unknown>;
  } | undefined;
  protected get _cachedJsonLd(): unknown | undefined;
  protected set _cachedJsonLd(value: unknown | undefined);
  /**
   * The type URI of {@link Link}: `https://www.w3.org/ns/activitystreams#Link`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Link with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    href?: URL | null;
    rel?: string | null;
    rels?: (string)[];
    mediaType?: string | null;
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    language?: LanguageTag | null;
    height?: number | null;
    width?: number | null;
    previews?: (Link | Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    href?: URL | null;
    rel?: string | null;
    rels?: (string)[];
    mediaType?: string | null;
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    language?: LanguageTag | null;
    height?: number | null;
    width?: number | null;
    previews?: (Link | Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Link;
  /** The target resource pointed to by a {@link Link}.
   */
  get href(): URL | null;
  /** A link relation associated with a {@link Link}. The value MUST conform to
   * both the HTML5 and RFC 5988 "link relation" definitions.
   *
   * In the HTML5, any string not containing the space (U+0020), tab (U+0009),
   * LF (U+000A), FF (U+000C), CR (U+000D) or comma (U+002C) characters can
   * be used as a valid link relation.
   */
  get rel(): string | null;
  /** A link relation associated with a {@link Link}. The value MUST conform to
   * both the HTML5 and RFC 5988 "link relation" definitions.
   *
   * In the HTML5, any string not containing the space (U+0020), tab (U+0009),
   * LF (U+000A), FF (U+000C), CR (U+000D) or comma (U+002C) characters can
   * be used as a valid link relation.
   */
  get rels(): (string)[];
  /** When used on a {@link Link}, identifies the MIME media type of the
   * referenced resource.
   */
  get mediaType(): string | null;
  /** A simple, human-readable, plain-text name for the object. HTML markup MUST
   * NOT be included. The name MAY be expressed using multiple language-tagged
   * values.
   */
  get name(): string | LanguageString | null;
  /** A simple, human-readable, plain-text name for the object. HTML markup MUST
   * NOT be included. The name MAY be expressed using multiple language-tagged
   * values.
   */
  get names(): ((string | LanguageString))[];
  /** Hints as to the language used by the target resource.
   * Value MUST be a BCP 47 Language-Tag.
   */
  get language(): LanguageTag | null;
  /** On a {@link Link}, specifies a hint as to the rendering height in
   * device-independent pixels of the linked resource.
   */
  get height(): number | null;
  /** On a {@link Link}, specifies a hint as to the rendering width in
   * device-independent pixels of the linked resource.
   */
  get width(): number | null;
  /**
   * Similar to
   * {@link Link.getPreviews},
   * but returns their `@id`s instead of the objects themselves.
   */
  get previewIds(): URL[];
  /** Identifies an entity that provides a preview of this object.
   */
  getPreviews(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Link | Object$1>;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Link>;
  protected static __fromJsonLd__Link__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Link>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** A specialized {@link Link} that represents an #hashtag.
 *
 * See also <https://swicg.github.io/miscellany/#Hashtag>.
 */
declare class Hashtag extends Link {
  /**
   * The type URI of {@link Hashtag}: `https://www.w3.org/ns/activitystreams#Hashtag`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Hashtag with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    href?: URL | null;
    rel?: string | null;
    rels?: (string)[];
    mediaType?: string | null;
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    language?: LanguageTag | null;
    height?: number | null;
    width?: number | null;
    previews?: (Link | Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    href?: URL | null;
    rel?: string | null;
    rels?: (string)[];
    mediaType?: string | null;
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    language?: LanguageTag | null;
    height?: number | null;
    width?: number | null;
    previews?: (Link | Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Hashtag;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Hashtag>;
  protected static __fromJsonLd__Hashtag__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Hashtag>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** An image document of any kind.
 */
declare class Image extends Document {
  /**
   * The type URI of {@link Image}: `https://www.w3.org/ns/activitystreams#Image`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Image with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    width?: number | null;
    height?: number | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    width?: number | null;
    height?: number | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Image;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Image>;
  protected static __fromJsonLd__Image__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Image>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Indicates that the actor is offering the object.
 * If specified, the target indicates the entity to which
 * the object is being offered.
 */

/** A subtype of {@link Collection} in which members of the logical collection
 * are assumed to always be strictly ordered.
 */
declare class OrderedCollection extends Collection {
  #private;
  /**
   * The type URI of {@link OrderedCollection}: `https://www.w3.org/ns/activitystreams#OrderedCollection`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of OrderedCollection with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    totalItems?: number | null;
    current?: CollectionPage | URL | null;
    first?: CollectionPage | URL | null;
    last?: CollectionPage | URL | null;
    likesOf?: Object$1 | URL | null;
    sharesOf?: Object$1 | URL | null;
    repliesOf?: Object$1 | URL | null;
    inboxOf?: Object$1 | URL | null;
    outboxOf?: Object$1 | URL | null;
    followersOf?: Object$1 | URL | null;
    followingOf?: Object$1 | URL | null;
    likedOf?: Object$1 | URL | null;
    items?: (Object$1 | Link | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    totalItems?: number | null;
    current?: CollectionPage | URL | null;
    first?: CollectionPage | URL | null;
    last?: CollectionPage | URL | null;
    likesOf?: Object$1 | URL | null;
    sharesOf?: Object$1 | URL | null;
    repliesOf?: Object$1 | URL | null;
    inboxOf?: Object$1 | URL | null;
    outboxOf?: Object$1 | URL | null;
    followersOf?: Object$1 | URL | null;
    followingOf?: Object$1 | URL | null;
    likedOf?: Object$1 | URL | null;
    items?: (Object$1 | Link | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): OrderedCollection;
  /**
   * Similar to
   * {@link OrderedCollection.getItems},
   * but returns their `@id`s instead of the objects themselves.
   */
  get itemIds(): URL[];
  /** Identifies the items contained in a collection.  The items might be ordered
   * or unordered.
   */
  getItems(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Object$1 | Link>;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<OrderedCollection>;
  protected static __fromJsonLd__OrderedCollection__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<OrderedCollection>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Used to represent ordered subsets of items from an `OrderedCollection`.
 * Refer to the Activity Streams 2.0 Core for a complete description of
 * the `OrderedCollectionPage` object.
 */
declare class OrderedCollectionPage extends CollectionPage {
  #private;
  /**
   * The type URI of {@link OrderedCollectionPage}: `https://www.w3.org/ns/activitystreams#OrderedCollectionPage`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of OrderedCollectionPage with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    totalItems?: number | null;
    current?: CollectionPage | URL | null;
    first?: CollectionPage | URL | null;
    last?: CollectionPage | URL | null;
    likesOf?: Object$1 | URL | null;
    sharesOf?: Object$1 | URL | null;
    repliesOf?: Object$1 | URL | null;
    inboxOf?: Object$1 | URL | null;
    outboxOf?: Object$1 | URL | null;
    followersOf?: Object$1 | URL | null;
    followingOf?: Object$1 | URL | null;
    likedOf?: Object$1 | URL | null;
    partOf?: Collection | URL | null;
    next?: CollectionPage | URL | null;
    prev?: CollectionPage | URL | null;
    items?: (Object$1 | Link | URL)[];
    startIndex?: number | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    totalItems?: number | null;
    current?: CollectionPage | URL | null;
    first?: CollectionPage | URL | null;
    last?: CollectionPage | URL | null;
    likesOf?: Object$1 | URL | null;
    sharesOf?: Object$1 | URL | null;
    repliesOf?: Object$1 | URL | null;
    inboxOf?: Object$1 | URL | null;
    outboxOf?: Object$1 | URL | null;
    followersOf?: Object$1 | URL | null;
    followingOf?: Object$1 | URL | null;
    likedOf?: Object$1 | URL | null;
    partOf?: Collection | URL | null;
    next?: CollectionPage | URL | null;
    prev?: CollectionPage | URL | null;
    items?: (Object$1 | Link | URL)[];
    startIndex?: number | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): OrderedCollectionPage;
  /**
   * Similar to
   * {@link OrderedCollectionPage.getItems},
   * but returns their `@id`s instead of the objects themselves.
   */
  get itemIds(): URL[];
  /** Identifies the items contained in a collection.  The items might be ordered
   * or unordered.
   */
  getItems(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Object$1 | Link>;
  /** A non-negative integer value identifying the relative position within
   * the logical view of a strictly ordered collection.
   */
  get startIndex(): number | null;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<OrderedCollectionPage>;
  protected static __fromJsonLd__OrderedCollectionPage__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<OrderedCollectionPage>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Represents an organization.
 */
declare class Organization extends Object$1 {
  #private;
  /**
   * The type URI of {@link Organization}: `https://www.w3.org/ns/activitystreams#Organization`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Organization with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    preferredUsername?: string | LanguageString | null;
    preferredUsernames?: ((string | LanguageString))[];
    publicKey?: CryptographicKey | URL | null;
    publicKeys?: (CryptographicKey | URL)[];
    assertionMethod?: Multikey | URL | null;
    assertionMethods?: (Multikey | URL)[];
    manuallyApprovesFollowers?: boolean | null;
    inbox?: OrderedCollection | OrderedCollectionPage | URL | null;
    outbox?: OrderedCollection | OrderedCollectionPage | URL | null;
    following?: Collection | URL | null;
    followers?: Collection | URL | null;
    liked?: Collection | URL | null;
    featured?: Collection | URL | null;
    featuredTags?: Collection | URL | null;
    streams?: (Collection | URL)[];
    endpoints?: Endpoints | null;
    discoverable?: boolean | null;
    suspended?: boolean | null;
    memorial?: boolean | null;
    indexable?: boolean | null;
    successor?: Application | Group | Organization | Person | Service | URL | null;
    alias?: Application | Group | Organization | Person | Service | URL | null;
    aliases?: (Application | Group | Organization | Person | Service | URL)[];
    service?: DidService | URL | null;
    services?: (DidService | URL)[];
    followedMessage?: string | null;
    cat?: boolean | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    preferredUsername?: string | LanguageString | null;
    preferredUsernames?: ((string | LanguageString))[];
    publicKey?: CryptographicKey | URL | null;
    publicKeys?: (CryptographicKey | URL)[];
    assertionMethod?: Multikey | URL | null;
    assertionMethods?: (Multikey | URL)[];
    manuallyApprovesFollowers?: boolean | null;
    inbox?: OrderedCollection | OrderedCollectionPage | URL | null;
    outbox?: OrderedCollection | OrderedCollectionPage | URL | null;
    following?: Collection | URL | null;
    followers?: Collection | URL | null;
    liked?: Collection | URL | null;
    featured?: Collection | URL | null;
    featuredTags?: Collection | URL | null;
    streams?: (Collection | URL)[];
    endpoints?: Endpoints | null;
    discoverable?: boolean | null;
    suspended?: boolean | null;
    memorial?: boolean | null;
    indexable?: boolean | null;
    successor?: Application | Group | Organization | Person | Service | URL | null;
    alias?: Application | Group | Organization | Person | Service | URL | null;
    aliases?: (Application | Group | Organization | Person | Service | URL)[];
    service?: DidService | URL | null;
    services?: (DidService | URL)[];
    followedMessage?: string | null;
    cat?: boolean | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Organization;
  /** A short username which may be used to refer to the actor,
   * with no uniqueness guarantees.
   */
  get preferredUsername(): string | LanguageString | null;
  /** A short username which may be used to refer to the actor,
   * with no uniqueness guarantees.
   */
  get preferredUsernames(): ((string | LanguageString))[];
  /**
   * Similar to
   * {@link Organization.getPublicKey},
   * but returns its `@id` URL instead of the object itself.
   */
  get publicKeyId(): URL | null;
  /** A public part of the key pair owned by this actor.
   */
  getPublicKey(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<CryptographicKey | null>;
  /**
   * Similar to
   * {@link Organization.getPublicKeys},
   * but returns their `@id`s instead of the objects themselves.
   */
  get publicKeyIds(): URL[];
  /** A public part of the key pair owned by this actor.
   */
  getPublicKeys(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<CryptographicKey>;
  /**
   * Similar to
   * {@link Organization.getAssertionMethod},
   * but returns its `@id` URL instead of the object itself.
   */
  get assertionMethodId(): URL | null;
  /** Represents this actor's public keys.  It serves as equivalent to
   * the `publicKeys` property, but is used for [FEP-521a] compliance.
   *
   * [FEP-521a]: https://w3id.org/fep/521a
   */
  getAssertionMethod(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Multikey | null>;
  /**
   * Similar to
   * {@link Organization.getAssertionMethods},
   * but returns their `@id`s instead of the objects themselves.
   */
  get assertionMethodIds(): URL[];
  /** Represents this actor's public keys.  It serves as equivalent to
   * the `publicKeys` property, but is used for [FEP-521a] compliance.
   *
   * [FEP-521a]: https://w3id.org/fep/521a
   */
  getAssertionMethods(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Multikey>;
  /** When `true`, conveys that for this actor, follow requests are not usually
   * automatically approved, but instead are examined by a person who may accept
   * or reject the request, at some time in the future.  Setting of `false`
   * conveys no information and may be ignored.  This information is typically
   * used to affect display of accounts, such as showing an account as private or
   * locked.
   */
  get manuallyApprovesFollowers(): boolean | null;
  /**
   * Similar to
   * {@link Organization.getInbox},
   * but returns its `@id` URL instead of the object itself.
   */
  get inboxId(): URL | null;
  /** The inbox stream contains all activities received by the actor.  The server
   * SHOULD filter content according to the requester's permission.  In general,
   * the owner of an inbox is likely to be able to access all of their inbox
   * contents.  Depending on access control, some other content may be public,
   * whereas other content may require authentication for non-owner users,
   * if they can access the inbox at all.
   *
   * The server MUST perform de-duplication of activities returned by the inbox.
   * Duplication can occur if an activity is addressed both to an actor's
   * followers, and a specific actor who also follows the recipient actor,
   * and the server has failed to de-duplicate the recipients list.
   * Such deduplication MUST be performed by comparing the `id` of the activities
   * and dropping any activities already seen.
   */
  getInbox(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<OrderedCollection | OrderedCollectionPage | null>;
  /**
   * Similar to
   * {@link Organization.getOutbox},
   * but returns its `@id` URL instead of the object itself.
   */
  get outboxId(): URL | null;
  /** The outbox stream contains activities the user has published,
   * subject to the ability of the requestor to retrieve the activity
   * (that is, the contents of the outbox are filtered by the permissions of
   * the person reading it).  If a user submits a request without
   * [Authorization](https://www.w3.org/TR/activitypub/#authorization)
   * the server should respond with all of the
   * [Public](https://www.w3.org/TR/activitypub/#public-addressing) posts.
   * This could potentially be all relevant objects published by the user,
   * though the number of available items is left to the discretion of those
   * implementing and deploying the server.
   */
  getOutbox(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<OrderedCollection | OrderedCollectionPage | null>;
  /**
   * Similar to
   * {@link Organization.getFollowing},
   * but returns its `@id` URL instead of the object itself.
   */
  get followingId(): URL | null;
  /** This is a list of everybody that the actor has followed, added as a
   * [side effect](https://www.w3.org/TR/activitypub/#follow-activity-outbox).
   * The `following` collection MUST be either an {@link OrderedCollection}
   * or a {@link Collection} and MAY be filtered on privileges of
   * an authenticated user or as appropriate when no authentication is given.
   */
  getFollowing(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Organization.getFollowers},
   * but returns its `@id` URL instead of the object itself.
   */
  get followersId(): URL | null;
  /** This is a list of everyone who has sent a {@link Follow} activity
   * for the actor, added as a
   * [side effect](https://www.w3.org/TR/activitypub/#follow-activity-outbox).
   * This is where one would find a list of all the actors that are following
   * the actor.  The `followers` collection MUST be either
   * an {@link OrderedCollection} or a {@link Collection} and MAY be filtered on
   * privileges of an authenticated user or as appropriate when no authentication
   * is given.
   */
  getFollowers(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Organization.getLiked},
   * but returns its `@id` URL instead of the object itself.
   */
  get likedId(): URL | null;
  /** This is a list of every object from all of the actor's {@link Like}
   * activities, added as a
   * [side effect](https://www.w3.org/TR/activitypub/#like-activity-outbox).
   * The `liked` collection MUST be either an {@link OrderedCollection} or
   * a {@link Collection} and MAY be filtered on privileges of an authenticated
   * user or as appropriate when no authentication is given.
   */
  getLiked(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Organization.getFeatured},
   * but returns its `@id` URL instead of the object itself.
   */
  get featuredId(): URL | null;
  /** What is known in Mastodon as "pinned statuses", or statuses that are always
   * featured at the top of people's profiles, is implemented using an extra
   * property `featured` on the actor object that points to a {@link Collection}
   * of objects.
   */
  getFeatured(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Organization.getFeaturedTags},
   * but returns its `@id` URL instead of the object itself.
   */
  get featuredTagsId(): URL | null;
  /** What is known in Mastodon as "featured hashtags", hashtags that are featured
   * at people's profiles, is implemented using an extra property `featuredTags`
   * on the actor object that points to a {@link Collection} of {@link Hashtag}
   * objects specifically.
   */
  getFeaturedTags(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Organization.getStreams},
   * but returns their `@id`s instead of the objects themselves.
   */
  get streamIds(): URL[];
  /** A list of supplementary Collections which may be of interest.
   */
  getStreams(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Collection>;
  /** A JSON object which maps additional (typically server/domain-wide) endpoints
   * which may be useful either for this actor or someone referencing this actor.
   * This mapping may be nested inside the actor document as the value or may be
   * a link to a JSON-LD document with these properties.
   */
  get endpoints(): Endpoints | null;
  /** Allows users to opt-in or opt-out of discoverability features like
   * the profile directory.  This flag may also be used as an indicator of
   * the user's preferences toward being included in external discovery services,
   * such as search engines or other indexing tools.
   */
  get discoverable(): boolean | null;
  /** Reports whether a user was locally suspended, for better handling of
   * these accounts.
   */
  get suspended(): boolean | null;
  /** Whether the actor is in-memorial state.
   */
  get memorial(): boolean | null;
  /** Whether the actor allows to be indexed.
   */
  get indexable(): boolean | null;
  /**
   * Similar to
   * {@link Organization.getSuccessor},
   * but returns its `@id` URL instead of the object itself.
   */
  get successorId(): URL | null;
  /** Signifies that an actor has been moved to a different ID. Used in Mastodon-style data portability with the {@link Move} activity; see [ActivityPub Data Portability/Move Action](https://swicg.github.io/activitypub-data-portability/#move-action) for more details.
   */
  getSuccessor(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Application | Group | Organization | Person | Service | null>;
  /**
   * Similar to
   * {@link Organization.getAlias},
   * but returns its `@id` URL instead of the object itself.
   */
  get aliasId(): URL | null;
  /** The `aliases` (`alsoKnownAs`) property is used to specify alternative names
   * or aliases for an entity.  It can be used to provide additional identifiers
   * or labels for an entity, which can be useful in scenarios where an entity
   * may have multiple names or aliases.
   */
  getAlias(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Application | Group | Organization | Person | Service | null>;
  /**
   * Similar to
   * {@link Organization.getAliases},
   * but returns their `@id`s instead of the objects themselves.
   */
  get aliasIds(): URL[];
  /** The `aliases` (`alsoKnownAs`) property is used to specify alternative names
   * or aliases for an entity.  It can be used to provide additional identifiers
   * or labels for an entity, which can be useful in scenarios where an entity
   * may have multiple names or aliases.
   */
  getAliases(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Application | Group | Organization | Person | Service>;
  /**
   * Similar to
   * {@link Organization.getService},
   * but returns its `@id` URL instead of the object itself.
   */
  get serviceId(): URL | null;
  /** Means of communicating or interacting with the DID subject or associated
   * entities via one or more service endpoints. Examples include discovery
   * services, agent services, social networking services, file storage services,
   * and verifiable credential repository services.
   */
  getService(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<DidService | null>;
  /**
   * Similar to
   * {@link Organization.getServices},
   * but returns their `@id`s instead of the objects themselves.
   */
  get serviceIds(): URL[];
  /** Means of communicating or interacting with the DID subject or associated
   * entities via one or more service endpoints. Examples include discovery
   * services, agent services, social networking services, file storage services,
   * and verifiable credential repository services.
   */
  getServices(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<DidService>;
  /** This value is used for `Actor` type objects to show message on followed.
   */
  get followedMessage(): string | null;
  /** Used on actors to indicate that they in some way identify as a cat,
   * expressed as a boolean value. If this property is set to `true`,
   * displaying the actor or their notes will have some special effects
   * attached in some clients.
   */
  get cat(): boolean | null;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Organization>;
  protected static __fromJsonLd__Organization__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Organization>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Represents a Web Page.
 */

/** Represents an individual person.
 */
declare class Person extends Object$1 {
  #private;
  /**
   * The type URI of {@link Person}: `https://www.w3.org/ns/activitystreams#Person`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Person with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    preferredUsername?: string | LanguageString | null;
    preferredUsernames?: ((string | LanguageString))[];
    publicKey?: CryptographicKey | URL | null;
    publicKeys?: (CryptographicKey | URL)[];
    assertionMethod?: Multikey | URL | null;
    assertionMethods?: (Multikey | URL)[];
    manuallyApprovesFollowers?: boolean | null;
    inbox?: OrderedCollection | OrderedCollectionPage | URL | null;
    outbox?: OrderedCollection | OrderedCollectionPage | URL | null;
    following?: Collection | URL | null;
    followers?: Collection | URL | null;
    liked?: Collection | URL | null;
    featured?: Collection | URL | null;
    featuredTags?: Collection | URL | null;
    streams?: (Collection | URL)[];
    endpoints?: Endpoints | null;
    discoverable?: boolean | null;
    suspended?: boolean | null;
    memorial?: boolean | null;
    indexable?: boolean | null;
    successor?: Application | Group | Organization | Person | Service | URL | null;
    alias?: Application | Group | Organization | Person | Service | URL | null;
    aliases?: (Application | Group | Organization | Person | Service | URL)[];
    service?: DidService | URL | null;
    services?: (DidService | URL)[];
    followedMessage?: string | null;
    cat?: boolean | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    preferredUsername?: string | LanguageString | null;
    preferredUsernames?: ((string | LanguageString))[];
    publicKey?: CryptographicKey | URL | null;
    publicKeys?: (CryptographicKey | URL)[];
    assertionMethod?: Multikey | URL | null;
    assertionMethods?: (Multikey | URL)[];
    manuallyApprovesFollowers?: boolean | null;
    inbox?: OrderedCollection | OrderedCollectionPage | URL | null;
    outbox?: OrderedCollection | OrderedCollectionPage | URL | null;
    following?: Collection | URL | null;
    followers?: Collection | URL | null;
    liked?: Collection | URL | null;
    featured?: Collection | URL | null;
    featuredTags?: Collection | URL | null;
    streams?: (Collection | URL)[];
    endpoints?: Endpoints | null;
    discoverable?: boolean | null;
    suspended?: boolean | null;
    memorial?: boolean | null;
    indexable?: boolean | null;
    successor?: Application | Group | Organization | Person | Service | URL | null;
    alias?: Application | Group | Organization | Person | Service | URL | null;
    aliases?: (Application | Group | Organization | Person | Service | URL)[];
    service?: DidService | URL | null;
    services?: (DidService | URL)[];
    followedMessage?: string | null;
    cat?: boolean | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Person;
  /** A short username which may be used to refer to the actor,
   * with no uniqueness guarantees.
   */
  get preferredUsername(): string | LanguageString | null;
  /** A short username which may be used to refer to the actor,
   * with no uniqueness guarantees.
   */
  get preferredUsernames(): ((string | LanguageString))[];
  /**
   * Similar to
   * {@link Person.getPublicKey},
   * but returns its `@id` URL instead of the object itself.
   */
  get publicKeyId(): URL | null;
  /** A public part of the key pair owned by this actor.
   */
  getPublicKey(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<CryptographicKey | null>;
  /**
   * Similar to
   * {@link Person.getPublicKeys},
   * but returns their `@id`s instead of the objects themselves.
   */
  get publicKeyIds(): URL[];
  /** A public part of the key pair owned by this actor.
   */
  getPublicKeys(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<CryptographicKey>;
  /**
   * Similar to
   * {@link Person.getAssertionMethod},
   * but returns its `@id` URL instead of the object itself.
   */
  get assertionMethodId(): URL | null;
  /** Represents this actor's public keys.  It serves as equivalent to
   * the `publicKeys` property, but is used for [FEP-521a] compliance.
   *
   * [FEP-521a]: https://w3id.org/fep/521a
   */
  getAssertionMethod(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Multikey | null>;
  /**
   * Similar to
   * {@link Person.getAssertionMethods},
   * but returns their `@id`s instead of the objects themselves.
   */
  get assertionMethodIds(): URL[];
  /** Represents this actor's public keys.  It serves as equivalent to
   * the `publicKeys` property, but is used for [FEP-521a] compliance.
   *
   * [FEP-521a]: https://w3id.org/fep/521a
   */
  getAssertionMethods(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Multikey>;
  /** When `true`, conveys that for this actor, follow requests are not usually
   * automatically approved, but instead are examined by a person who may accept
   * or reject the request, at some time in the future.  Setting of `false`
   * conveys no information and may be ignored.  This information is typically
   * used to affect display of accounts, such as showing an account as private or
   * locked.
   */
  get manuallyApprovesFollowers(): boolean | null;
  /**
   * Similar to
   * {@link Person.getInbox},
   * but returns its `@id` URL instead of the object itself.
   */
  get inboxId(): URL | null;
  /** The inbox stream contains all activities received by the actor.  The server
   * SHOULD filter content according to the requester's permission.  In general,
   * the owner of an inbox is likely to be able to access all of their inbox
   * contents.  Depending on access control, some other content may be public,
   * whereas other content may require authentication for non-owner users,
   * if they can access the inbox at all.
   *
   * The server MUST perform de-duplication of activities returned by the inbox.
   * Duplication can occur if an activity is addressed both to an actor's
   * followers, and a specific actor who also follows the recipient actor,
   * and the server has failed to de-duplicate the recipients list.
   * Such deduplication MUST be performed by comparing the `id` of the activities
   * and dropping any activities already seen.
   */
  getInbox(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<OrderedCollection | OrderedCollectionPage | null>;
  /**
   * Similar to
   * {@link Person.getOutbox},
   * but returns its `@id` URL instead of the object itself.
   */
  get outboxId(): URL | null;
  /** The outbox stream contains activities the user has published,
   * subject to the ability of the requestor to retrieve the activity
   * (that is, the contents of the outbox are filtered by the permissions of
   * the person reading it).  If a user submits a request without
   * [Authorization](https://www.w3.org/TR/activitypub/#authorization)
   * the server should respond with all of the
   * [Public](https://www.w3.org/TR/activitypub/#public-addressing) posts.
   * This could potentially be all relevant objects published by the user,
   * though the number of available items is left to the discretion of those
   * implementing and deploying the server.
   */
  getOutbox(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<OrderedCollection | OrderedCollectionPage | null>;
  /**
   * Similar to
   * {@link Person.getFollowing},
   * but returns its `@id` URL instead of the object itself.
   */
  get followingId(): URL | null;
  /** This is a list of everybody that the actor has followed, added as a
   * [side effect](https://www.w3.org/TR/activitypub/#follow-activity-outbox).
   * The `following` collection MUST be either an {@link OrderedCollection}
   * or a {@link Collection} and MAY be filtered on privileges of
   * an authenticated user or as appropriate when no authentication is given.
   */
  getFollowing(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Person.getFollowers},
   * but returns its `@id` URL instead of the object itself.
   */
  get followersId(): URL | null;
  /** This is a list of everyone who has sent a {@link Follow} activity
   * for the actor, added as a
   * [side effect](https://www.w3.org/TR/activitypub/#follow-activity-outbox).
   * This is where one would find a list of all the actors that are following
   * the actor.  The `followers` collection MUST be either
   * an {@link OrderedCollection} or a {@link Collection} and MAY be filtered on
   * privileges of an authenticated user or as appropriate when no authentication
   * is given.
   */
  getFollowers(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Person.getLiked},
   * but returns its `@id` URL instead of the object itself.
   */
  get likedId(): URL | null;
  /** This is a list of every object from all of the actor's {@link Like}
   * activities, added as a
   * [side effect](https://www.w3.org/TR/activitypub/#like-activity-outbox).
   * The `liked` collection MUST be either an {@link OrderedCollection} or
   * a {@link Collection} and MAY be filtered on privileges of an authenticated
   * user or as appropriate when no authentication is given.
   */
  getLiked(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Person.getFeatured},
   * but returns its `@id` URL instead of the object itself.
   */
  get featuredId(): URL | null;
  /** What is known in Mastodon as "pinned statuses", or statuses that are always
   * featured at the top of people's profiles, is implemented using an extra
   * property `featured` on the actor object that points to a {@link Collection}
   * of objects.
   */
  getFeatured(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Person.getFeaturedTags},
   * but returns its `@id` URL instead of the object itself.
   */
  get featuredTagsId(): URL | null;
  /** What is known in Mastodon as "featured hashtags", hashtags that are featured
   * at people's profiles, is implemented using an extra property `featuredTags`
   * on the actor object that points to a {@link Collection} of {@link Hashtag}
   * objects specifically.
   */
  getFeaturedTags(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Person.getStreams},
   * but returns their `@id`s instead of the objects themselves.
   */
  get streamIds(): URL[];
  /** A list of supplementary Collections which may be of interest.
   */
  getStreams(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Collection>;
  /** A JSON object which maps additional (typically server/domain-wide) endpoints
   * which may be useful either for this actor or someone referencing this actor.
   * This mapping may be nested inside the actor document as the value or may be
   * a link to a JSON-LD document with these properties.
   */
  get endpoints(): Endpoints | null;
  /** Allows users to opt-in or opt-out of discoverability features like
   * the profile directory.  This flag may also be used as an indicator of
   * the user's preferences toward being included in external discovery services,
   * such as search engines or other indexing tools.
   */
  get discoverable(): boolean | null;
  /** Reports whether a user was locally suspended, for better handling of
   * these accounts.
   */
  get suspended(): boolean | null;
  /** Whether the actor is in-memorial state.
   */
  get memorial(): boolean | null;
  /** Whether the actor allows to be indexed.
   */
  get indexable(): boolean | null;
  /**
   * Similar to
   * {@link Person.getSuccessor},
   * but returns its `@id` URL instead of the object itself.
   */
  get successorId(): URL | null;
  /** Signifies that an actor has been moved to a different ID. Used in Mastodon-style data portability with the {@link Move} activity; see [ActivityPub Data Portability/Move Action](https://swicg.github.io/activitypub-data-portability/#move-action) for more details.
   */
  getSuccessor(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Application | Group | Organization | Person | Service | null>;
  /**
   * Similar to
   * {@link Person.getAlias},
   * but returns its `@id` URL instead of the object itself.
   */
  get aliasId(): URL | null;
  /** The `aliases` (`alsoKnownAs`) property is used to specify alternative names
   * or aliases for an entity.  It can be used to provide additional identifiers
   * or labels for an entity, which can be useful in scenarios where an entity
   * may have multiple names or aliases.
   */
  getAlias(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Application | Group | Organization | Person | Service | null>;
  /**
   * Similar to
   * {@link Person.getAliases},
   * but returns their `@id`s instead of the objects themselves.
   */
  get aliasIds(): URL[];
  /** The `aliases` (`alsoKnownAs`) property is used to specify alternative names
   * or aliases for an entity.  It can be used to provide additional identifiers
   * or labels for an entity, which can be useful in scenarios where an entity
   * may have multiple names or aliases.
   */
  getAliases(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Application | Group | Organization | Person | Service>;
  /**
   * Similar to
   * {@link Person.getService},
   * but returns its `@id` URL instead of the object itself.
   */
  get serviceId(): URL | null;
  /** Means of communicating or interacting with the DID subject or associated
   * entities via one or more service endpoints. Examples include discovery
   * services, agent services, social networking services, file storage services,
   * and verifiable credential repository services.
   */
  getService(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<DidService | null>;
  /**
   * Similar to
   * {@link Person.getServices},
   * but returns their `@id`s instead of the objects themselves.
   */
  get serviceIds(): URL[];
  /** Means of communicating or interacting with the DID subject or associated
   * entities via one or more service endpoints. Examples include discovery
   * services, agent services, social networking services, file storage services,
   * and verifiable credential repository services.
   */
  getServices(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<DidService>;
  /** This value is used for `Actor` type objects to show message on followed.
   */
  get followedMessage(): string | null;
  /** Used on actors to indicate that they in some way identify as a cat,
   * expressed as a boolean value. If this property is set to `true`,
   * displaying the actor or their notes will have some special effects
   * attached in some clients.
   */
  get cat(): boolean | null;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Person>;
  protected static __fromJsonLd__Person__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Person>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Represents a logical or physical location.  See [5.3 Representing
 * Places](https://www.w3.org/TR/activitystreams-vocabulary/#places)
 * for additional information.
 */

/** Represents a service of any kind.
 */
declare class Service extends Object$1 {
  #private;
  /**
   * The type URI of {@link Service}: `https://www.w3.org/ns/activitystreams#Service`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Service with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    preferredUsername?: string | LanguageString | null;
    preferredUsernames?: ((string | LanguageString))[];
    publicKey?: CryptographicKey | URL | null;
    publicKeys?: (CryptographicKey | URL)[];
    assertionMethod?: Multikey | URL | null;
    assertionMethods?: (Multikey | URL)[];
    manuallyApprovesFollowers?: boolean | null;
    inbox?: OrderedCollection | OrderedCollectionPage | URL | null;
    outbox?: OrderedCollection | OrderedCollectionPage | URL | null;
    following?: Collection | URL | null;
    followers?: Collection | URL | null;
    liked?: Collection | URL | null;
    featured?: Collection | URL | null;
    featuredTags?: Collection | URL | null;
    streams?: (Collection | URL)[];
    endpoints?: Endpoints | null;
    discoverable?: boolean | null;
    suspended?: boolean | null;
    memorial?: boolean | null;
    indexable?: boolean | null;
    successor?: Application | Group | Organization | Person | Service | URL | null;
    alias?: Application | Group | Organization | Person | Service | URL | null;
    aliases?: (Application | Group | Organization | Person | Service | URL)[];
    service?: DidService | URL | null;
    services?: (DidService | URL)[];
    followedMessage?: string | null;
    cat?: boolean | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    preferredUsername?: string | LanguageString | null;
    preferredUsernames?: ((string | LanguageString))[];
    publicKey?: CryptographicKey | URL | null;
    publicKeys?: (CryptographicKey | URL)[];
    assertionMethod?: Multikey | URL | null;
    assertionMethods?: (Multikey | URL)[];
    manuallyApprovesFollowers?: boolean | null;
    inbox?: OrderedCollection | OrderedCollectionPage | URL | null;
    outbox?: OrderedCollection | OrderedCollectionPage | URL | null;
    following?: Collection | URL | null;
    followers?: Collection | URL | null;
    liked?: Collection | URL | null;
    featured?: Collection | URL | null;
    featuredTags?: Collection | URL | null;
    streams?: (Collection | URL)[];
    endpoints?: Endpoints | null;
    discoverable?: boolean | null;
    suspended?: boolean | null;
    memorial?: boolean | null;
    indexable?: boolean | null;
    successor?: Application | Group | Organization | Person | Service | URL | null;
    alias?: Application | Group | Organization | Person | Service | URL | null;
    aliases?: (Application | Group | Organization | Person | Service | URL)[];
    service?: DidService | URL | null;
    services?: (DidService | URL)[];
    followedMessage?: string | null;
    cat?: boolean | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Service;
  /** A short username which may be used to refer to the actor,
   * with no uniqueness guarantees.
   */
  get preferredUsername(): string | LanguageString | null;
  /** A short username which may be used to refer to the actor,
   * with no uniqueness guarantees.
   */
  get preferredUsernames(): ((string | LanguageString))[];
  /**
   * Similar to
   * {@link Service.getPublicKey},
   * but returns its `@id` URL instead of the object itself.
   */
  get publicKeyId(): URL | null;
  /** A public part of the key pair owned by this actor.
   */
  getPublicKey(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<CryptographicKey | null>;
  /**
   * Similar to
   * {@link Service.getPublicKeys},
   * but returns their `@id`s instead of the objects themselves.
   */
  get publicKeyIds(): URL[];
  /** A public part of the key pair owned by this actor.
   */
  getPublicKeys(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<CryptographicKey>;
  /**
   * Similar to
   * {@link Service.getAssertionMethod},
   * but returns its `@id` URL instead of the object itself.
   */
  get assertionMethodId(): URL | null;
  /** Represents this actor's public keys.  It serves as equivalent to
   * the `publicKeys` property, but is used for [FEP-521a] compliance.
   *
   * [FEP-521a]: https://w3id.org/fep/521a
   */
  getAssertionMethod(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Multikey | null>;
  /**
   * Similar to
   * {@link Service.getAssertionMethods},
   * but returns their `@id`s instead of the objects themselves.
   */
  get assertionMethodIds(): URL[];
  /** Represents this actor's public keys.  It serves as equivalent to
   * the `publicKeys` property, but is used for [FEP-521a] compliance.
   *
   * [FEP-521a]: https://w3id.org/fep/521a
   */
  getAssertionMethods(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Multikey>;
  /** When `true`, conveys that for this actor, follow requests are not usually
   * automatically approved, but instead are examined by a person who may accept
   * or reject the request, at some time in the future.  Setting of `false`
   * conveys no information and may be ignored.  This information is typically
   * used to affect display of accounts, such as showing an account as private or
   * locked.
   */
  get manuallyApprovesFollowers(): boolean | null;
  /**
   * Similar to
   * {@link Service.getInbox},
   * but returns its `@id` URL instead of the object itself.
   */
  get inboxId(): URL | null;
  /** The inbox stream contains all activities received by the actor.  The server
   * SHOULD filter content according to the requester's permission.  In general,
   * the owner of an inbox is likely to be able to access all of their inbox
   * contents.  Depending on access control, some other content may be public,
   * whereas other content may require authentication for non-owner users,
   * if they can access the inbox at all.
   *
   * The server MUST perform de-duplication of activities returned by the inbox.
   * Duplication can occur if an activity is addressed both to an actor's
   * followers, and a specific actor who also follows the recipient actor,
   * and the server has failed to de-duplicate the recipients list.
   * Such deduplication MUST be performed by comparing the `id` of the activities
   * and dropping any activities already seen.
   */
  getInbox(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<OrderedCollection | OrderedCollectionPage | null>;
  /**
   * Similar to
   * {@link Service.getOutbox},
   * but returns its `@id` URL instead of the object itself.
   */
  get outboxId(): URL | null;
  /** The outbox stream contains activities the user has published,
   * subject to the ability of the requestor to retrieve the activity
   * (that is, the contents of the outbox are filtered by the permissions of
   * the person reading it).  If a user submits a request without
   * [Authorization](https://www.w3.org/TR/activitypub/#authorization)
   * the server should respond with all of the
   * [Public](https://www.w3.org/TR/activitypub/#public-addressing) posts.
   * This could potentially be all relevant objects published by the user,
   * though the number of available items is left to the discretion of those
   * implementing and deploying the server.
   */
  getOutbox(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<OrderedCollection | OrderedCollectionPage | null>;
  /**
   * Similar to
   * {@link Service.getFollowing},
   * but returns its `@id` URL instead of the object itself.
   */
  get followingId(): URL | null;
  /** This is a list of everybody that the actor has followed, added as a
   * [side effect](https://www.w3.org/TR/activitypub/#follow-activity-outbox).
   * The `following` collection MUST be either an {@link OrderedCollection}
   * or a {@link Collection} and MAY be filtered on privileges of
   * an authenticated user or as appropriate when no authentication is given.
   */
  getFollowing(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Service.getFollowers},
   * but returns its `@id` URL instead of the object itself.
   */
  get followersId(): URL | null;
  /** This is a list of everyone who has sent a {@link Follow} activity
   * for the actor, added as a
   * [side effect](https://www.w3.org/TR/activitypub/#follow-activity-outbox).
   * This is where one would find a list of all the actors that are following
   * the actor.  The `followers` collection MUST be either
   * an {@link OrderedCollection} or a {@link Collection} and MAY be filtered on
   * privileges of an authenticated user or as appropriate when no authentication
   * is given.
   */
  getFollowers(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Service.getLiked},
   * but returns its `@id` URL instead of the object itself.
   */
  get likedId(): URL | null;
  /** This is a list of every object from all of the actor's {@link Like}
   * activities, added as a
   * [side effect](https://www.w3.org/TR/activitypub/#like-activity-outbox).
   * The `liked` collection MUST be either an {@link OrderedCollection} or
   * a {@link Collection} and MAY be filtered on privileges of an authenticated
   * user or as appropriate when no authentication is given.
   */
  getLiked(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Service.getFeatured},
   * but returns its `@id` URL instead of the object itself.
   */
  get featuredId(): URL | null;
  /** What is known in Mastodon as "pinned statuses", or statuses that are always
   * featured at the top of people's profiles, is implemented using an extra
   * property `featured` on the actor object that points to a {@link Collection}
   * of objects.
   */
  getFeatured(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Service.getFeaturedTags},
   * but returns its `@id` URL instead of the object itself.
   */
  get featuredTagsId(): URL | null;
  /** What is known in Mastodon as "featured hashtags", hashtags that are featured
   * at people's profiles, is implemented using an extra property `featuredTags`
   * on the actor object that points to a {@link Collection} of {@link Hashtag}
   * objects specifically.
   */
  getFeaturedTags(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Service.getStreams},
   * but returns their `@id`s instead of the objects themselves.
   */
  get streamIds(): URL[];
  /** A list of supplementary Collections which may be of interest.
   */
  getStreams(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Collection>;
  /** A JSON object which maps additional (typically server/domain-wide) endpoints
   * which may be useful either for this actor or someone referencing this actor.
   * This mapping may be nested inside the actor document as the value or may be
   * a link to a JSON-LD document with these properties.
   */
  get endpoints(): Endpoints | null;
  /** Allows users to opt-in or opt-out of discoverability features like
   * the profile directory.  This flag may also be used as an indicator of
   * the user's preferences toward being included in external discovery services,
   * such as search engines or other indexing tools.
   */
  get discoverable(): boolean | null;
  /** Reports whether a user was locally suspended, for better handling of
   * these accounts.
   */
  get suspended(): boolean | null;
  /** Whether the actor is in-memorial state.
   */
  get memorial(): boolean | null;
  /** Whether the actor allows to be indexed.
   */
  get indexable(): boolean | null;
  /**
   * Similar to
   * {@link Service.getSuccessor},
   * but returns its `@id` URL instead of the object itself.
   */
  get successorId(): URL | null;
  /** Signifies that an actor has been moved to a different ID. Used in Mastodon-style data portability with the {@link Move} activity; see [ActivityPub Data Portability/Move Action](https://swicg.github.io/activitypub-data-portability/#move-action) for more details.
   */
  getSuccessor(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Application | Group | Organization | Person | Service | null>;
  /**
   * Similar to
   * {@link Service.getAlias},
   * but returns its `@id` URL instead of the object itself.
   */
  get aliasId(): URL | null;
  /** The `aliases` (`alsoKnownAs`) property is used to specify alternative names
   * or aliases for an entity.  It can be used to provide additional identifiers
   * or labels for an entity, which can be useful in scenarios where an entity
   * may have multiple names or aliases.
   */
  getAlias(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Application | Group | Organization | Person | Service | null>;
  /**
   * Similar to
   * {@link Service.getAliases},
   * but returns their `@id`s instead of the objects themselves.
   */
  get aliasIds(): URL[];
  /** The `aliases` (`alsoKnownAs`) property is used to specify alternative names
   * or aliases for an entity.  It can be used to provide additional identifiers
   * or labels for an entity, which can be useful in scenarios where an entity
   * may have multiple names or aliases.
   */
  getAliases(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Application | Group | Organization | Person | Service>;
  /**
   * Similar to
   * {@link Service.getService},
   * but returns its `@id` URL instead of the object itself.
   */
  get serviceId(): URL | null;
  /** Means of communicating or interacting with the DID subject or associated
   * entities via one or more service endpoints. Examples include discovery
   * services, agent services, social networking services, file storage services,
   * and verifiable credential repository services.
   */
  getService(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<DidService | null>;
  /**
   * Similar to
   * {@link Service.getServices},
   * but returns their `@id`s instead of the objects themselves.
   */
  get serviceIds(): URL[];
  /** Means of communicating or interacting with the DID subject or associated
   * entities via one or more service endpoints. Examples include discovery
   * services, agent services, social networking services, file storage services,
   * and verifiable credential repository services.
   */
  getServices(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<DidService>;
  /** This value is used for `Actor` type objects to show message on followed.
   */
  get followedMessage(): string | null;
  /** Used on actors to indicate that they in some way identify as a cat,
   * expressed as a boolean value. If this property is set to `true`,
   * displaying the actor or their notes will have some special effects
   * attached in some clients.
   */
  get cat(): boolean | null;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Service>;
  protected static __fromJsonLd__Service__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Service>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Contents of {@link Object}'s `source`.
 */
declare class Source {
  #private;
  readonly id: URL | null;
  protected get _documentLoader(): DocumentLoader | undefined;
  protected get _contextLoader(): DocumentLoader | undefined;
  protected get _tracerProvider(): TracerProvider | undefined;
  protected get _warning(): {
    category: string[];
    message: string;
    values?: Record<string, unknown>;
  } | undefined;
  protected get _cachedJsonLd(): unknown | undefined;
  protected set _cachedJsonLd(value: unknown | undefined);
  /**
   * The type URI of {@link Source}: `https://www.w3.org/ns/activitystreams#Source`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Source with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    mediaType?: string | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    mediaType?: string | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Source;
  /** The source content.
   */
  get content(): string | LanguageString | null;
  /** The source content.
   */
  get contents(): ((string | LanguageString))[];
  /** The MIME media type of the source content.
   */
  get mediaType(): string | null;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Source>;
  protected static __fromJsonLd__Source__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Source>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** A specialization of {@link Accept} indicating that
 * the acceptance is tentative.
 */
//#endregion
//#region src/vocab/actor.d.ts
/**
 * Actor types are {@link Object} types that are capable of performing
 * activities.
 */
type Actor = Application | Group | Organization | Person | Service;
/**
 * Checks if the given object is an {@link Actor}.
 * @param object The object to check.
 * @returns `true` if the given object is an {@link Actor}.
 */

/**
 * The object that can be a recipient of an activity.
 *
 * Note that every {@link Actor} is also a {@link Recipient}.
 */
interface Recipient {
  /**
   * The URI of the actor.
   */
  readonly id: URL | null;
  /**
   * The URI of the actor's inbox.
   */
  readonly inboxId: URL | null;
  /**
   * The endpoints of the actor.
   */
  readonly endpoints?: {
    /**
     * The URI of the actor's shared inbox.
     */
    sharedInbox: URL | null;
  } | null;
}
//#endregion
//#region src/sig/owner.d.ts
/**
 * Options for {@link getKeyOwner}.
 * @since 0.8.0
 */
interface GetKeyOwnerOptions {
  /**
   * The document loader to use for fetching the key and its owner.
   */
  documentLoader?: DocumentLoader;
  /**
   * The context loader to use for JSON-LD context retrieval.
   */
  contextLoader?: DocumentLoader;
  /**
   * The OpenTelemetry tracer provider to use for tracing.  If omitted,
   * the global tracer provider is used.
   * @since 1.3.0
   */
  tracerProvider?: TracerProvider;
}
/**
 * Gets the actor that owns the specified key.  Returns `null` if the key has no
 * known owner.
 *
 * @param keyId The ID of the key to check, or the key itself.
 * @param options Options for getting the key owner.
 * @returns The actor that owns the key, or `null` if the key has no known
 *          owner.
 * @since 0.7.0
 */
//#endregion
//#region src/vocab/lookup.d.ts
/**
 * Options for the {@link lookupObject} function.
 *
 * @since 0.2.0
 */
interface LookupObjectOptions {
  /**
   * The document loader for loading remote JSON-LD documents.
   */
  documentLoader?: DocumentLoader;
  /**
   * The context loader for loading remote JSON-LD contexts.
   * @since 0.8.0
   */
  contextLoader?: DocumentLoader;
  /**
   * Whether to allow fetching an object with an `@id` having a different
   * origin than the object's URL.  This is not recommended, as it may
   * lead to security issues.  Only use this option if you know what you
   * are doing.
   *
   * How to handle the case when an object's `@id` has a different origin
   * than the object's URL:
   *
   *  -  `"ignore"` (default): Do not return the object, and log a warning.
   *  -  `"throw"`: Throw an error.
   *  -  `"trust"`: Bypass the check and return the object anyway.  This
   *     is not recommended, as it may lead to security issues.  Only use
   *     this option if you know what you are doing.
   *
   * @since 1.9.0
   */
  crossOrigin?: "ignore" | "throw" | "trust";
  /**
   * The options for making `User-Agent` header.
   * If a string is given, it is used as the `User-Agent` header value.
   * If an object is given, it is passed to {@link getUserAgent} to generate
   * the `User-Agent` header value.
   * @since 1.3.0
   */
  userAgent?: GetUserAgentOptions | string;
  /**
   * The OpenTelemetry tracer provider.  If omitted, the global tracer provider
   * is used.
   * @since 1.3.0
   */
  tracerProvider?: TracerProvider;
  /**
   * AbortSignal for cancelling the request.
   * @since 1.8.0
   */
  signal?: AbortSignal;
}
/**
 * Looks up an ActivityStreams object by its URI (including `acct:` URIs)
 * or a fediverse handle (e.g., `@user@server` or `user@server`).
 *
 * @example
 * ``` typescript
 * // Look up an actor by its fediverse handle:
 * await lookupObject("@hongminhee@fosstodon.org");
 * // returning a `Person` object.
 *
 * // A fediverse handle can omit the leading '@':
 * await lookupObject("hongminhee@fosstodon.org");
 * // returning a `Person` object.
 *
 * // A `acct:` URI can be used as well:
 * await lookupObject("acct:hongminhee@fosstodon.org");
 * // returning a `Person` object.
 *
 * // Look up an object by its URI:
 * await lookupObject("https://todon.eu/@hongminhee/112060633798771581");
 * // returning a `Note` object.
 *
 * // It can be a `URL` object as well:
 * await lookupObject(new URL("https://todon.eu/@hongminhee/112060633798771581"));
 * // returning a `Note` object.
 * ```
 *
 * @param identifier The URI or fediverse handle to look up.
 * @param options Lookup options.
 * @returns The object, or `null` if not found.
 * @since 0.2.0
 */

/**
 * Options for the {@link traverseCollection} function.
 * @since 1.1.0
 */
interface TraverseCollectionOptions {
  /**
   * The document loader for loading remote JSON-LD documents.
   */
  documentLoader?: DocumentLoader;
  /**
   * The context loader for loading remote JSON-LD contexts.
   */
  contextLoader?: DocumentLoader;
  /**
   * Whether to suppress errors when fetching pages.  If `true`,
   * errors will be logged but not thrown.  Defaults to `false`.
   */
  suppressError?: boolean;
  /**
   * The interval to wait between fetching pages.  Zero or negative
   * values will disable the interval.  Disabled by default.
   *
   * @default `{ seconds: 0 }`
   */
  interval?: Temporal.Duration | Temporal.DurationLike;
}
/**
 * Traverses a collection, yielding each item in the collection.
 * If the collection is paginated, it will fetch the next page
 * automatically.
 *
 * @example
 * ``` typescript
 * const collection = await lookupObject(collectionUrl);
 * if (collection instanceof Collection) {
 *   for await (const item of traverseCollection(collection)) {
 *     console.log(item.id?.href);
 *   }
 * }
 * ```
 *
 * @param collection The collection to traverse.
 * @param options Options for traversing the collection.
 * @returns An async iterable of each item in the collection.
 * @since 1.1.0
 */
//#endregion
//#region src/webfinger/jrd.d.ts
/**
 * Describes a resource.  See also
 * [RFC 7033 section 4.4](https://datatracker.ietf.org/doc/html/rfc7033#section-4.4).
 */
interface ResourceDescriptor {
  /**
   * A URI that identifies the entity that this descriptor describes.
   */
  subject?: string;
  /**
   * URIs that identify the same entity as the `subject`.
   */
  aliases?: string[];
  /**
   * Conveys additional information about the `subject` of this descriptor.
   */
  properties?: Record<string, string>;
  /**
   * Links to other resources.
   */
  links?: Link$1[];
}
/**
 * Represents a link.  See also
 * [RFC 7033 section 4.4.4](https://datatracker.ietf.org/doc/html/rfc7033#section-4.4.4).
 */
interface Link$1 {
  /**
   * The link's relation type, which is either a URI or a registered relation
   * type (see [RFC 5988](https://datatracker.ietf.org/doc/html/rfc5988)).
   */
  rel: string;
  /**
   * The media type of the target resource (see
   * [RFC 6838](https://datatracker.ietf.org/doc/html/rfc6838)).
   */
  type?: string;
  /**
   * A URI pointing to the target resource.
   */
  href?: string;
  /**
   * Human-readable titles describing the link relation.  If the language is
   * unknown or unspecified, the key is `"und"`.
   */
  titles?: Record<string, string>;
  /**
   * Conveys additional information about the link relation.
   */
  properties?: Record<string, string>;
  /**
   * A URI Template (RFC 6570) that can be used to construct URIs by
   * substituting variables. Used primarily for subscription endpoints
   * where parameters like account URIs need to be dynamically inserted.
   * @since 1.9.0
   */
  template?: string;
}
//#endregion
//#region src/webfinger/lookup.d.ts
/**
 * Options for {@link lookupWebFinger}.
 * @since 1.3.0
 */
interface LookupWebFingerOptions {
  /**
   * The options for making `User-Agent` header.
   * If a string is given, it is used as the `User-Agent` header value.
   * If an object is given, it is passed to {@link getUserAgent} to generate
   * the `User-Agent` header value.
   */
  userAgent?: GetUserAgentOptions | string;
  /**
   * Whether to allow private IP addresses in the URL.
   *
   * Mostly useful for testing purposes.  *Do not use this in production.*
   *
   * Turned off by default.
   * @since 1.4.0
   */
  allowPrivateAddress?: boolean;
  /**
   * The maximum number of redirections to follow.
   * @default `5`
   * @since 1.8.0
   */
  maxRedirection?: number;
  /**
   * The OpenTelemetry tracer provider.  If omitted, the global tracer provider
   * is used.
   */
  tracerProvider?: TracerProvider;
  /**
   * AbortSignal for cancelling the request.
   * @since 1.8.0
   * @
   */
  signal?: AbortSignal;
}
/**
 * Looks up a WebFinger resource.
 * @param resource The resource URL to look up.
 * @param options Extra options for looking up the resource.
 * @returns The resource descriptor, or `null` if not found.
 * @since 0.2.0
 */
//#endregion
//#region src/federation/collection.d.ts
/**
 * A page of items.
 */
interface PageItems<TItem> {
  prevCursor?: string | null;
  nextCursor?: string | null;
  items: TItem[];
}
/**
 * Calculates the [partial follower collection digest][1].
 *
 * [1]: https://w3id.org/fep/8fcf#partial-follower-collection-digest
 * @param uris The URIs to calculate the digest.  Duplicate URIs are ignored.
 * @returns The digest.
 */

//#endregion
//#region src/federation/send.d.ts
/**
 * A key pair for an actor who sends an activity.
 * @since 0.10.0
 */
interface SenderKeyPair {
  /**
   * The actor's private key to sign the request.
   */
  privateKey: CryptoKey;
  /**
   * The public key ID that corresponds to the private key.
   */
  keyId: URL;
}
/**
 * Parameters for {@link sendActivity}.
 */
//#endregion
//#region src/federation/callback.d.ts
/**
 * A callback that dispatches a {@link NodeInfo} object.
 *
 * @template TContextData The context data to pass to the {@link Context}.
 */
type NodeInfoDispatcher<TContextData> = (context: RequestContext<TContextData>) => NodeInfo | Promise<NodeInfo>;
/**
 * A callback that dispatches a array of {@link Link}.
 *
 * @template TContextData The context data to pass to the {@link Context}.
 * @param resource The URL queried via WebFinger.
 * @returns Links related to the queried resource.
 */
type WebFingerLinksDispatcher<TContextData> = (context: RequestContext<TContextData>, resource: URL) => readonly Link$1[] | Promise<readonly Link$1[]>;
/**
 * A callback that dispatches an {@link Actor} object.
 *
 * @template TContextData The context data to pass to the {@link Context}.
 * @param context The request context.
 * @param identifier The actor's internal identifier or username.
 */
type ActorDispatcher<TContextData> = (context: RequestContext<TContextData>, identifier: string) => Actor | null | Promise<Actor | null>;
/**
 * A callback that dispatches key pairs for an actor.
 *
 * @template TContextData The context data to pass to the {@link Context}.
 * @param context The context.
 * @param identifier The actor's internal identifier or username.
 * @returns The key pairs.
 * @since 0.10.0
 */
type ActorKeyPairsDispatcher<TContextData> = (context: Context<TContextData>, identifier: string) => CryptoKeyPair[] | Promise<CryptoKeyPair[]>;
/**
 * A callback that maps a WebFinger username to the corresponding actor's
 * internal identifier, or `null` if the username is not found.
 * @template TContextData The context data to pass to the {@link Context}.
 * @param context The context.
 * @param username The WebFinger username.
 * @returns The actor's internal identifier, or `null` if the username is not
 *          found.
 * @since 0.15.0
 */
type ActorHandleMapper<TContextData> = (context: Context<TContextData>, username: string) => string | null | Promise<string | null>;
/**
 * A callback that maps a WebFinger query to the corresponding actor's
 * internal identifier or username, or `null` if the query is not found.
 * @template TContextData The context data to pass to the {@link Context}.
 * @param context The request context.
 * @param resource The URL that was queried through WebFinger.
 * @returns The actor's internal identifier or username, or `null` if the query
 *          is not found.
 * @since 1.4.0
 */
type ActorAliasMapper<TContextData> = (context: RequestContext<TContextData>, resource: URL) => {
  identifier: string;
} | {
  username: string;
} | null | Promise<{
  identifier: string;
} | {
  username: string;
} | null>;
/**
 * A callback that dispatches an object.
 *
 * @template TContextData The context data to pass to the {@link Context}.
 * @template TObject The type of object to dispatch.
 * @template TParam The parameter names of the requested URL.
 * @since 0.7.0
 */
type ObjectDispatcher<TContextData, TObject extends Object$1, TParam extends string> = (context: RequestContext<TContextData>, values: Record<TParam, string>) => TObject | null | Promise<TObject | null>;
/**
 * A callback that dispatches a collection.
 *
 * @template TItem The type of items in the collection.
 * @template TContext The type of the context. {@link Context} or
 *                     {@link RequestContext}.
 * @template TContextData The context data to pass to the `TContext`.
 * @template TFilter The type of the filter, if any.
 * @param context The context.
 * @param identifier The internal identifier or the username of the collection
 *                   owner.
 * @param cursor The cursor to start the collection from, or `null` to dispatch
 *               the entire collection without pagination.
 * @param filter The filter to apply to the collection, if any.
 */
type CollectionDispatcher<TItem, TContext extends Context<TContextData>, TContextData, TFilter> = (context: TContext, identifier: string, cursor: string | null, filter?: TFilter) => PageItems<TItem> | null | Promise<PageItems<TItem> | null>;
/**
 * A callback that counts the number of items in a collection.
 *
 * @template TContextData The context data to pass to the {@link Context}.
 * @param context The context.
 * @param identifier The internal identifier or the username of the collection
 *                   owner.
 * @param filter The filter to apply to the collection, if any.
 */
type CollectionCounter<TContextData, TFilter> = (context: RequestContext<TContextData>, identifier: string, filter?: TFilter) => number | bigint | null | Promise<number | bigint | null>;
/**
 * A callback that returns a cursor for a collection.
 *
 * @template TContext The type of the context. {@link Context} or
 *                     {@link RequestContext}.
 * @template TContextData The context data to pass to the {@link Context}.
 * @template TFilter The type of the filter, if any.
 * @param context The context.
 * @param identifier The internal identifier or the username of the collection
 *                   owner.
 * @param filter The filter to apply to the collection, if any.
 */
type CollectionCursor<TContext extends Context<TContextData>, TContextData, TFilter> = (context: TContext, identifier: string, filter?: TFilter) => string | null | Promise<string | null>;
/**
 * A callback that listens for activities in an inbox.
 *
 * @template TContextData The context data to pass to the {@link Context}.
 * @template TActivity The type of activity to listen for.
 * @param context The inbox context.
 * @param activity The activity that was received.
 */
type InboxListener<TContextData, TActivity extends Activity> = (context: InboxContext<TContextData>, activity: TActivity) => void | Promise<void>;
/**
 * A callback that handles errors in an inbox.
 *
 * @template TContextData The context data to pass to the {@link Context}.
 * @param context The inbox context.
 */
type InboxErrorHandler<TContextData> = (context: Context<TContextData>, error: Error) => void | Promise<void>;
/**
 * A callback that dispatches the key pair for the authenticated document loader
 * of the {@link Context} passed to the shared inbox listener.
 *
 * @template TContextData The context data to pass to the {@link Context}.
 * @param context The context.
 * @returns The username or the internal identifier of the actor or the key pair
 *          for the authenticated document loader of the {@link Context} passed
 *          to the shared inbox listener.  If `null` is returned, the request is
 *          not authorized.
 * @since 0.11.0
 */
type SharedInboxKeyDispatcher<TContextData> = (context: Context<TContextData>) => SenderKeyPair | {
  identifier: string;
} | {
  username: string;
} | {
  handle: string;
} | null | Promise<SenderKeyPair | {
  identifier: string;
} | {
  username: string;
} | {
  handle: string;
} | null>;
/**
 * A callback that handles errors during outbox processing.
 *
 * @param error The error that occurred.
 * @param activity The activity that caused the error.  If it is `null`, the
 *                 error occurred during deserializing the activity.
 * @since 0.6.0
 */

/**
 * A callback that determines if a request is authorized or not.
 *
 * @template TContextData The context data to pass to the {@link Context}.
 * @param context The request context.
 * @param identifier The internal identifier of the actor that is being requested.
 * @param signedKey *Deprecated in Fedify 1.5.0 in favor of
 *                  {@link RequestContext.getSignedKey} method.*
 *                  The key that was used to sign the request, or `null` if
 *                  the request was not signed or the signature was invalid.
 * @param signedKeyOwner *Deprecated in Fedify 1.5.0 in favor of
 *                       {@link RequestContext.getSignedKeyOwner} method.*
 *                       The actor that owns the key that was used to sign the
 *                       request, or `null` if the request was not signed or the
 *                       signature was invalid, or if the key is not associated
 *                       with an actor.
 * @returns `true` if the request is authorized, `false` otherwise.
 * @since 0.7.0
 */
type AuthorizePredicate<TContextData> = (context: RequestContext<TContextData>, identifier: string, signedKey: CryptographicKey | null, signedKeyOwner: Actor | null) => boolean | Promise<boolean>;
/**
 * A callback that determines if a request is authorized or not.
 *
 * @template TContextData The context data to pass to the {@link Context}.
 * @template TParam The parameter names of the requested URL.
 * @param context The request context.
 * @param values The parameters of the requested URL.
 * @param signedKey *Deprecated in Fedify 1.5.0 in favor of
 *                  {@link RequestContext.getSignedKey} method.*
 *                  The key that was used to sign the request, or `null` if
 *                  the request was not signed or the signature was invalid.
 * @param signedKeyOwner *Deprecated in Fedify 1.5.0 in favor of
 *                       {@link RequestContext.getSignedKeyOwner} method.*
 *                       The actor that owns the key that was used to sign the
 *                       request, or `null` if the request was not signed or the
 *                       signature was invalid, or if the key is not associated
 *                       with an actor.
 * @returns `true` if the request is authorized, `false` otherwise.
 * @since 0.7.0
 */
type ObjectAuthorizePredicate<TContextData, TParam extends string> = (context: RequestContext<TContextData>, values: Record<TParam, string>, signedKey: CryptographicKey | null, signedKeyOwner: Actor | null) => boolean | Promise<boolean>;
/**
 * A callback that dispatches a custom collection.
 *
 * @template TItem The type of items in the collection.
 * @template TParams The parameter names of the requested URL.
 * @template TContext The type of the context. {@link Context} or
 *                     {@link RequestContext}.
 * @template TContextData The context data to pass to the `TContext`.
 * @template TFilter The type of the filter, if any.
 * @param context The context.
 * @param values The parameters of the requested URL.
 * @param cursor The cursor to start the collection from, or `null` to dispatch
 *               the entire collection without pagination.
 * @since 1.8.0
 */
type CustomCollectionDispatcher<TItem, TParam extends string, TContext extends Context<TContextData>, TContextData> = (context: TContext, values: Record<TParam, string>, cursor: string | null) => PageItems<TItem> | null | Promise<PageItems<TItem> | null>;
/**
 * A callback that counts the number of items in a custom collection.
 *
 * @template TParams The parameter names of the requested URL.
 * @template TContextData The context data to pass to the {@link Context}.
 * @param context The context.
 * @param values The parameters of the requested URL.
 * @since 1.8.0
 */
type CustomCollectionCounter<TParam extends string, TContextData> = (context: RequestContext<TContextData>, values: Record<TParam, string>) => number | bigint | null | Promise<number | bigint | null>;
/**
 * A callback that returns a cursor for a custom collection.
 *
 * @template TParams The parameter names of the requested URL.
 * @template TContext The type of the context. {@link Context} or
 *                     {@link RequestContext}.
 * @template TContextData The context data to pass to the {@link Context}.
 * @template TFilter The type of the filter, if any.
 * @param context The context.
 * @param values The parameters of the requested URL.
 * @since 1.8.0
 */
type CustomCollectionCursor<TParam extends string, TContext extends Context<TContextData>, TContextData> = (context: TContext, values: Record<TParam, string>) => string | null | Promise<string | null>;
//#endregion
//#region src/federation/queue.d.ts
interface SenderKeyJwkPair {
  keyId: string;
  privateKey: JsonWebKey;
}
/**
 * A message that represents a task to be processed by the background worker.
 * The concrete type of the message depends on the `type` property.
 *
 * Please do not depend on the concrete types of the messages, as they may
 * change in the future.  You should treat the `Message` type as an opaque
 * type.
 * @since 1.6.0
 */
type Message = FanoutMessage | OutboxMessage | InboxMessage;
interface FanoutMessage {
  type: "fanout";
  id: ReturnType<typeof crypto.randomUUID>;
  baseUrl: string;
  keys: SenderKeyJwkPair[];
  inboxes: Record<string, {
    actorIds: string[];
    sharedInbox: boolean;
  }>;
  activity: unknown;
  activityId?: string;
  activityType: string;
  collectionSync?: string;
  traceContext: Record<string, string>;
}
interface OutboxMessage {
  type: "outbox";
  id: ReturnType<typeof crypto.randomUUID>;
  baseUrl: string;
  keys: SenderKeyJwkPair[];
  activity: unknown;
  activityId?: string;
  activityType: string;
  inbox: string;
  sharedInbox: boolean;
  started: string;
  attempt: number;
  headers: Record<string, string>;
  traceContext: Record<string, string>;
}
interface InboxMessage {
  type: "inbox";
  id: ReturnType<typeof crypto.randomUUID>;
  baseUrl: string;
  activity: unknown;
  started: string;
  attempt: number;
  identifier: string | null;
  traceContext: Record<string, string>;
}
//#endregion
//#region src/federation/federation.d.ts
/**
 * Options for {@link Federation.startQueue} method.
 * @since 1.0.0
 */
interface FederationStartQueueOptions {
  /**
   * The signal to abort the task queue.
   */
  signal?: AbortSignal;
  /**
   * Starts the task worker only for the specified queue.  If unspecified,
   * which is the default, the task worker starts for all three queues:
   * inbox, outbox, and fanout.
   * @since 1.3.0
   */
  queue?: "inbox" | "outbox" | "fanout";
}
/**
 * A common interface between {@link Federation} and {@link FederationBuilder}.
 * @template TContextData The context data to pass to the {@link Context}.
 * @since 1.6.0
 */
interface Federatable<TContextData> {
  /**
   * Registers a NodeInfo dispatcher.
   * @param path The URI path pattern for the NodeInfo dispatcher.  The syntax
   *             is based on URI Template
   *             ([RFC 6570](https://tools.ietf.org/html/rfc6570)).  The path
   *             must have no variables.
   * @param dispatcher A NodeInfo dispatcher callback to register.
   * @throws {RouterError} Thrown if the path pattern is invalid.
   */
  setNodeInfoDispatcher(path: string, dispatcher: NodeInfoDispatcher<TContextData>): void;
  /**
   * Registers a links dispatcher to WebFinger
   * @param dispatcher A links dispatcher callback to register.
   */
  setWebFingerLinksDispatcher(dispatcher: WebFingerLinksDispatcher<TContextData>): void;
  /**
   * Registers an actor dispatcher.
   *
   * @example
   * ``` typescript
   * federation.setActorDispatcher(
   *   "/users/{identifier}",
   *   async (ctx, identifier) => {
   *     return new Person({
   *       id: ctx.getActorUri(identifier),
   *       // ...
   *     });
   *   }
   * );
   * ```
   *
   * @param path The URI path pattern for the actor dispatcher.  The syntax is
   *             based on URI Template
   *             ([RFC 6570](https://tools.ietf.org/html/rfc6570)).  The path
   *             must have one variable: `{identifier}`.
   * @param dispatcher An actor dispatcher callback to register.
   * @returns An object with methods to set other actor dispatcher callbacks.
   * @throws {RouterError} Thrown if the path pattern is invalid.
   */
  setActorDispatcher(path: `${string}${Rfc6570Expression<"identifier">}${string}` | `${string}${Rfc6570Expression<"handle">}${string}`, dispatcher: ActorDispatcher<TContextData>): ActorCallbackSetters<TContextData>;
  /**
   * Registers an object dispatcher.
   *
   * @template TContextData The context data to pass to the {@link Context}.
   * @template TObject The type of object to dispatch.
   * @template TParam The parameter names of the requested URL.
   * @param cls The Activity Vocabulary class of the object to dispatch.
   * @param path The URI path pattern for the object dispatcher.  The syntax is
   *             based on URI Template
   *             ([RFC 6570](https://tools.ietf.org/html/rfc6570)).  The path
   *             must have one or more variables.
   * @param dispatcher An object dispatcher callback to register.
   */
  setObjectDispatcher<TObject extends Object$1, TParam extends string>(cls: ConstructorWithTypeId<TObject>, path: `${string}{${TParam}}${string}{${TParam}}${string}{${TParam}}${string}{${TParam}}${string}{${TParam}}${string}{${TParam}}${string}`, dispatcher: ObjectDispatcher<TContextData, TObject, TParam>): ObjectCallbackSetters<TContextData, TObject, TParam>;
  /**
   * Registers an object dispatcher.
   *
   * @template TContextData The context data to pass to the {@link Context}.
   * @template TObject The type of object to dispatch.
   * @template TParam The parameter names of the requested URL.
   * @param cls The Activity Vocabulary class of the object to dispatch.
   * @param path The URI path pattern for the object dispatcher.  The syntax is
   *             based on URI Template
   *             ([RFC 6570](https://tools.ietf.org/html/rfc6570)).  The path
   *             must have one or more variables.
   * @param dispatcher An object dispatcher callback to register.
   */
  setObjectDispatcher<TObject extends Object$1, TParam extends string>(cls: ConstructorWithTypeId<TObject>, path: `${string}{${TParam}}${string}{${TParam}}${string}{${TParam}}${string}{${TParam}}${string}{${TParam}}${string}`, dispatcher: ObjectDispatcher<TContextData, TObject, TParam>): ObjectCallbackSetters<TContextData, TObject, TParam>;
  /**
   * Registers an object dispatcher.
   *
   * @template TContextData The context data to pass to the {@link Context}.
   * @template TObject The type of object to dispatch.
   * @template TParam The parameter names of the requested URL.
   * @param cls The Activity Vocabulary class of the object to dispatch.
   * @param path The URI path pattern for the object dispatcher.  The syntax is
   *             based on URI Template
   *             ([RFC 6570](https://tools.ietf.org/html/rfc6570)).  The path
   *             must have one or more variables.
   * @param dispatcher An object dispatcher callback to register.
   */
  setObjectDispatcher<TObject extends Object$1, TParam extends string>(cls: ConstructorWithTypeId<TObject>, path: `${string}{${TParam}}${string}{${TParam}}${string}{${TParam}}${string}{${TParam}}${string}`, dispatcher: ObjectDispatcher<TContextData, TObject, TParam>): ObjectCallbackSetters<TContextData, TObject, TParam>;
  /**
   * Registers an object dispatcher.
   *
   * @template TContextData The context data to pass to the {@link Context}.
   * @template TObject The type of object to dispatch.
   * @template TParam The parameter names of the requested URL.
   * @param cls The Activity Vocabulary class of the object to dispatch.
   * @param path The URI path pattern for the object dispatcher.  The syntax is
   *             based on URI Template
   *             ([RFC 6570](https://tools.ietf.org/html/rfc6570)).  The path
   *             must have one or more variables.
   * @param dispatcher An object dispatcher callback to register.
   */
  setObjectDispatcher<TObject extends Object$1, TParam extends string>(cls: ConstructorWithTypeId<TObject>, path: `${string}${Rfc6570Expression<TParam>}${string}${Rfc6570Expression<TParam>}${string}${Rfc6570Expression<TParam>}${string}`, dispatcher: ObjectDispatcher<TContextData, TObject, TParam>): ObjectCallbackSetters<TContextData, TObject, TParam>;
  /**
   * Registers an object dispatcher.
   *
   * @template TContextData The context data to pass to the {@link Context}.
   * @template TObject The type of object to dispatch.
   * @template TParam The parameter names of the requested URL.
   * @param cls The Activity Vocabulary class of the object to dispatch.
   * @param path The URI path pattern for the object dispatcher.  The syntax is
   *             based on URI Template
   *             ([RFC 6570](https://tools.ietf.org/html/rfc6570)).  The path
   *             must have one or more variables.
   * @param dispatcher An object dispatcher callback to register.
   */
  setObjectDispatcher<TObject extends Object$1, TParam extends string>(cls: ConstructorWithTypeId<TObject>, path: `${string}${Rfc6570Expression<TParam>}${string}${Rfc6570Expression<TParam>}${string}`, dispatcher: ObjectDispatcher<TContextData, TObject, TParam>): ObjectCallbackSetters<TContextData, TObject, TParam>;
  /**
   * Registers an object dispatcher.
   *
   * @template TContextData The context data to pass to the {@link Context}.
   * @template TObject The type of object to dispatch.
   * @template TParam The parameter names of the requested URL.
   * @param cls The Activity Vocabulary class of the object to dispatch.
   * @param path The URI path pattern for the object dispatcher.  The syntax is
   *             based on URI Template
   *             ([RFC 6570](https://tools.ietf.org/html/rfc6570)).  The path
   *             must have one or more variables.
   * @param dispatcher An object dispatcher callback to register.
   */
  setObjectDispatcher<TObject extends Object$1, TParam extends string>(cls: ConstructorWithTypeId<TObject>, path: `${string}${Rfc6570Expression<TParam>}${string}`, dispatcher: ObjectDispatcher<TContextData, TObject, TParam>): ObjectCallbackSetters<TContextData, TObject, TParam>;
  /**
   * Registers an inbox dispatcher.
   *
   * @param path The URI path pattern for the inbox dispatcher.  The syntax is
   *             based on URI Template
   *             ([RFC 6570](https://tools.ietf.org/html/rfc6570)).  The path
   *             must have one variable: `{identifier}`, and must match
   *             the inbox listener path.
   * @param dispatcher An inbox dispatcher callback to register.
   * @throws {@link RouterError} Thrown if the path pattern is invalid.
   */
  setInboxDispatcher(path: `${string}${Rfc6570Expression<"identifier">}${string}` | `${string}${Rfc6570Expression<"handle">}${string}`, dispatcher: CollectionDispatcher<Activity, RequestContext<TContextData>, TContextData, void>): CollectionCallbackSetters<RequestContext<TContextData>, TContextData, void>;
  /**
   * Registers an outbox dispatcher.
   *
   * @example
   * ``` typescript
   * federation.setOutboxDispatcher(
   *   "/users/{identifier}/outbox",
   *   async (ctx, identifier, options) => {
   *     let items: Activity[];
   *     let nextCursor: string;
   *     // ...
   *     return { items, nextCursor };
   *   }
   * );
   * ```
   *
   * @param path The URI path pattern for the outbox dispatcher.  The syntax is
   *             based on URI Template
   *             ([RFC 6570](https://tools.ietf.org/html/rfc6570)).  The path
   *             must have one variable: `{identifier}`.
   * @param dispatcher An outbox dispatcher callback to register.
   * @throws {@link RouterError} Thrown if the path pattern is invalid.
   */
  setOutboxDispatcher(path: `${string}${Rfc6570Expression<"identifier">}${string}` | `${string}${Rfc6570Expression<"handle">}${string}`, dispatcher: CollectionDispatcher<Activity, RequestContext<TContextData>, TContextData, void>): CollectionCallbackSetters<RequestContext<TContextData>, TContextData, void>;
  /**
   * Registers a following collection dispatcher.
   * @param path The URI path pattern for the following collection.  The syntax
   *             is based on URI Template
   *             ([RFC 6570](https://tools.ietf.org/html/rfc6570)).  The path
   *             must have one variable: `{identifier}`.
   * @param dispatcher A following collection callback to register.
   * @returns An object with methods to set other following collection
   *          callbacks.
   * @throws {RouterError} Thrown if the path pattern is invalid.
   */
  setFollowingDispatcher(path: `${string}${Rfc6570Expression<"identifier">}${string}` | `${string}${Rfc6570Expression<"handle">}${string}`, dispatcher: CollectionDispatcher<Actor | URL, RequestContext<TContextData>, TContextData, void>): CollectionCallbackSetters<RequestContext<TContextData>, TContextData, void>;
  /**
   * Registers a followers collection dispatcher.
   * @param path The URI path pattern for the followers collection.  The syntax
   *             is based on URI Template
   *             ([RFC 6570](https://tools.ietf.org/html/rfc6570)).  The path
   *             must have one variable: `{identifier}`.
   * @param dispatcher A followers collection callback to register.
   * @returns An object with methods to set other followers collection
   *          callbacks.
   * @throws {@link RouterError} Thrown if the path pattern is invalid.
   */
  setFollowersDispatcher(path: `${string}${Rfc6570Expression<"identifier">}${string}` | `${string}${Rfc6570Expression<"handle">}${string}`, dispatcher: CollectionDispatcher<Recipient, Context<TContextData>, TContextData, URL>): CollectionCallbackSetters<Context<TContextData>, TContextData, URL>;
  /**
   * Registers a liked collection dispatcher.
   * @param path The URI path pattern for the liked collection.  The syntax
   *             is based on URI Template
   *             ([RFC 6570](https://tools.ietf.org/html/rfc6570)).  The path
   *             must have one variable: `{identifier}`.
   * @param dispatcher A liked collection callback to register.
   * @returns An object with methods to set other liked collection
   *          callbacks.
   * @throws {@link RouterError} Thrown if the path pattern is invalid.
   */
  setLikedDispatcher(path: `${string}${Rfc6570Expression<"identifier">}${string}` | `${string}${Rfc6570Expression<"handle">}${string}`, dispatcher: CollectionDispatcher<Object$1 | URL, RequestContext<TContextData>, TContextData, void>): CollectionCallbackSetters<RequestContext<TContextData>, TContextData, void>;
  /**
   * Registers a featured collection dispatcher.
   * @param path The URI path pattern for the featured collection.  The syntax
   *             is based on URI Template
   *             ([RFC 6570](https://tools.ietf.org/html/rfc6570)).  The path
   *             must have one variable: `{identifier}`.
   * @param dispatcher A featured collection callback to register.
   * @returns An object with methods to set other featured collection
   *          callbacks.
   * @throws {@link RouterError} Thrown if the path pattern is invalid.
   */
  setFeaturedDispatcher(path: `${string}${Rfc6570Expression<"identifier">}${string}` | `${string}${Rfc6570Expression<"handle">}${string}`, dispatcher: CollectionDispatcher<Object$1, RequestContext<TContextData>, TContextData, void>): CollectionCallbackSetters<RequestContext<TContextData>, TContextData, void>;
  /**
   * Registers a featured tags collection dispatcher.
   * @param path The URI path pattern for the featured tags collection.
   *             The syntax is based on URI Template
   *             ([RFC 6570](https://tools.ietf.org/html/rfc6570)).  The path
   *             must have one variable: `{identifier}`.
   * @param dispatcher A featured tags collection callback to register.
   * @returns An object with methods to set other featured tags collection
   *          callbacks.
   * @throws {@link RouterError} Thrown if the path pattern is invalid.
   */
  setFeaturedTagsDispatcher(path: `${string}${Rfc6570Expression<"identifier">}${string}` | `${string}${Rfc6570Expression<"handle">}${string}`, dispatcher: CollectionDispatcher<Hashtag, RequestContext<TContextData>, TContextData, void>): CollectionCallbackSetters<RequestContext<TContextData>, TContextData, void>;
  /**
   * Assigns the URL path for the inbox and starts setting inbox listeners.
   *
   * @example
   * ``` typescript
   * federation
   *   .setInboxListeners("/users/{identifier}/inbox", "/inbox")
   *   .on(Follow, async (ctx, follow) => {
   *     const from = await follow.getActor(ctx);
   *     if (!isActor(from)) return;
   *     // ...
   *   })
   *   .on(Undo, async (ctx, undo) => {
   *     // ...
   *   });
   * ```
   *
   * @param inboxPath The URI path pattern for the inbox.  The syntax is based
   *                  on URI Template
   *                  ([RFC 6570](https://tools.ietf.org/html/rfc6570)).
   *                  The path must have one variable: `{identifier}`, and must
   *                  match the inbox dispatcher path.
   * @param sharedInboxPath An optional URI path pattern for the shared inbox.
   *                        The syntax is based on URI Template
   *                        ([RFC 6570](https://tools.ietf.org/html/rfc6570)).
   *                        The path must have no variables.
   * @returns An object to register inbox listeners.
   * @throws {RouteError} Thrown if the path pattern is invalid.
   */
  setInboxListeners(inboxPath: `${string}${Rfc6570Expression<"identifier">}${string}` | `${string}${Rfc6570Expression<"handle">}${string}`, sharedInboxPath?: string): InboxListenerSetters<TContextData>;
  /**
   * Registers a collection of objects dispatcher.
   *
   * @template TContextData The context data to pass to the {@link Context}.
   * @template TObject The type of objects to dispatch.
   * @template TParam The parameter names of the requested URL.
   * @param name A unique name for the collection dispatcher.
   * @param itemType The Activity Vocabulary class of the object to dispatch.
   * @param path The URI path pattern for the collection dispatcher.
   *             The syntax is based on URI Template
   *             ([RFC 6570](https://tools.ietf.org/html/rfc6570)).
   *             The path must have one or more variables.
   * @param dispatcher A collection dispatcher callback to register.
   */
  setCollectionDispatcher<TObject extends Object$1, TParam extends string>(name: string | symbol, itemType: ConstructorWithTypeId<TObject>, path: `${string}${Rfc6570Expression<TParam>}${string}${Rfc6570Expression<TParam>}${string}${Rfc6570Expression<TParam>}${string}`, dispatcher: CustomCollectionDispatcher<TObject, TParam, RequestContext<TContextData>, TContextData>): CustomCollectionCallbackSetters<TParam, RequestContext<TContextData>, TContextData>;
  /**
   * Registers a collection of objects dispatcher.
   *
   * @template TContextData The context data to pass to the {@link Context}.
   * @template TObject The type of objects to dispatch.
   * @template TParam The parameter names of the requested URL.
   * @param name A unique name for the collection dispatcher.
   * @param itemType The Activity Vocabulary class of the object to dispatch.
   * @param path The URI path pattern for the collection dispatcher.
   *             The syntax is based on URI Template
   *             ([RFC 6570](https://tools.ietf.org/html/rfc6570)).
   *             The path must have one or more variables.
   * @param dispatcher A collection dispatcher callback to register.
   */
  setCollectionDispatcher<TObject extends Object$1, TParam extends string>(name: string | symbol, itemType: ConstructorWithTypeId<TObject>, path: `${string}${Rfc6570Expression<TParam>}${string}${Rfc6570Expression<TParam>}${string}`, dispatcher: CustomCollectionDispatcher<TObject, TParam, RequestContext<TContextData>, TContextData>): CustomCollectionCallbackSetters<TParam, RequestContext<TContextData>, TContextData>;
  /**
   * Registers a collection of objects dispatcher.
   *
   * @template TContextData The context data to pass to the {@link Context}.
   * @template TObject The type of objects to dispatch.
   * @template TParam The parameter names of the requested URL.
   * @param name A unique name for the collection dispatcher.
   * @param itemType The Activity Vocabulary class of the object to dispatch.
   * @param path The URI path pattern for the collection dispatcher.
   *             The syntax is based on URI Template
   *             ([RFC 6570](https://tools.ietf.org/html/rfc6570)).
   *             The path must have one or more variables.
   * @param dispatcher A collection dispatcher callback to register.
   */
  setCollectionDispatcher<TObject extends Object$1, TParam extends string>(name: string | symbol, itemType: ConstructorWithTypeId<TObject>, path: `${string}${Rfc6570Expression<TParam>}${string}`, dispatcher: CustomCollectionDispatcher<TObject, TParam, RequestContext<TContextData>, TContextData>): CustomCollectionCallbackSetters<TParam, RequestContext<TContextData>, TContextData>;
  /**
   * Registers an ordered collection of objects dispatcher.
   *
   * @template TContextData The context data to pass to the {@link Context}.
   * @template TObject The type of objects to dispatch.
   * @template TParam The parameter names of the requested URL.
   * @param name A unique name for the collection dispatcher.
   * @param itemType The Activity Vocabulary class of the object to dispatch.
   * @param path The URI path pattern for the collection dispatcher.
   *             The syntax is based on URI Template
   *             ([RFC 6570](https://tools.ietf.org/html/rfc6570)).
   *             The path must have one or more variables.
   * @param dispatcher A collection dispatcher callback to register.
   */
  setOrderedCollectionDispatcher<TObject extends Object$1, TParam extends string>(name: string | symbol, itemType: ConstructorWithTypeId<TObject>, path: `${string}${Rfc6570Expression<TParam>}${string}${Rfc6570Expression<TParam>}${string}${Rfc6570Expression<TParam>}${string}`, dispatcher: CustomCollectionDispatcher<TObject, TParam, RequestContext<TContextData>, TContextData>): CustomCollectionCallbackSetters<TParam, RequestContext<TContextData>, TContextData>;
  /**
   * Registers an ordered collection of objects dispatcher.
   *
   * @template TContextData The context data to pass to the {@link Context}.
   * @template TObject The type of objects to dispatch.
   * @template TParam The parameter names of the requested URL.
   * @param name A unique name for the collection dispatcher.
   * @param itemType The Activity Vocabulary class of the object to dispatch.
   * @param path The URI path pattern for the collection dispatcher.
   *             The syntax is based on URI Template
   *             ([RFC 6570](https://tools.ietf.org/html/rfc6570)).
   *             The path must have one or more variables.
   * @param dispatcher A collection dispatcher callback to register.
   */
  setOrderedCollectionDispatcher<TObject extends Object$1, TParam extends string>(name: string | symbol, itemType: ConstructorWithTypeId<TObject>, path: `${string}${Rfc6570Expression<TParam>}${string}${Rfc6570Expression<TParam>}${string}`, dispatcher: CustomCollectionDispatcher<TObject, TParam, RequestContext<TContextData>, TContextData>): CustomCollectionCallbackSetters<TParam, RequestContext<TContextData>, TContextData>;
  /**
   * Registers an ordered collection of objects dispatcher.
   *
   * @template TContextData The context data to pass to the {@link Context}.
   * @template TObject The type of objects to dispatch.
   * @template TParam The parameter names of the requested URL.
   * @param name A unique name for the collection dispatcher.
   * @param itemType The Activity Vocabulary class of the object to dispatch.
   * @param path The URI path pattern for the collection dispatcher.
   *             The syntax is based on URI Template
   *             ([RFC 6570](https://tools.ietf.org/html/rfc6570)).
   *             The path must have one or more variables.
   * @param dispatcher A collection dispatcher callback to register.
   */
  setOrderedCollectionDispatcher<TObject extends Object$1, TParam extends string>(name: string | symbol, itemType: ConstructorWithTypeId<TObject>, path: `${string}${Rfc6570Expression<TParam>}${string}`, dispatcher: CustomCollectionDispatcher<TObject, TParam, RequestContext<TContextData>, TContextData>): CustomCollectionCallbackSetters<TParam, RequestContext<TContextData>, TContextData>;
}
/**
 * An object that registers federation-related business logic and dispatches
 * requests to the appropriate handlers.
 *
 * It also provides a middleware interface for handling requests before your
 * web framework's router; see {@link Federation.fetch}.
 * @template TContextData The context data to pass to the {@link Context}.
 * @since 0.13.0
 */
interface Federation<TContextData> extends Federatable<TContextData> {
  /**
   * Manually start the task queue.
   *
   * This method is useful when you set the `manuallyStartQueue` option to
   * `true` in the {@link createFederation} function.
   * @param contextData The context data to pass to the context.
   * @param options Additional options for starting the queue.
   */
  startQueue(contextData: TContextData, options?: FederationStartQueueOptions): Promise<void>;
  /**
   * Processes a queued message task.  This method handles different types of
   * tasks such as fanout, outbox, and inbox messages.
   *
   * Note that you usually do not need to call this method directly unless you
   * are deploying your federated application on a platform that does not
   * support long-running processing, such as Cloudflare Workers.
   * @param contextData The context data to pass to the context.
   * @param message The message that represents the task to be processed.
   * @returns A promise that resolves when the message has been processed.
   * @since 1.6.0
   */
  processQueuedTask(contextData: TContextData, message: Message): Promise<void>;
  /**
   * Create a new context.
   * @param baseUrl The base URL of the server.  The `pathname` remains root,
   *                and the `search` and `hash` are stripped.
   * @param contextData The context data to pass to the context.
   * @returns The new context.
   */
  createContext(baseUrl: URL, contextData: TContextData): Context<TContextData>;
  /**
   * Create a new context for a request.
   * @param request The request object.
   * @param contextData The context data to pass to the context.
   * @returns The new request context.
   */
  createContext(request: Request, contextData: TContextData): RequestContext<TContextData>;
  /**
   * Handles a request related to federation.  If a request is not related to
   * federation, the `onNotFound` or `onNotAcceptable` callback is called.
   *
   * Usually, this method is called from a server's request handler or
   * a web framework's middleware.
   *
   * @param request The request object.
   * @param parameters The parameters for handling the request.
   * @returns The response to the request.
   */
  fetch(request: Request, options: FederationFetchOptions<TContextData>): Promise<Response>;
}
/**
 * A builder for creating a {@link Federation} object. It defers the actual
 * instantiation of the {@link Federation} object until the {@link build}
 * method is called so that dispatchers and listeners can be registered
 * before the {@link Federation} object is instantiated.
 * @template TContextData The context data to pass to the {@link Context}.
 * @since 1.6.0
 */

/**
 * Additional settings for the actor dispatcher.
 *
 * ``` typescript
 * const federation = createFederation<void>({ ... });
 * federation
 *   .setActorDispatcher("/users/{identifier}", async (ctx, identifier) => {
 *     // ...
 *   })
 *   .setKeyPairsDispatcher(async (ctxData, identifier) => {
 *     // ...
 *   });
 * ```
 */
interface ActorCallbackSetters<TContextData> {
  /**
   * Sets the key pairs dispatcher for actors.
   * @param dispatcher A callback that returns the key pairs for an actor.
   * @returns The setters object so that settings can be chained.
   * @since 0.10.0
   */
  setKeyPairsDispatcher(dispatcher: ActorKeyPairsDispatcher<TContextData>): ActorCallbackSetters<TContextData>;
  /**
   * Sets the callback function that maps a WebFinger username to
   * the corresponding actor's identifier.  If it's omitted, the identifier
   * is assumed to be the same as the WebFinger username, which makes your
   * actors have the immutable handles.  If you want to let your actors change
   * their fediverse handles, you should set this dispatcher.
   * @param mapper A callback that maps a WebFinger username to
   *               the corresponding actor's identifier.
   * @returns The setters object so that settings can be chained.
   * @since 0.15.0
   */
  mapHandle(mapper: ActorHandleMapper<TContextData>): ActorCallbackSetters<TContextData>;
  /**
   * Sets the callback function that maps a WebFinger query to the corresponding
   * actor's identifier or username.  If it's omitted, the WebFinger handler
   * only supports the actor URIs and `acct:` URIs.  If you want to support
   * other queries, you should set this dispatcher.
   * @param mapper A callback that maps a WebFinger query to the corresponding
   *               actor's identifier or username.
   * @returns The setters object so that settings can be chained.
   * @since 1.4.0
   */
  mapAlias(mapper: ActorAliasMapper<TContextData>): ActorCallbackSetters<TContextData>;
  /**
   * Specifies the conditions under which requests are authorized.
   * @param predicate A callback that returns whether a request is authorized.
   * @returns The setters object so that settings can be chained.
   * @since 0.7.0
   */
  authorize(predicate: AuthorizePredicate<TContextData>): ActorCallbackSetters<TContextData>;
}
/**
 * Additional settings for an object dispatcher.
 */
interface ObjectCallbackSetters<TContextData, TObject extends Object$1, TParam extends string> {
  /**
   * Specifies the conditions under which requests are authorized.
   * @param predicate A callback that returns whether a request is authorized.
   * @returns The setters object so that settings can be chained.
   * @since 0.7.0
   */
  authorize(predicate: ObjectAuthorizePredicate<TContextData, TParam>): ObjectCallbackSetters<TContextData, TObject, TParam>;
}
/**
 * Additional settings for a collection dispatcher.
 *
 * @template TContext The type of the context.  {@link Context} or
 *                     {@link RequestContext}.
 * @template TContextData The context data to pass to the {@link Context}.
 * @template TFilter The type of filter for the collection.
 */
interface CollectionCallbackSetters<TContext extends Context<TContextData>, TContextData, TFilter> {
  /**
   * Sets the counter for the collection.
   * @param counter A callback that returns the number of items in the collection.
   * @returns The setters object so that settings can be chained.
   */
  setCounter(counter: CollectionCounter<TContextData, TFilter>): CollectionCallbackSetters<TContext, TContextData, TFilter>;
  /**
   * Sets the first cursor for the collection.
   * @param cursor The cursor for the first item in the collection.
   * @returns The setters object so that settings can be chained.
   */
  setFirstCursor(cursor: CollectionCursor<TContext, TContextData, TFilter>): CollectionCallbackSetters<TContext, TContextData, TFilter>;
  /**
   * Sets the last cursor for the collection.
   * @param cursor The cursor for the last item in the collection.
   * @returns The setters object so that settings can be chained.
   */
  setLastCursor(cursor: CollectionCursor<TContext, TContextData, TFilter>): CollectionCallbackSetters<TContext, TContextData, TFilter>;
  /**
   * Specifies the conditions under which requests are authorized.
   * @param predicate A callback that returns whether a request is authorized.
   * @returns The setters object so that settings can be chained.
   * @since 0.7.0
   */
  authorize(predicate: AuthorizePredicate<TContextData>): CollectionCallbackSetters<TContext, TContextData, TFilter>;
}
/**
 * The strategy for handling activity idempotency in inbox processing.
 *
 *  -  `"global"`: Activities are deduplicated globally across all inboxes and
 *     origins.  The same activity ID will be processed only once, regardless
 *     of which inbox receives it or which server sent it.
 *
 *  -  `"per-origin"`: Activities are deduplicated per receiving server's origin.
 *     The same activity ID will be processed only once on each receiving server,
 *     but can be processed separately on different receiving servers. This was
 *     the default behavior in Fedify 1.x versions.
 *
 *  -  `"per-inbox"`: Activities are deduplicated per inbox. The same activity
 *     ID can be processed once per inbox, allowing the same activity to be
 *     delivered to multiple inboxes independently.  This follows standard
 *     ActivityPub behavior and will be the default in Fedify 2.0.
 *
 * @since 1.9.0
 */
type IdempotencyStrategy = "global" | "per-origin" | "per-inbox";
/**
 * A callback to generate a custom idempotency key for an activity.
 * Returns the cache key to use, or null to skip idempotency checking.
 * @template TContextData The context data to pass to the {@link InboxContext}.
 * @param ctx The inbox context.
 * @param activity The activity being processed.
 * @returns The idempotency key to use for caching, or null to skip caching.
 * @since 1.9.0
 */
type IdempotencyKeyCallback<TContextData> = (ctx: InboxContext<TContextData>, activity: Activity) => string | null | Promise<string | null>;
/**
 * Registry for inbox listeners for different activity types.
 */
interface InboxListenerSetters<TContextData> {
  /**
   * Registers a listener for a specific incoming activity type.
   *
   * @param type A subclass of {@link Activity} to listen to.
   * @param listener A callback to handle an incoming activity.
   * @returns The setters object so that settings can be chained.
   */
  on<TActivity extends Activity>(type: new (...args: any[]) => TActivity, listener: InboxListener<TContextData, TActivity>): InboxListenerSetters<TContextData>;
  /**
   * Registers an error handler for inbox listeners.  Any exceptions thrown
   * from the listeners are caught and passed to this handler.
   *
   * @param handler A callback to handle an error.
   * @returns The setters object so that settings can be chained.
   */
  onError(handler: InboxErrorHandler<TContextData>): InboxListenerSetters<TContextData>;
  /**
   * Configures a callback to dispatch the key pair for the authenticated
   * document loader of the {@link Context} passed to the shared inbox listener.
   *
   * @param dispatcher A callback to dispatch the key pair for the authenticated
   *                   document loader.
   * @returns The setters object so that settings can be chained.
   * @since 0.11.0
   */
  setSharedKeyDispatcher(dispatcher: SharedInboxKeyDispatcher<TContextData>): InboxListenerSetters<TContextData>;
  /**
   * Configures the strategy for handling activity idempotency in inbox processing.
   *
   * @example
   * Use per-inbox strategy (standard ActivityPub behavior):
   * ```
   * federation
   *   .setInboxListeners("/users/{identifier}/inbox", "/inbox")
   *   .withIdempotency("per-inbox");
   * ```
   *
   * Use custom strategy:
   * ```
   * federation
   *   .setInboxListeners("/users/{identifier}/inbox", "/inbox")
   *   .withIdempotency((ctx, activity) => {
   *     // Return null to skip idempotency
   *     return `${ctx.origin}:${activity.id?.href}:${ctx.recipient}`;
   *   });
   * ```
   *
   * @param strategy The idempotency strategy to use. Can be:
   *   - `"global"`: Activities are deduplicated across all inboxes and origins
   *   - `"per-origin"`: Activities are deduplicated per inbox origin
   *   - `"per-inbox"`: Activities are deduplicated per inbox
   *   - A custom callback function that returns the cache key to use
   * @returns The setters object so that settings can be chained.
   * @since 1.9.0
   */
  withIdempotency(strategy: IdempotencyStrategy | IdempotencyKeyCallback<TContextData>): InboxListenerSetters<TContextData>;
}
/**
 * Parameters of {@link Federation.fetch} method.
 *
 * @template TContextData The context data to pass to the {@link Context}.
 * @since 0.6.0
 */
interface FederationFetchOptions<TContextData> {
  /**
   * The context data to pass to the {@link Context}.
   */
  contextData: TContextData;
  /**
   * A callback to handle a request when the route is not found.
   * If not provided, a 404 response is returned.
   * @param request The request object.
   * @returns The response to the request.
   */
  onNotFound?: (request: Request) => Response | Promise<Response>;
  /**
   * A callback to handle a request when the request's `Accept` header is not
   * acceptable.  If not provided, a 406 response is returned.
   * @param request The request object.
   * @returns The response to the request.
   */
  onNotAcceptable?: (request: Request) => Response | Promise<Response>;
  /**
   * A callback to handle a request when the request is unauthorized.
   * If not provided, a 401 response is returned.
   * @param request The request object.
   * @returns The response to the request.
   * @since 0.7.0
   */
  onUnauthorized?: (request: Request) => Response | Promise<Response>;
}
/**
 * Additional settings for a custom collection dispatcher.
 *
 * @template TParam The type of the parameters in the URL path.
 * @template TContext The type of the context.  {@link Context} or
 *                     {@link RequestContext}.
 * @template TContextData The context data to pass to the {@link Context}.
 * @template TFilter The type of filter for the collection.
 */
interface CustomCollectionCallbackSetters<TParam extends string, TContext extends Context<TContextData>, TContextData> {
  /**
   * Sets the counter for the custom collection.
   * @param counter A callback that returns the number of items in the custom collection.
   * @returns The setters object so that settings can be chained.
   */
  setCounter(counter: CustomCollectionCounter<TParam, TContextData>): CustomCollectionCallbackSetters<TParam, TContext, TContextData>;
  /**
   * Sets the first cursor for the custom collection.
   * @param cursor The cursor for the first item in the custom collection.
   * @returns The setters object so that settings can be chained.
   */
  setFirstCursor(cursor: CustomCollectionCursor<TParam, TContext, TContextData>): CustomCollectionCallbackSetters<TParam, TContext, TContextData>;
  /**
   * Sets the last cursor for the custom collection.
   * @param cursor The cursor for the last item in the custom collection.
   * @returns The setters object so that settings can be chained.
   */
  setLastCursor(cursor: CustomCollectionCursor<TParam, TContext, TContextData>): CustomCollectionCallbackSetters<TParam, TContext, TContextData>;
  /**
   * Specifies the conditions under which requests are authorized.
   * @param predicate A callback that returns whether a request is authorized.
   * @returns The setters object so that settings can be chained.
   * @since 0.7.0
   */
  authorize(predicate: ObjectAuthorizePredicate<TContextData, string>): CustomCollectionCallbackSetters<TParam, TContext, TContextData>;
}
/**
 * Represents an object with a type ID, which is either a constructor or an
 * instance of the object.
 *
 * @template TObject The type of the object.
 */
type ConstructorWithTypeId<TObject extends Object$1> = (new (...args: any[]) => TObject) & {
  typeId: URL;
};
/**
 * Defines a union of all valid RFC 6570 URI Template expressions for a given
 * parameter name.
 *
 * RFC 6570 specifies a syntax for URI templates, allowing for variable
 * expansion. This type captures all Level 1-4 operator expressions for a
 * single, named variable.
 *
 * The supported expression types are:
 * - `{Param}`: Simple string expansion
 * - `+{Param}`: Reserved string expansion
 * - `#{Param}`: Fragment expansion
 * - `{.Param}`: Label expansion with a dot-prefix
 * - `{/Param}`: Path segment expansion
 * - `{;Param}`: Path-style parameter expansion
 * - `{?Param}`: Query component expansion
 * - `{&Param}`: Query continuation expansion
 *
 * @template Param The name of the parameter to be used in the expressions.
 * @example
 * ```ts
 * type UserIdExpression = Rfc6570Expression<"userId">;
 *
 * // The variable `userPath` can be assigned any of the valid expressions.
 * const userPath: UserIdExpression = "{/userId}";
 * ```
 * @see {@link https://tools.ietf.org/html/rfc6570} for the full specification.
 */
type Rfc6570Expression<Param extends string> = `{${Param}}` | `{+${Param}}` | `{#${Param}}` | `{.${Param}}` | `{/${Param}}` | `{;${Param}}` | `{?${Param}}` | `{&${Param}}`;
//#endregion
//#region src/federation/context.d.ts
/**
 * A context.
 */
interface Context<TContextData> {
  /**
   * The origin of the federated server, including the scheme (`http://` or
   * `https://`) and the host (e.g., `example.com:8080`).
   * @since 0.12.0
   */
  readonly origin: string;
  /**
   * The canonical origin of the federated server, including the scheme
   * (`http://` or `https://`) and the host (e.g., `example.com:8080`).
   *
   * When the associated {@link Federation} object does not have any explicit
   * canonical origin, it is the same as the {@link Context.origin}.
   * @since 1.5.0
   */
  readonly canonicalOrigin: string;
  /**
   * The host of the federated server, including the hostname
   * (e.g., `example.com`) and the port following a colon (e.g., `:8080`)
   * if it is not the default port for the scheme.
   * @since 0.12.0
   */
  readonly host: string;
  /**
   * The hostname of the federated server (e.g., `example.com`).  This is
   * the same as the host without the port.
   * @since 0.12.0
   */
  readonly hostname: string;
  /**
   * The user-defined data associated with the context.
   */
  readonly data: TContextData;
  /**
   * The OpenTelemetry tracer provider.
   * @since 1.3.0
   */
  readonly tracerProvider: TracerProvider;
  /**
   * The document loader for loading remote JSON-LD documents.
   */
  readonly documentLoader: DocumentLoader;
  /**
   * The context loader for loading remote JSON-LD contexts.
   */
  readonly contextLoader: DocumentLoader;
  /**
   * The federation object that this context belongs to.
   * @since 1.6.0
   */
  readonly federation: Federation<TContextData>;
  /**
   * Creates a new context with the same properties as this one,
   * but with the given data.
   * @param data The new data to associate with the context.
   * @returns A new context with the same properties as this one,
   *          but with the given data.
   * @since 1.6.0
   */
  clone(data: TContextData): Context<TContextData>;
  /**
   * Builds the URI of the NodeInfo document.
   * @returns The NodeInfo URI.
   * @throws {RouterError} If no NodeInfo dispatcher is available.
   * @since 0.2.0
   */
  getNodeInfoUri(): URL;
  /**
   * Builds the URI of an actor with the given identifier.
   * @param identifier The actor's identifier.
   * @returns The actor's URI.
   * @throws {RouterError} If no actor dispatcher is available.
   */
  getActorUri(identifier: string): URL;
  /**
   * Builds the URI of an object with the given class and values.
   * @param cls The class of the object.
   * @param values The values to pass to the object dispatcher.
   * @returns The object's URI.
   * @throws {RouteError} If no object dispatcher is available for the class.
   * @throws {TypeError} If values are invalid.
   * @since 0.7.0
   */
  getObjectUri<TObject extends Object$1>(cls: ConstructorWithTypeId<TObject>, values: Record<string, string>): URL;
  /**
   * Builds the URI of an actor's outbox with the given identifier.
   * @param identifier The actor's identifier.
   * @returns The actor's outbox URI.
   * @throws {RouterError} If no outbox dispatcher is available.
   */
  getOutboxUri(identifier: string): URL;
  /**
   * Builds the URI of the shared inbox.
   * @returns The shared inbox URI.
   * @throws {RouterError} If no inbox listener is available.
   */
  getInboxUri(): URL;
  /**
   * Builds the URI of an actor's inbox with the given identifier.
   * @param identifier The actor's identifier.
   * @returns The actor's inbox URI.
   * @throws {RouterError} If no inbox listener is available.
   */
  getInboxUri(identifier: string): URL;
  /**
   * Builds the URI of an actor's following collection with the given
   * identifier.
   * @param identifier The actor's identifier.
   * @returns The actor's following collection URI.
   * @throws {RouterError} If no following collection is available.
   */
  getFollowingUri(identifier: string): URL;
  /**
   * Builds the URI of an actor's followers collection with the given
   * identifier.
   * @param identifier The actor's identifier.
   * @returns The actor's followers collection URI.
   * @throws {RouterError} If no followers collection is available.
   */
  getFollowersUri(identifier: string): URL;
  /**
   * Builds the URI of an actor's liked collection with the given identifier.
   * @param identifier The actor's identifier.
   * @returns The actor's liked collection URI.
   * @throws {RouterError} If no liked collection is available.
   * @since 0.11.0
   */
  getLikedUri(identifier: string): URL;
  /**
   * Builds the URI of an actor's featured collection with the given identifier.
   * @param identifier The actor's identifier.
   * @returns The actor's featured collection URI.
   * @throws {RouterError} If no featured collection is available.
   * @since 0.11.0
   */
  getFeaturedUri(identifier: string): URL;
  /**
   * Builds the URI of an actor's featured tags collection with the given
   * identifier.
   * @param identifier The actor's identifier.
   * @returns The actor's featured tags collection URI.
   * @throws {RouterError} If no featured tags collection is available.
   * @since 0.11.0
   */
  getFeaturedTagsUri(identifier: string): URL;
  /**
   * Determines the type of the URI and extracts the associated data.
   * @param uri The URI to parse.
   * @returns The result of parsing the URI.  If `null` is given or
   *          the URI is not recognized, `null` is returned.
   * @since 0.9.0
   */
  parseUri(uri: URL | null): ParseUriResult | null;
  /**
   * Gets the key pairs for an actor.
   * @param identifier The actor's identifier.
   * @returns An async iterable of the actor's key pairs.  It can be empty.
   * @since 0.10.0
   */
  getActorKeyPairs(identifier: string): Promise<ActorKeyPair[]>;
  /**
   * Gets an authenticated {@link DocumentLoader} for the given identity.
   * Note that an authenticated document loader intentionally does not cache
   * the fetched documents.
   * @param identity The identity to get the document loader for.
   *                 The actor's identifier or username.
   * @returns The authenticated document loader.
   * @throws {Error} If the identity is not valid.
   * @throws {TypeError} If the key is invalid or unsupported.
   * @since 0.4.0
   */
  getDocumentLoader(identity: {
    identifier: string;
  } | {
    username: string;
  } | {
    handle: string;
  }): Promise<DocumentLoader>;
  /**
   * Gets an authenticated {@link DocumentLoader} for the given identity.
   * Note that an authenticated document loader intentionally does not cache
   * the fetched documents.
   * @param identity The identity to get the document loader for.
   *                 The actor's key pair.
   * @returns The authenticated document loader.
   * @throws {TypeError} If the key is invalid or unsupported.
   * @since 0.4.0
   */
  getDocumentLoader(identity: {
    keyId: URL;
    privateKey: CryptoKey;
  }): DocumentLoader;
  /**
   * Looks up an ActivityStreams object by its URI (including `acct:` URIs)
   * or a fediverse handle (e.g., `@user@server` or `user@server`).
   *
   * @example
   * ``` typescript
   * // Look up an actor by its fediverse handle:
   * await ctx.lookupObject("@hongminhee@fosstodon.org");
   * // returning a `Person` object.
   *
   * // A fediverse handle can omit the leading '@':
   * await ctx.lookupObject("hongminhee@fosstodon.org");
   * // returning a `Person` object.
   *
   * // A `acct:` URI can be used as well:
   * await ctx.lookupObject("acct:hongminhee@fosstodon.org");
   * // returning a `Person` object.
   *
   * // Look up an object by its URI:
   * await ctx.lookupObject("https://todon.eu/@hongminhee/112060633798771581");
   * // returning a `Note` object.
   *
   * // It can be a `URL` object as well:
   * await ctx.lookupObject(
   *   new URL("https://todon.eu/@hongminhee/112060633798771581")
   * );
   * // returning a `Note` object.
   * ```
   *
   * It's almost the same as the {@link lookupObject} function, but it uses
   * the context's document loader and context loader by default.
   *
   * @param identifier The URI or fediverse handle to look up.
   * @param options Lookup options.
   * @returns The object, or `null` if not found.
   * @since 0.15.0
   */
  lookupObject(identifier: string | URL, options?: LookupObjectOptions): Promise<Object$1 | null>;
  /**
   * Traverses a collection, yielding each item in the collection.
   * If the collection is paginated, it will fetch the next page
   * automatically.
   *
   * @example
   * ``` typescript
   * const collection = await ctx.lookupObject(collectionUrl);
   * if (collection instanceof Collection) {
   *   for await (const item of ctx.traverseCollection(collection)) {
   *     console.log(item.id?.href);
   *   }
   * }
   * ```
   *
   * It's almost the same as the {@link traverseCollection} function, but it
   * uses the context's document loader and context loader by default.
   * @param collection The collection to traverse.
   * @param options Options for traversing the collection.
   * @returns An async iterable of each item in the collection.
   * @since 1.1.0
   */
  traverseCollection(collection: Collection, options?: TraverseCollectionOptions): AsyncIterable<Object$1 | Link>;
  /**
   * Fetches the NodeInfo document from the given URL.
   * @param url The base URL of the server.  If `options.direct` is turned off
   *            (default), the NodeInfo document will be fetched from
   *            the `.well-known` location of this URL (hence the only origin
   *            of the URL is used).  If `options.direct` is turned on,
   *            the NodeInfo document will be fetched from the given URL.
   * @param options Options for fetching the NodeInfo document.
   * @returns The NodeInfo document if it could be fetched successfully.
   *          Otherwise, `undefined` is returned.
   * @since 1.4.0
   */
  lookupNodeInfo(url: URL | string, options?: GetNodeInfoOptions & {
    parse?: "strict" | "best-effort";
  }): Promise<NodeInfo | undefined>;
  /**
   * Fetches the NodeInfo document from the given URL.
   * @param url The base URL of the server.  If `options.direct` is turned off
   *            (default), the NodeInfo document will be fetched from
   *            the `.well-known` location of this URL (hence the only origin
   *            of the URL is used).  If `options.direct` is turned on,
   *            the NodeInfo document will be fetched from the given URL.
   * @param options Options for fetching the NodeInfo document.
   * @returns The NodeInfo document if it could be fetched successfully.
   *          Otherwise, `undefined` is returned.
   * @since 1.4.0
   */
  lookupNodeInfo(url: URL | string, options?: GetNodeInfoOptions & {
    parse: "none";
  }): Promise<JsonValue | undefined>;
  /**
   * Looks up a WebFinger resource.
   *
   * It's almost the same as the {@link lookupWebFinger} function, but it uses
   * the context's configuration by default.
   *
   * @param resource The resource URL to look up.
   * @param options Extra options for looking up the resource.
   * @returns The resource descriptor, or `null` if not found.
   * @since 1.6.0
   */
  lookupWebFinger(resource: URL | string, options?: LookupWebFingerOptions): Promise<ResourceDescriptor | null>;
  /**
   * Sends an activity to recipients' inboxes.
   * @param sender The sender's identifier or the sender's username or
   *               the sender's key pair(s).
   * @param recipients The recipients of the activity.
   * @param activity The activity to send.
   * @param options Options for sending the activity.
   */
  sendActivity(sender: SenderKeyPair | SenderKeyPair[] | {
    identifier: string;
  } | {
    username: string;
  } | {
    handle: string;
  }, recipients: Recipient | Recipient[], activity: Activity, options?: SendActivityOptions): Promise<void>;
  /**
   * Sends an activity to the outboxes of the sender's followers.
   * @param sender The sender's identifier or the sender's username.
   * @param recipients In this case, it must be `"followers"`.
   * @param activity The activity to send.
   * @param options Options for sending the activity.
   * @throws {Error} If no followers collection is registered.
   * @since 0.14.0
   */
  sendActivity(sender: {
    identifier: string;
  } | {
    username: string;
  } | {
    handle: string;
  }, recipients: "followers", activity: Activity, options?: SendActivityOptionsForCollection): Promise<void>;
  /**
   * Manually routes an activity to the appropriate inbox listener.
   *
   * It is useful for routing an activity that is not received from the network,
   * or for routing an activity that is enclosed in another activity.
   *
   * Note that the activity will be verified if it has Object Integrity Proofs
   * or is equivalent to the actual remote object.  If the activity is not
   * verified, it will be rejected.
   * @param recipient The recipient of the activity.  If it is `null`,
   *                  the activity will be routed to the shared inbox.
   *                  Otherwise, the activity will be routed to the personal
   *                  inbox of the recipient with the given identifier.
   * @param activity The activity to route.  It must have a proof or
   *                 a dereferenceable `id` to verify the activity.
   * @param options Options for routing the activity.
   * @returns `true` if the activity is successfully verified and routed.
   *          Otherwise, `false`.
   * @since 1.3.0
   */
  routeActivity(recipient: string | null, activity: Activity, options?: RouteActivityOptions): Promise<boolean>;
  /**
   * Builds the URI of a collection of objects with the given name and values.
   * @param name The name of the collection, which can be a string or a symbol.
   * @param values The values of the URI parameters.
   * @return The URI of the collection.
   * @throws {RouteError} If no object dispatcher is available for the name.
   * @throws {TypeError} If values are invalid.
   * @since 1.8.0
   */
  getCollectionUri<TParam extends Record<string, string>>(name: string | symbol, values: TParam): URL;
}
/**
 * A context for a request.
 */
interface RequestContext<TContextData> extends Context<TContextData> {
  /**
   * The request object.
   */
  readonly request: Request;
  /**
   * The URL of the request.
   */
  readonly url: URL;
  /**
   * Creates a new context with the same properties as this one,
   * but with the given data.
   * @param data The new data to associate with the context.
   * @returns A new context with the same properties as this one,
   *          but with the given data.
   * @since 1.6.0
   */
  clone(data: TContextData): RequestContext<TContextData>;
  /**
   * Gets an {@link Actor} object for the given identifier.
   * @param identifier The actor's identifier.
   * @returns The actor object, or `null` if the actor is not found.
   * @throws {Error} If no actor dispatcher is available.
   * @since 0.7.0
   */
  getActor(identifier: string): Promise<Actor | null>;
  /**
   * Gets an object of the given class with the given values.
   * @param cls The class to instantiate.
   * @param values The values to pass to the object dispatcher.
   * @returns The object of the given class with the given values, or `null`
   *          if the object is not found.
   * @throws {Error} If no object dispatcher is available for the class.
   * @throws {TypeError} If values are invalid.
   * @since 0.7.0
   */
  getObject<TObject extends Object$1>(cls: ConstructorWithTypeId<TObject>, values: Record<string, string>): Promise<TObject | null>;
  /**
   * Gets the public key of the sender, if any exists and it is verified.
   * Otherwise, `null` is returned.
   *
   * This can be used for implementing [authorized fetch] (also known as
   * secure mode) in ActivityPub.
   *
   * [authorized fetch]: https://swicg.github.io/activitypub-http-signature/#authorized-fetch
   *
   * @returns The public key of the sender, or `null` if the sender is not verified.
   * @since 0.7.0
   */
  getSignedKey(): Promise<CryptographicKey | null>;
  /**
   * Gets the public key of the sender, if any exists and it is verified.
   * Otherwise, `null` is returned.
   *
   * This can be used for implementing [authorized fetch] (also known as
   * secure mode) in ActivityPub.
   *
   * [authorized fetch]: https://swicg.github.io/activitypub-http-signature/#authorized-fetch
   *
   * @param options Options for getting the signed key. You usually may want to
   *                specify the custom `documentLoader` so that making
   *                an HTTP request to the sender's server is signed with
   *                your [instance actor].
   * @returns The public key of the sender, or `null` if the sender is not verified.
   * @since 1.5.0
   *
   * [instance actor]: https://swicg.github.io/activitypub-http-signature/#instance-actor
   */
  getSignedKey(options: GetSignedKeyOptions): Promise<CryptographicKey | null>;
  /**
   * Gets the owner of the signed key, if any exists and it is verified.
   * Otherwise, `null` is returned.
   *
   * This can be used for implementing [authorized fetch] (also known as
   * secure mode) in ActivityPub.
   *
   * [authorized fetch]: https://swicg.github.io/activitypub-http-signature/#authorized-fetch
   *
   * @returns The owner of the signed key, or `null` if the key is not verified
   *          or the owner is not found.
   * @since 0.7.0
   */
  getSignedKeyOwner(): Promise<Actor | null>;
  /**
   * Gets the owner of the signed key, if any exists and it is verified.
   * Otherwise, `null` is returned.
   *
   * This can be used for implementing [authorized fetch] (also known as
   * secure mode) in ActivityPub.
   *
   * [authorized fetch]: https://swicg.github.io/activitypub-http-signature/#authorized-fetch
   *
   * @param options Options for getting the key owner. You usually may want to
   *                specify the custom `documentLoader` so that making
   *                an HTTP request to the key owner's server is signed with
   *                your [instance actor].
   * @returns The owner of the signed key, or `null` if the key is not verified
   *          or the owner is not found.
   * @since 1.5.0
   *
   * [instance actor]: https://swicg.github.io/activitypub-http-signature/#instance-actor
   */
  getSignedKeyOwner(options: GetKeyOwnerOptions): Promise<Actor | null>;
}
/**
 * A context for inbox listeners.
 * @since 1.0.0
 */
interface InboxContext<TContextData> extends Context<TContextData> {
  /**
   * The identifier of the recipient of the inbox.  If the inbox is a shared
   * inbox, it is `null`.
   * @since 1.2.0
   */
  recipient: string | null;
  /**
   * Creates a new context with the same properties as this one,
   * but with the given data.
   * @param data The new data to associate with the context.
   * @returns A new context with the same properties as this one,
   *          but with the given data.
   * @since 1.6.0
   */
  clone(data: TContextData): InboxContext<TContextData>;
  /**
   * Forwards a received activity to the recipients' inboxes.  The forwarded
   * activity will be signed in HTTP Signatures by the forwarder, but its
   * payload will not be modified, i.e., Linked Data Signatures and Object
   * Integrity Proofs will not be added.  Therefore, if the activity is not
   * signed (i.e., it has neither Linked Data Signatures nor Object Integrity
   * Proofs), the recipient probably will not trust the activity.
   * @param forwarder The forwarder's identifier or the forwarder's username
   *                  or the forwarder's key pair(s).
   * @param recipients The recipients of the activity.
   * @param options Options for forwarding the activity.
   * @since 1.0.0
   */
  forwardActivity(forwarder: SenderKeyPair | SenderKeyPair[] | {
    identifier: string;
  } | {
    username: string;
  } | {
    handle: string;
  }, recipients: Recipient | Recipient[], options?: ForwardActivityOptions): Promise<void>;
  /**
   * Forwards a received activity to the recipients' inboxes.  The forwarded
   * activity will be signed in HTTP Signatures by the forwarder, but its
   * payload will not be modified, i.e., Linked Data Signatures and Object
   * Integrity Proofs will not be added.  Therefore, if the activity is not
   * signed (i.e., it has neither Linked Data Signatures nor Object Integrity
   * Proofs), the recipient probably will not trust the activity.
   * @param forwarder The forwarder's identifier or the forwarder's username.
   * @param recipients In this case, it must be `"followers"`.
   * @param options Options for forwarding the activity.
   * @since 1.0.0
   */
  forwardActivity(forwarder: {
    identifier: string;
  } | {
    username: string;
  } | {
    handle: string;
  }, recipients: "followers", options?: ForwardActivityOptions): Promise<void>;
}
/**
 * A result of parsing an URI.
 */
type ParseUriResult =
/**
 * The case of an actor URI.
 */
{
  readonly type: "actor";
  readonly identifier: string;
  readonly handle: string;
}
/**
 * The case of an object URI.
 */ | {
  readonly type: "object";
  readonly class: ConstructorWithTypeId<Object$1>;
  readonly typeId: URL;
  readonly values: Record<string, string>;
}
/**
 * The case of an shared inbox URI.
 */ | {
  readonly type: "inbox";
  readonly identifier: undefined;
  readonly handle: undefined;
}
/**
 * The case of an personal inbox URI.
 */ | {
  readonly type: "inbox";
  readonly identifier: string;
  readonly handle: string;
}
/**
 * The case of an outbox collection URI.
 */ | {
  readonly type: "outbox";
  readonly identifier: string;
  readonly handle: string;
}
/**
 * The case of a following collection URI.
 */ | {
  readonly type: "following";
  readonly identifier: string;
  readonly handle: string;
}
/**
 * The case of a followers collection URI.
 */ | {
  readonly type: "followers";
  readonly identifier: string;
  readonly handle: string;
}
/**
 * The case of a liked collection URI.
 * @since 0.11.0
 */ | {
  readonly type: "liked";
  readonly identifier: string;
  readonly handle: string;
}
/**
 * The case of a featured collection URI.
 * @since 0.11.0
 */ | {
  readonly type: "featured";
  readonly identifier: string;
  readonly handle: string;
}
/**
 * The case of a featured tags collection URI.
 * @since 0.11.0
 */ | {
  readonly type: "featuredTags";
  readonly identifier: string;
  readonly handle: string;
}
/**
 * The case of a custom collection URI.
 * @since 1.8.0
 */ | {
  readonly type: "collection";
  readonly name: string | symbol;
  readonly class: ConstructorWithTypeId<Object$1>;
  readonly typeId: URL;
  readonly values: Record<string, string>;
}
/**
 * The case of a custom ordered collection URI.
 * @since 1.8.0
 */ | {
  readonly type: "orderedCollection";
  readonly name: string | symbol;
  readonly class: ConstructorWithTypeId<Object$1>;
  readonly typeId: URL;
  readonly values: Record<string, string>;
};
/**
 * Options for {@link Context.sendActivity} method.
 */
interface SendActivityOptions {
  /**
   * Whether to prefer the shared inbox for the recipients.
   */
  preferSharedInbox?: boolean;
  /**
   * Whether to send the activity immediately, without enqueuing it.
   * If `true`, the activity will be sent immediately and the retrial
   * policy will not be applied.
   *
   * @since 0.3.0
   */
  immediate?: boolean;
  /**
   * Determines how activities are queued when sent to multiple recipients.
   *
   * - "auto" (default): Automatically chooses optimal strategy based on
   *   recipient count.
   * - "skip": Always enqueues individual messages per recipient,
   *   bypassing the fanout queue. Use when payload needs to vary per recipient.
   * - "force": Always uses fanout queue regardless of recipient count.
   *   Useful for testing or special cases.
   *
   * This option is ignored when `immediate: true` is specified, as immediate
   * delivery bypasses all queuing mechanisms.
   *
   * @default `"auto"`
   * @since 1.5.0
   */
  fanout?: "auto" | "skip" | "force";
  /**
   * The base URIs to exclude from the recipients' inboxes.  It is useful
   * for excluding the recipients having the same shared inbox with the sender.
   *
   * Note that the only `origin` parts of the `URL`s are compared.
   *
   * @since 0.9.0
   */
  excludeBaseUris?: URL[];
}
/**
 * Options for {@link Context.sendActivity} method when sending to a collection.
 * @since 1.5.0
 */
interface SendActivityOptionsForCollection extends SendActivityOptions {
  /**
   * Whether to synchronize the collection using `Collection-Synchronization`
   * header ([FEP-8fcf]).
   *
   * [FEP-8fcf]: https://w3id.org/fep/8fcf
   */
  syncCollection?: boolean;
}
/**
 * Options for {@link InboxContext.forwardActivity} method.
 * @since 1.0.0
 */
type ForwardActivityOptions = Omit<SendActivityOptions, "fanout"> & {
  /**
   * Whether to skip forwarding the activity if it is not signed, i.e., it has
   * neither Linked Data Signatures nor Object Integrity Proofs.
   *
   * If the activity is not signed, the recipient probably will not trust the
   * activity.  Therefore, it is recommended to skip forwarding the activity
   * if it is not signed.
   */
  skipIfUnsigned: boolean;
};
/**
 * Options for {@link Context.routeActivity} method.
 * @since 1.3.0
 */
interface RouteActivityOptions {
  /**
   * Whether to skip enqueuing the activity and invoke the listener immediately.
   * If no inbox queue is available, this option is ignored and the activity
   * will be always invoked immediately.
   * @default false
   */
  immediate?: boolean;
  /**
   * The document loader for loading remote JSON-LD documents.
   */
  documentLoader?: DocumentLoader;
  /**
   * The context loader for loading remote JSON-LD contexts.
   */
  contextLoader?: DocumentLoader;
  /**
   * The OpenTelemetry tracer provider.  If omitted, the global tracer provider
   * is used.
   */
  tracerProvider?: TracerProvider;
}
/**
 * Options for {@link Context.getSignedKey} method.
 * @since 1.5.0
 */
interface GetSignedKeyOptions {
  /**
   * The document loader for loading remote JSON-LD documents.
   */
  documentLoader?: DocumentLoader;
  /**
   * The context loader for loading remote JSON-LD contexts.
   */
  contextLoader?: DocumentLoader;
  /**
   * The OpenTelemetry tracer provider.  If omitted, the global tracer provider
   * is used.
   */
  tracerProvider?: TracerProvider;
}
/**
 * A pair of a public key and a private key in various formats.
 * @since 0.10.0
 */
interface ActorKeyPair extends CryptoKeyPair {
  /**
   * The URI of the public key, which is used for verifying HTTP Signatures.
   */
  keyId: URL;
  /**
   * A {@link CryptographicKey} instance of the public key.
   */
  cryptographicKey: CryptographicKey;
  /**
   * A {@link Multikey} instance of the public key.
   */
  multikey: Multikey;
}
//#endregion
//#region src/testing/context.d.ts
declare function createRequestContext<TContextData>(args: Partial<RequestContext<TContextData>> & {
  url: URL;
  data: TContextData;
  federation: Federation<TContextData>;
}): RequestContext<TContextData>;
declare function createInboxContext<TContextData>(args: Partial<InboxContext<TContextData>> & {
  url?: URL;
  data: TContextData;
  recipient?: string | null;
  federation: Federation<TContextData>;
}): InboxContext<TContextData>;
//#endregion
//#region src/testing/mod.d.ts
declare const testDefinitions: Deno.TestDefinition[];
declare function test(options: Deno.TestDefinition): void;
declare function test(name: string, fn: (t: Deno.TestContext) => void | Promise<void>): void;
declare function test(name: string, options: Omit<Deno.TestDefinition, "fn" | "name">, fn: (t: Deno.TestContext) => void | Promise<void>): void;
//#endregion
export { createInboxContext, createRequestContext, test, testDefinitions };