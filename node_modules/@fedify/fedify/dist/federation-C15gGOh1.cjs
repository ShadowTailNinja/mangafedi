
          const { Temporal } = require("@js-temporal/polyfill");
          const { URLPattern } = require("urlpattern-polyfill");
        
const require_chunk = require('./chunk-DqRYRqnO.cjs');
const es_toolkit = require_chunk.__toESM(require("es-toolkit"));

//#region src/federation/kv.ts
/**
* A keyâ€“value store that stores values in memory.
* Do not use this in production as it does not persist values.
*
* @since 0.5.0
*/
var MemoryKvStore = class {
	#values = {};
	#encodeKey(key) {
		return JSON.stringify(key);
	}
	/**
	* {@inheritDoc KvStore.get}
	*/
	get(key) {
		const encodedKey = this.#encodeKey(key);
		const entry = this.#values[encodedKey];
		if (entry == null) return Promise.resolve(void 0);
		const [value, expiration] = entry;
		if (expiration != null && Temporal.Now.instant().until(expiration).sign < 0) {
			delete this.#values[encodedKey];
			return Promise.resolve(void 0);
		}
		return Promise.resolve(value);
	}
	/**
	* {@inheritDoc KvStore.set}
	*/
	set(key, value, options) {
		const encodedKey = this.#encodeKey(key);
		const expiration = options?.ttl == null ? null : Temporal.Now.instant().add(options.ttl.round({ largestUnit: "hour" }));
		this.#values[encodedKey] = [value, expiration];
		return Promise.resolve();
	}
	/**
	* {@inheritDoc KvStore.delete}
	*/
	delete(key) {
		const encodedKey = this.#encodeKey(key);
		delete this.#values[encodedKey];
		return Promise.resolve();
	}
	/**
	* {@inheritDoc KvStore.cas}
	*/
	cas(key, expectedValue, newValue, options) {
		const encodedKey = this.#encodeKey(key);
		const entry = this.#values[encodedKey];
		let currentValue;
		if (entry == null) currentValue = void 0;
		else {
			const [value, expiration$1] = entry;
			if (expiration$1 != null && Temporal.Now.instant().until(expiration$1).sign < 0) {
				delete this.#values[encodedKey];
				currentValue = void 0;
			} else currentValue = value;
		}
		if (!(0, es_toolkit.isEqual)(currentValue, expectedValue)) return Promise.resolve(false);
		const expiration = options?.ttl == null ? null : Temporal.Now.instant().add(options.ttl.round({ largestUnit: "hour" }));
		this.#values[encodedKey] = [newValue, expiration];
		return Promise.resolve(true);
	}
	/**
	* {@inheritDoc KvStore.list}
	*/
	async *list(prefix) {
		const now = Temporal.Now.instant();
		for (const [encodedKey, entry] of Object.entries(this.#values)) {
			const key = JSON.parse(encodedKey);
			if (prefix != null) {
				if (key.length < prefix.length) continue;
				if (!prefix.every((p, i) => key[i] === p)) continue;
			}
			const [value, expiration] = entry;
			if (expiration != null && now.until(expiration).sign < 0) {
				delete this.#values[encodedKey];
				continue;
			}
			yield {
				key,
				value
			};
		}
	}
};

//#endregion
//#region src/federation/mq.ts
/**
* A message queue that processes messages in the same process.
* Do not use this in production as it does neither persist messages nor
* distribute them across multiple processes.
*
* @since 0.5.0
*/
var InProcessMessageQueue = class {
	#messages;
	#monitors;
	#pollIntervalMs;
	/**
	* In-process message queue does not provide native retry mechanisms.
	* @since 1.7.0
	*/
	nativeRetrial = false;
	/**
	* Constructs a new {@link InProcessMessageQueue} with the given options.
	* @param options Additional options for the in-process message queue.
	*/
	constructor(options = {}) {
		this.#messages = [];
		this.#monitors = {};
		this.#pollIntervalMs = Temporal.Duration.from(options.pollInterval ?? { seconds: 5 }).total("millisecond");
	}
	enqueue(message, options) {
		const delay = options?.delay == null ? 0 : Math.max(options.delay.total("millisecond"), 0);
		if (delay > 0) {
			setTimeout(() => this.enqueue(message, {
				...options,
				delay: void 0
			}), delay);
			return Promise.resolve();
		}
		this.#messages.push(message);
		for (const monitorId in this.#monitors) this.#monitors[monitorId]();
		return Promise.resolve();
	}
	enqueueMany(messages, options) {
		if (messages.length === 0) return Promise.resolve();
		const delay = options?.delay == null ? 0 : Math.max(options.delay.total("millisecond"), 0);
		if (delay > 0) {
			setTimeout(() => this.enqueueMany(messages, {
				...options,
				delay: void 0
			}), delay);
			return Promise.resolve();
		}
		this.#messages.push(...messages);
		for (const monitorId in this.#monitors) this.#monitors[monitorId]();
		return Promise.resolve();
	}
	async listen(handler, options = {}) {
		const signal = options.signal;
		while (signal == null || !signal.aborted) {
			while (this.#messages.length > 0) {
				const message = this.#messages.shift();
				await handler(message);
			}
			await this.#wait(this.#pollIntervalMs, signal);
		}
	}
	#wait(ms, signal) {
		let timer = null;
		return Promise.any([new Promise((resolve) => {
			signal?.addEventListener("abort", () => {
				if (timer != null) clearTimeout(timer);
				resolve();
			}, { once: true });
			const monitorId = crypto.randomUUID();
			this.#monitors[monitorId] = () => {
				delete this.#monitors[monitorId];
				if (timer != null) clearTimeout(timer);
				resolve();
			};
		}), new Promise((resolve) => timer = setTimeout(resolve, ms))]);
	}
};
/**
* A message queue that processes messages in parallel.  It takes another
* {@link MessageQueue}, and processes messages in parallel up to a certain
* number of workers.
*
* Actually, it's rather a decorator than a queue itself.
*
* Note that the workers do not run in truly parallel, in the sense that they
* are not running in separate threads or processes.  They are running in the
* same process, but are scheduled to run in parallel.  Hence, this is useful
* for I/O-bound tasks, but not for CPU-bound tasks, which is okay for Fedify's
* workloads.
*
* @since 1.0.0
*/
var ParallelMessageQueue = class ParallelMessageQueue {
	queue;
	workers;
	/**
	* Inherits the native retry capability from the wrapped queue.
	* @since 1.7.0
	*/
	nativeRetrial;
	/**
	* Constructs a new {@link ParallelMessageQueue} with the given queue and
	* number of workers.
	* @param queue The message queue to use under the hood.  Note that
	*              {@link ParallelMessageQueue} cannot be nested.
	* @param workers The number of workers to process messages in parallel.
	* @throws {TypeError} If the given queue is an instance of
	*                     {@link ParallelMessageQueue}.
	*/
	constructor(queue, workers) {
		if (queue instanceof ParallelMessageQueue) throw new TypeError("Cannot nest ParallelMessageQueue.");
		this.queue = queue;
		this.workers = workers;
		this.nativeRetrial = queue.nativeRetrial;
	}
	enqueue(message, options) {
		return this.queue.enqueue(message, options);
	}
	async enqueueMany(messages, options) {
		if (this.queue.enqueueMany == null) {
			const results = await Promise.allSettled(messages.map((message) => this.queue.enqueue(message, options)));
			const errors = results.filter((r) => r.status === "rejected").map((r) => r.reason);
			if (errors.length > 1) throw new AggregateError(errors, "Failed to enqueue messages.");
			else if (errors.length === 1) throw errors[0];
			return;
		}
		await this.queue.enqueueMany(messages, options);
	}
	listen(handler, options = {}) {
		const workers = /* @__PURE__ */ new Map();
		return this.queue.listen(async (message) => {
			while (workers.size >= this.workers) {
				const consumedId = await Promise.any(workers.values());
				workers.delete(consumedId);
			}
			const workerId = crypto.randomUUID();
			const promise = this.#work(workerId, handler, message);
			workers.set(workerId, promise);
		}, options);
	}
	async #work(workerId, handler, message) {
		await this.#sleep(0);
		await handler(message);
		return workerId;
	}
	#sleep(ms) {
		return new Promise((resolve) => setTimeout(resolve, ms));
	}
};

//#endregion
Object.defineProperty(exports, 'InProcessMessageQueue', {
  enumerable: true,
  get: function () {
    return InProcessMessageQueue;
  }
});
Object.defineProperty(exports, 'MemoryKvStore', {
  enumerable: true,
  get: function () {
    return MemoryKvStore;
  }
});
Object.defineProperty(exports, 'ParallelMessageQueue', {
  enumerable: true,
  get: function () {
    return ParallelMessageQueue;
  }
});