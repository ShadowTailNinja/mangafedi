import { Temporal } from "@js-temporal/polyfill";
import { URLPattern } from "urlpattern-polyfill";
import { DocumentLoader } from "./docloader-BucCRHZI.js";
import { Span, TracerProvider } from "@opentelemetry/api";
import { LanguageTag } from "@phensley/language-tag";

//#region src/runtime/langstr.d.ts
/**
 * A language-tagged string which corresponds to the `rdf:langString` type.
 */
declare class LanguageString extends String {
  readonly language: LanguageTag;
  /**
   * Constructs a new `LanguageString`.
   * @param value A string value written in the given language.
   * @param language The language of the string.  If a string is given, it will
   *                 be parsed as a `LanguageTag`.
   */
  constructor(value: string, language: LanguageTag | string);
}
//#endregion
//#region src/vocab/vocab.d.ts
/** Describes an object of any kind. The Object type serves as the base type for
 * most of the other kinds of objects defined in the Activity Vocabulary,
 * including other Core types such as {@link Activity},
 * {@link IntransitiveActivity}, {@link Collection} and
 * {@link OrderedCollection}.
 */
declare class Object$1 {
  #private;
  readonly id: URL | null;
  protected get _documentLoader(): DocumentLoader | undefined;
  protected get _contextLoader(): DocumentLoader | undefined;
  protected get _tracerProvider(): TracerProvider | undefined;
  protected get _warning(): {
    category: string[];
    message: string;
    values?: Record<string, unknown>;
  } | undefined;
  protected get _cachedJsonLd(): unknown | undefined;
  protected set _cachedJsonLd(value: unknown | undefined);
  /**
   * The type URI of {@link Object}: `https://www.w3.org/ns/activitystreams#Object`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Object with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Object$1;
  /**
   * Similar to
   * {@link Object.getAttachments},
   * but returns their `@id`s instead of the objects themselves.
   */
  get attachmentIds(): URL[];
  /** Identifies a resource attached or related to an object that potentially
   * requires special handling.  The intent is to provide a model that is at
   * least semantically similar to attachments in email.
   */
  getAttachments(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Object$1 | Link | PropertyValue>;
  /**
   * Similar to
   * {@link Object.getAttribution},
   * but returns its `@id` URL instead of the object itself.
   */
  get attributionId(): URL | null;
  /** Identifies one or more entities to which this object is attributed.
   * The attributed entities might not be Actors.  For instance,
   * an object might be attributed to the completion of another activity.
   */
  getAttribution(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Application | Group | Organization | Person | Service | null>;
  /**
   * Similar to
   * {@link Object.getAttributions},
   * but returns their `@id`s instead of the objects themselves.
   */
  get attributionIds(): URL[];
  /** Identifies one or more entities to which this object is attributed.
   * The attributed entities might not be Actors.  For instance,
   * an object might be attributed to the completion of another activity.
   */
  getAttributions(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Application | Group | Organization | Person | Service>;
  /**
   * Similar to
   * {@link Object.getAudience},
   * but returns its `@id` URL instead of the object itself.
   */
  get audienceId(): URL | null;
  /** Identifies one or more entities that represent the total population of
   * entities for which the object can considered to be relevant.
   */
  getAudience(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Object$1 | null>;
  /**
   * Similar to
   * {@link Object.getAudiences},
   * but returns their `@id`s instead of the objects themselves.
   */
  get audienceIds(): URL[];
  /** Identifies one or more entities that represent the total population of
   * entities for which the object can considered to be relevant.
   */
  getAudiences(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Object$1>;
  /** The content or textual representation of the Object encoded as a JSON
   * string.  By default, the value of `content` is HTML.  The `mediaType`
   * property can be used in the object to indicate a different content type.
   *
   * The content MAY be expressed using multiple language-tagged values.
   */
  get content(): string | LanguageString | null;
  /** The content or textual representation of the Object encoded as a JSON
   * string.  By default, the value of `content` is HTML.  The `mediaType`
   * property can be used in the object to indicate a different content type.
   *
   * The content MAY be expressed using multiple language-tagged values.
   */
  get contents(): ((string | LanguageString))[];
  /**
   * Similar to
   * {@link Object.getContexts},
   * but returns their `@id`s instead of the objects themselves.
   */
  get contextIds(): URL[];
  /** Identifies the context within which the object exists or an activity was
   * performed.
   *
   * The notion of "context" used is intentionally vague.  The intended function
   * is to serve as a means of grouping objects and activities that share
   * a common originating context or purpose.  An example could be all activities
   * relating to a common project or event.
   */
  getContexts(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Object$1 | Link>;
  /** A simple, human-readable, plain-text name for the object. HTML markup MUST
   * NOT be included. The name MAY be expressed using multiple language-tagged
   * values.
   */
  get name(): string | LanguageString | null;
  /** A simple, human-readable, plain-text name for the object. HTML markup MUST
   * NOT be included. The name MAY be expressed using multiple language-tagged
   * values.
   */
  get names(): ((string | LanguageString))[];
  /** The date and time describing the actual or expected ending time of
   * the object.  When used with an {@link Activity} object, for instance,
   * the `endTime`` property specifies the moment the activity concluded
   * or is expected to conclude.
   */
  get endTime(): Temporal.Instant | null;
  /**
   * Similar to
   * {@link Object.getGenerators},
   * but returns their `@id`s instead of the objects themselves.
   */
  get generatorIds(): URL[];
  /** Identifies the entity (e.g. an application) that generated the object.
   */
  getGenerators(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Object$1 | Link>;
  /**
   * Similar to
   * {@link Object.getIcon},
   * but returns its `@id` URL instead of the object itself.
   */
  get iconId(): URL | null;
  /** Indicates an entity that describes an icon for this object.
   * The image should have an aspect ratio of one (horizontal) to one
   * (vertical) and should be suitable for presentation at a small size.
   */
  getIcon(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Image | null>;
  /**
   * Similar to
   * {@link Object.getIcons},
   * but returns their `@id`s instead of the objects themselves.
   */
  get iconIds(): URL[];
  /** Indicates an entity that describes an icon for this object.
   * The image should have an aspect ratio of one (horizontal) to one
   * (vertical) and should be suitable for presentation at a small size.
   */
  getIcons(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Image>;
  /**
   * Similar to
   * {@link Object.getImage},
   * but returns its `@id` URL instead of the object itself.
   */
  get imageId(): URL | null;
  /** Indicates an entity that describes an image for this object.
   * Unlike the icon property, there are no aspect ratio or display size
   * limitations assumed.
   */
  getImage(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Image | null>;
  /**
   * Similar to
   * {@link Object.getImages},
   * but returns their `@id`s instead of the objects themselves.
   */
  get imageIds(): URL[];
  /** Indicates an entity that describes an image for this object.
   * Unlike the icon property, there are no aspect ratio or display size
   * limitations assumed.
   */
  getImages(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Image>;
  /**
   * Similar to
   * {@link Object.getReplyTarget},
   * but returns its `@id` URL instead of the object itself.
   */
  get replyTargetId(): URL | null;
  /** Indicates one or more entities for which this object is considered
   * a response.
   */
  getReplyTarget(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Object$1 | Link | null>;
  /**
   * Similar to
   * {@link Object.getReplyTargets},
   * but returns their `@id`s instead of the objects themselves.
   */
  get replyTargetIds(): URL[];
  /** Indicates one or more entities for which this object is considered
   * a response.
   */
  getReplyTargets(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Object$1 | Link>;
  /**
   * Similar to
   * {@link Object.getLocation},
   * but returns its `@id` URL instead of the object itself.
   */
  get locationId(): URL | null;
  /** Indicates one or more physical or logical locations associated with
   * the object.
   */
  getLocation(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Object$1 | Link | null>;
  /**
   * Similar to
   * {@link Object.getLocations},
   * but returns their `@id`s instead of the objects themselves.
   */
  get locationIds(): URL[];
  /** Indicates one or more physical or logical locations associated with
   * the object.
   */
  getLocations(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Object$1 | Link>;
  /**
   * Similar to
   * {@link Object.getPreview},
   * but returns its `@id` URL instead of the object itself.
   */
  get previewId(): URL | null;
  /** Identifies an entity that provides a preview of this object.
   */
  getPreview(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Link | Object$1 | null>;
  /**
   * Similar to
   * {@link Object.getPreviews},
   * but returns their `@id`s instead of the objects themselves.
   */
  get previewIds(): URL[];
  /** Identifies an entity that provides a preview of this object.
   */
  getPreviews(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Link | Object$1>;
  /** The date and time at which the object was published.
   */
  get published(): Temporal.Instant | null;
  /**
   * Similar to
   * {@link Object.getReplies},
   * but returns its `@id` URL instead of the object itself.
   */
  get repliesId(): URL | null;
  /** Identifies a {@link Collection} containing objects considered to be
   * responses to this object.
   */
  getReplies(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Object.getShares},
   * but returns its `@id` URL instead of the object itself.
   */
  get sharesId(): URL | null;
  /** Every object *may* have a `shares` collection. This is a list of all
   * {@link Announce} activities with this object as the `object` property,
   * added as a [side effect]. The `shares` collection *must* be either
   * an {@link OrderedCollection} or a {@link Collection} and *may* be filtered
   * on privileges of an authenticated user or as appropriate
   * when no authentication is given.
   *
   * [side effect]: https://www.w3.org/TR/activitypub/#announce-activity-inbox
   */
  getShares(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Object.getLikes},
   * but returns its `@id` URL instead of the object itself.
   */
  get likesId(): URL | null;
  /** Every object *may* have a `likes` collection. This is a list of all
   * {@link Like} activities with this object as the `object` property,
   * added as a [side effect]. The `likes` collection *must* be either
   * an {@link OrderedCollection} or a {@link Collection} and *may* be filtered
   * on privileges of an authenticated user or as appropriate
   * when no authentication is given.
   *
   * [side effect]: https://www.w3.org/TR/activitypub/#announce-activity-inbox
   */
  getLikes(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Object.getEmojiReactions},
   * but returns its `@id` URL instead of the object itself.
   */
  get emojiReactionsId(): URL | null;
  /** Identifies a {@link Collection} containing objects considered to be
   * emoji reactions to this object.
   */
  getEmojiReactions(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /** The date and time describing the actual or expected starting time of
   * the object.  When used with an {@link Activity} object, for instance,
   * the `startTime` property specifies the moment the activity began or
   * is scheduled to begin.
   */
  get startTime(): Temporal.Instant | null;
  /** A natural language summarization of the object encoded as HTML.
   * Multiple language tagged summaries MAY be provided.
   */
  get summary(): string | LanguageString | null;
  /** A natural language summarization of the object encoded as HTML.
   * Multiple language tagged summaries MAY be provided.
   */
  get summaries(): ((string | LanguageString))[];
  /**
   * Similar to
   * {@link Object.getTags},
   * but returns their `@id`s instead of the objects themselves.
   */
  get tagIds(): URL[];
  /** One or more "tags" that have been associated with an objects.
   * A tag can be any kind of Object.  The key difference between `attachment`
   * and `tag` is that the former implies association by inclusion,
   * while the latter implies associated by reference.
   */
  getTags(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Object$1 | Link>;
  /** The date and time at which the object was updated.
   */
  get updated(): Temporal.Instant | null;
  /** Identifies one or more links to representations of the object.
   */
  get url(): URL | Link | null;
  /** Identifies one or more links to representations of the object.
   */
  get urls(): ((URL | Link))[];
  /**
   * Similar to
   * {@link Object.getTo},
   * but returns its `@id` URL instead of the object itself.
   */
  get toId(): URL | null;
  /** Identifies an entity considered to be part of the public primary audience
   * of an Object.
   */
  getTo(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Object$1 | null>;
  /**
   * Similar to
   * {@link Object.getTos},
   * but returns their `@id`s instead of the objects themselves.
   */
  get toIds(): URL[];
  /** Identifies an entity considered to be part of the public primary audience
   * of an Object.
   */
  getTos(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Object$1>;
  /**
   * Similar to
   * {@link Object.getBto},
   * but returns its `@id` URL instead of the object itself.
   */
  get btoId(): URL | null;
  /** Identifies an Object that is part of the private primary audience of
   * this Object.
   */
  getBto(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Object$1 | null>;
  /**
   * Similar to
   * {@link Object.getBtos},
   * but returns their `@id`s instead of the objects themselves.
   */
  get btoIds(): URL[];
  /** Identifies an Object that is part of the private primary audience of
   * this Object.
   */
  getBtos(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Object$1>;
  /**
   * Similar to
   * {@link Object.getCc},
   * but returns its `@id` URL instead of the object itself.
   */
  get ccId(): URL | null;
  /** Identifies an Object that is part of the public secondary audience of
   * this Object.
   */
  getCc(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Object$1 | null>;
  /**
   * Similar to
   * {@link Object.getCcs},
   * but returns their `@id`s instead of the objects themselves.
   */
  get ccIds(): URL[];
  /** Identifies an Object that is part of the public secondary audience of
   * this Object.
   */
  getCcs(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Object$1>;
  /**
   * Similar to
   * {@link Object.getBcc},
   * but returns its `@id` URL instead of the object itself.
   */
  get bccId(): URL | null;
  /** Identifies one or more Objects that are part of the private secondary
   * audience of this Object.
   */
  getBcc(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Object$1 | null>;
  /**
   * Similar to
   * {@link Object.getBccs},
   * but returns their `@id`s instead of the objects themselves.
   */
  get bccIds(): URL[];
  /** Identifies one or more Objects that are part of the private secondary
   * audience of this Object.
   */
  getBccs(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Object$1>;
  /** When used on an {@link Object}, identifies the MIME media type of the value
   * of the `content` property.  If not specified, the `content` property is
   * assumed to contain `text/html` content.
   */
  get mediaType(): string | null;
  /** When the object describes a time-bound resource, such as an audio or video,
   * a meeting, etc, the `duration` property indicates the object's approximate
   * duration.  The value MUST be expressed as an `xsd:duration` as defined by
   * W3C XML Schema Definition Language (XSD) 1.1 Part 2: DataTypes, section
   * 3.3.6 (e.g. a period of 5 seconds is represented as `PT5S`).
   */
  get duration(): Temporal.Duration | null;
  /** Whether it contains any sensitive contents.
   */
  get sensitive(): boolean | null;
  /** The `source` property is intended to convey some sort of source from which
   * the `content` markup was derived, as a form of provenance, or to support
   * future editing by clients.  In general, clients do the conversion from
   * `source` to `content`, not the other way around.
   */
  get source(): Source | null;
  /**
   * Similar to
   * {@link Object.getProof},
   * but returns its `@id` URL instead of the object itself.
   */
  get proofId(): URL | null;
  /** A cryptographic proof that can be used to verify the integrity of an object.
   */
  getProof(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<DataIntegrityProof | null>;
  /**
   * Similar to
   * {@link Object.getProofs},
   * but returns their `@id`s instead of the objects themselves.
   */
  get proofIds(): URL[];
  /** A cryptographic proof that can be used to verify the integrity of an object.
   */
  getProofs(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<DataIntegrityProof>;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Object$1>;
  protected static __fromJsonLd__Object__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Object$1>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Represents a custom emoji.
 */
declare class Emoji extends Object$1 {
  /**
   * The type URI of {@link Emoji}: `http://joinmastodon.org/ns#Emoji`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Emoji with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Emoji;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Emoji>;
  protected static __fromJsonLd__Emoji__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Emoji>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** `ChatMessage`s are the messages sent in 1-on-1 chats.  They are similar to
 * {@link Note}s, but the addressing is done by having a single AP actor in
 * the `to` field.  Addressing multiple actors is not allowed.  These messages
 * are always private, there is no public version of them.  They are created with
 * a {@link Create} activity.
 */
declare class ChatMessage extends Object$1 {
  #private;
  /**
   * The type URI of {@link ChatMessage}: `http://litepub.social/ns#ChatMessage`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of ChatMessage with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    quoteUrl?: URL | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    quoteUrl?: URL | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): ChatMessage;
  /** The URI of the ActivityStreams object that this object quotes.
   *
   * This property sets three JSON-LD properties at once under the hood:
   *
   * 1. https://www.w3.org/ns/activitystreams#quoteUrl
   * 2. https://misskey-hub.net/ns#_misskey_quote
   * 3. http://fedibird.com/ns#quoteUri
   *
   * When a JSON-LD object is parsed, this property is filled with one of
   * the values of those three properties in order.
   */
  get quoteUrl(): URL | null;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<ChatMessage>;
  protected static __fromJsonLd__ChatMessage__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<ChatMessage>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** An Activity is a subtype of {@link Object} that describes some form of action
 * that may happen, is currently happening, or has already happened.
 * The {@link Activity} type itself serves as an abstract base type for all types
 * of activities.  It is important to note that the {@link Activity} type itself
 * does not carry any specific semantics about the kind of action being taken.
 */
declare class Activity extends Object$1 {
  #private;
  /**
   * The type URI of {@link Activity}: `https://www.w3.org/ns/activitystreams#Activity`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Activity with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Activity;
  /**
   * Similar to
   * {@link Activity.getActor},
   * but returns its `@id` URL instead of the object itself.
   */
  get actorId(): URL | null;
  /** Describes one or more entities that either performed or are expected to
   * perform the activity.  Any single activity can have multiple actors.
   * The actor MAY be specified using an indirect {@link Link}.
   */
  getActor(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Application | Group | Organization | Person | Service | null>;
  /**
   * Similar to
   * {@link Activity.getActors},
   * but returns their `@id`s instead of the objects themselves.
   */
  get actorIds(): URL[];
  /** Describes one or more entities that either performed or are expected to
   * perform the activity.  Any single activity can have multiple actors.
   * The actor MAY be specified using an indirect {@link Link}.
   */
  getActors(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Application | Group | Organization | Person | Service>;
  /**
   * Similar to
   * {@link Activity.getObject},
   * but returns its `@id` URL instead of the object itself.
   */
  get objectId(): URL | null;
  /** When used within an {@link Activity}, describes the direct object of
   * the activity.  For instance, in the activity "John added a movie to his
   * wishlist", the object of the activity is the movie added.
   */
  getObject(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Object$1 | null>;
  /**
   * Similar to
   * {@link Activity.getObjects},
   * but returns their `@id`s instead of the objects themselves.
   */
  get objectIds(): URL[];
  /** When used within an {@link Activity}, describes the direct object of
   * the activity.  For instance, in the activity "John added a movie to his
   * wishlist", the object of the activity is the movie added.
   */
  getObjects(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Object$1>;
  /**
   * Similar to
   * {@link Activity.getTarget},
   * but returns its `@id` URL instead of the object itself.
   */
  get targetId(): URL | null;
  /** Describes the indirect object, or target, of the activity.  The precise
   * meaning of the target is largely dependent on the type of action being
   * described but will often be the object of the English preposition "to".
   * For instance, in the activity "John added a movie to his wishlist",
   * the target of the activity is John's wishlist.  An activity can have more
   * than one target.
   */
  getTarget(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Object$1 | null>;
  /**
   * Similar to
   * {@link Activity.getTargets},
   * but returns their `@id`s instead of the objects themselves.
   */
  get targetIds(): URL[];
  /** Describes the indirect object, or target, of the activity.  The precise
   * meaning of the target is largely dependent on the type of action being
   * described but will often be the object of the English preposition "to".
   * For instance, in the activity "John added a movie to his wishlist",
   * the target of the activity is John's wishlist.  An activity can have more
   * than one target.
   */
  getTargets(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Object$1>;
  /**
   * Similar to
   * {@link Activity.getResult},
   * but returns its `@id` URL instead of the object itself.
   */
  get resultId(): URL | null;
  /** Describes the result of the activity.  For instance, if a particular action
   * results in the creation of a new resource, the result property can be used
   * to describe that new resource.
   */
  getResult(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Object$1 | null>;
  /**
   * Similar to
   * {@link Activity.getResults},
   * but returns their `@id`s instead of the objects themselves.
   */
  get resultIds(): URL[];
  /** Describes the result of the activity.  For instance, if a particular action
   * results in the creation of a new resource, the result property can be used
   * to describe that new resource.
   */
  getResults(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Object$1>;
  /**
   * Similar to
   * {@link Activity.getOrigin},
   * but returns its `@id` URL instead of the object itself.
   */
  get originId(): URL | null;
  /** Describes an indirect object of the activity from which the activity is
   * directed.  The precise meaning of the origin is the object of the English
   * preposition "from". For instance, in the activity "John moved an item to
   * List B from List A", the origin of the activity is "List A".
   */
  getOrigin(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Object$1 | null>;
  /**
   * Similar to
   * {@link Activity.getOrigins},
   * but returns their `@id`s instead of the objects themselves.
   */
  get originIds(): URL[];
  /** Describes an indirect object of the activity from which the activity is
   * directed.  The precise meaning of the origin is the object of the English
   * preposition "from". For instance, in the activity "John moved an item to
   * List B from List A", the origin of the activity is "List A".
   */
  getOrigins(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Object$1>;
  /**
   * Similar to
   * {@link Activity.getInstrument},
   * but returns its `@id` URL instead of the object itself.
   */
  get instrumentId(): URL | null;
  /** Identifies one or more objects used (or to be used) in the completion of
   * an {@link Activity}.
   */
  getInstrument(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Object$1 | null>;
  /**
   * Similar to
   * {@link Activity.getInstruments},
   * but returns their `@id`s instead of the objects themselves.
   */
  get instrumentIds(): URL[];
  /** Identifies one or more objects used (or to be used) in the completion of
   * an {@link Activity}.
   */
  getInstruments(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Object$1>;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Activity>;
  protected static __fromJsonLd__Activity__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Activity>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Represents an emoji reaction.  See also [FEP-c0e0](https://w3id.org/fep/c0e0).
 */
declare class EmojiReact extends Activity {
  /**
   * The type URI of {@link EmojiReact}: `http://litepub.social/ns#EmojiReact`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of EmojiReact with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): EmojiReact;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<EmojiReact>;
  protected static __fromJsonLd__EmojiReact__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<EmojiReact>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** A pair of property name and value.
 */
declare class PropertyValue {
  #private;
  readonly id: URL | null;
  protected get _documentLoader(): DocumentLoader | undefined;
  protected get _contextLoader(): DocumentLoader | undefined;
  protected get _tracerProvider(): TracerProvider | undefined;
  protected get _warning(): {
    category: string[];
    message: string;
    values?: Record<string, unknown>;
  } | undefined;
  protected get _cachedJsonLd(): unknown | undefined;
  protected set _cachedJsonLd(value: unknown | undefined);
  /**
   * The type URI of {@link PropertyValue}: `http://schema.org#PropertyValue`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of PropertyValue with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    name?: string | LanguageString | null;
    value?: string | LanguageString | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    name?: string | LanguageString | null;
    value?: string | LanguageString | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): PropertyValue;
  /** The name of a property.
   */
  get name(): string | LanguageString | null;
  /** The value of a property.
   */
  get value(): string | LanguageString | null;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<PropertyValue>;
  protected static __fromJsonLd__PropertyValue__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<PropertyValue>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Means of communicating or interacting with the DID subject or associated
 * entities via one or more service endpoints. Examples include discovery
 * services, agent services, social networking services, file storage services,
 * and verifiable credential repository services.
 */
declare class DidService {
  #private;
  readonly id: URL | null;
  protected get _documentLoader(): DocumentLoader | undefined;
  protected get _contextLoader(): DocumentLoader | undefined;
  protected get _tracerProvider(): TracerProvider | undefined;
  protected get _warning(): {
    category: string[];
    message: string;
    values?: Record<string, unknown>;
  } | undefined;
  protected get _cachedJsonLd(): unknown | undefined;
  protected set _cachedJsonLd(value: unknown | undefined);
  /**
   * The type URI of {@link DidService}: `https://www.w3.org/ns/did#Service`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of DidService with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    endpoint?: URL | null;
    endpoints?: (URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    endpoint?: URL | null;
    endpoints?: (URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): DidService;
  /** A network address, such as an HTTP URL, at which services operate on behalf
   * of a DID subject.
   */
  get endpoint(): URL | null;
  /** A network address, such as an HTTP URL, at which services operate on behalf
   * of a DID subject.
   */
  get endpoints(): (URL)[];
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<DidService>;
  protected static __fromJsonLd__DidService__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<DidService>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** "Export Actor" service.
 */
declare class Export extends DidService {
  /**
   * The type URI of {@link Export}: `https://w3id.org/fep/9091#Export`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Export with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    endpoint?: URL | null;
    endpoints?: (URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    endpoint?: URL | null;
    endpoints?: (URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Export;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Export>;
  protected static __fromJsonLd__Export__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Export>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** A proof that can be added to any activity or object, allowing recipients to
 * verify the identity of the actor and the integrity of the data.
 */
declare class DataIntegrityProof {
  #private;
  readonly id: URL | null;
  protected get _documentLoader(): DocumentLoader | undefined;
  protected get _contextLoader(): DocumentLoader | undefined;
  protected get _tracerProvider(): TracerProvider | undefined;
  protected get _warning(): {
    category: string[];
    message: string;
    values?: Record<string, unknown>;
  } | undefined;
  protected get _cachedJsonLd(): unknown | undefined;
  protected set _cachedJsonLd(value: unknown | undefined);
  /**
   * The type URI of {@link DataIntegrityProof}: `https://w3id.org/security#DataIntegrityProof`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of DataIntegrityProof with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    cryptosuite?: "eddsa-jcs-2022" | null;
    verificationMethod?: Multikey | URL | null;
    proofPurpose?: "assertionMethod" | "authentication" | "capabilityInvocation" | "capabilityDelegation" | "keyAgreement" | null;
    proofValue?: Uint8Array | null;
    created?: Temporal.Instant | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    cryptosuite?: "eddsa-jcs-2022" | null;
    verificationMethod?: Multikey | URL | null;
    proofPurpose?: "assertionMethod" | "authentication" | "capabilityInvocation" | "capabilityDelegation" | "keyAgreement" | null;
    proofValue?: Uint8Array | null;
    created?: Temporal.Instant | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): DataIntegrityProof;
  /** The cryptographic suite used to create the proof.
   */
  get cryptosuite(): "eddsa-jcs-2022" | null;
  /**
   * Similar to
   * {@link DataIntegrityProof.getVerificationMethod},
   * but returns its `@id` URL instead of the object itself.
   */
  get verificationMethodId(): URL | null;
  /** A key owned by an actor according to [FEP-521a: Representing actor's public
   * keys][1].
   *
   * [1]: https://w3id.org/fep/521a
   */
  getVerificationMethod(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Multikey | null>;
  /** The reason the proof was created.
   *
   * - `"assertionMethod"`
   * - `"authentication"`
   * - `"capabilityInvocation"`
   * - `"capabilityDelegation"`
   * - `"keyAgreement"`
   */
  get proofPurpose(): "assertionMethod" | "authentication" | "capabilityInvocation" | "capabilityDelegation" | "keyAgreement" | null;
  /** The proof value.
   */
  get proofValue(): Uint8Array | null;
  /** The date and time the proof was created.
   */
  get created(): Temporal.Instant | null;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<DataIntegrityProof>;
  protected static __fromJsonLd__DataIntegrityProof__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<DataIntegrityProof>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** A key owned by an actor.
 */
declare class CryptographicKey {
  #private;
  readonly id: URL | null;
  protected get _documentLoader(): DocumentLoader | undefined;
  protected get _contextLoader(): DocumentLoader | undefined;
  protected get _tracerProvider(): TracerProvider | undefined;
  protected get _warning(): {
    category: string[];
    message: string;
    values?: Record<string, unknown>;
  } | undefined;
  protected get _cachedJsonLd(): unknown | undefined;
  protected set _cachedJsonLd(value: unknown | undefined);
  /**
   * The type URI of {@link CryptographicKey}: `https://w3id.org/security#Key`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of CryptographicKey with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    owner?: Application | Group | Organization | Person | Service | URL | null;
    publicKey?: CryptoKey | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    owner?: Application | Group | Organization | Person | Service | URL | null;
    publicKey?: CryptoKey | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): CryptographicKey;
  /**
   * Similar to
   * {@link CryptographicKey.getOwner},
   * but returns its `@id` URL instead of the object itself.
   */
  get ownerId(): URL | null;
  /** An actor who owns this key.
   */
  getOwner(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Application | Group | Organization | Person | Service | null>;
  /** A PEM-encoded public key.
   */
  get publicKey(): CryptoKey | null;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<CryptographicKey>;
  protected static __fromJsonLd__CryptographicKey__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<CryptographicKey>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Represents a key owned by an actor according to [FEP-521a: Representing
 * actor's public keys.][1]
 *
 * [1]: https://w3id.org/fep/521a
 */
declare class Multikey {
  #private;
  readonly id: URL | null;
  protected get _documentLoader(): DocumentLoader | undefined;
  protected get _contextLoader(): DocumentLoader | undefined;
  protected get _tracerProvider(): TracerProvider | undefined;
  protected get _warning(): {
    category: string[];
    message: string;
    values?: Record<string, unknown>;
  } | undefined;
  protected get _cachedJsonLd(): unknown | undefined;
  protected set _cachedJsonLd(value: unknown | undefined);
  /**
   * The type URI of {@link Multikey}: `https://w3id.org/security#Multikey`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Multikey with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    controller?: Application | Group | Organization | Person | Service | URL | null;
    publicKey?: CryptoKey | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    controller?: Application | Group | Organization | Person | Service | URL | null;
    publicKey?: CryptoKey | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Multikey;
  /**
   * Similar to
   * {@link Multikey.getController},
   * but returns its `@id` URL instead of the object itself.
   */
  get controllerId(): URL | null;
  /** An actor who owns this key.
   */
  getController(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Application | Group | Organization | Person | Service | null>;
  /** A [Multibase]-encoded value of a [Multicodec] prefix and the key.
   *
   * [Multibase]: https://www.w3.org/TR/vc-data-integrity/#multibase-0
   * [Multicodec]: https://github.com/multiformats/multicodec/
   */
  get publicKey(): CryptoKey | null;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Multikey>;
  protected static __fromJsonLd__Multikey__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Multikey>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Indicates that the `actor` accepts the `object`.  The `target` property can be
 * used in certain circumstances to indicate the context into which the `object`
 * has been accepted.
 */
declare class Accept extends Activity {
  /**
   * The type URI of {@link Accept}: `https://www.w3.org/ns/activitystreams#Accept`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Accept with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Accept;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Accept>;
  protected static __fromJsonLd__Accept__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Accept>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Indicates that the `actor` has added the `object` to the `target`.
 * If the `target` property is not explicitly specified, the target would need
 * to be determined implicitly by context.  The `origin` can be used to identify
 * the context from which the `object` originated.
 */
declare class Add extends Activity {
  /**
   * The type URI of {@link Add}: `https://www.w3.org/ns/activitystreams#Add`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Add with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Add;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Add>;
  protected static __fromJsonLd__Add__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Add>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Indicates that the `actor` is calling the `target`'s attention the `object`.
 *
 * The `origin` typically has no defined meaning.
 */
declare class Announce extends Activity {
  /**
   * The type URI of {@link Announce}: `https://www.w3.org/ns/activitystreams#Announce`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Announce with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Announce;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Announce>;
  protected static __fromJsonLd__Announce__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Announce>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Describes a software application.
 */
declare class Application extends Object$1 {
  #private;
  /**
   * The type URI of {@link Application}: `https://www.w3.org/ns/activitystreams#Application`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Application with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    preferredUsername?: string | LanguageString | null;
    preferredUsernames?: ((string | LanguageString))[];
    publicKey?: CryptographicKey | URL | null;
    publicKeys?: (CryptographicKey | URL)[];
    assertionMethod?: Multikey | URL | null;
    assertionMethods?: (Multikey | URL)[];
    manuallyApprovesFollowers?: boolean | null;
    inbox?: OrderedCollection | OrderedCollectionPage | URL | null;
    outbox?: OrderedCollection | OrderedCollectionPage | URL | null;
    following?: Collection | URL | null;
    followers?: Collection | URL | null;
    liked?: Collection | URL | null;
    featured?: Collection | URL | null;
    featuredTags?: Collection | URL | null;
    streams?: (Collection | URL)[];
    endpoints?: Endpoints | null;
    discoverable?: boolean | null;
    suspended?: boolean | null;
    memorial?: boolean | null;
    indexable?: boolean | null;
    successor?: Application | Group | Organization | Person | Service | URL | null;
    alias?: Application | Group | Organization | Person | Service | URL | null;
    aliases?: (Application | Group | Organization | Person | Service | URL)[];
    service?: DidService | URL | null;
    services?: (DidService | URL)[];
    followedMessage?: string | null;
    cat?: boolean | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    preferredUsername?: string | LanguageString | null;
    preferredUsernames?: ((string | LanguageString))[];
    publicKey?: CryptographicKey | URL | null;
    publicKeys?: (CryptographicKey | URL)[];
    assertionMethod?: Multikey | URL | null;
    assertionMethods?: (Multikey | URL)[];
    manuallyApprovesFollowers?: boolean | null;
    inbox?: OrderedCollection | OrderedCollectionPage | URL | null;
    outbox?: OrderedCollection | OrderedCollectionPage | URL | null;
    following?: Collection | URL | null;
    followers?: Collection | URL | null;
    liked?: Collection | URL | null;
    featured?: Collection | URL | null;
    featuredTags?: Collection | URL | null;
    streams?: (Collection | URL)[];
    endpoints?: Endpoints | null;
    discoverable?: boolean | null;
    suspended?: boolean | null;
    memorial?: boolean | null;
    indexable?: boolean | null;
    successor?: Application | Group | Organization | Person | Service | URL | null;
    alias?: Application | Group | Organization | Person | Service | URL | null;
    aliases?: (Application | Group | Organization | Person | Service | URL)[];
    service?: DidService | URL | null;
    services?: (DidService | URL)[];
    followedMessage?: string | null;
    cat?: boolean | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Application;
  /** A short username which may be used to refer to the actor,
   * with no uniqueness guarantees.
   */
  get preferredUsername(): string | LanguageString | null;
  /** A short username which may be used to refer to the actor,
   * with no uniqueness guarantees.
   */
  get preferredUsernames(): ((string | LanguageString))[];
  /**
   * Similar to
   * {@link Application.getPublicKey},
   * but returns its `@id` URL instead of the object itself.
   */
  get publicKeyId(): URL | null;
  /** A public part of the key pair owned by this actor.
   */
  getPublicKey(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<CryptographicKey | null>;
  /**
   * Similar to
   * {@link Application.getPublicKeys},
   * but returns their `@id`s instead of the objects themselves.
   */
  get publicKeyIds(): URL[];
  /** A public part of the key pair owned by this actor.
   */
  getPublicKeys(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<CryptographicKey>;
  /**
   * Similar to
   * {@link Application.getAssertionMethod},
   * but returns its `@id` URL instead of the object itself.
   */
  get assertionMethodId(): URL | null;
  /** Represents this actor's public keys.  It serves as equivalent to
   * the `publicKeys` property, but is used for [FEP-521a] compliance.
   *
   * [FEP-521a]: https://w3id.org/fep/521a
   */
  getAssertionMethod(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Multikey | null>;
  /**
   * Similar to
   * {@link Application.getAssertionMethods},
   * but returns their `@id`s instead of the objects themselves.
   */
  get assertionMethodIds(): URL[];
  /** Represents this actor's public keys.  It serves as equivalent to
   * the `publicKeys` property, but is used for [FEP-521a] compliance.
   *
   * [FEP-521a]: https://w3id.org/fep/521a
   */
  getAssertionMethods(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Multikey>;
  /** When `true`, conveys that for this actor, follow requests are not usually
   * automatically approved, but instead are examined by a person who may accept
   * or reject the request, at some time in the future.  Setting of `false`
   * conveys no information and may be ignored.  This information is typically
   * used to affect display of accounts, such as showing an account as private or
   * locked.
   */
  get manuallyApprovesFollowers(): boolean | null;
  /**
   * Similar to
   * {@link Application.getInbox},
   * but returns its `@id` URL instead of the object itself.
   */
  get inboxId(): URL | null;
  /** The inbox stream contains all activities received by the actor.  The server
   * SHOULD filter content according to the requester's permission.  In general,
   * the owner of an inbox is likely to be able to access all of their inbox
   * contents.  Depending on access control, some other content may be public,
   * whereas other content may require authentication for non-owner users,
   * if they can access the inbox at all.
   *
   * The server MUST perform de-duplication of activities returned by the inbox.
   * Duplication can occur if an activity is addressed both to an actor's
   * followers, and a specific actor who also follows the recipient actor,
   * and the server has failed to de-duplicate the recipients list.
   * Such deduplication MUST be performed by comparing the `id` of the activities
   * and dropping any activities already seen.
   */
  getInbox(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<OrderedCollection | OrderedCollectionPage | null>;
  /**
   * Similar to
   * {@link Application.getOutbox},
   * but returns its `@id` URL instead of the object itself.
   */
  get outboxId(): URL | null;
  /** The outbox stream contains activities the user has published,
   * subject to the ability of the requestor to retrieve the activity
   * (that is, the contents of the outbox are filtered by the permissions of
   * the person reading it).  If a user submits a request without
   * [Authorization](https://www.w3.org/TR/activitypub/#authorization)
   * the server should respond with all of the
   * [Public](https://www.w3.org/TR/activitypub/#public-addressing) posts.
   * This could potentially be all relevant objects published by the user,
   * though the number of available items is left to the discretion of those
   * implementing and deploying the server.
   */
  getOutbox(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<OrderedCollection | OrderedCollectionPage | null>;
  /**
   * Similar to
   * {@link Application.getFollowing},
   * but returns its `@id` URL instead of the object itself.
   */
  get followingId(): URL | null;
  /** This is a list of everybody that the actor has followed, added as a
   * [side effect](https://www.w3.org/TR/activitypub/#follow-activity-outbox).
   * The `following` collection MUST be either an {@link OrderedCollection}
   * or a {@link Collection} and MAY be filtered on privileges of
   * an authenticated user or as appropriate when no authentication is given.
   */
  getFollowing(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Application.getFollowers},
   * but returns its `@id` URL instead of the object itself.
   */
  get followersId(): URL | null;
  /** This is a list of everyone who has sent a {@link Follow} activity
   * for the actor, added as a
   * [side effect](https://www.w3.org/TR/activitypub/#follow-activity-outbox).
   * This is where one would find a list of all the actors that are following
   * the actor.  The `followers` collection MUST be either
   * an {@link OrderedCollection} or a {@link Collection} and MAY be filtered on
   * privileges of an authenticated user or as appropriate when no authentication
   * is given.
   */
  getFollowers(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Application.getLiked},
   * but returns its `@id` URL instead of the object itself.
   */
  get likedId(): URL | null;
  /** This is a list of every object from all of the actor's {@link Like}
   * activities, added as a
   * [side effect](https://www.w3.org/TR/activitypub/#like-activity-outbox).
   * The `liked` collection MUST be either an {@link OrderedCollection} or
   * a {@link Collection} and MAY be filtered on privileges of an authenticated
   * user or as appropriate when no authentication is given.
   */
  getLiked(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Application.getFeatured},
   * but returns its `@id` URL instead of the object itself.
   */
  get featuredId(): URL | null;
  /** What is known in Mastodon as "pinned statuses", or statuses that are always
   * featured at the top of people's profiles, is implemented using an extra
   * property `featured` on the actor object that points to a {@link Collection}
   * of objects.
   */
  getFeatured(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Application.getFeaturedTags},
   * but returns its `@id` URL instead of the object itself.
   */
  get featuredTagsId(): URL | null;
  /** What is known in Mastodon as "featured hashtags", hashtags that are featured
   * at people's profiles, is implemented using an extra property `featuredTags`
   * on the actor object that points to a {@link Collection} of {@link Hashtag}
   * objects specifically.
   */
  getFeaturedTags(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Application.getStreams},
   * but returns their `@id`s instead of the objects themselves.
   */
  get streamIds(): URL[];
  /** A list of supplementary Collections which may be of interest.
   */
  getStreams(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Collection>;
  /** A JSON object which maps additional (typically server/domain-wide) endpoints
   * which may be useful either for this actor or someone referencing this actor.
   * This mapping may be nested inside the actor document as the value or may be
   * a link to a JSON-LD document with these properties.
   */
  get endpoints(): Endpoints | null;
  /** Allows users to opt-in or opt-out of discoverability features like
   * the profile directory.  This flag may also be used as an indicator of
   * the user's preferences toward being included in external discovery services,
   * such as search engines or other indexing tools.
   */
  get discoverable(): boolean | null;
  /** Reports whether a user was locally suspended, for better handling of
   * these accounts.
   */
  get suspended(): boolean | null;
  /** Whether the actor is in-memorial state.
   */
  get memorial(): boolean | null;
  /** Whether the actor allows to be indexed.
   */
  get indexable(): boolean | null;
  /**
   * Similar to
   * {@link Application.getSuccessor},
   * but returns its `@id` URL instead of the object itself.
   */
  get successorId(): URL | null;
  /** Signifies that an actor has been moved to a different ID. Used in Mastodon-style data portability with the {@link Move} activity; see [ActivityPub Data Portability/Move Action](https://swicg.github.io/activitypub-data-portability/#move-action) for more details.
   */
  getSuccessor(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Application | Group | Organization | Person | Service | null>;
  /**
   * Similar to
   * {@link Application.getAlias},
   * but returns its `@id` URL instead of the object itself.
   */
  get aliasId(): URL | null;
  /** The `aliases` (`alsoKnownAs`) property is used to specify alternative names
   * or aliases for an entity.  It can be used to provide additional identifiers
   * or labels for an entity, which can be useful in scenarios where an entity
   * may have multiple names or aliases.
   */
  getAlias(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Application | Group | Organization | Person | Service | null>;
  /**
   * Similar to
   * {@link Application.getAliases},
   * but returns their `@id`s instead of the objects themselves.
   */
  get aliasIds(): URL[];
  /** The `aliases` (`alsoKnownAs`) property is used to specify alternative names
   * or aliases for an entity.  It can be used to provide additional identifiers
   * or labels for an entity, which can be useful in scenarios where an entity
   * may have multiple names or aliases.
   */
  getAliases(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Application | Group | Organization | Person | Service>;
  /**
   * Similar to
   * {@link Application.getService},
   * but returns its `@id` URL instead of the object itself.
   */
  get serviceId(): URL | null;
  /** Means of communicating or interacting with the DID subject or associated
   * entities via one or more service endpoints. Examples include discovery
   * services, agent services, social networking services, file storage services,
   * and verifiable credential repository services.
   */
  getService(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<DidService | null>;
  /**
   * Similar to
   * {@link Application.getServices},
   * but returns their `@id`s instead of the objects themselves.
   */
  get serviceIds(): URL[];
  /** Means of communicating or interacting with the DID subject or associated
   * entities via one or more service endpoints. Examples include discovery
   * services, agent services, social networking services, file storage services,
   * and verifiable credential repository services.
   */
  getServices(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<DidService>;
  /** This value is used for `Actor` type objects to show message on followed.
   */
  get followedMessage(): string | null;
  /** Used on actors to indicate that they in some way identify as a cat,
   * expressed as a boolean value. If this property is set to `true`,
   * displaying the actor or their notes will have some special effects
   * attached in some clients.
   */
  get cat(): boolean | null;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Application>;
  protected static __fromJsonLd__Application__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Application>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Instances of `IntransitiveActivity` are a subtype of {@link Activity}
 * representing intransitive actions.  The `object` property is therefore
 * inappropriate for these activities.
 */
declare class IntransitiveActivity extends Activity {
  /**
   * The type URI of {@link IntransitiveActivity}: `https://www.w3.org/ns/activitystreams#IntransitiveActivity`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of IntransitiveActivity with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): IntransitiveActivity;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<IntransitiveActivity>;
  protected static __fromJsonLd__IntransitiveActivity__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<IntransitiveActivity>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** An `IntransitiveActivity` that indicates that the `actor` has arrived at the `location`.
 * The `origin` can be used to identify the context from which the `actor` originated.
 * The `target` typically has no defined meaning.
 */
declare class Arrive extends IntransitiveActivity {
  /**
   * The type URI of {@link Arrive}: `https://www.w3.org/ns/activitystreams#Arrive`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Arrive with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Arrive;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Arrive>;
  protected static __fromJsonLd__Arrive__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Arrive>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Represents any kind of multi-paragraph written work.
 */
declare class Article extends Object$1 {
  #private;
  /**
   * The type URI of {@link Article}: `https://www.w3.org/ns/activitystreams#Article`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Article with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    quoteUrl?: URL | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    quoteUrl?: URL | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Article;
  /** The URI of the ActivityStreams object that this object quotes.
   *
   * This property sets three JSON-LD properties at once under the hood:
   *
   * 1. https://www.w3.org/ns/activitystreams#quoteUrl
   * 2. https://misskey-hub.net/ns#_misskey_quote
   * 3. http://fedibird.com/ns#quoteUri
   *
   * When a JSON-LD object is parsed, this property is filled with one of
   * the values of those three properties in order.
   */
  get quoteUrl(): URL | null;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Article>;
  protected static __fromJsonLd__Article__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Article>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Represents a document of any kind.
 */
declare class Document extends Object$1 {
  #private;
  /**
   * The type URI of {@link Document}: `https://www.w3.org/ns/activitystreams#Document`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Document with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    width?: number | null;
    height?: number | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    width?: number | null;
    height?: number | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Document;
  /** Specifies a hint as to the rendering width in
   * device-independent pixels of the linked resource.
   */
  get width(): number | null;
  /** Specifies a hint as to the rendering height in
   * device-independent pixels of the linked resource.
   */
  get height(): number | null;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Document>;
  protected static __fromJsonLd__Document__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Document>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Represents an audio document of any kind.
 */
declare class Audio extends Document {
  /**
   * The type URI of {@link Audio}: `https://www.w3.org/ns/activitystreams#Audio`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Audio with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    width?: number | null;
    height?: number | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    width?: number | null;
    height?: number | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Audio;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Audio>;
  protected static __fromJsonLd__Audio__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Audio>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Indicates that the `actor` is ignoring the `object`.  The `target` and
 * `origin` typically have no defined meaning.
 */
declare class Ignore extends Activity {
  /**
   * The type URI of {@link Ignore}: `https://www.w3.org/ns/activitystreams#Ignore`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Ignore with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Ignore;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Ignore>;
  protected static __fromJsonLd__Ignore__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Ignore>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Indicates that the `actor` is blocking the `object`.  Blocking is a stronger
 * form of {@link Ignore}.  The typical use is to support social systems that
 * allow one user to block activities or content of other users.  The `target`
 * and `origin` typically have no defined meaning.
 */
declare class Block extends Ignore {
  /**
   * The type URI of {@link Block}: `https://www.w3.org/ns/activitystreams#Block`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Block with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Block;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Block>;
  protected static __fromJsonLd__Block__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Block>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** A `Collection` is a subtype of {@link Object} that represents ordered or
 * unordered sets of {@link Object} or {@link Link} instances.
 *
 * Refer to the Activity Streams 2.0 Core specification for a complete
 * description of the Collection type.
 */
declare class Collection extends Object$1 {
  #private;
  /**
   * The type URI of {@link Collection}: `https://www.w3.org/ns/activitystreams#Collection`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Collection with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    totalItems?: number | null;
    current?: CollectionPage | URL | null;
    first?: CollectionPage | URL | null;
    last?: CollectionPage | URL | null;
    items?: (Object$1 | Link | URL)[];
    likesOf?: Object$1 | URL | null;
    sharesOf?: Object$1 | URL | null;
    repliesOf?: Object$1 | URL | null;
    inboxOf?: Object$1 | URL | null;
    outboxOf?: Object$1 | URL | null;
    followersOf?: Object$1 | URL | null;
    followingOf?: Object$1 | URL | null;
    likedOf?: Object$1 | URL | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    totalItems?: number | null;
    current?: CollectionPage | URL | null;
    first?: CollectionPage | URL | null;
    last?: CollectionPage | URL | null;
    items?: (Object$1 | Link | URL)[];
    likesOf?: Object$1 | URL | null;
    sharesOf?: Object$1 | URL | null;
    repliesOf?: Object$1 | URL | null;
    inboxOf?: Object$1 | URL | null;
    outboxOf?: Object$1 | URL | null;
    followersOf?: Object$1 | URL | null;
    followingOf?: Object$1 | URL | null;
    likedOf?: Object$1 | URL | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Collection;
  /** A non-negative integer specifying the total number of objects contained by
   * the logical view of the collection. This number might not reflect the actual
   * number of items serialized within the {@link Collection} object instance.
   */
  get totalItems(): number | null;
  /**
   * Similar to
   * {@link Collection.getCurrent},
   * but returns its `@id` URL instead of the object itself.
   */
  get currentId(): URL | null;
  /** In a paged {@link Collection}, indicates the page that contains
   * the most recently updated member items.
   */
  getCurrent(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<CollectionPage | null>;
  /**
   * Similar to
   * {@link Collection.getFirst},
   * but returns its `@id` URL instead of the object itself.
   */
  get firstId(): URL | null;
  /** In a paged {@link Collection}, indicates the furthest preceding page of
   * items in the collection.
   */
  getFirst(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<CollectionPage | null>;
  /**
   * Similar to
   * {@link Collection.getLast},
   * but returns its `@id` URL instead of the object itself.
   */
  get lastId(): URL | null;
  /** In a paged {@link Collection}, indicates the furthest proceeding page of
   * the collection.
   */
  getLast(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<CollectionPage | null>;
  /**
   * Similar to
   * {@link Collection.getItems},
   * but returns their `@id`s instead of the objects themselves.
   */
  get itemIds(): URL[];
  /** Identifies the items contained in a collection.  The items might be ordered
   * or unordered.
   */
  getItems(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Object$1 | Link>;
  /**
   * Similar to
   * {@link Collection.getLikesOf},
   * but returns its `@id` URL instead of the object itself.
   */
  get likesOfId(): URL | null;
  /** Defines an object for which the collection is the value of the likes property.
   */
  getLikesOf(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Object$1 | null>;
  /**
   * Similar to
   * {@link Collection.getSharesOf},
   * but returns its `@id` URL instead of the object itself.
   */
  get sharesOfId(): URL | null;
  /** Defines an object for which the collection is the value of the shares property.
   */
  getSharesOf(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Object$1 | null>;
  /**
   * Similar to
   * {@link Collection.getRepliesOf},
   * but returns its `@id` URL instead of the object itself.
   */
  get repliesOfId(): URL | null;
  /** Defines an object for which the collection is the value of the replies property.
   */
  getRepliesOf(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Object$1 | null>;
  /**
   * Similar to
   * {@link Collection.getInboxOf},
   * but returns its `@id` URL instead of the object itself.
   */
  get inboxOfId(): URL | null;
  /** Defines an actor for which the collection is the value of the inbox property.
   */
  getInboxOf(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Object$1 | null>;
  /**
   * Similar to
   * {@link Collection.getOutboxOf},
   * but returns its `@id` URL instead of the object itself.
   */
  get outboxOfId(): URL | null;
  /** Defines an actor for which the collection is the value of the outbox property.
   */
  getOutboxOf(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Object$1 | null>;
  /**
   * Similar to
   * {@link Collection.getFollowersOf},
   * but returns its `@id` URL instead of the object itself.
   */
  get followersOfId(): URL | null;
  /** Defines an actor for which the collection is the value of the followers property.
   */
  getFollowersOf(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Object$1 | null>;
  /**
   * Similar to
   * {@link Collection.getFollowingOf},
   * but returns its `@id` URL instead of the object itself.
   */
  get followingOfId(): URL | null;
  /** Defines an actor for which the collection is the value of the following property.
   */
  getFollowingOf(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Object$1 | null>;
  /**
   * Similar to
   * {@link Collection.getLikedOf},
   * but returns its `@id` URL instead of the object itself.
   */
  get likedOfId(): URL | null;
  /** Defines an actor for which the collection is the value of the liked property.
   */
  getLikedOf(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Object$1 | null>;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Collection>;
  protected static __fromJsonLd__Collection__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Collection>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Used to represent distinct subsets of items from a `Collection`.
 * Refer to the Activity Streams 2.0 Core for a complete description of
 * the `CollectionPage` object.
 */
declare class CollectionPage extends Collection {
  #private;
  /**
   * The type URI of {@link CollectionPage}: `https://www.w3.org/ns/activitystreams#CollectionPage`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of CollectionPage with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    totalItems?: number | null;
    current?: CollectionPage | URL | null;
    first?: CollectionPage | URL | null;
    last?: CollectionPage | URL | null;
    items?: (Object$1 | Link | URL)[];
    likesOf?: Object$1 | URL | null;
    sharesOf?: Object$1 | URL | null;
    repliesOf?: Object$1 | URL | null;
    inboxOf?: Object$1 | URL | null;
    outboxOf?: Object$1 | URL | null;
    followersOf?: Object$1 | URL | null;
    followingOf?: Object$1 | URL | null;
    likedOf?: Object$1 | URL | null;
    partOf?: Collection | URL | null;
    next?: CollectionPage | URL | null;
    prev?: CollectionPage | URL | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    totalItems?: number | null;
    current?: CollectionPage | URL | null;
    first?: CollectionPage | URL | null;
    last?: CollectionPage | URL | null;
    items?: (Object$1 | Link | URL)[];
    likesOf?: Object$1 | URL | null;
    sharesOf?: Object$1 | URL | null;
    repliesOf?: Object$1 | URL | null;
    inboxOf?: Object$1 | URL | null;
    outboxOf?: Object$1 | URL | null;
    followersOf?: Object$1 | URL | null;
    followingOf?: Object$1 | URL | null;
    likedOf?: Object$1 | URL | null;
    partOf?: Collection | URL | null;
    next?: CollectionPage | URL | null;
    prev?: CollectionPage | URL | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): CollectionPage;
  /**
   * Similar to
   * {@link CollectionPage.getPartOf},
   * but returns its `@id` URL instead of the object itself.
   */
  get partOfId(): URL | null;
  /** Identifies the {@link Collection} to which a {@link CollectionPage} objects
   * items belong.
   */
  getPartOf(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link CollectionPage.getNext},
   * but returns its `@id` URL instead of the object itself.
   */
  get nextId(): URL | null;
  /** In a paged {@link Collection}, indicates the next page of items.
   */
  getNext(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<CollectionPage | null>;
  /**
   * Similar to
   * {@link CollectionPage.getPrev},
   * but returns its `@id` URL instead of the object itself.
   */
  get prevId(): URL | null;
  /** In a paged {@link Collection}, identifies the previous page of items.
   */
  getPrev(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<CollectionPage | null>;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<CollectionPage>;
  protected static __fromJsonLd__CollectionPage__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<CollectionPage>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Indicates that the `actor` has created the `object`.
 */
declare class Create extends Activity {
  /**
   * The type URI of {@link Create}: `https://www.w3.org/ns/activitystreams#Create`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Create with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Create;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Create>;
  protected static __fromJsonLd__Create__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Create>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Indicates that the `actor` has deleted the `object`.  If specified,
 * the `origin` indicates the context from which the `object` was deleted.
 */
declare class Delete extends Activity {
  /**
   * The type URI of {@link Delete}: `https://www.w3.org/ns/activitystreams#Delete`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Delete with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Delete;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Delete>;
  protected static __fromJsonLd__Delete__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Delete>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Indicates that the `actor` dislikes the `object`.
 */
declare class Dislike extends Activity {
  /**
   * The type URI of {@link Dislike}: `https://www.w3.org/ns/activitystreams#Dislike`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Dislike with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Dislike;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Dislike>;
  protected static __fromJsonLd__Dislike__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Dislike>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Contents of {@link Actor}'s `endpoints`.
 */
declare class Endpoints {
  #private;
  readonly id: URL | null;
  protected get _documentLoader(): DocumentLoader | undefined;
  protected get _contextLoader(): DocumentLoader | undefined;
  protected get _tracerProvider(): TracerProvider | undefined;
  protected get _warning(): {
    category: string[];
    message: string;
    values?: Record<string, unknown>;
  } | undefined;
  protected get _cachedJsonLd(): unknown | undefined;
  protected set _cachedJsonLd(value: unknown | undefined);
  /**
   * The type URI of {@link Endpoints}: `https://www.w3.org/ns/activitystreams#Endpoints`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Endpoints with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    proxyUrl?: URL | null;
    oauthAuthorizationEndpoint?: URL | null;
    oauthTokenEndpoint?: URL | null;
    provideClientKey?: URL | null;
    signClientKey?: URL | null;
    sharedInbox?: URL | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    proxyUrl?: URL | null;
    oauthAuthorizationEndpoint?: URL | null;
    oauthTokenEndpoint?: URL | null;
    provideClientKey?: URL | null;
    signClientKey?: URL | null;
    sharedInbox?: URL | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Endpoints;
  /** Endpoint URI so this actor's clients may access remote ActivityStreams
   * objects which require authentication to access.  To use this endpoint,
   * the client posts an `x-www-form-urlencoded` `id` parameter with the value
   * being the `id` of the requested ActivityStreams object.
   */
  get proxyUrl(): URL | null;
  /** If OAuth 2.0 bearer tokens [RFC 6749] [RFC 6750] are being used for
   * authenticating [client to server
   * interactions](https://www.w3.org/TR/activitypub/#client-to-server-interactions),
   * this endpoint specifies a URI at which a browser-authenticated user may
   * obtain a new authorization grant.
   */
  get oauthAuthorizationEndpoint(): URL | null;
  /** If OAuth 2.0 bearer tokens [RFC 6749] [RFC 6750] are being used for
   * authenticating [client to server
   * interactions](https://www.w3.org/TR/activitypub/#client-to-server-interactions),
   * this endpoint specifies a URI at which a client may acquire an access token.
   */
  get oauthTokenEndpoint(): URL | null;
  /** If Linked Data Signatures and HTTP Signatures are being used for
   * authentication and authorization, this endpoint specifies a URI at which
   * browser-authenticated users may authorize a client's public key for [client
   * to server interactions](https://www.w3.org/TR/activitypub/#client-to-server-interactions).
   */
  get provideClientKey(): URL | null;
  /** If Linked Data Signatures and HTTP Signatures are being used for
   * authentication and authorization, this endpoint specifies a URI at which
   * a client key may be signed by the actor's key for a time window to act on
   * behalf of the actor in interacting with foreign servers.
   */
  get signClientKey(): URL | null;
  /** An optional endpoint [used for wide delivery of publicly addressed
   * activities and activities sent to
   * followers](https://www.w3.org/TR/activitypub/#shared-inbox-delivery).
   * `sharedInbox` endpoints SHOULD also be publicly readable
   * {@link OrderedCollection} objects containing objects addressed to the
   * [Public](https://www.w3.org/TR/activitypub/#public-addressing) special
   * collection.  Reading from the `sharedInbox` endpoint MUST NOT present
   * objects which are not addressed to the `Public`` endpoint.
   */
  get sharedInbox(): URL | null;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Endpoints>;
  protected static __fromJsonLd__Endpoints__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Endpoints>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Represents any kind of event.
 */
declare class Event extends Object$1 {
  /**
   * The type URI of {@link Event}: `https://www.w3.org/ns/activitystreams#Event`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Event with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Event;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Event>;
  protected static __fromJsonLd__Event__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Event>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Indicates that the `actor` is "flagging" the `object`.  Flagging is defined
 * in the sense common to many social platforms as reporting content as being
 * inappropriate for any number of reasons.
 */
declare class Flag extends Activity {
  /**
   * The type URI of {@link Flag}: `https://www.w3.org/ns/activitystreams#Flag`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Flag with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Flag;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Flag>;
  protected static __fromJsonLd__Flag__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Flag>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Indicates that the `actor` is "following" the `object`.  Following is defined
 * in the sense typically used within Social systems in which the actor is
 * interested in any activity performed by or on the object.  The `target` and
 * `origin` typically have no defined meaning.
 */
declare class Follow extends Activity {
  /**
   * The type URI of {@link Follow}: `https://www.w3.org/ns/activitystreams#Follow`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Follow with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Follow;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Follow>;
  protected static __fromJsonLd__Follow__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Follow>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Represents a formal or informal collective of Actors.
 */
declare class Group extends Object$1 {
  #private;
  /**
   * The type URI of {@link Group}: `https://www.w3.org/ns/activitystreams#Group`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Group with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    preferredUsername?: string | LanguageString | null;
    preferredUsernames?: ((string | LanguageString))[];
    publicKey?: CryptographicKey | URL | null;
    publicKeys?: (CryptographicKey | URL)[];
    assertionMethod?: Multikey | URL | null;
    assertionMethods?: (Multikey | URL)[];
    manuallyApprovesFollowers?: boolean | null;
    inbox?: OrderedCollection | OrderedCollectionPage | URL | null;
    outbox?: OrderedCollection | OrderedCollectionPage | URL | null;
    following?: Collection | URL | null;
    followers?: Collection | URL | null;
    liked?: Collection | URL | null;
    featured?: Collection | URL | null;
    featuredTags?: Collection | URL | null;
    streams?: (Collection | URL)[];
    endpoints?: Endpoints | null;
    discoverable?: boolean | null;
    suspended?: boolean | null;
    memorial?: boolean | null;
    indexable?: boolean | null;
    successor?: Application | Group | Organization | Person | Service | URL | null;
    alias?: Application | Group | Organization | Person | Service | URL | null;
    aliases?: (Application | Group | Organization | Person | Service | URL)[];
    service?: DidService | URL | null;
    services?: (DidService | URL)[];
    followedMessage?: string | null;
    cat?: boolean | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    preferredUsername?: string | LanguageString | null;
    preferredUsernames?: ((string | LanguageString))[];
    publicKey?: CryptographicKey | URL | null;
    publicKeys?: (CryptographicKey | URL)[];
    assertionMethod?: Multikey | URL | null;
    assertionMethods?: (Multikey | URL)[];
    manuallyApprovesFollowers?: boolean | null;
    inbox?: OrderedCollection | OrderedCollectionPage | URL | null;
    outbox?: OrderedCollection | OrderedCollectionPage | URL | null;
    following?: Collection | URL | null;
    followers?: Collection | URL | null;
    liked?: Collection | URL | null;
    featured?: Collection | URL | null;
    featuredTags?: Collection | URL | null;
    streams?: (Collection | URL)[];
    endpoints?: Endpoints | null;
    discoverable?: boolean | null;
    suspended?: boolean | null;
    memorial?: boolean | null;
    indexable?: boolean | null;
    successor?: Application | Group | Organization | Person | Service | URL | null;
    alias?: Application | Group | Organization | Person | Service | URL | null;
    aliases?: (Application | Group | Organization | Person | Service | URL)[];
    service?: DidService | URL | null;
    services?: (DidService | URL)[];
    followedMessage?: string | null;
    cat?: boolean | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Group;
  /** A short username which may be used to refer to the actor,
   * with no uniqueness guarantees.
   */
  get preferredUsername(): string | LanguageString | null;
  /** A short username which may be used to refer to the actor,
   * with no uniqueness guarantees.
   */
  get preferredUsernames(): ((string | LanguageString))[];
  /**
   * Similar to
   * {@link Group.getPublicKey},
   * but returns its `@id` URL instead of the object itself.
   */
  get publicKeyId(): URL | null;
  /** A public part of the key pair owned by this actor.
   */
  getPublicKey(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<CryptographicKey | null>;
  /**
   * Similar to
   * {@link Group.getPublicKeys},
   * but returns their `@id`s instead of the objects themselves.
   */
  get publicKeyIds(): URL[];
  /** A public part of the key pair owned by this actor.
   */
  getPublicKeys(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<CryptographicKey>;
  /**
   * Similar to
   * {@link Group.getAssertionMethod},
   * but returns its `@id` URL instead of the object itself.
   */
  get assertionMethodId(): URL | null;
  /** Represents this actor's public keys.  It serves as equivalent to
   * the `publicKeys` property, but is used for [FEP-521a] compliance.
   *
   * [FEP-521a]: https://w3id.org/fep/521a
   */
  getAssertionMethod(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Multikey | null>;
  /**
   * Similar to
   * {@link Group.getAssertionMethods},
   * but returns their `@id`s instead of the objects themselves.
   */
  get assertionMethodIds(): URL[];
  /** Represents this actor's public keys.  It serves as equivalent to
   * the `publicKeys` property, but is used for [FEP-521a] compliance.
   *
   * [FEP-521a]: https://w3id.org/fep/521a
   */
  getAssertionMethods(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Multikey>;
  /** When `true`, conveys that for this actor, follow requests are not usually
   * automatically approved, but instead are examined by a person who may accept
   * or reject the request, at some time in the future.  Setting of `false`
   * conveys no information and may be ignored.  This information is typically
   * used to affect display of accounts, such as showing an account as private or
   * locked.
   */
  get manuallyApprovesFollowers(): boolean | null;
  /**
   * Similar to
   * {@link Group.getInbox},
   * but returns its `@id` URL instead of the object itself.
   */
  get inboxId(): URL | null;
  /** The inbox stream contains all activities received by the actor.  The server
   * SHOULD filter content according to the requester's permission.  In general,
   * the owner of an inbox is likely to be able to access all of their inbox
   * contents.  Depending on access control, some other content may be public,
   * whereas other content may require authentication for non-owner users,
   * if they can access the inbox at all.
   *
   * The server MUST perform de-duplication of activities returned by the inbox.
   * Duplication can occur if an activity is addressed both to an actor's
   * followers, and a specific actor who also follows the recipient actor,
   * and the server has failed to de-duplicate the recipients list.
   * Such deduplication MUST be performed by comparing the `id` of the activities
   * and dropping any activities already seen.
   */
  getInbox(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<OrderedCollection | OrderedCollectionPage | null>;
  /**
   * Similar to
   * {@link Group.getOutbox},
   * but returns its `@id` URL instead of the object itself.
   */
  get outboxId(): URL | null;
  /** The outbox stream contains activities the user has published,
   * subject to the ability of the requestor to retrieve the activity
   * (that is, the contents of the outbox are filtered by the permissions of
   * the person reading it).  If a user submits a request without
   * [Authorization](https://www.w3.org/TR/activitypub/#authorization)
   * the server should respond with all of the
   * [Public](https://www.w3.org/TR/activitypub/#public-addressing) posts.
   * This could potentially be all relevant objects published by the user,
   * though the number of available items is left to the discretion of those
   * implementing and deploying the server.
   */
  getOutbox(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<OrderedCollection | OrderedCollectionPage | null>;
  /**
   * Similar to
   * {@link Group.getFollowing},
   * but returns its `@id` URL instead of the object itself.
   */
  get followingId(): URL | null;
  /** This is a list of everybody that the actor has followed, added as a
   * [side effect](https://www.w3.org/TR/activitypub/#follow-activity-outbox).
   * The `following` collection MUST be either an {@link OrderedCollection}
   * or a {@link Collection} and MAY be filtered on privileges of
   * an authenticated user or as appropriate when no authentication is given.
   */
  getFollowing(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Group.getFollowers},
   * but returns its `@id` URL instead of the object itself.
   */
  get followersId(): URL | null;
  /** This is a list of everyone who has sent a {@link Follow} activity
   * for the actor, added as a
   * [side effect](https://www.w3.org/TR/activitypub/#follow-activity-outbox).
   * This is where one would find a list of all the actors that are following
   * the actor.  The `followers` collection MUST be either
   * an {@link OrderedCollection} or a {@link Collection} and MAY be filtered on
   * privileges of an authenticated user or as appropriate when no authentication
   * is given.
   */
  getFollowers(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Group.getLiked},
   * but returns its `@id` URL instead of the object itself.
   */
  get likedId(): URL | null;
  /** This is a list of every object from all of the actor's {@link Like}
   * activities, added as a
   * [side effect](https://www.w3.org/TR/activitypub/#like-activity-outbox).
   * The `liked` collection MUST be either an {@link OrderedCollection} or
   * a {@link Collection} and MAY be filtered on privileges of an authenticated
   * user or as appropriate when no authentication is given.
   */
  getLiked(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Group.getFeatured},
   * but returns its `@id` URL instead of the object itself.
   */
  get featuredId(): URL | null;
  /** What is known in Mastodon as "pinned statuses", or statuses that are always
   * featured at the top of people's profiles, is implemented using an extra
   * property `featured` on the actor object that points to a {@link Collection}
   * of objects.
   */
  getFeatured(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Group.getFeaturedTags},
   * but returns its `@id` URL instead of the object itself.
   */
  get featuredTagsId(): URL | null;
  /** What is known in Mastodon as "featured hashtags", hashtags that are featured
   * at people's profiles, is implemented using an extra property `featuredTags`
   * on the actor object that points to a {@link Collection} of {@link Hashtag}
   * objects specifically.
   */
  getFeaturedTags(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Group.getStreams},
   * but returns their `@id`s instead of the objects themselves.
   */
  get streamIds(): URL[];
  /** A list of supplementary Collections which may be of interest.
   */
  getStreams(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Collection>;
  /** A JSON object which maps additional (typically server/domain-wide) endpoints
   * which may be useful either for this actor or someone referencing this actor.
   * This mapping may be nested inside the actor document as the value or may be
   * a link to a JSON-LD document with these properties.
   */
  get endpoints(): Endpoints | null;
  /** Allows users to opt-in or opt-out of discoverability features like
   * the profile directory.  This flag may also be used as an indicator of
   * the user's preferences toward being included in external discovery services,
   * such as search engines or other indexing tools.
   */
  get discoverable(): boolean | null;
  /** Reports whether a user was locally suspended, for better handling of
   * these accounts.
   */
  get suspended(): boolean | null;
  /** Whether the actor is in-memorial state.
   */
  get memorial(): boolean | null;
  /** Whether the actor allows to be indexed.
   */
  get indexable(): boolean | null;
  /**
   * Similar to
   * {@link Group.getSuccessor},
   * but returns its `@id` URL instead of the object itself.
   */
  get successorId(): URL | null;
  /** Signifies that an actor has been moved to a different ID. Used in Mastodon-style data portability with the {@link Move} activity; see [ActivityPub Data Portability/Move Action](https://swicg.github.io/activitypub-data-portability/#move-action) for more details.
   */
  getSuccessor(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Application | Group | Organization | Person | Service | null>;
  /**
   * Similar to
   * {@link Group.getAlias},
   * but returns its `@id` URL instead of the object itself.
   */
  get aliasId(): URL | null;
  /** The `aliases` (`alsoKnownAs`) property is used to specify alternative names
   * or aliases for an entity.  It can be used to provide additional identifiers
   * or labels for an entity, which can be useful in scenarios where an entity
   * may have multiple names or aliases.
   */
  getAlias(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Application | Group | Organization | Person | Service | null>;
  /**
   * Similar to
   * {@link Group.getAliases},
   * but returns their `@id`s instead of the objects themselves.
   */
  get aliasIds(): URL[];
  /** The `aliases` (`alsoKnownAs`) property is used to specify alternative names
   * or aliases for an entity.  It can be used to provide additional identifiers
   * or labels for an entity, which can be useful in scenarios where an entity
   * may have multiple names or aliases.
   */
  getAliases(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Application | Group | Organization | Person | Service>;
  /**
   * Similar to
   * {@link Group.getService},
   * but returns its `@id` URL instead of the object itself.
   */
  get serviceId(): URL | null;
  /** Means of communicating or interacting with the DID subject or associated
   * entities via one or more service endpoints. Examples include discovery
   * services, agent services, social networking services, file storage services,
   * and verifiable credential repository services.
   */
  getService(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<DidService | null>;
  /**
   * Similar to
   * {@link Group.getServices},
   * but returns their `@id`s instead of the objects themselves.
   */
  get serviceIds(): URL[];
  /** Means of communicating or interacting with the DID subject or associated
   * entities via one or more service endpoints. Examples include discovery
   * services, agent services, social networking services, file storage services,
   * and verifiable credential repository services.
   */
  getServices(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<DidService>;
  /** This value is used for `Actor` type objects to show message on followed.
   */
  get followedMessage(): string | null;
  /** Used on actors to indicate that they in some way identify as a cat,
   * expressed as a boolean value. If this property is set to `true`,
   * displaying the actor or their notes will have some special effects
   * attached in some clients.
   */
  get cat(): boolean | null;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Group>;
  protected static __fromJsonLd__Group__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Group>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** A Link is an indirect, qualified reference to a resource identified by a URL.
 * The fundamental model for links is established by RFC 5988. Many of the
 * properties defined by the Activity Vocabulary allow values that are either
 * instances of {@link Object} or {@link Link}. When a {@link Link} is used,
 * it establishes a qualified relation connecting the subject (the containing
 * object) to the resource identified by the `href`. Properties of
 * the {@link Link} are properties of the reference as opposed to properties of
 * the resource.
 */
declare class Link {
  #private;
  readonly id: URL | null;
  protected get _documentLoader(): DocumentLoader | undefined;
  protected get _contextLoader(): DocumentLoader | undefined;
  protected get _tracerProvider(): TracerProvider | undefined;
  protected get _warning(): {
    category: string[];
    message: string;
    values?: Record<string, unknown>;
  } | undefined;
  protected get _cachedJsonLd(): unknown | undefined;
  protected set _cachedJsonLd(value: unknown | undefined);
  /**
   * The type URI of {@link Link}: `https://www.w3.org/ns/activitystreams#Link`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Link with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    href?: URL | null;
    rel?: string | null;
    rels?: (string)[];
    mediaType?: string | null;
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    language?: LanguageTag | null;
    height?: number | null;
    width?: number | null;
    previews?: (Link | Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    href?: URL | null;
    rel?: string | null;
    rels?: (string)[];
    mediaType?: string | null;
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    language?: LanguageTag | null;
    height?: number | null;
    width?: number | null;
    previews?: (Link | Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Link;
  /** The target resource pointed to by a {@link Link}.
   */
  get href(): URL | null;
  /** A link relation associated with a {@link Link}. The value MUST conform to
   * both the HTML5 and RFC 5988 "link relation" definitions.
   *
   * In the HTML5, any string not containing the space (U+0020), tab (U+0009),
   * LF (U+000A), FF (U+000C), CR (U+000D) or comma (U+002C) characters can
   * be used as a valid link relation.
   */
  get rel(): string | null;
  /** A link relation associated with a {@link Link}. The value MUST conform to
   * both the HTML5 and RFC 5988 "link relation" definitions.
   *
   * In the HTML5, any string not containing the space (U+0020), tab (U+0009),
   * LF (U+000A), FF (U+000C), CR (U+000D) or comma (U+002C) characters can
   * be used as a valid link relation.
   */
  get rels(): (string)[];
  /** When used on a {@link Link}, identifies the MIME media type of the
   * referenced resource.
   */
  get mediaType(): string | null;
  /** A simple, human-readable, plain-text name for the object. HTML markup MUST
   * NOT be included. The name MAY be expressed using multiple language-tagged
   * values.
   */
  get name(): string | LanguageString | null;
  /** A simple, human-readable, plain-text name for the object. HTML markup MUST
   * NOT be included. The name MAY be expressed using multiple language-tagged
   * values.
   */
  get names(): ((string | LanguageString))[];
  /** Hints as to the language used by the target resource.
   * Value MUST be a BCP 47 Language-Tag.
   */
  get language(): LanguageTag | null;
  /** On a {@link Link}, specifies a hint as to the rendering height in
   * device-independent pixels of the linked resource.
   */
  get height(): number | null;
  /** On a {@link Link}, specifies a hint as to the rendering width in
   * device-independent pixels of the linked resource.
   */
  get width(): number | null;
  /**
   * Similar to
   * {@link Link.getPreviews},
   * but returns their `@id`s instead of the objects themselves.
   */
  get previewIds(): URL[];
  /** Identifies an entity that provides a preview of this object.
   */
  getPreviews(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Link | Object$1>;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Link>;
  protected static __fromJsonLd__Link__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Link>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** A specialized {@link Link} that represents an #hashtag.
 *
 * See also <https://swicg.github.io/miscellany/#Hashtag>.
 */
declare class Hashtag extends Link {
  /**
   * The type URI of {@link Hashtag}: `https://www.w3.org/ns/activitystreams#Hashtag`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Hashtag with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    href?: URL | null;
    rel?: string | null;
    rels?: (string)[];
    mediaType?: string | null;
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    language?: LanguageTag | null;
    height?: number | null;
    width?: number | null;
    previews?: (Link | Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    href?: URL | null;
    rel?: string | null;
    rels?: (string)[];
    mediaType?: string | null;
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    language?: LanguageTag | null;
    height?: number | null;
    width?: number | null;
    previews?: (Link | Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Hashtag;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Hashtag>;
  protected static __fromJsonLd__Hashtag__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Hashtag>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** An image document of any kind.
 */
declare class Image extends Document {
  /**
   * The type URI of {@link Image}: `https://www.w3.org/ns/activitystreams#Image`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Image with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    width?: number | null;
    height?: number | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    width?: number | null;
    height?: number | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Image;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Image>;
  protected static __fromJsonLd__Image__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Image>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Indicates that the actor is offering the object.
 * If specified, the target indicates the entity to which
 * the object is being offered.
 */
declare class Offer extends Activity {
  /**
   * The type URI of {@link Offer}: `https://www.w3.org/ns/activitystreams#Offer`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Offer with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Offer;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Offer>;
  protected static __fromJsonLd__Offer__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Offer>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** A specialization of `Offer` in which the `actor` is extending an invitation
 * for the `object` to the `target`.
 */
declare class Invite extends Offer {
  /**
   * The type URI of {@link Invite}: `https://www.w3.org/ns/activitystreams#Invite`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Invite with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Invite;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Invite>;
  protected static __fromJsonLd__Invite__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Invite>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Indicates that the `actor` has joined the `object`.
 * The `target` and `origin` typically have no defined meaning.
 */
declare class Join extends Activity {
  /**
   * The type URI of {@link Join}: `https://www.w3.org/ns/activitystreams#Join`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Join with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Join;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Join>;
  protected static __fromJsonLd__Join__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Join>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Indicates that the `actor` has left the `object`.
 * The `target` and `origin` typically have no meaning.
 */
declare class Leave extends Activity {
  /**
   * The type URI of {@link Leave}: `https://www.w3.org/ns/activitystreams#Leave`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Leave with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Leave;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Leave>;
  protected static __fromJsonLd__Leave__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Leave>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Indicates that the `actor` likes, recommends or endorses the `object`.
 * The `target` and `origin` typically have no defined meaning.
 */
declare class Like extends Activity {
  /**
   * The type URI of {@link Like}: `https://www.w3.org/ns/activitystreams#Like`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Like with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Like;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Like>;
  protected static __fromJsonLd__Like__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Like>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Indicates that the `actor` has listened to the `object`.
 */
declare class Listen extends Activity {
  /**
   * The type URI of {@link Listen}: `https://www.w3.org/ns/activitystreams#Listen`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Listen with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Listen;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Listen>;
  protected static __fromJsonLd__Listen__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Listen>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** A specialized {@link Link} that represents an @mention.
 */
declare class Mention extends Link {
  /**
   * The type URI of {@link Mention}: `https://www.w3.org/ns/activitystreams#Mention`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Mention with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    href?: URL | null;
    rel?: string | null;
    rels?: (string)[];
    mediaType?: string | null;
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    language?: LanguageTag | null;
    height?: number | null;
    width?: number | null;
    previews?: (Link | Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    href?: URL | null;
    rel?: string | null;
    rels?: (string)[];
    mediaType?: string | null;
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    language?: LanguageTag | null;
    height?: number | null;
    width?: number | null;
    previews?: (Link | Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Mention;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Mention>;
  protected static __fromJsonLd__Mention__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Mention>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Indicates that the `actor` has moved `object` from `origin` to `target`.
 * If the `origin` or `target` are not specified,
 * either can be determined by context.
 */
declare class Move extends Activity {
  /**
   * The type URI of {@link Move}: `https://www.w3.org/ns/activitystreams#Move`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Move with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Move;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Move>;
  protected static __fromJsonLd__Move__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Move>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Represents a short written work typically less than a single paragraph in
 * length.
 */
declare class Note extends Object$1 {
  #private;
  /**
   * The type URI of {@link Note}: `https://www.w3.org/ns/activitystreams#Note`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Note with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    quoteUrl?: URL | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    quoteUrl?: URL | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Note;
  /** The URI of the ActivityStreams object that this object quotes.
   *
   * This property sets three JSON-LD properties at once under the hood:
   *
   * 1. https://www.w3.org/ns/activitystreams#quoteUrl
   * 2. https://misskey-hub.net/ns#_misskey_quote
   * 3. http://fedibird.com/ns#quoteUri
   *
   * When a JSON-LD object is parsed, this property is filled with one of
   * the values of those three properties in order.
   */
  get quoteUrl(): URL | null;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Note>;
  protected static __fromJsonLd__Note__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Note>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** A subtype of {@link Collection} in which members of the logical collection
 * are assumed to always be strictly ordered.
 */
declare class OrderedCollection extends Collection {
  #private;
  /**
   * The type URI of {@link OrderedCollection}: `https://www.w3.org/ns/activitystreams#OrderedCollection`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of OrderedCollection with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    totalItems?: number | null;
    current?: CollectionPage | URL | null;
    first?: CollectionPage | URL | null;
    last?: CollectionPage | URL | null;
    likesOf?: Object$1 | URL | null;
    sharesOf?: Object$1 | URL | null;
    repliesOf?: Object$1 | URL | null;
    inboxOf?: Object$1 | URL | null;
    outboxOf?: Object$1 | URL | null;
    followersOf?: Object$1 | URL | null;
    followingOf?: Object$1 | URL | null;
    likedOf?: Object$1 | URL | null;
    items?: (Object$1 | Link | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    totalItems?: number | null;
    current?: CollectionPage | URL | null;
    first?: CollectionPage | URL | null;
    last?: CollectionPage | URL | null;
    likesOf?: Object$1 | URL | null;
    sharesOf?: Object$1 | URL | null;
    repliesOf?: Object$1 | URL | null;
    inboxOf?: Object$1 | URL | null;
    outboxOf?: Object$1 | URL | null;
    followersOf?: Object$1 | URL | null;
    followingOf?: Object$1 | URL | null;
    likedOf?: Object$1 | URL | null;
    items?: (Object$1 | Link | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): OrderedCollection;
  /**
   * Similar to
   * {@link OrderedCollection.getItems},
   * but returns their `@id`s instead of the objects themselves.
   */
  get itemIds(): URL[];
  /** Identifies the items contained in a collection.  The items might be ordered
   * or unordered.
   */
  getItems(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Object$1 | Link>;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<OrderedCollection>;
  protected static __fromJsonLd__OrderedCollection__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<OrderedCollection>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Used to represent ordered subsets of items from an `OrderedCollection`.
 * Refer to the Activity Streams 2.0 Core for a complete description of
 * the `OrderedCollectionPage` object.
 */
declare class OrderedCollectionPage extends CollectionPage {
  #private;
  /**
   * The type URI of {@link OrderedCollectionPage}: `https://www.w3.org/ns/activitystreams#OrderedCollectionPage`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of OrderedCollectionPage with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    totalItems?: number | null;
    current?: CollectionPage | URL | null;
    first?: CollectionPage | URL | null;
    last?: CollectionPage | URL | null;
    likesOf?: Object$1 | URL | null;
    sharesOf?: Object$1 | URL | null;
    repliesOf?: Object$1 | URL | null;
    inboxOf?: Object$1 | URL | null;
    outboxOf?: Object$1 | URL | null;
    followersOf?: Object$1 | URL | null;
    followingOf?: Object$1 | URL | null;
    likedOf?: Object$1 | URL | null;
    partOf?: Collection | URL | null;
    next?: CollectionPage | URL | null;
    prev?: CollectionPage | URL | null;
    items?: (Object$1 | Link | URL)[];
    startIndex?: number | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    totalItems?: number | null;
    current?: CollectionPage | URL | null;
    first?: CollectionPage | URL | null;
    last?: CollectionPage | URL | null;
    likesOf?: Object$1 | URL | null;
    sharesOf?: Object$1 | URL | null;
    repliesOf?: Object$1 | URL | null;
    inboxOf?: Object$1 | URL | null;
    outboxOf?: Object$1 | URL | null;
    followersOf?: Object$1 | URL | null;
    followingOf?: Object$1 | URL | null;
    likedOf?: Object$1 | URL | null;
    partOf?: Collection | URL | null;
    next?: CollectionPage | URL | null;
    prev?: CollectionPage | URL | null;
    items?: (Object$1 | Link | URL)[];
    startIndex?: number | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): OrderedCollectionPage;
  /**
   * Similar to
   * {@link OrderedCollectionPage.getItems},
   * but returns their `@id`s instead of the objects themselves.
   */
  get itemIds(): URL[];
  /** Identifies the items contained in a collection.  The items might be ordered
   * or unordered.
   */
  getItems(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Object$1 | Link>;
  /** A non-negative integer value identifying the relative position within
   * the logical view of a strictly ordered collection.
   */
  get startIndex(): number | null;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<OrderedCollectionPage>;
  protected static __fromJsonLd__OrderedCollectionPage__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<OrderedCollectionPage>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Represents an organization.
 */
declare class Organization extends Object$1 {
  #private;
  /**
   * The type URI of {@link Organization}: `https://www.w3.org/ns/activitystreams#Organization`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Organization with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    preferredUsername?: string | LanguageString | null;
    preferredUsernames?: ((string | LanguageString))[];
    publicKey?: CryptographicKey | URL | null;
    publicKeys?: (CryptographicKey | URL)[];
    assertionMethod?: Multikey | URL | null;
    assertionMethods?: (Multikey | URL)[];
    manuallyApprovesFollowers?: boolean | null;
    inbox?: OrderedCollection | OrderedCollectionPage | URL | null;
    outbox?: OrderedCollection | OrderedCollectionPage | URL | null;
    following?: Collection | URL | null;
    followers?: Collection | URL | null;
    liked?: Collection | URL | null;
    featured?: Collection | URL | null;
    featuredTags?: Collection | URL | null;
    streams?: (Collection | URL)[];
    endpoints?: Endpoints | null;
    discoverable?: boolean | null;
    suspended?: boolean | null;
    memorial?: boolean | null;
    indexable?: boolean | null;
    successor?: Application | Group | Organization | Person | Service | URL | null;
    alias?: Application | Group | Organization | Person | Service | URL | null;
    aliases?: (Application | Group | Organization | Person | Service | URL)[];
    service?: DidService | URL | null;
    services?: (DidService | URL)[];
    followedMessage?: string | null;
    cat?: boolean | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    preferredUsername?: string | LanguageString | null;
    preferredUsernames?: ((string | LanguageString))[];
    publicKey?: CryptographicKey | URL | null;
    publicKeys?: (CryptographicKey | URL)[];
    assertionMethod?: Multikey | URL | null;
    assertionMethods?: (Multikey | URL)[];
    manuallyApprovesFollowers?: boolean | null;
    inbox?: OrderedCollection | OrderedCollectionPage | URL | null;
    outbox?: OrderedCollection | OrderedCollectionPage | URL | null;
    following?: Collection | URL | null;
    followers?: Collection | URL | null;
    liked?: Collection | URL | null;
    featured?: Collection | URL | null;
    featuredTags?: Collection | URL | null;
    streams?: (Collection | URL)[];
    endpoints?: Endpoints | null;
    discoverable?: boolean | null;
    suspended?: boolean | null;
    memorial?: boolean | null;
    indexable?: boolean | null;
    successor?: Application | Group | Organization | Person | Service | URL | null;
    alias?: Application | Group | Organization | Person | Service | URL | null;
    aliases?: (Application | Group | Organization | Person | Service | URL)[];
    service?: DidService | URL | null;
    services?: (DidService | URL)[];
    followedMessage?: string | null;
    cat?: boolean | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Organization;
  /** A short username which may be used to refer to the actor,
   * with no uniqueness guarantees.
   */
  get preferredUsername(): string | LanguageString | null;
  /** A short username which may be used to refer to the actor,
   * with no uniqueness guarantees.
   */
  get preferredUsernames(): ((string | LanguageString))[];
  /**
   * Similar to
   * {@link Organization.getPublicKey},
   * but returns its `@id` URL instead of the object itself.
   */
  get publicKeyId(): URL | null;
  /** A public part of the key pair owned by this actor.
   */
  getPublicKey(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<CryptographicKey | null>;
  /**
   * Similar to
   * {@link Organization.getPublicKeys},
   * but returns their `@id`s instead of the objects themselves.
   */
  get publicKeyIds(): URL[];
  /** A public part of the key pair owned by this actor.
   */
  getPublicKeys(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<CryptographicKey>;
  /**
   * Similar to
   * {@link Organization.getAssertionMethod},
   * but returns its `@id` URL instead of the object itself.
   */
  get assertionMethodId(): URL | null;
  /** Represents this actor's public keys.  It serves as equivalent to
   * the `publicKeys` property, but is used for [FEP-521a] compliance.
   *
   * [FEP-521a]: https://w3id.org/fep/521a
   */
  getAssertionMethod(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Multikey | null>;
  /**
   * Similar to
   * {@link Organization.getAssertionMethods},
   * but returns their `@id`s instead of the objects themselves.
   */
  get assertionMethodIds(): URL[];
  /** Represents this actor's public keys.  It serves as equivalent to
   * the `publicKeys` property, but is used for [FEP-521a] compliance.
   *
   * [FEP-521a]: https://w3id.org/fep/521a
   */
  getAssertionMethods(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Multikey>;
  /** When `true`, conveys that for this actor, follow requests are not usually
   * automatically approved, but instead are examined by a person who may accept
   * or reject the request, at some time in the future.  Setting of `false`
   * conveys no information and may be ignored.  This information is typically
   * used to affect display of accounts, such as showing an account as private or
   * locked.
   */
  get manuallyApprovesFollowers(): boolean | null;
  /**
   * Similar to
   * {@link Organization.getInbox},
   * but returns its `@id` URL instead of the object itself.
   */
  get inboxId(): URL | null;
  /** The inbox stream contains all activities received by the actor.  The server
   * SHOULD filter content according to the requester's permission.  In general,
   * the owner of an inbox is likely to be able to access all of their inbox
   * contents.  Depending on access control, some other content may be public,
   * whereas other content may require authentication for non-owner users,
   * if they can access the inbox at all.
   *
   * The server MUST perform de-duplication of activities returned by the inbox.
   * Duplication can occur if an activity is addressed both to an actor's
   * followers, and a specific actor who also follows the recipient actor,
   * and the server has failed to de-duplicate the recipients list.
   * Such deduplication MUST be performed by comparing the `id` of the activities
   * and dropping any activities already seen.
   */
  getInbox(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<OrderedCollection | OrderedCollectionPage | null>;
  /**
   * Similar to
   * {@link Organization.getOutbox},
   * but returns its `@id` URL instead of the object itself.
   */
  get outboxId(): URL | null;
  /** The outbox stream contains activities the user has published,
   * subject to the ability of the requestor to retrieve the activity
   * (that is, the contents of the outbox are filtered by the permissions of
   * the person reading it).  If a user submits a request without
   * [Authorization](https://www.w3.org/TR/activitypub/#authorization)
   * the server should respond with all of the
   * [Public](https://www.w3.org/TR/activitypub/#public-addressing) posts.
   * This could potentially be all relevant objects published by the user,
   * though the number of available items is left to the discretion of those
   * implementing and deploying the server.
   */
  getOutbox(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<OrderedCollection | OrderedCollectionPage | null>;
  /**
   * Similar to
   * {@link Organization.getFollowing},
   * but returns its `@id` URL instead of the object itself.
   */
  get followingId(): URL | null;
  /** This is a list of everybody that the actor has followed, added as a
   * [side effect](https://www.w3.org/TR/activitypub/#follow-activity-outbox).
   * The `following` collection MUST be either an {@link OrderedCollection}
   * or a {@link Collection} and MAY be filtered on privileges of
   * an authenticated user or as appropriate when no authentication is given.
   */
  getFollowing(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Organization.getFollowers},
   * but returns its `@id` URL instead of the object itself.
   */
  get followersId(): URL | null;
  /** This is a list of everyone who has sent a {@link Follow} activity
   * for the actor, added as a
   * [side effect](https://www.w3.org/TR/activitypub/#follow-activity-outbox).
   * This is where one would find a list of all the actors that are following
   * the actor.  The `followers` collection MUST be either
   * an {@link OrderedCollection} or a {@link Collection} and MAY be filtered on
   * privileges of an authenticated user or as appropriate when no authentication
   * is given.
   */
  getFollowers(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Organization.getLiked},
   * but returns its `@id` URL instead of the object itself.
   */
  get likedId(): URL | null;
  /** This is a list of every object from all of the actor's {@link Like}
   * activities, added as a
   * [side effect](https://www.w3.org/TR/activitypub/#like-activity-outbox).
   * The `liked` collection MUST be either an {@link OrderedCollection} or
   * a {@link Collection} and MAY be filtered on privileges of an authenticated
   * user or as appropriate when no authentication is given.
   */
  getLiked(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Organization.getFeatured},
   * but returns its `@id` URL instead of the object itself.
   */
  get featuredId(): URL | null;
  /** What is known in Mastodon as "pinned statuses", or statuses that are always
   * featured at the top of people's profiles, is implemented using an extra
   * property `featured` on the actor object that points to a {@link Collection}
   * of objects.
   */
  getFeatured(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Organization.getFeaturedTags},
   * but returns its `@id` URL instead of the object itself.
   */
  get featuredTagsId(): URL | null;
  /** What is known in Mastodon as "featured hashtags", hashtags that are featured
   * at people's profiles, is implemented using an extra property `featuredTags`
   * on the actor object that points to a {@link Collection} of {@link Hashtag}
   * objects specifically.
   */
  getFeaturedTags(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Organization.getStreams},
   * but returns their `@id`s instead of the objects themselves.
   */
  get streamIds(): URL[];
  /** A list of supplementary Collections which may be of interest.
   */
  getStreams(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Collection>;
  /** A JSON object which maps additional (typically server/domain-wide) endpoints
   * which may be useful either for this actor or someone referencing this actor.
   * This mapping may be nested inside the actor document as the value or may be
   * a link to a JSON-LD document with these properties.
   */
  get endpoints(): Endpoints | null;
  /** Allows users to opt-in or opt-out of discoverability features like
   * the profile directory.  This flag may also be used as an indicator of
   * the user's preferences toward being included in external discovery services,
   * such as search engines or other indexing tools.
   */
  get discoverable(): boolean | null;
  /** Reports whether a user was locally suspended, for better handling of
   * these accounts.
   */
  get suspended(): boolean | null;
  /** Whether the actor is in-memorial state.
   */
  get memorial(): boolean | null;
  /** Whether the actor allows to be indexed.
   */
  get indexable(): boolean | null;
  /**
   * Similar to
   * {@link Organization.getSuccessor},
   * but returns its `@id` URL instead of the object itself.
   */
  get successorId(): URL | null;
  /** Signifies that an actor has been moved to a different ID. Used in Mastodon-style data portability with the {@link Move} activity; see [ActivityPub Data Portability/Move Action](https://swicg.github.io/activitypub-data-portability/#move-action) for more details.
   */
  getSuccessor(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Application | Group | Organization | Person | Service | null>;
  /**
   * Similar to
   * {@link Organization.getAlias},
   * but returns its `@id` URL instead of the object itself.
   */
  get aliasId(): URL | null;
  /** The `aliases` (`alsoKnownAs`) property is used to specify alternative names
   * or aliases for an entity.  It can be used to provide additional identifiers
   * or labels for an entity, which can be useful in scenarios where an entity
   * may have multiple names or aliases.
   */
  getAlias(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Application | Group | Organization | Person | Service | null>;
  /**
   * Similar to
   * {@link Organization.getAliases},
   * but returns their `@id`s instead of the objects themselves.
   */
  get aliasIds(): URL[];
  /** The `aliases` (`alsoKnownAs`) property is used to specify alternative names
   * or aliases for an entity.  It can be used to provide additional identifiers
   * or labels for an entity, which can be useful in scenarios where an entity
   * may have multiple names or aliases.
   */
  getAliases(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Application | Group | Organization | Person | Service>;
  /**
   * Similar to
   * {@link Organization.getService},
   * but returns its `@id` URL instead of the object itself.
   */
  get serviceId(): URL | null;
  /** Means of communicating or interacting with the DID subject or associated
   * entities via one or more service endpoints. Examples include discovery
   * services, agent services, social networking services, file storage services,
   * and verifiable credential repository services.
   */
  getService(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<DidService | null>;
  /**
   * Similar to
   * {@link Organization.getServices},
   * but returns their `@id`s instead of the objects themselves.
   */
  get serviceIds(): URL[];
  /** Means of communicating or interacting with the DID subject or associated
   * entities via one or more service endpoints. Examples include discovery
   * services, agent services, social networking services, file storage services,
   * and verifiable credential repository services.
   */
  getServices(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<DidService>;
  /** This value is used for `Actor` type objects to show message on followed.
   */
  get followedMessage(): string | null;
  /** Used on actors to indicate that they in some way identify as a cat,
   * expressed as a boolean value. If this property is set to `true`,
   * displaying the actor or their notes will have some special effects
   * attached in some clients.
   */
  get cat(): boolean | null;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Organization>;
  protected static __fromJsonLd__Organization__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Organization>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Represents a Web Page.
 */
declare class Page extends Document {
  /**
   * The type URI of {@link Page}: `https://www.w3.org/ns/activitystreams#Page`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Page with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    width?: number | null;
    height?: number | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    width?: number | null;
    height?: number | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Page;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Page>;
  protected static __fromJsonLd__Page__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Page>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Represents an individual person.
 */
declare class Person extends Object$1 {
  #private;
  /**
   * The type URI of {@link Person}: `https://www.w3.org/ns/activitystreams#Person`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Person with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    preferredUsername?: string | LanguageString | null;
    preferredUsernames?: ((string | LanguageString))[];
    publicKey?: CryptographicKey | URL | null;
    publicKeys?: (CryptographicKey | URL)[];
    assertionMethod?: Multikey | URL | null;
    assertionMethods?: (Multikey | URL)[];
    manuallyApprovesFollowers?: boolean | null;
    inbox?: OrderedCollection | OrderedCollectionPage | URL | null;
    outbox?: OrderedCollection | OrderedCollectionPage | URL | null;
    following?: Collection | URL | null;
    followers?: Collection | URL | null;
    liked?: Collection | URL | null;
    featured?: Collection | URL | null;
    featuredTags?: Collection | URL | null;
    streams?: (Collection | URL)[];
    endpoints?: Endpoints | null;
    discoverable?: boolean | null;
    suspended?: boolean | null;
    memorial?: boolean | null;
    indexable?: boolean | null;
    successor?: Application | Group | Organization | Person | Service | URL | null;
    alias?: Application | Group | Organization | Person | Service | URL | null;
    aliases?: (Application | Group | Organization | Person | Service | URL)[];
    service?: DidService | URL | null;
    services?: (DidService | URL)[];
    followedMessage?: string | null;
    cat?: boolean | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    preferredUsername?: string | LanguageString | null;
    preferredUsernames?: ((string | LanguageString))[];
    publicKey?: CryptographicKey | URL | null;
    publicKeys?: (CryptographicKey | URL)[];
    assertionMethod?: Multikey | URL | null;
    assertionMethods?: (Multikey | URL)[];
    manuallyApprovesFollowers?: boolean | null;
    inbox?: OrderedCollection | OrderedCollectionPage | URL | null;
    outbox?: OrderedCollection | OrderedCollectionPage | URL | null;
    following?: Collection | URL | null;
    followers?: Collection | URL | null;
    liked?: Collection | URL | null;
    featured?: Collection | URL | null;
    featuredTags?: Collection | URL | null;
    streams?: (Collection | URL)[];
    endpoints?: Endpoints | null;
    discoverable?: boolean | null;
    suspended?: boolean | null;
    memorial?: boolean | null;
    indexable?: boolean | null;
    successor?: Application | Group | Organization | Person | Service | URL | null;
    alias?: Application | Group | Organization | Person | Service | URL | null;
    aliases?: (Application | Group | Organization | Person | Service | URL)[];
    service?: DidService | URL | null;
    services?: (DidService | URL)[];
    followedMessage?: string | null;
    cat?: boolean | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Person;
  /** A short username which may be used to refer to the actor,
   * with no uniqueness guarantees.
   */
  get preferredUsername(): string | LanguageString | null;
  /** A short username which may be used to refer to the actor,
   * with no uniqueness guarantees.
   */
  get preferredUsernames(): ((string | LanguageString))[];
  /**
   * Similar to
   * {@link Person.getPublicKey},
   * but returns its `@id` URL instead of the object itself.
   */
  get publicKeyId(): URL | null;
  /** A public part of the key pair owned by this actor.
   */
  getPublicKey(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<CryptographicKey | null>;
  /**
   * Similar to
   * {@link Person.getPublicKeys},
   * but returns their `@id`s instead of the objects themselves.
   */
  get publicKeyIds(): URL[];
  /** A public part of the key pair owned by this actor.
   */
  getPublicKeys(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<CryptographicKey>;
  /**
   * Similar to
   * {@link Person.getAssertionMethod},
   * but returns its `@id` URL instead of the object itself.
   */
  get assertionMethodId(): URL | null;
  /** Represents this actor's public keys.  It serves as equivalent to
   * the `publicKeys` property, but is used for [FEP-521a] compliance.
   *
   * [FEP-521a]: https://w3id.org/fep/521a
   */
  getAssertionMethod(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Multikey | null>;
  /**
   * Similar to
   * {@link Person.getAssertionMethods},
   * but returns their `@id`s instead of the objects themselves.
   */
  get assertionMethodIds(): URL[];
  /** Represents this actor's public keys.  It serves as equivalent to
   * the `publicKeys` property, but is used for [FEP-521a] compliance.
   *
   * [FEP-521a]: https://w3id.org/fep/521a
   */
  getAssertionMethods(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Multikey>;
  /** When `true`, conveys that for this actor, follow requests are not usually
   * automatically approved, but instead are examined by a person who may accept
   * or reject the request, at some time in the future.  Setting of `false`
   * conveys no information and may be ignored.  This information is typically
   * used to affect display of accounts, such as showing an account as private or
   * locked.
   */
  get manuallyApprovesFollowers(): boolean | null;
  /**
   * Similar to
   * {@link Person.getInbox},
   * but returns its `@id` URL instead of the object itself.
   */
  get inboxId(): URL | null;
  /** The inbox stream contains all activities received by the actor.  The server
   * SHOULD filter content according to the requester's permission.  In general,
   * the owner of an inbox is likely to be able to access all of their inbox
   * contents.  Depending on access control, some other content may be public,
   * whereas other content may require authentication for non-owner users,
   * if they can access the inbox at all.
   *
   * The server MUST perform de-duplication of activities returned by the inbox.
   * Duplication can occur if an activity is addressed both to an actor's
   * followers, and a specific actor who also follows the recipient actor,
   * and the server has failed to de-duplicate the recipients list.
   * Such deduplication MUST be performed by comparing the `id` of the activities
   * and dropping any activities already seen.
   */
  getInbox(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<OrderedCollection | OrderedCollectionPage | null>;
  /**
   * Similar to
   * {@link Person.getOutbox},
   * but returns its `@id` URL instead of the object itself.
   */
  get outboxId(): URL | null;
  /** The outbox stream contains activities the user has published,
   * subject to the ability of the requestor to retrieve the activity
   * (that is, the contents of the outbox are filtered by the permissions of
   * the person reading it).  If a user submits a request without
   * [Authorization](https://www.w3.org/TR/activitypub/#authorization)
   * the server should respond with all of the
   * [Public](https://www.w3.org/TR/activitypub/#public-addressing) posts.
   * This could potentially be all relevant objects published by the user,
   * though the number of available items is left to the discretion of those
   * implementing and deploying the server.
   */
  getOutbox(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<OrderedCollection | OrderedCollectionPage | null>;
  /**
   * Similar to
   * {@link Person.getFollowing},
   * but returns its `@id` URL instead of the object itself.
   */
  get followingId(): URL | null;
  /** This is a list of everybody that the actor has followed, added as a
   * [side effect](https://www.w3.org/TR/activitypub/#follow-activity-outbox).
   * The `following` collection MUST be either an {@link OrderedCollection}
   * or a {@link Collection} and MAY be filtered on privileges of
   * an authenticated user or as appropriate when no authentication is given.
   */
  getFollowing(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Person.getFollowers},
   * but returns its `@id` URL instead of the object itself.
   */
  get followersId(): URL | null;
  /** This is a list of everyone who has sent a {@link Follow} activity
   * for the actor, added as a
   * [side effect](https://www.w3.org/TR/activitypub/#follow-activity-outbox).
   * This is where one would find a list of all the actors that are following
   * the actor.  The `followers` collection MUST be either
   * an {@link OrderedCollection} or a {@link Collection} and MAY be filtered on
   * privileges of an authenticated user or as appropriate when no authentication
   * is given.
   */
  getFollowers(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Person.getLiked},
   * but returns its `@id` URL instead of the object itself.
   */
  get likedId(): URL | null;
  /** This is a list of every object from all of the actor's {@link Like}
   * activities, added as a
   * [side effect](https://www.w3.org/TR/activitypub/#like-activity-outbox).
   * The `liked` collection MUST be either an {@link OrderedCollection} or
   * a {@link Collection} and MAY be filtered on privileges of an authenticated
   * user or as appropriate when no authentication is given.
   */
  getLiked(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Person.getFeatured},
   * but returns its `@id` URL instead of the object itself.
   */
  get featuredId(): URL | null;
  /** What is known in Mastodon as "pinned statuses", or statuses that are always
   * featured at the top of people's profiles, is implemented using an extra
   * property `featured` on the actor object that points to a {@link Collection}
   * of objects.
   */
  getFeatured(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Person.getFeaturedTags},
   * but returns its `@id` URL instead of the object itself.
   */
  get featuredTagsId(): URL | null;
  /** What is known in Mastodon as "featured hashtags", hashtags that are featured
   * at people's profiles, is implemented using an extra property `featuredTags`
   * on the actor object that points to a {@link Collection} of {@link Hashtag}
   * objects specifically.
   */
  getFeaturedTags(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Person.getStreams},
   * but returns their `@id`s instead of the objects themselves.
   */
  get streamIds(): URL[];
  /** A list of supplementary Collections which may be of interest.
   */
  getStreams(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Collection>;
  /** A JSON object which maps additional (typically server/domain-wide) endpoints
   * which may be useful either for this actor or someone referencing this actor.
   * This mapping may be nested inside the actor document as the value or may be
   * a link to a JSON-LD document with these properties.
   */
  get endpoints(): Endpoints | null;
  /** Allows users to opt-in or opt-out of discoverability features like
   * the profile directory.  This flag may also be used as an indicator of
   * the user's preferences toward being included in external discovery services,
   * such as search engines or other indexing tools.
   */
  get discoverable(): boolean | null;
  /** Reports whether a user was locally suspended, for better handling of
   * these accounts.
   */
  get suspended(): boolean | null;
  /** Whether the actor is in-memorial state.
   */
  get memorial(): boolean | null;
  /** Whether the actor allows to be indexed.
   */
  get indexable(): boolean | null;
  /**
   * Similar to
   * {@link Person.getSuccessor},
   * but returns its `@id` URL instead of the object itself.
   */
  get successorId(): URL | null;
  /** Signifies that an actor has been moved to a different ID. Used in Mastodon-style data portability with the {@link Move} activity; see [ActivityPub Data Portability/Move Action](https://swicg.github.io/activitypub-data-portability/#move-action) for more details.
   */
  getSuccessor(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Application | Group | Organization | Person | Service | null>;
  /**
   * Similar to
   * {@link Person.getAlias},
   * but returns its `@id` URL instead of the object itself.
   */
  get aliasId(): URL | null;
  /** The `aliases` (`alsoKnownAs`) property is used to specify alternative names
   * or aliases for an entity.  It can be used to provide additional identifiers
   * or labels for an entity, which can be useful in scenarios where an entity
   * may have multiple names or aliases.
   */
  getAlias(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Application | Group | Organization | Person | Service | null>;
  /**
   * Similar to
   * {@link Person.getAliases},
   * but returns their `@id`s instead of the objects themselves.
   */
  get aliasIds(): URL[];
  /** The `aliases` (`alsoKnownAs`) property is used to specify alternative names
   * or aliases for an entity.  It can be used to provide additional identifiers
   * or labels for an entity, which can be useful in scenarios where an entity
   * may have multiple names or aliases.
   */
  getAliases(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Application | Group | Organization | Person | Service>;
  /**
   * Similar to
   * {@link Person.getService},
   * but returns its `@id` URL instead of the object itself.
   */
  get serviceId(): URL | null;
  /** Means of communicating or interacting with the DID subject or associated
   * entities via one or more service endpoints. Examples include discovery
   * services, agent services, social networking services, file storage services,
   * and verifiable credential repository services.
   */
  getService(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<DidService | null>;
  /**
   * Similar to
   * {@link Person.getServices},
   * but returns their `@id`s instead of the objects themselves.
   */
  get serviceIds(): URL[];
  /** Means of communicating or interacting with the DID subject or associated
   * entities via one or more service endpoints. Examples include discovery
   * services, agent services, social networking services, file storage services,
   * and verifiable credential repository services.
   */
  getServices(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<DidService>;
  /** This value is used for `Actor` type objects to show message on followed.
   */
  get followedMessage(): string | null;
  /** Used on actors to indicate that they in some way identify as a cat,
   * expressed as a boolean value. If this property is set to `true`,
   * displaying the actor or their notes will have some special effects
   * attached in some clients.
   */
  get cat(): boolean | null;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Person>;
  protected static __fromJsonLd__Person__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Person>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Represents a logical or physical location.  See [5.3 Representing
 * Places](https://www.w3.org/TR/activitystreams-vocabulary/#places)
 * for additional information.
 */
declare class Place extends Object$1 {
  #private;
  /**
   * The type URI of {@link Place}: `https://www.w3.org/ns/activitystreams#Place`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Place with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    accuracy?: number | null;
    altitude?: number | null;
    latitude?: number | null;
    longitude?: number | null;
    radius?: number | null;
    units?: "cm" | "feet" | "inches" | "km" | "m" | "miles" | URL | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    accuracy?: number | null;
    altitude?: number | null;
    latitude?: number | null;
    longitude?: number | null;
    radius?: number | null;
    units?: "cm" | "feet" | "inches" | "km" | "m" | "miles" | URL | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Place;
  /** Indicates the accuracy of position coordinates on a {@link Place} objects.
   * Expressed in properties of percentage. e.g. "94.0" means "94.0% accurate".
   */
  get accuracy(): number | null;
  /** Indicates the altitude of a place.  The measurement units is indicated
   * using the {@link Place.units} property.  If {@link Place.units} is not
   * specified, the default is assumed to be "`m`" indicating meters.
   */
  get altitude(): number | null;
  /** The latitude of a place.
   */
  get latitude(): number | null;
  /** The longitude of a place.
   */
  get longitude(): number | null;
  /** The radius from the given latitude and longitude for a {@link Place}.
   * The units is expressed by the {@link Place.units} property.
   * If {@link Place.units} is not specified, the default is assumed to be
   * "`m`" indicating "meters".
   */
  get radius(): number | null;
  /** Specifies the measurement units for the {@link Place.radius} and
   * {@link Place.altitude} properties on a {@link Place} object.
   * If not specified, the default is assumed to be "`m`" for "meters".
   */
  get units(): "cm" | "feet" | "inches" | "km" | "m" | "miles" | URL | null;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Place>;
  protected static __fromJsonLd__Place__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Place>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** A {@link Profile} is a content object that describes another {@link Object},
 * typically used to describe [Actor
 * Type](https://www.w3.org/TR/activitystreams-vocabulary/#actor-types) objects.
 * The {@link Profile.describes} property is used to reference the object being
 * described by the profile.
 */
declare class Profile extends Object$1 {
  #private;
  /**
   * The type URI of {@link Profile}: `https://www.w3.org/ns/activitystreams#Profile`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Profile with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    describes?: Object$1 | URL | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    describes?: Object$1 | URL | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Profile;
  /**
   * Similar to
   * {@link Profile.getDescribes},
   * but returns its `@id` URL instead of the object itself.
   */
  get describesId(): URL | null;
  /** On a {@link Profile} object, the {@link Profile.describes} property
   * identifies the object described by the {@link Profile}.
   */
  getDescribes(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Object$1 | null>;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Profile>;
  protected static __fromJsonLd__Profile__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Profile>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Represents a question being asked.  Question objects are an extension of
 * {@link IntransitiveActivity}.  That is, the Question object is an Activity,
 * but the direct object is the question itself and therefore it would not
 * contain an `object` property.
 *
 * Either of the `inclusiveOptions` and `exclusiveOptions` properties *may* be
 * used to express possible answers, but a Question object *must not* have both
 * properties.
 */
declare class Question extends IntransitiveActivity {
  #private;
  /**
   * The type URI of {@link Question}: `https://www.w3.org/ns/activitystreams#Question`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Question with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
    exclusiveOptions?: (Object$1 | URL)[];
    inclusiveOptions?: (Object$1 | URL)[];
    closed?: Temporal.Instant | boolean | null;
    voters?: number | null;
    quoteUrl?: URL | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
    exclusiveOptions?: (Object$1 | URL)[];
    inclusiveOptions?: (Object$1 | URL)[];
    closed?: Temporal.Instant | boolean | null;
    voters?: number | null;
    quoteUrl?: URL | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Question;
  /**
   * Similar to
   * {@link Question.getExclusiveOptions},
   * but returns their `@id`s instead of the objects themselves.
   */
  get exclusiveOptionIds(): URL[];
  /** Identifies an exclusive option for a Question.  Use of `exclusiveOptions`
   * implies that the Question can have only a single answer.  To indicate that
   * a Question can have multiple answers, use `inclusiveOptions`.
   */
  getExclusiveOptions(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Object$1>;
  /**
   * Similar to
   * {@link Question.getInclusiveOptions},
   * but returns their `@id`s instead of the objects themselves.
   */
  get inclusiveOptionIds(): URL[];
  /** Identifies an inclusive option for a Question.  Use of `inclusiveOptions`
   * implies that the Question can have multiple answers.  To indicate that
   * a Question can have only one answer, use `exclusiveOptions`.
   */
  getInclusiveOptions(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Object$1>;
  /** Indicates that a question has been closed, and answers are no longer
   * accepted.
   */
  get closed(): Temporal.Instant | boolean | null;
  /** How many people have voted in the poll.  Distinct from how many votes have
   * been cast (in the case of multiple-choice polls).
   */
  get voters(): number | null;
  /** The URI of the ActivityStreams object that this object quotes.
   *
   * This property sets three JSON-LD properties at once under the hood:
   *
   * 1. https://www.w3.org/ns/activitystreams#quoteUrl
   * 2. https://misskey-hub.net/ns#_misskey_quote
   * 3. http://fedibird.com/ns#quoteUri
   *
   * When a JSON-LD object is parsed, this property is filled with one of
   * the values of those three properties in order.
   */
  get quoteUrl(): URL | null;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Question>;
  protected static __fromJsonLd__Question__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Question>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Indicates that the `actor` has read the `object`.
 */
declare class Read extends Activity {
  /**
   * The type URI of {@link Read}: `https://www.w3.org/ns/activitystreams#Read`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Read with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Read;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Read>;
  protected static __fromJsonLd__Read__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Read>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Indicates that the `actor` is rejecting the `object`.  The `target` and
 * `origin` typically have no defined meaning.
 */
declare class Reject extends Activity {
  /**
   * The type URI of {@link Reject}: `https://www.w3.org/ns/activitystreams#Reject`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Reject with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Reject;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Reject>;
  protected static __fromJsonLd__Reject__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Reject>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Describes a relationship between two individuals.
 * The {@link Relationship.subject} and {@link Relationship.object} properties
 * are used to identify the connected individuals.
 *
 * See [5.2 Representing Relationships Between
 * Entities](https://www.w3.org/TR/activitystreams-vocabulary/#connections)
 * for additional information.
 */
declare class Relationship extends Object$1 {
  #private;
  /**
   * The type URI of {@link Relationship}: `https://www.w3.org/ns/activitystreams#Relationship`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Relationship with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    subject?: Object$1 | URL | null;
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    relationship?: Object$1 | URL | null;
    relationships?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    subject?: Object$1 | URL | null;
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    relationship?: Object$1 | URL | null;
    relationships?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Relationship;
  /**
   * Similar to
   * {@link Relationship.getSubject},
   * but returns its `@id` URL instead of the object itself.
   */
  get subjectId(): URL | null;
  /** On a {@link Relationship} object, the {@link Relationship.subject} property
   * identifies one of the connected individuals.  For instance,
   * for a {@link Relationship} object describing "John is related to Sally",
   * the {@link Relationship.subject} property would refer to John.
   */
  getSubject(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Object$1 | null>;
  /**
   * Similar to
   * {@link Relationship.getObject},
   * but returns its `@id` URL instead of the object itself.
   */
  get objectId(): URL | null;
  /** Describes the entity to which the {@link Relationship.subject} is related.
   */
  getObject(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Object$1 | null>;
  /**
   * Similar to
   * {@link Relationship.getObjects},
   * but returns their `@id`s instead of the objects themselves.
   */
  get objectIds(): URL[];
  /** Describes the entity to which the {@link Relationship.subject} is related.
   */
  getObjects(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Object$1>;
  /**
   * Similar to
   * {@link Relationship.getRelationship},
   * but returns its `@id` URL instead of the object itself.
   */
  get relationshipId(): URL | null;
  /** On a {@link Relationship} object, the {@link Relationship.relationship}
   * property identifies the kind of relationship that exists between
   * {@link Relationship.subject} and {@link Relationship.object}.
   */
  getRelationship(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Object$1 | null>;
  /**
   * Similar to
   * {@link Relationship.getRelationships},
   * but returns their `@id`s instead of the objects themselves.
   */
  get relationshipIds(): URL[];
  /** On a {@link Relationship} object, the {@link Relationship.relationship}
   * property identifies the kind of relationship that exists between
   * {@link Relationship.subject} and {@link Relationship.object}.
   */
  getRelationships(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Object$1>;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Relationship>;
  protected static __fromJsonLd__Relationship__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Relationship>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Indicates that the `actor` is removing the `object`.  If specified,
 * the `origin` indicates the context from which the `object` is being removed.
 */
declare class Remove extends Activity {
  /**
   * The type URI of {@link Remove}: `https://www.w3.org/ns/activitystreams#Remove`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Remove with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Remove;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Remove>;
  protected static __fromJsonLd__Remove__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Remove>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Represents a service of any kind.
 */
declare class Service extends Object$1 {
  #private;
  /**
   * The type URI of {@link Service}: `https://www.w3.org/ns/activitystreams#Service`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Service with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    preferredUsername?: string | LanguageString | null;
    preferredUsernames?: ((string | LanguageString))[];
    publicKey?: CryptographicKey | URL | null;
    publicKeys?: (CryptographicKey | URL)[];
    assertionMethod?: Multikey | URL | null;
    assertionMethods?: (Multikey | URL)[];
    manuallyApprovesFollowers?: boolean | null;
    inbox?: OrderedCollection | OrderedCollectionPage | URL | null;
    outbox?: OrderedCollection | OrderedCollectionPage | URL | null;
    following?: Collection | URL | null;
    followers?: Collection | URL | null;
    liked?: Collection | URL | null;
    featured?: Collection | URL | null;
    featuredTags?: Collection | URL | null;
    streams?: (Collection | URL)[];
    endpoints?: Endpoints | null;
    discoverable?: boolean | null;
    suspended?: boolean | null;
    memorial?: boolean | null;
    indexable?: boolean | null;
    successor?: Application | Group | Organization | Person | Service | URL | null;
    alias?: Application | Group | Organization | Person | Service | URL | null;
    aliases?: (Application | Group | Organization | Person | Service | URL)[];
    service?: DidService | URL | null;
    services?: (DidService | URL)[];
    followedMessage?: string | null;
    cat?: boolean | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    preferredUsername?: string | LanguageString | null;
    preferredUsernames?: ((string | LanguageString))[];
    publicKey?: CryptographicKey | URL | null;
    publicKeys?: (CryptographicKey | URL)[];
    assertionMethod?: Multikey | URL | null;
    assertionMethods?: (Multikey | URL)[];
    manuallyApprovesFollowers?: boolean | null;
    inbox?: OrderedCollection | OrderedCollectionPage | URL | null;
    outbox?: OrderedCollection | OrderedCollectionPage | URL | null;
    following?: Collection | URL | null;
    followers?: Collection | URL | null;
    liked?: Collection | URL | null;
    featured?: Collection | URL | null;
    featuredTags?: Collection | URL | null;
    streams?: (Collection | URL)[];
    endpoints?: Endpoints | null;
    discoverable?: boolean | null;
    suspended?: boolean | null;
    memorial?: boolean | null;
    indexable?: boolean | null;
    successor?: Application | Group | Organization | Person | Service | URL | null;
    alias?: Application | Group | Organization | Person | Service | URL | null;
    aliases?: (Application | Group | Organization | Person | Service | URL)[];
    service?: DidService | URL | null;
    services?: (DidService | URL)[];
    followedMessage?: string | null;
    cat?: boolean | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Service;
  /** A short username which may be used to refer to the actor,
   * with no uniqueness guarantees.
   */
  get preferredUsername(): string | LanguageString | null;
  /** A short username which may be used to refer to the actor,
   * with no uniqueness guarantees.
   */
  get preferredUsernames(): ((string | LanguageString))[];
  /**
   * Similar to
   * {@link Service.getPublicKey},
   * but returns its `@id` URL instead of the object itself.
   */
  get publicKeyId(): URL | null;
  /** A public part of the key pair owned by this actor.
   */
  getPublicKey(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<CryptographicKey | null>;
  /**
   * Similar to
   * {@link Service.getPublicKeys},
   * but returns their `@id`s instead of the objects themselves.
   */
  get publicKeyIds(): URL[];
  /** A public part of the key pair owned by this actor.
   */
  getPublicKeys(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<CryptographicKey>;
  /**
   * Similar to
   * {@link Service.getAssertionMethod},
   * but returns its `@id` URL instead of the object itself.
   */
  get assertionMethodId(): URL | null;
  /** Represents this actor's public keys.  It serves as equivalent to
   * the `publicKeys` property, but is used for [FEP-521a] compliance.
   *
   * [FEP-521a]: https://w3id.org/fep/521a
   */
  getAssertionMethod(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Multikey | null>;
  /**
   * Similar to
   * {@link Service.getAssertionMethods},
   * but returns their `@id`s instead of the objects themselves.
   */
  get assertionMethodIds(): URL[];
  /** Represents this actor's public keys.  It serves as equivalent to
   * the `publicKeys` property, but is used for [FEP-521a] compliance.
   *
   * [FEP-521a]: https://w3id.org/fep/521a
   */
  getAssertionMethods(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Multikey>;
  /** When `true`, conveys that for this actor, follow requests are not usually
   * automatically approved, but instead are examined by a person who may accept
   * or reject the request, at some time in the future.  Setting of `false`
   * conveys no information and may be ignored.  This information is typically
   * used to affect display of accounts, such as showing an account as private or
   * locked.
   */
  get manuallyApprovesFollowers(): boolean | null;
  /**
   * Similar to
   * {@link Service.getInbox},
   * but returns its `@id` URL instead of the object itself.
   */
  get inboxId(): URL | null;
  /** The inbox stream contains all activities received by the actor.  The server
   * SHOULD filter content according to the requester's permission.  In general,
   * the owner of an inbox is likely to be able to access all of their inbox
   * contents.  Depending on access control, some other content may be public,
   * whereas other content may require authentication for non-owner users,
   * if they can access the inbox at all.
   *
   * The server MUST perform de-duplication of activities returned by the inbox.
   * Duplication can occur if an activity is addressed both to an actor's
   * followers, and a specific actor who also follows the recipient actor,
   * and the server has failed to de-duplicate the recipients list.
   * Such deduplication MUST be performed by comparing the `id` of the activities
   * and dropping any activities already seen.
   */
  getInbox(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<OrderedCollection | OrderedCollectionPage | null>;
  /**
   * Similar to
   * {@link Service.getOutbox},
   * but returns its `@id` URL instead of the object itself.
   */
  get outboxId(): URL | null;
  /** The outbox stream contains activities the user has published,
   * subject to the ability of the requestor to retrieve the activity
   * (that is, the contents of the outbox are filtered by the permissions of
   * the person reading it).  If a user submits a request without
   * [Authorization](https://www.w3.org/TR/activitypub/#authorization)
   * the server should respond with all of the
   * [Public](https://www.w3.org/TR/activitypub/#public-addressing) posts.
   * This could potentially be all relevant objects published by the user,
   * though the number of available items is left to the discretion of those
   * implementing and deploying the server.
   */
  getOutbox(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<OrderedCollection | OrderedCollectionPage | null>;
  /**
   * Similar to
   * {@link Service.getFollowing},
   * but returns its `@id` URL instead of the object itself.
   */
  get followingId(): URL | null;
  /** This is a list of everybody that the actor has followed, added as a
   * [side effect](https://www.w3.org/TR/activitypub/#follow-activity-outbox).
   * The `following` collection MUST be either an {@link OrderedCollection}
   * or a {@link Collection} and MAY be filtered on privileges of
   * an authenticated user or as appropriate when no authentication is given.
   */
  getFollowing(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Service.getFollowers},
   * but returns its `@id` URL instead of the object itself.
   */
  get followersId(): URL | null;
  /** This is a list of everyone who has sent a {@link Follow} activity
   * for the actor, added as a
   * [side effect](https://www.w3.org/TR/activitypub/#follow-activity-outbox).
   * This is where one would find a list of all the actors that are following
   * the actor.  The `followers` collection MUST be either
   * an {@link OrderedCollection} or a {@link Collection} and MAY be filtered on
   * privileges of an authenticated user or as appropriate when no authentication
   * is given.
   */
  getFollowers(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Service.getLiked},
   * but returns its `@id` URL instead of the object itself.
   */
  get likedId(): URL | null;
  /** This is a list of every object from all of the actor's {@link Like}
   * activities, added as a
   * [side effect](https://www.w3.org/TR/activitypub/#like-activity-outbox).
   * The `liked` collection MUST be either an {@link OrderedCollection} or
   * a {@link Collection} and MAY be filtered on privileges of an authenticated
   * user or as appropriate when no authentication is given.
   */
  getLiked(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Service.getFeatured},
   * but returns its `@id` URL instead of the object itself.
   */
  get featuredId(): URL | null;
  /** What is known in Mastodon as "pinned statuses", or statuses that are always
   * featured at the top of people's profiles, is implemented using an extra
   * property `featured` on the actor object that points to a {@link Collection}
   * of objects.
   */
  getFeatured(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Service.getFeaturedTags},
   * but returns its `@id` URL instead of the object itself.
   */
  get featuredTagsId(): URL | null;
  /** What is known in Mastodon as "featured hashtags", hashtags that are featured
   * at people's profiles, is implemented using an extra property `featuredTags`
   * on the actor object that points to a {@link Collection} of {@link Hashtag}
   * objects specifically.
   */
  getFeaturedTags(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Collection | null>;
  /**
   * Similar to
   * {@link Service.getStreams},
   * but returns their `@id`s instead of the objects themselves.
   */
  get streamIds(): URL[];
  /** A list of supplementary Collections which may be of interest.
   */
  getStreams(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Collection>;
  /** A JSON object which maps additional (typically server/domain-wide) endpoints
   * which may be useful either for this actor or someone referencing this actor.
   * This mapping may be nested inside the actor document as the value or may be
   * a link to a JSON-LD document with these properties.
   */
  get endpoints(): Endpoints | null;
  /** Allows users to opt-in or opt-out of discoverability features like
   * the profile directory.  This flag may also be used as an indicator of
   * the user's preferences toward being included in external discovery services,
   * such as search engines or other indexing tools.
   */
  get discoverable(): boolean | null;
  /** Reports whether a user was locally suspended, for better handling of
   * these accounts.
   */
  get suspended(): boolean | null;
  /** Whether the actor is in-memorial state.
   */
  get memorial(): boolean | null;
  /** Whether the actor allows to be indexed.
   */
  get indexable(): boolean | null;
  /**
   * Similar to
   * {@link Service.getSuccessor},
   * but returns its `@id` URL instead of the object itself.
   */
  get successorId(): URL | null;
  /** Signifies that an actor has been moved to a different ID. Used in Mastodon-style data portability with the {@link Move} activity; see [ActivityPub Data Portability/Move Action](https://swicg.github.io/activitypub-data-portability/#move-action) for more details.
   */
  getSuccessor(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Application | Group | Organization | Person | Service | null>;
  /**
   * Similar to
   * {@link Service.getAlias},
   * but returns its `@id` URL instead of the object itself.
   */
  get aliasId(): URL | null;
  /** The `aliases` (`alsoKnownAs`) property is used to specify alternative names
   * or aliases for an entity.  It can be used to provide additional identifiers
   * or labels for an entity, which can be useful in scenarios where an entity
   * may have multiple names or aliases.
   */
  getAlias(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<Application | Group | Organization | Person | Service | null>;
  /**
   * Similar to
   * {@link Service.getAliases},
   * but returns their `@id`s instead of the objects themselves.
   */
  get aliasIds(): URL[];
  /** The `aliases` (`alsoKnownAs`) property is used to specify alternative names
   * or aliases for an entity.  It can be used to provide additional identifiers
   * or labels for an entity, which can be useful in scenarios where an entity
   * may have multiple names or aliases.
   */
  getAliases(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<Application | Group | Organization | Person | Service>;
  /**
   * Similar to
   * {@link Service.getService},
   * but returns its `@id` URL instead of the object itself.
   */
  get serviceId(): URL | null;
  /** Means of communicating or interacting with the DID subject or associated
   * entities via one or more service endpoints. Examples include discovery
   * services, agent services, social networking services, file storage services,
   * and verifiable credential repository services.
   */
  getService(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): Promise<DidService | null>;
  /**
   * Similar to
   * {@link Service.getServices},
   * but returns their `@id`s instead of the objects themselves.
   */
  get serviceIds(): URL[];
  /** Means of communicating or interacting with the DID subject or associated
   * entities via one or more service endpoints. Examples include discovery
   * services, agent services, social networking services, file storage services,
   * and verifiable credential repository services.
   */
  getServices(options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    suppressError?: boolean;
    tracerProvider?: TracerProvider;
    crossOrigin?: "ignore" | "throw" | "trust";
  }): AsyncIterable<DidService>;
  /** This value is used for `Actor` type objects to show message on followed.
   */
  get followedMessage(): string | null;
  /** Used on actors to indicate that they in some way identify as a cat,
   * expressed as a boolean value. If this property is set to `true`,
   * displaying the actor or their notes will have some special effects
   * attached in some clients.
   */
  get cat(): boolean | null;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Service>;
  protected static __fromJsonLd__Service__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Service>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Contents of {@link Object}'s `source`.
 */
declare class Source {
  #private;
  readonly id: URL | null;
  protected get _documentLoader(): DocumentLoader | undefined;
  protected get _contextLoader(): DocumentLoader | undefined;
  protected get _tracerProvider(): TracerProvider | undefined;
  protected get _warning(): {
    category: string[];
    message: string;
    values?: Record<string, unknown>;
  } | undefined;
  protected get _cachedJsonLd(): unknown | undefined;
  protected set _cachedJsonLd(value: unknown | undefined);
  /**
   * The type URI of {@link Source}: `https://www.w3.org/ns/activitystreams#Source`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Source with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    mediaType?: string | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    mediaType?: string | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Source;
  /** The source content.
   */
  get content(): string | LanguageString | null;
  /** The source content.
   */
  get contents(): ((string | LanguageString))[];
  /** The MIME media type of the source content.
   */
  get mediaType(): string | null;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Source>;
  protected static __fromJsonLd__Source__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Source>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** A specialization of {@link Accept} indicating that
 * the acceptance is tentative.
 */
declare class TentativeAccept extends Accept {
  /**
   * The type URI of {@link TentativeAccept}: `https://www.w3.org/ns/activitystreams#TentativeAccept`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of TentativeAccept with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): TentativeAccept;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<TentativeAccept>;
  protected static __fromJsonLd__TentativeAccept__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<TentativeAccept>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** A specialization of {@link Reject} in which
 * the rejection is considered tentative.
 */
declare class TentativeReject extends Reject {
  /**
   * The type URI of {@link TentativeReject}: `https://www.w3.org/ns/activitystreams#TentativeReject`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of TentativeReject with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): TentativeReject;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<TentativeReject>;
  protected static __fromJsonLd__TentativeReject__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<TentativeReject>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** A `Tombstone` represents a content object that has been deleted.
 * It can be used in {@link Collection}s to signify that there used to be
 * an object at this position, but it has been deleted.
 */
declare class Tombstone extends Object$1 {
  #private;
  /**
   * The type URI of {@link Tombstone}: `https://www.w3.org/ns/activitystreams#Tombstone`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Tombstone with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    deleted?: Temporal.Instant | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    deleted?: Temporal.Instant | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Tombstone;
  /** On a `Tombstone` object, the `deleted` property is a timestamp for when
   * the object was deleted.
   */
  get deleted(): Temporal.Instant | null;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Tombstone>;
  protected static __fromJsonLd__Tombstone__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Tombstone>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Indicates that the `actor` is traveling to `target` from `origin`.
 * `Travel` is an `IntransitiveObject` whose `actor` specifies the direct object.
 * If the `target` or `origin` are not specified,
 * either can be determined by context.
 */
declare class Travel extends IntransitiveActivity {
  /**
   * The type URI of {@link Travel}: `https://www.w3.org/ns/activitystreams#Travel`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Travel with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Travel;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Travel>;
  protected static __fromJsonLd__Travel__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Travel>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Indicates that the `actor` is undoing the `object`.  In most cases,
 * the `object` will be an {@link Activity} describing some previously performed
 * action (for instance, a person may have previously "liked" an article but,
 * for whatever reason, might choose to undo that like at some later point in
 * time).
 *
 * The `target` and `origin` typically have no defined meaning.
 */
declare class Undo extends Activity {
  /**
   * The type URI of {@link Undo}: `https://www.w3.org/ns/activitystreams#Undo`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Undo with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Undo;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Undo>;
  protected static __fromJsonLd__Undo__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Undo>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Indicates that the `actor` has updated the `object`.  Note, however,
 * that this vocabulary does not define a mechanism for describing the actual
 * set of modifications made to `object`.
 *
 * The `target` and `origin` typically have no defined meaning.
 */
declare class Update extends Activity {
  /**
   * The type URI of {@link Update}: `https://www.w3.org/ns/activitystreams#Update`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Update with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Update;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Update>;
  protected static __fromJsonLd__Update__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Update>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Represents a video document of any kind.
 */
declare class Video extends Document {
  /**
   * The type URI of {@link Video}: `https://www.w3.org/ns/activitystreams#Video`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of Video with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    width?: number | null;
    height?: number | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    width?: number | null;
    height?: number | null;
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): Video;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Video>;
  protected static __fromJsonLd__Video__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<Video>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
/** Indicates that the `actor` has viewed the object.
 */
declare class View extends Activity {
  /**
   * The type URI of {@link View}: `https://www.w3.org/ns/activitystreams#View`.
   */
  static get typeId(): URL;
  /**
   * Constructs a new instance of View with the given values.
   * @param values The values to initialize the instance with.
   * @param options The options to use for initialization.
   */
  constructor(values: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
  });
  /**
   * Clones this instance, optionally updating it with the given values.
   * @param values The values to update the clone with.
   * @options The options to use for cloning.
   * @returns The cloned instance.
   */
  clone(values?: {
    id?: URL | null;
    attachments?: (Object$1 | Link | PropertyValue | URL)[];
    attribution?: Application | Group | Organization | Person | Service | URL | null;
    attributions?: (Application | Group | Organization | Person | Service | URL)[];
    audience?: Object$1 | URL | null;
    audiences?: (Object$1 | URL)[];
    content?: string | LanguageString | null;
    contents?: ((string | LanguageString))[];
    contexts?: (Object$1 | Link | URL)[];
    name?: string | LanguageString | null;
    names?: ((string | LanguageString))[];
    endTime?: Temporal.Instant | null;
    generators?: (Object$1 | Link | URL)[];
    icon?: Image | URL | null;
    icons?: (Image | URL)[];
    image?: Image | URL | null;
    images?: (Image | URL)[];
    replyTarget?: Object$1 | Link | URL | null;
    replyTargets?: (Object$1 | Link | URL)[];
    location?: Object$1 | Link | URL | null;
    locations?: (Object$1 | Link | URL)[];
    preview?: Link | Object$1 | URL | null;
    previews?: (Link | Object$1 | URL)[];
    published?: Temporal.Instant | null;
    replies?: Collection | URL | null;
    shares?: Collection | URL | null;
    likes?: Collection | URL | null;
    emojiReactions?: Collection | URL | null;
    startTime?: Temporal.Instant | null;
    summary?: string | LanguageString | null;
    summaries?: ((string | LanguageString))[];
    tags?: (Object$1 | Link | URL)[];
    updated?: Temporal.Instant | null;
    url?: URL | Link | null;
    urls?: ((URL | Link))[];
    to?: Object$1 | URL | null;
    tos?: (Object$1 | URL)[];
    bto?: Object$1 | URL | null;
    btos?: (Object$1 | URL)[];
    cc?: Object$1 | URL | null;
    ccs?: (Object$1 | URL)[];
    bcc?: Object$1 | URL | null;
    bccs?: (Object$1 | URL)[];
    mediaType?: string | null;
    duration?: Temporal.Duration | null;
    sensitive?: boolean | null;
    source?: Source | null;
    proof?: DataIntegrityProof | URL | null;
    proofs?: (DataIntegrityProof | URL)[];
    actor?: Application | Group | Organization | Person | Service | URL | null;
    actors?: (Application | Group | Organization | Person | Service | URL)[];
    object?: Object$1 | URL | null;
    objects?: (Object$1 | URL)[];
    target?: Object$1 | URL | null;
    targets?: (Object$1 | URL)[];
    result?: Object$1 | URL | null;
    results?: (Object$1 | URL)[];
    origin?: Object$1 | URL | null;
    origins?: (Object$1 | URL)[];
    instrument?: Object$1 | URL | null;
    instruments?: (Object$1 | URL)[];
  }, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
  }): View;
  /**
   * Converts this object to a JSON-LD structure.
   * @param options The options to use.
   *                - `format`: The format of the output: `compact` or
                      `expand`.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `context`: The JSON-LD context to use.  Not applicable
                      when `format` is set to `'expand'`.
   * @returns The JSON-LD representation of this object.
   */
  toJsonLd(options?: {
    format?: "compact" | "expand";
    contextLoader?: DocumentLoader;
    context?: string | Record<string, string> | (string | Record<string, string>)[];
  }): Promise<unknown>;
  protected isCompactable(): boolean;
  /**
   * Converts a JSON-LD structure to an object of this type.
   * @param json The JSON-LD structure to convert.
   * @param options The options to use.
   *                - `documentLoader`: The loader for remote JSON-LD documents.
   *                - `contextLoader`: The loader for remote JSON-LD contexts.
   *                - `tracerProvider`: The OpenTelemetry tracer provider to use.
   *                  If omitted, the global tracer provider is used.
   * @returns The object of this type.
   * @throws {TypeError} If the given `json` is invalid.
   */
  static fromJsonLd(json: unknown, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<View>;
  protected static __fromJsonLd__View__(json: unknown, span: Span, options?: {
    documentLoader?: DocumentLoader;
    contextLoader?: DocumentLoader;
    tracerProvider?: TracerProvider;
    baseUrl?: URL;
  }): Promise<View>;
  protected _getCustomInspectProxy(): Record<string, unknown>;
}
//#endregion
export { Accept, Activity, Add, Announce, Application, Arrive, Article, Audio, Block, ChatMessage, Collection, CollectionPage, Create, CryptographicKey, DataIntegrityProof, Delete, DidService, Dislike, Document, Emoji, EmojiReact, Endpoints, Event, Export, Flag, Follow, Group, Hashtag, Ignore, Image, IntransitiveActivity, Invite, Join, LanguageString, Leave, Like, Link, Listen, Mention, Move, Multikey, Note, Object$1 as Object, Offer, OrderedCollection, OrderedCollectionPage, Organization, Page, Person, Place, Profile, PropertyValue, Question, Read, Reject, Relationship, Remove, Service, Source, TentativeAccept, TentativeReject, Tombstone, Travel, Undo, Update, Video, View };