
      import { Temporal } from "@js-temporal/polyfill";
      import { URLPattern } from "urlpattern-polyfill";
      globalThis.addEventListener = () => {};
    
import { createRequire } from "node:module";
import { getLogger } from "@logtape/logtape";
import { SpanKind, SpanStatusCode, trace } from "@opentelemetry/api";
import process from "node:process";
import { lookup } from "node:dns/promises";
import { isIP } from "node:net";
import { decodeBase64, encodeBase64 } from "byte-encodings/base64";
import { decodeHex } from "byte-encodings/hex";
import jsonld from "jsonld";
import { LanguageTag, parseLanguageTag } from "@phensley/language-tag";
import baseX from "@multiformats/base-x";
import { Integer, Sequence } from "asn1js";
import { decodeBase64Url } from "byte-encodings/base64url";
import { addPrefix, getCodeFromData, rmPrefix } from "multicodec";
import { createPublicKey } from "node:crypto";
import { PublicKeyInfo } from "pkijs";

//#region rolldown:runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function() {
	return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
	for (var name$1 in all) __defProp(target, name$1, {
		get: all[name$1],
		enumerable: true
	});
};
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") for (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) {
		key = keys[i];
		if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
			get: ((k) => from[k]).bind(null, key),
			enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
		});
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));
var __require = /* @__PURE__ */ createRequire(import.meta.url);

//#endregion
//#region deno.json
var name = "@fedify/fedify";
var version = "1.10.3";
var license = "MIT";
var exports = {
	".": "./src/mod.ts",
	"./compat": "./src/compat/mod.ts",
	"./federation": "./src/federation/mod.ts",
	"./nodeinfo": "./src/nodeinfo/mod.ts",
	"./runtime": "./src/runtime/mod.ts",
	"./sig": "./src/sig/mod.ts",
	"./testing": "./src/testing/mod.ts",
	"./vocab": "./src/vocab/mod.ts",
	"./webfinger": "./src/webfinger/mod.ts",
	"./otel": "./src/otel/mod.ts",
	"./x/cfworkers": "./src/x/cfworkers.ts",
	"./x/denokv": "./src/x/denokv.ts",
	"./x/fresh": "./src/x/fresh.ts",
	"./x/hono": "./src/x/hono.ts",
	"./x/sveltekit": "./src/x/sveltekit.ts"
};
var imports = {
	"@cfworker/json-schema": "npm:@cfworker/json-schema@^4.1.1",
	"@multiformats/base-x": "npm:@multiformats/base-x@^4.0.1",
	"@opentelemetry/api": "npm:@opentelemetry/api@^1.9.0",
	"@opentelemetry/core": "npm:@opentelemetry/core@^1.30.1",
	"@opentelemetry/sdk-trace-base": "npm:@opentelemetry/sdk-trace-base@^1.30.1",
	"@opentelemetry/semantic-conventions": "npm:@opentelemetry/semantic-conventions@^1.27.0",
	"@phensley/language-tag": "npm:@phensley/language-tag@^1.9.0",
	"@std/assert": "jsr:@std/assert@^0.226.0",
	"@std/testing": "jsr:@std/testing@^0.224.0",
	"@std/url": "jsr:@std/url@^0.225.1",
	"asn1js": "npm:asn1js@^3.0.5",
	"byte-encodings": "npm:byte-encodings@^1.0.11",
	"es-toolkit": "jsr:@es-toolkit/es-toolkit@^1.39.5",
	"fast-check": "npm:fast-check@^3.22.0",
	"fetch-mock": "npm:fetch-mock@^12.5.2",
	"json-canon": "npm:json-canon@^1.0.1",
	"jsonld": "npm:jsonld@^9.0.0",
	"multicodec": "npm:multicodec@^3.2.1",
	"pkijs": "npm:pkijs@^3.2.4",
	"structured-field-values": "npm:structured-field-values@^2.0.4",
	"uri-template-router": "npm:uri-template-router@^1.0.0",
	"url-template": "npm:url-template@^3.1.1"
};
var include = ["src/vocab/vocab.ts"];
var exclude = [
	".test-report.xml",
	"apidoc/",
	"dist/",
	"node_modules/",
	"npm/",
	"pnpm-lock.yaml",
	"src/cfworkers/dist/",
	"src/cfworkers/fixtures/",
	"src/cfworkers/imports.ts",
	"src/cfworkers/README.md",
	"src/cfworkers/server.ts",
	"src/cfworkers/server.js",
	"src/cfworkers/server.js.map",
	"src/codegen/schema.yaml",
	"src/vocab/*.yaml",
	"!src/vocab/vocab.ts"
];
var tasks = {
	"codegen": "GENPATH=vocab-$(deno eval \"console.log(crypto.randomUUID());\").ts && deno run --allow-read --allow-write --check src/codegen/main.ts src/vocab/ ../runtime/ src/vocab/$GENPATH && deno fmt src/vocab/$GENPATH && mv src/vocab/$GENPATH src/vocab/vocab.ts && deno cache src/vocab/vocab.ts && deno check src/vocab/vocab.ts",
	"cache": {
		"command": "deno cache src/mod.ts",
		"dependencies": ["codegen"]
	},
	"check": {
		"command": "deno fmt --check && deno lint && deno check src/**/*.ts",
		"dependencies": ["codegen"]
	},
	"test": {
		"command": "deno test --check --doc --allow-read --allow-write --allow-env --unstable-kv --trace-leaks --parallel",
		"dependencies": ["codegen"]
	},
	"coverage": "deno task test --clean --coverage && deno coverage --html coverage",
	"bench": {
		"command": "deno bench --allow-read --allow-write --allow-net --allow-env --allow-run --unstable-kv",
		"dependencies": ["codegen"]
	},
	"apidoc": {
		"command": "deno doc --html --name=Fedify --output=apidoc/ src/mod.ts",
		"dependencies": ["codegen"]
	},
	"publish": {
		"command": "deno publish",
		"dependencies": ["codegen"]
	},
	"pnpm:install": "pnpm install",
	"pnpm:build": {
		"command": "pnpm exec tsdown",
		"dependencies": ["codegen", "pnpm:install"]
	},
	"test:node": {
		"command": "cd dist/ && node --test",
		"dependencies": ["pnpm:build"]
	},
	"test:bun": {
		"command": "cd dist/ && bun test --timeout 60000",
		"dependencies": ["pnpm:build"]
	},
	"test:cfworkers": {
		"command": "pnpm exec wrangler deploy --dry-run --outdir src/cfworkers && node --import=tsx src/cfworkers/client.ts",
		"dependencies": ["pnpm:build"]
	},
	"test-all": { "dependencies": [
		"check",
		"test",
		"test:node",
		"test:bun",
		"test:cfworkers"
	] }
};
var deno_default = {
	name,
	version,
	license,
	exports,
	imports,
	include,
	exclude,
	tasks
};

//#endregion
//#region src/runtime/contexts.ts
const preloadedContexts = {
	"https://www.w3.org/ns/activitystreams": { "@context": {
		"@vocab": "_:",
		"xsd": "http://www.w3.org/2001/XMLSchema#",
		"as": "https://www.w3.org/ns/activitystreams#",
		"ldp": "http://www.w3.org/ns/ldp#",
		"vcard": "http://www.w3.org/2006/vcard/ns#",
		"id": "@id",
		"type": "@type",
		"Accept": "as:Accept",
		"Activity": "as:Activity",
		"IntransitiveActivity": "as:IntransitiveActivity",
		"Add": "as:Add",
		"Announce": "as:Announce",
		"Application": "as:Application",
		"Arrive": "as:Arrive",
		"Article": "as:Article",
		"Audio": "as:Audio",
		"Block": "as:Block",
		"Collection": "as:Collection",
		"CollectionPage": "as:CollectionPage",
		"Relationship": "as:Relationship",
		"Create": "as:Create",
		"Delete": "as:Delete",
		"Dislike": "as:Dislike",
		"Document": "as:Document",
		"Event": "as:Event",
		"Follow": "as:Follow",
		"Flag": "as:Flag",
		"Group": "as:Group",
		"Ignore": "as:Ignore",
		"Image": "as:Image",
		"Invite": "as:Invite",
		"Join": "as:Join",
		"Leave": "as:Leave",
		"Like": "as:Like",
		"Link": "as:Link",
		"Mention": "as:Mention",
		"Note": "as:Note",
		"Object": "as:Object",
		"Offer": "as:Offer",
		"OrderedCollection": "as:OrderedCollection",
		"OrderedCollectionPage": "as:OrderedCollectionPage",
		"Organization": "as:Organization",
		"Page": "as:Page",
		"Person": "as:Person",
		"Place": "as:Place",
		"Profile": "as:Profile",
		"Question": "as:Question",
		"Reject": "as:Reject",
		"Remove": "as:Remove",
		"Service": "as:Service",
		"TentativeAccept": "as:TentativeAccept",
		"TentativeReject": "as:TentativeReject",
		"Tombstone": "as:Tombstone",
		"Undo": "as:Undo",
		"Update": "as:Update",
		"Video": "as:Video",
		"View": "as:View",
		"Listen": "as:Listen",
		"Read": "as:Read",
		"Move": "as:Move",
		"Travel": "as:Travel",
		"IsFollowing": "as:IsFollowing",
		"IsFollowedBy": "as:IsFollowedBy",
		"IsContact": "as:IsContact",
		"IsMember": "as:IsMember",
		"subject": {
			"@id": "as:subject",
			"@type": "@id"
		},
		"relationship": {
			"@id": "as:relationship",
			"@type": "@id"
		},
		"actor": {
			"@id": "as:actor",
			"@type": "@id"
		},
		"attributedTo": {
			"@id": "as:attributedTo",
			"@type": "@id"
		},
		"attachment": {
			"@id": "as:attachment",
			"@type": "@id"
		},
		"bcc": {
			"@id": "as:bcc",
			"@type": "@id"
		},
		"bto": {
			"@id": "as:bto",
			"@type": "@id"
		},
		"cc": {
			"@id": "as:cc",
			"@type": "@id"
		},
		"context": {
			"@id": "as:context",
			"@type": "@id"
		},
		"current": {
			"@id": "as:current",
			"@type": "@id"
		},
		"first": {
			"@id": "as:first",
			"@type": "@id"
		},
		"generator": {
			"@id": "as:generator",
			"@type": "@id"
		},
		"icon": {
			"@id": "as:icon",
			"@type": "@id"
		},
		"image": {
			"@id": "as:image",
			"@type": "@id"
		},
		"inReplyTo": {
			"@id": "as:inReplyTo",
			"@type": "@id"
		},
		"items": {
			"@id": "as:items",
			"@type": "@id"
		},
		"instrument": {
			"@id": "as:instrument",
			"@type": "@id"
		},
		"orderedItems": {
			"@id": "as:items",
			"@type": "@id",
			"@container": "@list"
		},
		"last": {
			"@id": "as:last",
			"@type": "@id"
		},
		"location": {
			"@id": "as:location",
			"@type": "@id"
		},
		"next": {
			"@id": "as:next",
			"@type": "@id"
		},
		"object": {
			"@id": "as:object",
			"@type": "@id"
		},
		"oneOf": {
			"@id": "as:oneOf",
			"@type": "@id"
		},
		"anyOf": {
			"@id": "as:anyOf",
			"@type": "@id"
		},
		"closed": {
			"@id": "as:closed",
			"@type": "xsd:dateTime"
		},
		"origin": {
			"@id": "as:origin",
			"@type": "@id"
		},
		"accuracy": {
			"@id": "as:accuracy",
			"@type": "xsd:float"
		},
		"prev": {
			"@id": "as:prev",
			"@type": "@id"
		},
		"preview": {
			"@id": "as:preview",
			"@type": "@id"
		},
		"replies": {
			"@id": "as:replies",
			"@type": "@id"
		},
		"result": {
			"@id": "as:result",
			"@type": "@id"
		},
		"audience": {
			"@id": "as:audience",
			"@type": "@id"
		},
		"partOf": {
			"@id": "as:partOf",
			"@type": "@id"
		},
		"tag": {
			"@id": "as:tag",
			"@type": "@id"
		},
		"target": {
			"@id": "as:target",
			"@type": "@id"
		},
		"to": {
			"@id": "as:to",
			"@type": "@id"
		},
		"url": {
			"@id": "as:url",
			"@type": "@id"
		},
		"altitude": {
			"@id": "as:altitude",
			"@type": "xsd:float"
		},
		"content": "as:content",
		"contentMap": {
			"@id": "as:content",
			"@container": "@language"
		},
		"name": "as:name",
		"nameMap": {
			"@id": "as:name",
			"@container": "@language"
		},
		"duration": {
			"@id": "as:duration",
			"@type": "xsd:duration"
		},
		"endTime": {
			"@id": "as:endTime",
			"@type": "xsd:dateTime"
		},
		"height": {
			"@id": "as:height",
			"@type": "xsd:nonNegativeInteger"
		},
		"href": {
			"@id": "as:href",
			"@type": "@id"
		},
		"hreflang": "as:hreflang",
		"latitude": {
			"@id": "as:latitude",
			"@type": "xsd:float"
		},
		"longitude": {
			"@id": "as:longitude",
			"@type": "xsd:float"
		},
		"mediaType": "as:mediaType",
		"published": {
			"@id": "as:published",
			"@type": "xsd:dateTime"
		},
		"radius": {
			"@id": "as:radius",
			"@type": "xsd:float"
		},
		"rel": "as:rel",
		"startIndex": {
			"@id": "as:startIndex",
			"@type": "xsd:nonNegativeInteger"
		},
		"startTime": {
			"@id": "as:startTime",
			"@type": "xsd:dateTime"
		},
		"summary": "as:summary",
		"summaryMap": {
			"@id": "as:summary",
			"@container": "@language"
		},
		"totalItems": {
			"@id": "as:totalItems",
			"@type": "xsd:nonNegativeInteger"
		},
		"units": "as:units",
		"updated": {
			"@id": "as:updated",
			"@type": "xsd:dateTime"
		},
		"width": {
			"@id": "as:width",
			"@type": "xsd:nonNegativeInteger"
		},
		"describes": {
			"@id": "as:describes",
			"@type": "@id"
		},
		"formerType": {
			"@id": "as:formerType",
			"@type": "@id"
		},
		"deleted": {
			"@id": "as:deleted",
			"@type": "xsd:dateTime"
		},
		"inbox": {
			"@id": "ldp:inbox",
			"@type": "@id"
		},
		"outbox": {
			"@id": "as:outbox",
			"@type": "@id"
		},
		"following": {
			"@id": "as:following",
			"@type": "@id"
		},
		"followers": {
			"@id": "as:followers",
			"@type": "@id"
		},
		"streams": {
			"@id": "as:streams",
			"@type": "@id"
		},
		"preferredUsername": "as:preferredUsername",
		"endpoints": {
			"@id": "as:endpoints",
			"@type": "@id"
		},
		"uploadMedia": {
			"@id": "as:uploadMedia",
			"@type": "@id"
		},
		"proxyUrl": {
			"@id": "as:proxyUrl",
			"@type": "@id"
		},
		"liked": {
			"@id": "as:liked",
			"@type": "@id"
		},
		"oauthAuthorizationEndpoint": {
			"@id": "as:oauthAuthorizationEndpoint",
			"@type": "@id"
		},
		"oauthTokenEndpoint": {
			"@id": "as:oauthTokenEndpoint",
			"@type": "@id"
		},
		"provideClientKey": {
			"@id": "as:provideClientKey",
			"@type": "@id"
		},
		"signClientKey": {
			"@id": "as:signClientKey",
			"@type": "@id"
		},
		"sharedInbox": {
			"@id": "as:sharedInbox",
			"@type": "@id"
		},
		"Public": {
			"@id": "as:Public",
			"@type": "@id"
		},
		"source": "as:source",
		"likes": {
			"@id": "as:likes",
			"@type": "@id"
		},
		"shares": {
			"@id": "as:shares",
			"@type": "@id"
		},
		"alsoKnownAs": {
			"@id": "as:alsoKnownAs",
			"@type": "@id"
		}
	} },
	"https://w3id.org/security/v1": { "@context": {
		"id": "@id",
		"type": "@type",
		"dc": "http://purl.org/dc/terms/",
		"sec": "https://w3id.org/security#",
		"xsd": "http://www.w3.org/2001/XMLSchema#",
		"EcdsaKoblitzSignature2016": "sec:EcdsaKoblitzSignature2016",
		"Ed25519Signature2018": "sec:Ed25519Signature2018",
		"EncryptedMessage": "sec:EncryptedMessage",
		"GraphSignature2012": "sec:GraphSignature2012",
		"LinkedDataSignature2015": "sec:LinkedDataSignature2015",
		"LinkedDataSignature2016": "sec:LinkedDataSignature2016",
		"CryptographicKey": "sec:Key",
		"authenticationTag": "sec:authenticationTag",
		"canonicalizationAlgorithm": "sec:canonicalizationAlgorithm",
		"cipherAlgorithm": "sec:cipherAlgorithm",
		"cipherData": "sec:cipherData",
		"cipherKey": "sec:cipherKey",
		"created": {
			"@id": "dc:created",
			"@type": "xsd:dateTime"
		},
		"creator": {
			"@id": "dc:creator",
			"@type": "@id"
		},
		"digestAlgorithm": "sec:digestAlgorithm",
		"digestValue": "sec:digestValue",
		"domain": "sec:domain",
		"encryptionKey": "sec:encryptionKey",
		"expiration": {
			"@id": "sec:expiration",
			"@type": "xsd:dateTime"
		},
		"expires": {
			"@id": "sec:expiration",
			"@type": "xsd:dateTime"
		},
		"initializationVector": "sec:initializationVector",
		"iterationCount": "sec:iterationCount",
		"nonce": "sec:nonce",
		"normalizationAlgorithm": "sec:normalizationAlgorithm",
		"owner": {
			"@id": "sec:owner",
			"@type": "@id"
		},
		"password": "sec:password",
		"privateKey": {
			"@id": "sec:privateKey",
			"@type": "@id"
		},
		"privateKeyPem": "sec:privateKeyPem",
		"publicKey": {
			"@id": "sec:publicKey",
			"@type": "@id"
		},
		"publicKeyBase58": "sec:publicKeyBase58",
		"publicKeyPem": "sec:publicKeyPem",
		"publicKeyWif": "sec:publicKeyWif",
		"publicKeyService": {
			"@id": "sec:publicKeyService",
			"@type": "@id"
		},
		"revoked": {
			"@id": "sec:revoked",
			"@type": "xsd:dateTime"
		},
		"salt": "sec:salt",
		"signature": "sec:signature",
		"signatureAlgorithm": "sec:signingAlgorithm",
		"signatureValue": "sec:signatureValue"
	} },
	"https://w3id.org/security/data-integrity/v1": { "@context": {
		"id": "@id",
		"type": "@type",
		"@protected": true,
		"digestMultibase": {
			"@id": "https://w3id.org/security#digestMultibase",
			"@type": "https://w3id.org/security#multibase"
		},
		"proof": {
			"@id": "https://w3id.org/security#proof",
			"@type": "@id",
			"@container": "@graph"
		},
		"DataIntegrityProof": {
			"@id": "https://w3id.org/security#DataIntegrityProof",
			"@context": {
				"@protected": true,
				"id": "@id",
				"type": "@type",
				"challenge": "https://w3id.org/security#challenge",
				"created": {
					"@id": "http://purl.org/dc/terms/created",
					"@type": "http://www.w3.org/2001/XMLSchema#dateTime"
				},
				"domain": "https://w3id.org/security#domain",
				"expires": {
					"@id": "https://w3id.org/security#expiration",
					"@type": "http://www.w3.org/2001/XMLSchema#dateTime"
				},
				"nonce": "https://w3id.org/security#nonce",
				"proofPurpose": {
					"@id": "https://w3id.org/security#proofPurpose",
					"@type": "@vocab",
					"@context": {
						"@protected": true,
						"id": "@id",
						"type": "@type",
						"assertionMethod": {
							"@id": "https://w3id.org/security#assertionMethod",
							"@type": "@id",
							"@container": "@set"
						},
						"authentication": {
							"@id": "https://w3id.org/security#authenticationMethod",
							"@type": "@id",
							"@container": "@set"
						},
						"capabilityInvocation": {
							"@id": "https://w3id.org/security#capabilityInvocationMethod",
							"@type": "@id",
							"@container": "@set"
						},
						"capabilityDelegation": {
							"@id": "https://w3id.org/security#capabilityDelegationMethod",
							"@type": "@id",
							"@container": "@set"
						},
						"keyAgreement": {
							"@id": "https://w3id.org/security#keyAgreementMethod",
							"@type": "@id",
							"@container": "@set"
						}
					}
				},
				"cryptosuite": "https://w3id.org/security#cryptosuite",
				"proofValue": {
					"@id": "https://w3id.org/security#proofValue",
					"@type": "https://w3id.org/security#multibase"
				},
				"verificationMethod": {
					"@id": "https://w3id.org/security#verificationMethod",
					"@type": "@id"
				}
			}
		}
	} },
	"https://www.w3.org/ns/did/v1": { "@context": {
		"@protected": true,
		"id": "@id",
		"type": "@type",
		"alsoKnownAs": {
			"@id": "https://www.w3.org/ns/activitystreams#alsoKnownAs",
			"@type": "@id"
		},
		"assertionMethod": {
			"@id": "https://w3id.org/security#assertionMethod",
			"@type": "@id",
			"@container": "@set"
		},
		"authentication": {
			"@id": "https://w3id.org/security#authenticationMethod",
			"@type": "@id",
			"@container": "@set"
		},
		"capabilityDelegation": {
			"@id": "https://w3id.org/security#capabilityDelegationMethod",
			"@type": "@id",
			"@container": "@set"
		},
		"capabilityInvocation": {
			"@id": "https://w3id.org/security#capabilityInvocationMethod",
			"@type": "@id",
			"@container": "@set"
		},
		"controller": {
			"@id": "https://w3id.org/security#controller",
			"@type": "@id"
		},
		"keyAgreement": {
			"@id": "https://w3id.org/security#keyAgreementMethod",
			"@type": "@id",
			"@container": "@set"
		},
		"service": {
			"@id": "https://www.w3.org/ns/did#service",
			"@type": "@id",
			"@context": {
				"@protected": true,
				"id": "@id",
				"type": "@type",
				"serviceEndpoint": {
					"@id": "https://www.w3.org/ns/did#serviceEndpoint",
					"@type": "@id"
				}
			}
		},
		"verificationMethod": {
			"@id": "https://w3id.org/security#verificationMethod",
			"@type": "@id"
		}
	} },
	"https://w3id.org/security/multikey/v1": { "@context": {
		"id": "@id",
		"type": "@type",
		"@protected": true,
		"Multikey": {
			"@id": "https://w3id.org/security#Multikey",
			"@context": {
				"@protected": true,
				"id": "@id",
				"type": "@type",
				"controller": {
					"@id": "https://w3id.org/security#controller",
					"@type": "@id"
				},
				"revoked": {
					"@id": "https://w3id.org/security#revoked",
					"@type": "http://www.w3.org/2001/XMLSchema#dateTime"
				},
				"expires": {
					"@id": "https://w3id.org/security#expiration",
					"@type": "http://www.w3.org/2001/XMLSchema#dateTime"
				},
				"publicKeyMultibase": {
					"@id": "https://w3id.org/security#publicKeyMultibase",
					"@type": "https://w3id.org/security#multibase"
				},
				"secretKeyMultibase": {
					"@id": "https://w3id.org/security#secretKeyMultibase",
					"@type": "https://w3id.org/security#multibase"
				}
			}
		}
	} },
	"https://w3id.org/identity/v1": { "@context": {
		"id": "@id",
		"type": "@type",
		"cred": "https://w3id.org/credentials#",
		"dc": "http://purl.org/dc/terms/",
		"identity": "https://w3id.org/identity#",
		"perm": "https://w3id.org/permissions#",
		"ps": "https://w3id.org/payswarm#",
		"rdf": "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
		"rdfs": "http://www.w3.org/2000/01/rdf-schema#",
		"sec": "https://w3id.org/security#",
		"schema": "http://schema.org/",
		"xsd": "http://www.w3.org/2001/XMLSchema#",
		"Group": "https://www.w3.org/ns/activitystreams#Group",
		"claim": {
			"@id": "cred:claim",
			"@type": "@id"
		},
		"credential": {
			"@id": "cred:credential",
			"@type": "@id"
		},
		"issued": {
			"@id": "cred:issued",
			"@type": "xsd:dateTime"
		},
		"issuer": {
			"@id": "cred:issuer",
			"@type": "@id"
		},
		"recipient": {
			"@id": "cred:recipient",
			"@type": "@id"
		},
		"Credential": "cred:Credential",
		"CryptographicKeyCredential": "cred:CryptographicKeyCredential",
		"about": {
			"@id": "schema:about",
			"@type": "@id"
		},
		"address": {
			"@id": "schema:address",
			"@type": "@id"
		},
		"addressCountry": "schema:addressCountry",
		"addressLocality": "schema:addressLocality",
		"addressRegion": "schema:addressRegion",
		"comment": "rdfs:comment",
		"created": {
			"@id": "dc:created",
			"@type": "xsd:dateTime"
		},
		"creator": {
			"@id": "dc:creator",
			"@type": "@id"
		},
		"description": "schema:description",
		"email": "schema:email",
		"familyName": "schema:familyName",
		"givenName": "schema:givenName",
		"image": {
			"@id": "schema:image",
			"@type": "@id"
		},
		"label": "rdfs:label",
		"name": "schema:name",
		"postalCode": "schema:postalCode",
		"streetAddress": "schema:streetAddress",
		"title": "dc:title",
		"url": {
			"@id": "schema:url",
			"@type": "@id"
		},
		"Person": "schema:Person",
		"PostalAddress": "schema:PostalAddress",
		"Organization": "schema:Organization",
		"identityService": {
			"@id": "identity:identityService",
			"@type": "@id"
		},
		"idp": {
			"@id": "identity:idp",
			"@type": "@id"
		},
		"Identity": "identity:Identity",
		"paymentProcessor": "ps:processor",
		"preferences": {
			"@id": "ps:preferences",
			"@type": "@vocab"
		},
		"cipherAlgorithm": "sec:cipherAlgorithm",
		"cipherData": "sec:cipherData",
		"cipherKey": "sec:cipherKey",
		"digestAlgorithm": "sec:digestAlgorithm",
		"digestValue": "sec:digestValue",
		"domain": "sec:domain",
		"expires": {
			"@id": "sec:expiration",
			"@type": "xsd:dateTime"
		},
		"initializationVector": "sec:initializationVector",
		"member": {
			"@id": "schema:member",
			"@type": "@id"
		},
		"memberOf": {
			"@id": "schema:memberOf",
			"@type": "@id"
		},
		"nonce": "sec:nonce",
		"normalizationAlgorithm": "sec:normalizationAlgorithm",
		"owner": {
			"@id": "sec:owner",
			"@type": "@id"
		},
		"password": "sec:password",
		"privateKey": {
			"@id": "sec:privateKey",
			"@type": "@id"
		},
		"privateKeyPem": "sec:privateKeyPem",
		"publicKey": {
			"@id": "sec:publicKey",
			"@type": "@id"
		},
		"publicKeyPem": "sec:publicKeyPem",
		"publicKeyService": {
			"@id": "sec:publicKeyService",
			"@type": "@id"
		},
		"revoked": {
			"@id": "sec:revoked",
			"@type": "xsd:dateTime"
		},
		"signature": "sec:signature",
		"signatureAlgorithm": "sec:signatureAlgorithm",
		"signatureValue": "sec:signatureValue",
		"CryptographicKey": "sec:Key",
		"EncryptedMessage": "sec:EncryptedMessage",
		"GraphSignature2012": "sec:GraphSignature2012",
		"LinkedDataSignature2015": "sec:LinkedDataSignature2015",
		"accessControl": {
			"@id": "perm:accessControl",
			"@type": "@id"
		},
		"writePermission": {
			"@id": "perm:writePermission",
			"@type": "@id"
		}
	} },
	"https://purl.archive.org/socialweb/webfinger": { "@context": {
		"wf": "https://purl.archive.org/socialweb/webfinger#",
		"xsd": "http://www.w3.org/2001/XMLSchema#",
		"webfinger": {
			"@id": "wf:webfinger",
			"@type": "xsd:string"
		}
	} },
	"http://schema.org/": { "@context": {
		"type": "@type",
		"id": "@id",
		"HTML": { "@id": "rdf:HTML" },
		"@vocab": "http://schema.org/",
		"csvw": "http://www.w3.org/ns/csvw#",
		"dc": "http://purl.org/dc/elements/1.1/",
		"dcat": "http://www.w3.org/ns/dcat#",
		"dcmitype": "http://purl.org/dc/dcmitype/",
		"dcterms": "http://purl.org/dc/terms/",
		"dcam": "http://purl.org/dc/dcam/",
		"doap": "http://usefulinc.com/ns/doap#",
		"foaf": "http://xmlns.com/foaf/0.1/",
		"odrl": "http://www.w3.org/ns/odrl/2/",
		"org": "http://www.w3.org/ns/org#",
		"owl": "http://www.w3.org/2002/07/owl#",
		"prof": "http://www.w3.org/ns/dx/prof/",
		"prov": "http://www.w3.org/ns/prov#",
		"qb": "http://purl.org/linked-data/cube#",
		"rdf": "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
		"rdfs": "http://www.w3.org/2000/01/rdf-schema#",
		"schema": "http://schema.org/",
		"sh": "http://www.w3.org/ns/shacl#",
		"skos": "http://www.w3.org/2004/02/skos/core#",
		"sosa": "http://www.w3.org/ns/sosa/",
		"ssn": "http://www.w3.org/ns/ssn/",
		"time": "http://www.w3.org/2006/time#",
		"vann": "http://purl.org/vocab/vann/",
		"void": "http://rdfs.org/ns/void#",
		"xsd": "http://www.w3.org/2001/XMLSchema#",
		"xml": "http://www.w3.org/XML/1998/namespace",
		"dct": "http://purl.org/dc/terms/",
		"dctype": "http://purl.org/dc/dcmitype/",
		"3DModel": { "@id": "schema:3DModel" },
		"AMRadioChannel": { "@id": "schema:AMRadioChannel" },
		"APIReference": { "@id": "schema:APIReference" },
		"Abdomen": { "@id": "schema:Abdomen" },
		"AboutPage": { "@id": "schema:AboutPage" },
		"AcceptAction": { "@id": "schema:AcceptAction" },
		"Accommodation": { "@id": "schema:Accommodation" },
		"AccountingService": { "@id": "schema:AccountingService" },
		"AchieveAction": { "@id": "schema:AchieveAction" },
		"Action": { "@id": "schema:Action" },
		"ActionAccessSpecification": { "@id": "schema:ActionAccessSpecification" },
		"ActionStatusType": { "@id": "schema:ActionStatusType" },
		"ActivateAction": { "@id": "schema:ActivateAction" },
		"ActivationFee": { "@id": "schema:ActivationFee" },
		"ActiveActionStatus": { "@id": "schema:ActiveActionStatus" },
		"ActiveNotRecruiting": { "@id": "schema:ActiveNotRecruiting" },
		"AddAction": { "@id": "schema:AddAction" },
		"AdministrativeArea": { "@id": "schema:AdministrativeArea" },
		"AdultEntertainment": { "@id": "schema:AdultEntertainment" },
		"AdultOrientedEnumeration": { "@id": "schema:AdultOrientedEnumeration" },
		"AdvertiserContentArticle": { "@id": "schema:AdvertiserContentArticle" },
		"AerobicActivity": { "@id": "schema:AerobicActivity" },
		"AggregateOffer": { "@id": "schema:AggregateOffer" },
		"AggregateRating": { "@id": "schema:AggregateRating" },
		"AgreeAction": { "@id": "schema:AgreeAction" },
		"Airline": { "@id": "schema:Airline" },
		"Airport": { "@id": "schema:Airport" },
		"AlbumRelease": { "@id": "schema:AlbumRelease" },
		"AlcoholConsideration": { "@id": "schema:AlcoholConsideration" },
		"AlgorithmicMediaDigitalSource": { "@id": "schema:AlgorithmicMediaDigitalSource" },
		"AlgorithmicallyEnhancedDigitalSource": { "@id": "schema:AlgorithmicallyEnhancedDigitalSource" },
		"AlignmentObject": { "@id": "schema:AlignmentObject" },
		"AllWheelDriveConfiguration": { "@id": "schema:AllWheelDriveConfiguration" },
		"AllergiesHealthAspect": { "@id": "schema:AllergiesHealthAspect" },
		"AllocateAction": { "@id": "schema:AllocateAction" },
		"AmpStory": { "@id": "schema:AmpStory" },
		"AmusementPark": { "@id": "schema:AmusementPark" },
		"AnaerobicActivity": { "@id": "schema:AnaerobicActivity" },
		"AnalysisNewsArticle": { "@id": "schema:AnalysisNewsArticle" },
		"AnatomicalStructure": { "@id": "schema:AnatomicalStructure" },
		"AnatomicalSystem": { "@id": "schema:AnatomicalSystem" },
		"AndroidPlatform": { "@id": "schema:AndroidPlatform" },
		"Anesthesia": { "@id": "schema:Anesthesia" },
		"AnimalShelter": { "@id": "schema:AnimalShelter" },
		"Answer": { "@id": "schema:Answer" },
		"Apartment": { "@id": "schema:Apartment" },
		"ApartmentComplex": { "@id": "schema:ApartmentComplex" },
		"Appearance": { "@id": "schema:Appearance" },
		"AppendAction": { "@id": "schema:AppendAction" },
		"ApplyAction": { "@id": "schema:ApplyAction" },
		"ApprovedIndication": { "@id": "schema:ApprovedIndication" },
		"Aquarium": { "@id": "schema:Aquarium" },
		"ArchiveComponent": { "@id": "schema:ArchiveComponent" },
		"ArchiveOrganization": { "@id": "schema:ArchiveOrganization" },
		"ArriveAction": { "@id": "schema:ArriveAction" },
		"ArtGallery": { "@id": "schema:ArtGallery" },
		"Artery": { "@id": "schema:Artery" },
		"Article": { "@id": "schema:Article" },
		"AskAction": { "@id": "schema:AskAction" },
		"AskPublicNewsArticle": { "@id": "schema:AskPublicNewsArticle" },
		"AssessAction": { "@id": "schema:AssessAction" },
		"AssignAction": { "@id": "schema:AssignAction" },
		"Atlas": { "@id": "schema:Atlas" },
		"Attorney": { "@id": "schema:Attorney" },
		"Audience": { "@id": "schema:Audience" },
		"AudioObject": { "@id": "schema:AudioObject" },
		"AudioObjectSnapshot": { "@id": "schema:AudioObjectSnapshot" },
		"Audiobook": { "@id": "schema:Audiobook" },
		"AudiobookFormat": { "@id": "schema:AudiobookFormat" },
		"AuthoritativeLegalValue": { "@id": "schema:AuthoritativeLegalValue" },
		"AuthorizeAction": { "@id": "schema:AuthorizeAction" },
		"AutoBodyShop": { "@id": "schema:AutoBodyShop" },
		"AutoDealer": { "@id": "schema:AutoDealer" },
		"AutoPartsStore": { "@id": "schema:AutoPartsStore" },
		"AutoRental": { "@id": "schema:AutoRental" },
		"AutoRepair": { "@id": "schema:AutoRepair" },
		"AutoWash": { "@id": "schema:AutoWash" },
		"AutomatedTeller": { "@id": "schema:AutomatedTeller" },
		"AutomotiveBusiness": { "@id": "schema:AutomotiveBusiness" },
		"Ayurvedic": { "@id": "schema:Ayurvedic" },
		"BackOrder": { "@id": "schema:BackOrder" },
		"BackgroundNewsArticle": { "@id": "schema:BackgroundNewsArticle" },
		"Bacteria": { "@id": "schema:Bacteria" },
		"Bakery": { "@id": "schema:Bakery" },
		"Balance": { "@id": "schema:Balance" },
		"BankAccount": { "@id": "schema:BankAccount" },
		"BankOrCreditUnion": { "@id": "schema:BankOrCreditUnion" },
		"BarOrPub": { "@id": "schema:BarOrPub" },
		"Barcode": { "@id": "schema:Barcode" },
		"BasicIncome": { "@id": "schema:BasicIncome" },
		"Beach": { "@id": "schema:Beach" },
		"BeautySalon": { "@id": "schema:BeautySalon" },
		"BedAndBreakfast": { "@id": "schema:BedAndBreakfast" },
		"BedDetails": { "@id": "schema:BedDetails" },
		"BedType": { "@id": "schema:BedType" },
		"BefriendAction": { "@id": "schema:BefriendAction" },
		"BenefitsHealthAspect": { "@id": "schema:BenefitsHealthAspect" },
		"BikeStore": { "@id": "schema:BikeStore" },
		"BioChemEntity": { "@id": "schema:BioChemEntity" },
		"Blog": { "@id": "schema:Blog" },
		"BlogPosting": { "@id": "schema:BlogPosting" },
		"BloodTest": { "@id": "schema:BloodTest" },
		"BoardingPolicyType": { "@id": "schema:BoardingPolicyType" },
		"BoatReservation": { "@id": "schema:BoatReservation" },
		"BoatTerminal": { "@id": "schema:BoatTerminal" },
		"BoatTrip": { "@id": "schema:BoatTrip" },
		"BodyMeasurementArm": { "@id": "schema:BodyMeasurementArm" },
		"BodyMeasurementBust": { "@id": "schema:BodyMeasurementBust" },
		"BodyMeasurementChest": { "@id": "schema:BodyMeasurementChest" },
		"BodyMeasurementFoot": { "@id": "schema:BodyMeasurementFoot" },
		"BodyMeasurementHand": { "@id": "schema:BodyMeasurementHand" },
		"BodyMeasurementHead": { "@id": "schema:BodyMeasurementHead" },
		"BodyMeasurementHeight": { "@id": "schema:BodyMeasurementHeight" },
		"BodyMeasurementHips": { "@id": "schema:BodyMeasurementHips" },
		"BodyMeasurementInsideLeg": { "@id": "schema:BodyMeasurementInsideLeg" },
		"BodyMeasurementNeck": { "@id": "schema:BodyMeasurementNeck" },
		"BodyMeasurementTypeEnumeration": { "@id": "schema:BodyMeasurementTypeEnumeration" },
		"BodyMeasurementUnderbust": { "@id": "schema:BodyMeasurementUnderbust" },
		"BodyMeasurementWaist": { "@id": "schema:BodyMeasurementWaist" },
		"BodyMeasurementWeight": { "@id": "schema:BodyMeasurementWeight" },
		"BodyOfWater": { "@id": "schema:BodyOfWater" },
		"Bone": { "@id": "schema:Bone" },
		"Book": { "@id": "schema:Book" },
		"BookFormatType": { "@id": "schema:BookFormatType" },
		"BookSeries": { "@id": "schema:BookSeries" },
		"BookStore": { "@id": "schema:BookStore" },
		"BookmarkAction": { "@id": "schema:BookmarkAction" },
		"Boolean": { "@id": "schema:Boolean" },
		"BorrowAction": { "@id": "schema:BorrowAction" },
		"BowlingAlley": { "@id": "schema:BowlingAlley" },
		"BrainStructure": { "@id": "schema:BrainStructure" },
		"Brand": { "@id": "schema:Brand" },
		"BreadcrumbList": { "@id": "schema:BreadcrumbList" },
		"Brewery": { "@id": "schema:Brewery" },
		"Bridge": { "@id": "schema:Bridge" },
		"BroadcastChannel": { "@id": "schema:BroadcastChannel" },
		"BroadcastEvent": { "@id": "schema:BroadcastEvent" },
		"BroadcastFrequencySpecification": { "@id": "schema:BroadcastFrequencySpecification" },
		"BroadcastRelease": { "@id": "schema:BroadcastRelease" },
		"BroadcastService": { "@id": "schema:BroadcastService" },
		"BrokerageAccount": { "@id": "schema:BrokerageAccount" },
		"BuddhistTemple": { "@id": "schema:BuddhistTemple" },
		"BusOrCoach": { "@id": "schema:BusOrCoach" },
		"BusReservation": { "@id": "schema:BusReservation" },
		"BusStation": { "@id": "schema:BusStation" },
		"BusStop": { "@id": "schema:BusStop" },
		"BusTrip": { "@id": "schema:BusTrip" },
		"BusinessAudience": { "@id": "schema:BusinessAudience" },
		"BusinessEntityType": { "@id": "schema:BusinessEntityType" },
		"BusinessEvent": { "@id": "schema:BusinessEvent" },
		"BusinessFunction": { "@id": "schema:BusinessFunction" },
		"BusinessSupport": { "@id": "schema:BusinessSupport" },
		"BuyAction": { "@id": "schema:BuyAction" },
		"ByBankTransferInAdvance": { "@id": "schema:ByBankTransferInAdvance" },
		"ByInvoice": { "@id": "schema:ByInvoice" },
		"CDCPMDRecord": { "@id": "schema:CDCPMDRecord" },
		"CDFormat": { "@id": "schema:CDFormat" },
		"COD": { "@id": "schema:COD" },
		"CT": { "@id": "schema:CT" },
		"CableOrSatelliteService": { "@id": "schema:CableOrSatelliteService" },
		"CafeOrCoffeeShop": { "@id": "schema:CafeOrCoffeeShop" },
		"Campground": { "@id": "schema:Campground" },
		"CampingPitch": { "@id": "schema:CampingPitch" },
		"Canal": { "@id": "schema:Canal" },
		"CancelAction": { "@id": "schema:CancelAction" },
		"Car": { "@id": "schema:Car" },
		"CarUsageType": { "@id": "schema:CarUsageType" },
		"Cardiovascular": { "@id": "schema:Cardiovascular" },
		"CardiovascularExam": { "@id": "schema:CardiovascularExam" },
		"CaseSeries": { "@id": "schema:CaseSeries" },
		"Cash": { "@id": "schema:Cash" },
		"Casino": { "@id": "schema:Casino" },
		"CassetteFormat": { "@id": "schema:CassetteFormat" },
		"CategoryCode": { "@id": "schema:CategoryCode" },
		"CategoryCodeSet": { "@id": "schema:CategoryCodeSet" },
		"CatholicChurch": { "@id": "schema:CatholicChurch" },
		"CausesHealthAspect": { "@id": "schema:CausesHealthAspect" },
		"Cemetery": { "@id": "schema:Cemetery" },
		"Certification": { "@id": "schema:Certification" },
		"CertificationActive": { "@id": "schema:CertificationActive" },
		"CertificationInactive": { "@id": "schema:CertificationInactive" },
		"CertificationStatusEnumeration": { "@id": "schema:CertificationStatusEnumeration" },
		"Chapter": { "@id": "schema:Chapter" },
		"CharitableIncorporatedOrganization": { "@id": "schema:CharitableIncorporatedOrganization" },
		"CheckAction": { "@id": "schema:CheckAction" },
		"CheckInAction": { "@id": "schema:CheckInAction" },
		"CheckInAdvance": { "@id": "schema:CheckInAdvance" },
		"CheckOutAction": { "@id": "schema:CheckOutAction" },
		"CheckoutPage": { "@id": "schema:CheckoutPage" },
		"ChemicalSubstance": { "@id": "schema:ChemicalSubstance" },
		"ChildCare": { "@id": "schema:ChildCare" },
		"ChildrensEvent": { "@id": "schema:ChildrensEvent" },
		"Chiropractic": { "@id": "schema:Chiropractic" },
		"ChooseAction": { "@id": "schema:ChooseAction" },
		"Church": { "@id": "schema:Church" },
		"City": { "@id": "schema:City" },
		"CityHall": { "@id": "schema:CityHall" },
		"CivicStructure": { "@id": "schema:CivicStructure" },
		"Claim": { "@id": "schema:Claim" },
		"ClaimReview": { "@id": "schema:ClaimReview" },
		"Class": { "@id": "schema:Class" },
		"CleaningFee": { "@id": "schema:CleaningFee" },
		"Clinician": { "@id": "schema:Clinician" },
		"Clip": { "@id": "schema:Clip" },
		"ClothingStore": { "@id": "schema:ClothingStore" },
		"CoOp": { "@id": "schema:CoOp" },
		"Code": { "@id": "schema:Code" },
		"CohortStudy": { "@id": "schema:CohortStudy" },
		"Collection": { "@id": "schema:Collection" },
		"CollectionPage": { "@id": "schema:CollectionPage" },
		"CollegeOrUniversity": { "@id": "schema:CollegeOrUniversity" },
		"ComedyClub": { "@id": "schema:ComedyClub" },
		"ComedyEvent": { "@id": "schema:ComedyEvent" },
		"ComicCoverArt": { "@id": "schema:ComicCoverArt" },
		"ComicIssue": { "@id": "schema:ComicIssue" },
		"ComicSeries": { "@id": "schema:ComicSeries" },
		"ComicStory": { "@id": "schema:ComicStory" },
		"Comment": { "@id": "schema:Comment" },
		"CommentAction": { "@id": "schema:CommentAction" },
		"CommentPermission": { "@id": "schema:CommentPermission" },
		"CommunicateAction": { "@id": "schema:CommunicateAction" },
		"CommunityHealth": { "@id": "schema:CommunityHealth" },
		"CompilationAlbum": { "@id": "schema:CompilationAlbum" },
		"CompleteDataFeed": { "@id": "schema:CompleteDataFeed" },
		"Completed": { "@id": "schema:Completed" },
		"CompletedActionStatus": { "@id": "schema:CompletedActionStatus" },
		"CompositeCaptureDigitalSource": { "@id": "schema:CompositeCaptureDigitalSource" },
		"CompositeSyntheticDigitalSource": { "@id": "schema:CompositeSyntheticDigitalSource" },
		"CompositeWithTrainedAlgorithmicMediaDigitalSource": { "@id": "schema:CompositeWithTrainedAlgorithmicMediaDigitalSource" },
		"CompoundPriceSpecification": { "@id": "schema:CompoundPriceSpecification" },
		"ComputerLanguage": { "@id": "schema:ComputerLanguage" },
		"ComputerStore": { "@id": "schema:ComputerStore" },
		"ConfirmAction": { "@id": "schema:ConfirmAction" },
		"Consortium": { "@id": "schema:Consortium" },
		"ConstraintNode": { "@id": "schema:ConstraintNode" },
		"ConsumeAction": { "@id": "schema:ConsumeAction" },
		"ContactPage": { "@id": "schema:ContactPage" },
		"ContactPoint": { "@id": "schema:ContactPoint" },
		"ContactPointOption": { "@id": "schema:ContactPointOption" },
		"ContagiousnessHealthAspect": { "@id": "schema:ContagiousnessHealthAspect" },
		"Continent": { "@id": "schema:Continent" },
		"ControlAction": { "@id": "schema:ControlAction" },
		"ConvenienceStore": { "@id": "schema:ConvenienceStore" },
		"Conversation": { "@id": "schema:Conversation" },
		"CookAction": { "@id": "schema:CookAction" },
		"Corporation": { "@id": "schema:Corporation" },
		"CorrectionComment": { "@id": "schema:CorrectionComment" },
		"Country": { "@id": "schema:Country" },
		"Course": { "@id": "schema:Course" },
		"CourseInstance": { "@id": "schema:CourseInstance" },
		"Courthouse": { "@id": "schema:Courthouse" },
		"CoverArt": { "@id": "schema:CoverArt" },
		"CovidTestingFacility": { "@id": "schema:CovidTestingFacility" },
		"CreateAction": { "@id": "schema:CreateAction" },
		"CreativeWork": { "@id": "schema:CreativeWork" },
		"CreativeWorkSeason": { "@id": "schema:CreativeWorkSeason" },
		"CreativeWorkSeries": { "@id": "schema:CreativeWorkSeries" },
		"CreditCard": { "@id": "schema:CreditCard" },
		"Crematorium": { "@id": "schema:Crematorium" },
		"CriticReview": { "@id": "schema:CriticReview" },
		"CrossSectional": { "@id": "schema:CrossSectional" },
		"CssSelectorType": { "@id": "schema:CssSelectorType" },
		"CurrencyConversionService": { "@id": "schema:CurrencyConversionService" },
		"DDxElement": { "@id": "schema:DDxElement" },
		"DJMixAlbum": { "@id": "schema:DJMixAlbum" },
		"DVDFormat": { "@id": "schema:DVDFormat" },
		"DamagedCondition": { "@id": "schema:DamagedCondition" },
		"DanceEvent": { "@id": "schema:DanceEvent" },
		"DanceGroup": { "@id": "schema:DanceGroup" },
		"DangerousGoodConsideration": { "@id": "schema:DangerousGoodConsideration" },
		"DataCatalog": { "@id": "schema:DataCatalog" },
		"DataDownload": { "@id": "schema:DataDownload" },
		"DataDrivenMediaDigitalSource": { "@id": "schema:DataDrivenMediaDigitalSource" },
		"DataFeed": { "@id": "schema:DataFeed" },
		"DataFeedItem": { "@id": "schema:DataFeedItem" },
		"DataType": { "@id": "schema:DataType" },
		"Dataset": { "@id": "schema:Dataset" },
		"Date": { "@id": "schema:Date" },
		"DateTime": { "@id": "schema:DateTime" },
		"DatedMoneySpecification": { "@id": "schema:DatedMoneySpecification" },
		"DayOfWeek": { "@id": "schema:DayOfWeek" },
		"DaySpa": { "@id": "schema:DaySpa" },
		"DeactivateAction": { "@id": "schema:DeactivateAction" },
		"DecontextualizedContent": { "@id": "schema:DecontextualizedContent" },
		"DefenceEstablishment": { "@id": "schema:DefenceEstablishment" },
		"DefinedRegion": { "@id": "schema:DefinedRegion" },
		"DefinedTerm": { "@id": "schema:DefinedTerm" },
		"DefinedTermSet": { "@id": "schema:DefinedTermSet" },
		"DefinitiveLegalValue": { "@id": "schema:DefinitiveLegalValue" },
		"DeleteAction": { "@id": "schema:DeleteAction" },
		"DeliveryChargeSpecification": { "@id": "schema:DeliveryChargeSpecification" },
		"DeliveryEvent": { "@id": "schema:DeliveryEvent" },
		"DeliveryMethod": { "@id": "schema:DeliveryMethod" },
		"DeliveryTimeSettings": { "@id": "schema:DeliveryTimeSettings" },
		"Demand": { "@id": "schema:Demand" },
		"DemoAlbum": { "@id": "schema:DemoAlbum" },
		"DemoGameAvailability": { "@id": "schema:DemoGameAvailability" },
		"Dentist": { "@id": "schema:Dentist" },
		"Dentistry": { "@id": "schema:Dentistry" },
		"DepartAction": { "@id": "schema:DepartAction" },
		"DepartmentStore": { "@id": "schema:DepartmentStore" },
		"DepositAccount": { "@id": "schema:DepositAccount" },
		"Dermatologic": { "@id": "schema:Dermatologic" },
		"Dermatology": { "@id": "schema:Dermatology" },
		"DesktopWebPlatform": { "@id": "schema:DesktopWebPlatform" },
		"DiabeticDiet": { "@id": "schema:DiabeticDiet" },
		"Diagnostic": { "@id": "schema:Diagnostic" },
		"DiagnosticLab": { "@id": "schema:DiagnosticLab" },
		"DiagnosticProcedure": { "@id": "schema:DiagnosticProcedure" },
		"Diet": { "@id": "schema:Diet" },
		"DietNutrition": { "@id": "schema:DietNutrition" },
		"DietarySupplement": { "@id": "schema:DietarySupplement" },
		"DigitalArtDigitalSource": { "@id": "schema:DigitalArtDigitalSource" },
		"DigitalAudioTapeFormat": { "@id": "schema:DigitalAudioTapeFormat" },
		"DigitalCaptureDigitalSource": { "@id": "schema:DigitalCaptureDigitalSource" },
		"DigitalDocument": { "@id": "schema:DigitalDocument" },
		"DigitalDocumentPermission": { "@id": "schema:DigitalDocumentPermission" },
		"DigitalDocumentPermissionType": { "@id": "schema:DigitalDocumentPermissionType" },
		"DigitalFormat": { "@id": "schema:DigitalFormat" },
		"DigitalPlatformEnumeration": { "@id": "schema:DigitalPlatformEnumeration" },
		"DirectDebit": { "@id": "schema:DirectDebit" },
		"DisabilitySupport": { "@id": "schema:DisabilitySupport" },
		"DisagreeAction": { "@id": "schema:DisagreeAction" },
		"Discontinued": { "@id": "schema:Discontinued" },
		"DiscoverAction": { "@id": "schema:DiscoverAction" },
		"DiscussionForumPosting": { "@id": "schema:DiscussionForumPosting" },
		"DislikeAction": { "@id": "schema:DislikeAction" },
		"Distance": { "@id": "schema:Distance" },
		"DistanceFee": { "@id": "schema:DistanceFee" },
		"Distillery": { "@id": "schema:Distillery" },
		"DonateAction": { "@id": "schema:DonateAction" },
		"DoseSchedule": { "@id": "schema:DoseSchedule" },
		"DoubleBlindedTrial": { "@id": "schema:DoubleBlindedTrial" },
		"DownloadAction": { "@id": "schema:DownloadAction" },
		"Downpayment": { "@id": "schema:Downpayment" },
		"DrawAction": { "@id": "schema:DrawAction" },
		"Drawing": { "@id": "schema:Drawing" },
		"DrinkAction": { "@id": "schema:DrinkAction" },
		"DriveWheelConfigurationValue": { "@id": "schema:DriveWheelConfigurationValue" },
		"DrivingSchoolVehicleUsage": { "@id": "schema:DrivingSchoolVehicleUsage" },
		"Drug": { "@id": "schema:Drug" },
		"DrugClass": { "@id": "schema:DrugClass" },
		"DrugCost": { "@id": "schema:DrugCost" },
		"DrugCostCategory": { "@id": "schema:DrugCostCategory" },
		"DrugLegalStatus": { "@id": "schema:DrugLegalStatus" },
		"DrugPregnancyCategory": { "@id": "schema:DrugPregnancyCategory" },
		"DrugPrescriptionStatus": { "@id": "schema:DrugPrescriptionStatus" },
		"DrugStrength": { "@id": "schema:DrugStrength" },
		"DryCleaningOrLaundry": { "@id": "schema:DryCleaningOrLaundry" },
		"Duration": { "@id": "schema:Duration" },
		"EBook": { "@id": "schema:EBook" },
		"EPRelease": { "@id": "schema:EPRelease" },
		"EUEnergyEfficiencyCategoryA": { "@id": "schema:EUEnergyEfficiencyCategoryA" },
		"EUEnergyEfficiencyCategoryA1Plus": { "@id": "schema:EUEnergyEfficiencyCategoryA1Plus" },
		"EUEnergyEfficiencyCategoryA2Plus": { "@id": "schema:EUEnergyEfficiencyCategoryA2Plus" },
		"EUEnergyEfficiencyCategoryA3Plus": { "@id": "schema:EUEnergyEfficiencyCategoryA3Plus" },
		"EUEnergyEfficiencyCategoryB": { "@id": "schema:EUEnergyEfficiencyCategoryB" },
		"EUEnergyEfficiencyCategoryC": { "@id": "schema:EUEnergyEfficiencyCategoryC" },
		"EUEnergyEfficiencyCategoryD": { "@id": "schema:EUEnergyEfficiencyCategoryD" },
		"EUEnergyEfficiencyCategoryE": { "@id": "schema:EUEnergyEfficiencyCategoryE" },
		"EUEnergyEfficiencyCategoryF": { "@id": "schema:EUEnergyEfficiencyCategoryF" },
		"EUEnergyEfficiencyCategoryG": { "@id": "schema:EUEnergyEfficiencyCategoryG" },
		"EUEnergyEfficiencyEnumeration": { "@id": "schema:EUEnergyEfficiencyEnumeration" },
		"Ear": { "@id": "schema:Ear" },
		"EatAction": { "@id": "schema:EatAction" },
		"EditedOrCroppedContent": { "@id": "schema:EditedOrCroppedContent" },
		"EducationEvent": { "@id": "schema:EducationEvent" },
		"EducationalAudience": { "@id": "schema:EducationalAudience" },
		"EducationalOccupationalCredential": { "@id": "schema:EducationalOccupationalCredential" },
		"EducationalOccupationalProgram": { "@id": "schema:EducationalOccupationalProgram" },
		"EducationalOrganization": { "@id": "schema:EducationalOrganization" },
		"EffectivenessHealthAspect": { "@id": "schema:EffectivenessHealthAspect" },
		"Electrician": { "@id": "schema:Electrician" },
		"ElectronicsStore": { "@id": "schema:ElectronicsStore" },
		"ElementarySchool": { "@id": "schema:ElementarySchool" },
		"EmailMessage": { "@id": "schema:EmailMessage" },
		"Embassy": { "@id": "schema:Embassy" },
		"Emergency": { "@id": "schema:Emergency" },
		"EmergencyService": { "@id": "schema:EmergencyService" },
		"EmployeeRole": { "@id": "schema:EmployeeRole" },
		"EmployerAggregateRating": { "@id": "schema:EmployerAggregateRating" },
		"EmployerReview": { "@id": "schema:EmployerReview" },
		"EmploymentAgency": { "@id": "schema:EmploymentAgency" },
		"Endocrine": { "@id": "schema:Endocrine" },
		"EndorseAction": { "@id": "schema:EndorseAction" },
		"EndorsementRating": { "@id": "schema:EndorsementRating" },
		"Energy": { "@id": "schema:Energy" },
		"EnergyConsumptionDetails": { "@id": "schema:EnergyConsumptionDetails" },
		"EnergyEfficiencyEnumeration": { "@id": "schema:EnergyEfficiencyEnumeration" },
		"EnergyStarCertified": { "@id": "schema:EnergyStarCertified" },
		"EnergyStarEnergyEfficiencyEnumeration": { "@id": "schema:EnergyStarEnergyEfficiencyEnumeration" },
		"EngineSpecification": { "@id": "schema:EngineSpecification" },
		"EnrollingByInvitation": { "@id": "schema:EnrollingByInvitation" },
		"EntertainmentBusiness": { "@id": "schema:EntertainmentBusiness" },
		"EntryPoint": { "@id": "schema:EntryPoint" },
		"Enumeration": { "@id": "schema:Enumeration" },
		"Episode": { "@id": "schema:Episode" },
		"Event": { "@id": "schema:Event" },
		"EventAttendanceModeEnumeration": { "@id": "schema:EventAttendanceModeEnumeration" },
		"EventCancelled": { "@id": "schema:EventCancelled" },
		"EventMovedOnline": { "@id": "schema:EventMovedOnline" },
		"EventPostponed": { "@id": "schema:EventPostponed" },
		"EventRescheduled": { "@id": "schema:EventRescheduled" },
		"EventReservation": { "@id": "schema:EventReservation" },
		"EventScheduled": { "@id": "schema:EventScheduled" },
		"EventSeries": { "@id": "schema:EventSeries" },
		"EventStatusType": { "@id": "schema:EventStatusType" },
		"EventVenue": { "@id": "schema:EventVenue" },
		"EvidenceLevelA": { "@id": "schema:EvidenceLevelA" },
		"EvidenceLevelB": { "@id": "schema:EvidenceLevelB" },
		"EvidenceLevelC": { "@id": "schema:EvidenceLevelC" },
		"ExampleMeasurementMethodEnum": { "@id": "schema:ExampleMeasurementMethodEnum" },
		"ExchangeRateSpecification": { "@id": "schema:ExchangeRateSpecification" },
		"ExchangeRefund": { "@id": "schema:ExchangeRefund" },
		"ExerciseAction": { "@id": "schema:ExerciseAction" },
		"ExerciseGym": { "@id": "schema:ExerciseGym" },
		"ExercisePlan": { "@id": "schema:ExercisePlan" },
		"ExhibitionEvent": { "@id": "schema:ExhibitionEvent" },
		"Eye": { "@id": "schema:Eye" },
		"FAQPage": { "@id": "schema:FAQPage" },
		"FDAcategoryA": { "@id": "schema:FDAcategoryA" },
		"FDAcategoryB": { "@id": "schema:FDAcategoryB" },
		"FDAcategoryC": { "@id": "schema:FDAcategoryC" },
		"FDAcategoryD": { "@id": "schema:FDAcategoryD" },
		"FDAcategoryX": { "@id": "schema:FDAcategoryX" },
		"FDAnotEvaluated": { "@id": "schema:FDAnotEvaluated" },
		"FMRadioChannel": { "@id": "schema:FMRadioChannel" },
		"FailedActionStatus": { "@id": "schema:FailedActionStatus" },
		"False": { "@id": "schema:False" },
		"FastFoodRestaurant": { "@id": "schema:FastFoodRestaurant" },
		"Female": { "@id": "schema:Female" },
		"Festival": { "@id": "schema:Festival" },
		"FilmAction": { "@id": "schema:FilmAction" },
		"FinancialProduct": { "@id": "schema:FinancialProduct" },
		"FinancialService": { "@id": "schema:FinancialService" },
		"FindAction": { "@id": "schema:FindAction" },
		"FireStation": { "@id": "schema:FireStation" },
		"Flexibility": { "@id": "schema:Flexibility" },
		"Flight": { "@id": "schema:Flight" },
		"FlightReservation": { "@id": "schema:FlightReservation" },
		"Float": { "@id": "schema:Float" },
		"FloorPlan": { "@id": "schema:FloorPlan" },
		"Florist": { "@id": "schema:Florist" },
		"FollowAction": { "@id": "schema:FollowAction" },
		"FoodEstablishment": { "@id": "schema:FoodEstablishment" },
		"FoodEstablishmentReservation": { "@id": "schema:FoodEstablishmentReservation" },
		"FoodEvent": { "@id": "schema:FoodEvent" },
		"FoodService": { "@id": "schema:FoodService" },
		"FourWheelDriveConfiguration": { "@id": "schema:FourWheelDriveConfiguration" },
		"FreeReturn": { "@id": "schema:FreeReturn" },
		"Friday": { "@id": "schema:Friday" },
		"FrontWheelDriveConfiguration": { "@id": "schema:FrontWheelDriveConfiguration" },
		"FullGameAvailability": { "@id": "schema:FullGameAvailability" },
		"FullRefund": { "@id": "schema:FullRefund" },
		"FundingAgency": { "@id": "schema:FundingAgency" },
		"FundingScheme": { "@id": "schema:FundingScheme" },
		"Fungus": { "@id": "schema:Fungus" },
		"FurnitureStore": { "@id": "schema:FurnitureStore" },
		"Game": { "@id": "schema:Game" },
		"GameAvailabilityEnumeration": { "@id": "schema:GameAvailabilityEnumeration" },
		"GamePlayMode": { "@id": "schema:GamePlayMode" },
		"GameServer": { "@id": "schema:GameServer" },
		"GameServerStatus": { "@id": "schema:GameServerStatus" },
		"GardenStore": { "@id": "schema:GardenStore" },
		"GasStation": { "@id": "schema:GasStation" },
		"Gastroenterologic": { "@id": "schema:Gastroenterologic" },
		"GatedResidenceCommunity": { "@id": "schema:GatedResidenceCommunity" },
		"GenderType": { "@id": "schema:GenderType" },
		"Gene": { "@id": "schema:Gene" },
		"GeneralContractor": { "@id": "schema:GeneralContractor" },
		"GenericWebPlatform": { "@id": "schema:GenericWebPlatform" },
		"Genetic": { "@id": "schema:Genetic" },
		"Genitourinary": { "@id": "schema:Genitourinary" },
		"GeoCircle": { "@id": "schema:GeoCircle" },
		"GeoCoordinates": { "@id": "schema:GeoCoordinates" },
		"GeoShape": { "@id": "schema:GeoShape" },
		"GeospatialGeometry": { "@id": "schema:GeospatialGeometry" },
		"Geriatric": { "@id": "schema:Geriatric" },
		"GettingAccessHealthAspect": { "@id": "schema:GettingAccessHealthAspect" },
		"GiveAction": { "@id": "schema:GiveAction" },
		"GlutenFreeDiet": { "@id": "schema:GlutenFreeDiet" },
		"GolfCourse": { "@id": "schema:GolfCourse" },
		"GovernmentBenefitsType": { "@id": "schema:GovernmentBenefitsType" },
		"GovernmentBuilding": { "@id": "schema:GovernmentBuilding" },
		"GovernmentOffice": { "@id": "schema:GovernmentOffice" },
		"GovernmentOrganization": { "@id": "schema:GovernmentOrganization" },
		"GovernmentPermit": { "@id": "schema:GovernmentPermit" },
		"GovernmentService": { "@id": "schema:GovernmentService" },
		"Grant": { "@id": "schema:Grant" },
		"GraphicNovel": { "@id": "schema:GraphicNovel" },
		"GroceryStore": { "@id": "schema:GroceryStore" },
		"GroupBoardingPolicy": { "@id": "schema:GroupBoardingPolicy" },
		"Guide": { "@id": "schema:Guide" },
		"Gynecologic": { "@id": "schema:Gynecologic" },
		"HVACBusiness": { "@id": "schema:HVACBusiness" },
		"Hackathon": { "@id": "schema:Hackathon" },
		"HairSalon": { "@id": "schema:HairSalon" },
		"HalalDiet": { "@id": "schema:HalalDiet" },
		"Hardcover": { "@id": "schema:Hardcover" },
		"HardwareStore": { "@id": "schema:HardwareStore" },
		"Head": { "@id": "schema:Head" },
		"HealthAndBeautyBusiness": { "@id": "schema:HealthAndBeautyBusiness" },
		"HealthAspectEnumeration": { "@id": "schema:HealthAspectEnumeration" },
		"HealthCare": { "@id": "schema:HealthCare" },
		"HealthClub": { "@id": "schema:HealthClub" },
		"HealthInsurancePlan": { "@id": "schema:HealthInsurancePlan" },
		"HealthPlanCostSharingSpecification": { "@id": "schema:HealthPlanCostSharingSpecification" },
		"HealthPlanFormulary": { "@id": "schema:HealthPlanFormulary" },
		"HealthPlanNetwork": { "@id": "schema:HealthPlanNetwork" },
		"HealthTopicContent": { "@id": "schema:HealthTopicContent" },
		"HealthcareConsideration": { "@id": "schema:HealthcareConsideration" },
		"HearingImpairedSupported": { "@id": "schema:HearingImpairedSupported" },
		"Hematologic": { "@id": "schema:Hematologic" },
		"HighSchool": { "@id": "schema:HighSchool" },
		"HinduDiet": { "@id": "schema:HinduDiet" },
		"HinduTemple": { "@id": "schema:HinduTemple" },
		"HobbyShop": { "@id": "schema:HobbyShop" },
		"HomeAndConstructionBusiness": { "@id": "schema:HomeAndConstructionBusiness" },
		"HomeGoodsStore": { "@id": "schema:HomeGoodsStore" },
		"Homeopathic": { "@id": "schema:Homeopathic" },
		"Hospital": { "@id": "schema:Hospital" },
		"Hostel": { "@id": "schema:Hostel" },
		"Hotel": { "@id": "schema:Hotel" },
		"HotelRoom": { "@id": "schema:HotelRoom" },
		"House": { "@id": "schema:House" },
		"HousePainter": { "@id": "schema:HousePainter" },
		"HowItWorksHealthAspect": { "@id": "schema:HowItWorksHealthAspect" },
		"HowOrWhereHealthAspect": { "@id": "schema:HowOrWhereHealthAspect" },
		"HowTo": { "@id": "schema:HowTo" },
		"HowToDirection": { "@id": "schema:HowToDirection" },
		"HowToItem": { "@id": "schema:HowToItem" },
		"HowToSection": { "@id": "schema:HowToSection" },
		"HowToStep": { "@id": "schema:HowToStep" },
		"HowToSupply": { "@id": "schema:HowToSupply" },
		"HowToTip": { "@id": "schema:HowToTip" },
		"HowToTool": { "@id": "schema:HowToTool" },
		"HyperToc": { "@id": "schema:HyperToc" },
		"HyperTocEntry": { "@id": "schema:HyperTocEntry" },
		"IOSPlatform": { "@id": "schema:IOSPlatform" },
		"IPTCDigitalSourceEnumeration": { "@id": "schema:IPTCDigitalSourceEnumeration" },
		"IceCreamShop": { "@id": "schema:IceCreamShop" },
		"IgnoreAction": { "@id": "schema:IgnoreAction" },
		"ImageGallery": { "@id": "schema:ImageGallery" },
		"ImageObject": { "@id": "schema:ImageObject" },
		"ImageObjectSnapshot": { "@id": "schema:ImageObjectSnapshot" },
		"ImagingTest": { "@id": "schema:ImagingTest" },
		"InForce": { "@id": "schema:InForce" },
		"InStock": { "@id": "schema:InStock" },
		"InStoreOnly": { "@id": "schema:InStoreOnly" },
		"InStorePrepay": { "@id": "schema:InStorePrepay" },
		"IndividualPhysician": { "@id": "schema:IndividualPhysician" },
		"IndividualProduct": { "@id": "schema:IndividualProduct" },
		"Infectious": { "@id": "schema:Infectious" },
		"InfectiousAgentClass": { "@id": "schema:InfectiousAgentClass" },
		"InfectiousDisease": { "@id": "schema:InfectiousDisease" },
		"InformAction": { "@id": "schema:InformAction" },
		"IngredientsHealthAspect": { "@id": "schema:IngredientsHealthAspect" },
		"InsertAction": { "@id": "schema:InsertAction" },
		"InstallAction": { "@id": "schema:InstallAction" },
		"Installment": { "@id": "schema:Installment" },
		"InsuranceAgency": { "@id": "schema:InsuranceAgency" },
		"Intangible": { "@id": "schema:Intangible" },
		"Integer": { "@id": "schema:Integer" },
		"InteractAction": { "@id": "schema:InteractAction" },
		"InteractionCounter": { "@id": "schema:InteractionCounter" },
		"InternationalTrial": { "@id": "schema:InternationalTrial" },
		"InternetCafe": { "@id": "schema:InternetCafe" },
		"InvestmentFund": { "@id": "schema:InvestmentFund" },
		"InvestmentOrDeposit": { "@id": "schema:InvestmentOrDeposit" },
		"InviteAction": { "@id": "schema:InviteAction" },
		"Invoice": { "@id": "schema:Invoice" },
		"InvoicePrice": { "@id": "schema:InvoicePrice" },
		"ItemAvailability": { "@id": "schema:ItemAvailability" },
		"ItemList": { "@id": "schema:ItemList" },
		"ItemListOrderAscending": { "@id": "schema:ItemListOrderAscending" },
		"ItemListOrderDescending": { "@id": "schema:ItemListOrderDescending" },
		"ItemListOrderType": { "@id": "schema:ItemListOrderType" },
		"ItemListUnordered": { "@id": "schema:ItemListUnordered" },
		"ItemPage": { "@id": "schema:ItemPage" },
		"JewelryStore": { "@id": "schema:JewelryStore" },
		"JobPosting": { "@id": "schema:JobPosting" },
		"JoinAction": { "@id": "schema:JoinAction" },
		"Joint": { "@id": "schema:Joint" },
		"KeepProduct": { "@id": "schema:KeepProduct" },
		"KosherDiet": { "@id": "schema:KosherDiet" },
		"LaboratoryScience": { "@id": "schema:LaboratoryScience" },
		"LakeBodyOfWater": { "@id": "schema:LakeBodyOfWater" },
		"Landform": { "@id": "schema:Landform" },
		"LandmarksOrHistoricalBuildings": { "@id": "schema:LandmarksOrHistoricalBuildings" },
		"Language": { "@id": "schema:Language" },
		"LaserDiscFormat": { "@id": "schema:LaserDiscFormat" },
		"LearningResource": { "@id": "schema:LearningResource" },
		"LeaveAction": { "@id": "schema:LeaveAction" },
		"LeftHandDriving": { "@id": "schema:LeftHandDriving" },
		"LegalForceStatus": { "@id": "schema:LegalForceStatus" },
		"LegalService": { "@id": "schema:LegalService" },
		"LegalValueLevel": { "@id": "schema:LegalValueLevel" },
		"Legislation": { "@id": "schema:Legislation" },
		"LegislationObject": { "@id": "schema:LegislationObject" },
		"LegislativeBuilding": { "@id": "schema:LegislativeBuilding" },
		"LeisureTimeActivity": { "@id": "schema:LeisureTimeActivity" },
		"LendAction": { "@id": "schema:LendAction" },
		"Library": { "@id": "schema:Library" },
		"LibrarySystem": { "@id": "schema:LibrarySystem" },
		"LifestyleModification": { "@id": "schema:LifestyleModification" },
		"Ligament": { "@id": "schema:Ligament" },
		"LikeAction": { "@id": "schema:LikeAction" },
		"LimitedAvailability": { "@id": "schema:LimitedAvailability" },
		"LimitedByGuaranteeCharity": { "@id": "schema:LimitedByGuaranteeCharity" },
		"LinkRole": { "@id": "schema:LinkRole" },
		"LiquorStore": { "@id": "schema:LiquorStore" },
		"ListItem": { "@id": "schema:ListItem" },
		"ListPrice": { "@id": "schema:ListPrice" },
		"ListenAction": { "@id": "schema:ListenAction" },
		"LiteraryEvent": { "@id": "schema:LiteraryEvent" },
		"LiveAlbum": { "@id": "schema:LiveAlbum" },
		"LiveBlogPosting": { "@id": "schema:LiveBlogPosting" },
		"LivingWithHealthAspect": { "@id": "schema:LivingWithHealthAspect" },
		"LoanOrCredit": { "@id": "schema:LoanOrCredit" },
		"LocalBusiness": { "@id": "schema:LocalBusiness" },
		"LocationFeatureSpecification": { "@id": "schema:LocationFeatureSpecification" },
		"LockerDelivery": { "@id": "schema:LockerDelivery" },
		"Locksmith": { "@id": "schema:Locksmith" },
		"LodgingBusiness": { "@id": "schema:LodgingBusiness" },
		"LodgingReservation": { "@id": "schema:LodgingReservation" },
		"Longitudinal": { "@id": "schema:Longitudinal" },
		"LoseAction": { "@id": "schema:LoseAction" },
		"LowCalorieDiet": { "@id": "schema:LowCalorieDiet" },
		"LowFatDiet": { "@id": "schema:LowFatDiet" },
		"LowLactoseDiet": { "@id": "schema:LowLactoseDiet" },
		"LowSaltDiet": { "@id": "schema:LowSaltDiet" },
		"Lung": { "@id": "schema:Lung" },
		"LymphaticVessel": { "@id": "schema:LymphaticVessel" },
		"MRI": { "@id": "schema:MRI" },
		"MSRP": { "@id": "schema:MSRP" },
		"MadeToOrder": { "@id": "schema:MadeToOrder" },
		"Male": { "@id": "schema:Male" },
		"Manuscript": { "@id": "schema:Manuscript" },
		"Map": { "@id": "schema:Map" },
		"MapCategoryType": { "@id": "schema:MapCategoryType" },
		"MarryAction": { "@id": "schema:MarryAction" },
		"Mass": { "@id": "schema:Mass" },
		"MathSolver": { "@id": "schema:MathSolver" },
		"MaximumDoseSchedule": { "@id": "schema:MaximumDoseSchedule" },
		"MayTreatHealthAspect": { "@id": "schema:MayTreatHealthAspect" },
		"MeasurementMethodEnum": { "@id": "schema:MeasurementMethodEnum" },
		"MeasurementTypeEnumeration": { "@id": "schema:MeasurementTypeEnumeration" },
		"MediaEnumeration": { "@id": "schema:MediaEnumeration" },
		"MediaGallery": { "@id": "schema:MediaGallery" },
		"MediaManipulationRatingEnumeration": { "@id": "schema:MediaManipulationRatingEnumeration" },
		"MediaObject": { "@id": "schema:MediaObject" },
		"MediaReview": { "@id": "schema:MediaReview" },
		"MediaReviewItem": { "@id": "schema:MediaReviewItem" },
		"MediaSubscription": { "@id": "schema:MediaSubscription" },
		"MedicalAudience": { "@id": "schema:MedicalAudience" },
		"MedicalAudienceType": { "@id": "schema:MedicalAudienceType" },
		"MedicalBusiness": { "@id": "schema:MedicalBusiness" },
		"MedicalCause": { "@id": "schema:MedicalCause" },
		"MedicalClinic": { "@id": "schema:MedicalClinic" },
		"MedicalCode": { "@id": "schema:MedicalCode" },
		"MedicalCondition": { "@id": "schema:MedicalCondition" },
		"MedicalConditionStage": { "@id": "schema:MedicalConditionStage" },
		"MedicalContraindication": { "@id": "schema:MedicalContraindication" },
		"MedicalDevice": { "@id": "schema:MedicalDevice" },
		"MedicalDevicePurpose": { "@id": "schema:MedicalDevicePurpose" },
		"MedicalEntity": { "@id": "schema:MedicalEntity" },
		"MedicalEnumeration": { "@id": "schema:MedicalEnumeration" },
		"MedicalEvidenceLevel": { "@id": "schema:MedicalEvidenceLevel" },
		"MedicalGuideline": { "@id": "schema:MedicalGuideline" },
		"MedicalGuidelineContraindication": { "@id": "schema:MedicalGuidelineContraindication" },
		"MedicalGuidelineRecommendation": { "@id": "schema:MedicalGuidelineRecommendation" },
		"MedicalImagingTechnique": { "@id": "schema:MedicalImagingTechnique" },
		"MedicalIndication": { "@id": "schema:MedicalIndication" },
		"MedicalIntangible": { "@id": "schema:MedicalIntangible" },
		"MedicalObservationalStudy": { "@id": "schema:MedicalObservationalStudy" },
		"MedicalObservationalStudyDesign": { "@id": "schema:MedicalObservationalStudyDesign" },
		"MedicalOrganization": { "@id": "schema:MedicalOrganization" },
		"MedicalProcedure": { "@id": "schema:MedicalProcedure" },
		"MedicalProcedureType": { "@id": "schema:MedicalProcedureType" },
		"MedicalResearcher": { "@id": "schema:MedicalResearcher" },
		"MedicalRiskCalculator": { "@id": "schema:MedicalRiskCalculator" },
		"MedicalRiskEstimator": { "@id": "schema:MedicalRiskEstimator" },
		"MedicalRiskFactor": { "@id": "schema:MedicalRiskFactor" },
		"MedicalRiskScore": { "@id": "schema:MedicalRiskScore" },
		"MedicalScholarlyArticle": { "@id": "schema:MedicalScholarlyArticle" },
		"MedicalSign": { "@id": "schema:MedicalSign" },
		"MedicalSignOrSymptom": { "@id": "schema:MedicalSignOrSymptom" },
		"MedicalSpecialty": { "@id": "schema:MedicalSpecialty" },
		"MedicalStudy": { "@id": "schema:MedicalStudy" },
		"MedicalStudyStatus": { "@id": "schema:MedicalStudyStatus" },
		"MedicalSymptom": { "@id": "schema:MedicalSymptom" },
		"MedicalTest": { "@id": "schema:MedicalTest" },
		"MedicalTestPanel": { "@id": "schema:MedicalTestPanel" },
		"MedicalTherapy": { "@id": "schema:MedicalTherapy" },
		"MedicalTrial": { "@id": "schema:MedicalTrial" },
		"MedicalTrialDesign": { "@id": "schema:MedicalTrialDesign" },
		"MedicalWebPage": { "@id": "schema:MedicalWebPage" },
		"MedicineSystem": { "@id": "schema:MedicineSystem" },
		"MeetingRoom": { "@id": "schema:MeetingRoom" },
		"MemberProgram": { "@id": "schema:MemberProgram" },
		"MemberProgramTier": { "@id": "schema:MemberProgramTier" },
		"MensClothingStore": { "@id": "schema:MensClothingStore" },
		"Menu": { "@id": "schema:Menu" },
		"MenuItem": { "@id": "schema:MenuItem" },
		"MenuSection": { "@id": "schema:MenuSection" },
		"MerchantReturnEnumeration": { "@id": "schema:MerchantReturnEnumeration" },
		"MerchantReturnFiniteReturnWindow": { "@id": "schema:MerchantReturnFiniteReturnWindow" },
		"MerchantReturnNotPermitted": { "@id": "schema:MerchantReturnNotPermitted" },
		"MerchantReturnPolicy": { "@id": "schema:MerchantReturnPolicy" },
		"MerchantReturnPolicySeasonalOverride": { "@id": "schema:MerchantReturnPolicySeasonalOverride" },
		"MerchantReturnUnlimitedWindow": { "@id": "schema:MerchantReturnUnlimitedWindow" },
		"MerchantReturnUnspecified": { "@id": "schema:MerchantReturnUnspecified" },
		"Message": { "@id": "schema:Message" },
		"MiddleSchool": { "@id": "schema:MiddleSchool" },
		"Midwifery": { "@id": "schema:Midwifery" },
		"MinimumAdvertisedPrice": { "@id": "schema:MinimumAdvertisedPrice" },
		"MinorHumanEditsDigitalSource": { "@id": "schema:MinorHumanEditsDigitalSource" },
		"MisconceptionsHealthAspect": { "@id": "schema:MisconceptionsHealthAspect" },
		"MixedEventAttendanceMode": { "@id": "schema:MixedEventAttendanceMode" },
		"MixtapeAlbum": { "@id": "schema:MixtapeAlbum" },
		"MobileApplication": { "@id": "schema:MobileApplication" },
		"MobilePhoneStore": { "@id": "schema:MobilePhoneStore" },
		"MobileWebPlatform": { "@id": "schema:MobileWebPlatform" },
		"MolecularEntity": { "@id": "schema:MolecularEntity" },
		"Monday": { "@id": "schema:Monday" },
		"MonetaryAmount": { "@id": "schema:MonetaryAmount" },
		"MonetaryAmountDistribution": { "@id": "schema:MonetaryAmountDistribution" },
		"MonetaryGrant": { "@id": "schema:MonetaryGrant" },
		"MoneyTransfer": { "@id": "schema:MoneyTransfer" },
		"MortgageLoan": { "@id": "schema:MortgageLoan" },
		"Mosque": { "@id": "schema:Mosque" },
		"Motel": { "@id": "schema:Motel" },
		"Motorcycle": { "@id": "schema:Motorcycle" },
		"MotorcycleDealer": { "@id": "schema:MotorcycleDealer" },
		"MotorcycleRepair": { "@id": "schema:MotorcycleRepair" },
		"MotorizedBicycle": { "@id": "schema:MotorizedBicycle" },
		"Mountain": { "@id": "schema:Mountain" },
		"MoveAction": { "@id": "schema:MoveAction" },
		"Movie": { "@id": "schema:Movie" },
		"MovieClip": { "@id": "schema:MovieClip" },
		"MovieRentalStore": { "@id": "schema:MovieRentalStore" },
		"MovieSeries": { "@id": "schema:MovieSeries" },
		"MovieTheater": { "@id": "schema:MovieTheater" },
		"MovingCompany": { "@id": "schema:MovingCompany" },
		"MultiCenterTrial": { "@id": "schema:MultiCenterTrial" },
		"MultiPlayer": { "@id": "schema:MultiPlayer" },
		"MulticellularParasite": { "@id": "schema:MulticellularParasite" },
		"Muscle": { "@id": "schema:Muscle" },
		"Musculoskeletal": { "@id": "schema:Musculoskeletal" },
		"MusculoskeletalExam": { "@id": "schema:MusculoskeletalExam" },
		"Museum": { "@id": "schema:Museum" },
		"MusicAlbum": { "@id": "schema:MusicAlbum" },
		"MusicAlbumProductionType": { "@id": "schema:MusicAlbumProductionType" },
		"MusicAlbumReleaseType": { "@id": "schema:MusicAlbumReleaseType" },
		"MusicComposition": { "@id": "schema:MusicComposition" },
		"MusicEvent": { "@id": "schema:MusicEvent" },
		"MusicGroup": { "@id": "schema:MusicGroup" },
		"MusicPlaylist": { "@id": "schema:MusicPlaylist" },
		"MusicRecording": { "@id": "schema:MusicRecording" },
		"MusicRelease": { "@id": "schema:MusicRelease" },
		"MusicReleaseFormatType": { "@id": "schema:MusicReleaseFormatType" },
		"MusicStore": { "@id": "schema:MusicStore" },
		"MusicVenue": { "@id": "schema:MusicVenue" },
		"MusicVideoObject": { "@id": "schema:MusicVideoObject" },
		"NGO": { "@id": "schema:NGO" },
		"NLNonprofitType": { "@id": "schema:NLNonprofitType" },
		"NailSalon": { "@id": "schema:NailSalon" },
		"NarcoticConsideration": { "@id": "schema:NarcoticConsideration" },
		"Neck": { "@id": "schema:Neck" },
		"NegativeFilmDigitalSource": { "@id": "schema:NegativeFilmDigitalSource" },
		"Nerve": { "@id": "schema:Nerve" },
		"Neuro": { "@id": "schema:Neuro" },
		"Neurologic": { "@id": "schema:Neurologic" },
		"NewCondition": { "@id": "schema:NewCondition" },
		"NewsArticle": { "@id": "schema:NewsArticle" },
		"NewsMediaOrganization": { "@id": "schema:NewsMediaOrganization" },
		"Newspaper": { "@id": "schema:Newspaper" },
		"NightClub": { "@id": "schema:NightClub" },
		"NoninvasiveProcedure": { "@id": "schema:NoninvasiveProcedure" },
		"Nonprofit501a": { "@id": "schema:Nonprofit501a" },
		"Nonprofit501c1": { "@id": "schema:Nonprofit501c1" },
		"Nonprofit501c10": { "@id": "schema:Nonprofit501c10" },
		"Nonprofit501c11": { "@id": "schema:Nonprofit501c11" },
		"Nonprofit501c12": { "@id": "schema:Nonprofit501c12" },
		"Nonprofit501c13": { "@id": "schema:Nonprofit501c13" },
		"Nonprofit501c14": { "@id": "schema:Nonprofit501c14" },
		"Nonprofit501c15": { "@id": "schema:Nonprofit501c15" },
		"Nonprofit501c16": { "@id": "schema:Nonprofit501c16" },
		"Nonprofit501c17": { "@id": "schema:Nonprofit501c17" },
		"Nonprofit501c18": { "@id": "schema:Nonprofit501c18" },
		"Nonprofit501c19": { "@id": "schema:Nonprofit501c19" },
		"Nonprofit501c2": { "@id": "schema:Nonprofit501c2" },
		"Nonprofit501c20": { "@id": "schema:Nonprofit501c20" },
		"Nonprofit501c21": { "@id": "schema:Nonprofit501c21" },
		"Nonprofit501c22": { "@id": "schema:Nonprofit501c22" },
		"Nonprofit501c23": { "@id": "schema:Nonprofit501c23" },
		"Nonprofit501c24": { "@id": "schema:Nonprofit501c24" },
		"Nonprofit501c25": { "@id": "schema:Nonprofit501c25" },
		"Nonprofit501c26": { "@id": "schema:Nonprofit501c26" },
		"Nonprofit501c27": { "@id": "schema:Nonprofit501c27" },
		"Nonprofit501c28": { "@id": "schema:Nonprofit501c28" },
		"Nonprofit501c3": { "@id": "schema:Nonprofit501c3" },
		"Nonprofit501c4": { "@id": "schema:Nonprofit501c4" },
		"Nonprofit501c5": { "@id": "schema:Nonprofit501c5" },
		"Nonprofit501c6": { "@id": "schema:Nonprofit501c6" },
		"Nonprofit501c7": { "@id": "schema:Nonprofit501c7" },
		"Nonprofit501c8": { "@id": "schema:Nonprofit501c8" },
		"Nonprofit501c9": { "@id": "schema:Nonprofit501c9" },
		"Nonprofit501d": { "@id": "schema:Nonprofit501d" },
		"Nonprofit501e": { "@id": "schema:Nonprofit501e" },
		"Nonprofit501f": { "@id": "schema:Nonprofit501f" },
		"Nonprofit501k": { "@id": "schema:Nonprofit501k" },
		"Nonprofit501n": { "@id": "schema:Nonprofit501n" },
		"Nonprofit501q": { "@id": "schema:Nonprofit501q" },
		"Nonprofit527": { "@id": "schema:Nonprofit527" },
		"NonprofitANBI": { "@id": "schema:NonprofitANBI" },
		"NonprofitSBBI": { "@id": "schema:NonprofitSBBI" },
		"NonprofitType": { "@id": "schema:NonprofitType" },
		"Nose": { "@id": "schema:Nose" },
		"NotInForce": { "@id": "schema:NotInForce" },
		"NotYetRecruiting": { "@id": "schema:NotYetRecruiting" },
		"Notary": { "@id": "schema:Notary" },
		"NoteDigitalDocument": { "@id": "schema:NoteDigitalDocument" },
		"Number": { "@id": "schema:Number" },
		"Nursing": { "@id": "schema:Nursing" },
		"NutritionInformation": { "@id": "schema:NutritionInformation" },
		"OTC": { "@id": "schema:OTC" },
		"Observation": { "@id": "schema:Observation" },
		"Observational": { "@id": "schema:Observational" },
		"Obstetric": { "@id": "schema:Obstetric" },
		"Occupation": { "@id": "schema:Occupation" },
		"OccupationalActivity": { "@id": "schema:OccupationalActivity" },
		"OccupationalExperienceRequirements": { "@id": "schema:OccupationalExperienceRequirements" },
		"OccupationalTherapy": { "@id": "schema:OccupationalTherapy" },
		"OceanBodyOfWater": { "@id": "schema:OceanBodyOfWater" },
		"Offer": { "@id": "schema:Offer" },
		"OfferCatalog": { "@id": "schema:OfferCatalog" },
		"OfferForLease": { "@id": "schema:OfferForLease" },
		"OfferForPurchase": { "@id": "schema:OfferForPurchase" },
		"OfferItemCondition": { "@id": "schema:OfferItemCondition" },
		"OfferShippingDetails": { "@id": "schema:OfferShippingDetails" },
		"OfficeEquipmentStore": { "@id": "schema:OfficeEquipmentStore" },
		"OfficialLegalValue": { "@id": "schema:OfficialLegalValue" },
		"OfflineEventAttendanceMode": { "@id": "schema:OfflineEventAttendanceMode" },
		"OfflinePermanently": { "@id": "schema:OfflinePermanently" },
		"OfflineTemporarily": { "@id": "schema:OfflineTemporarily" },
		"OnDemandEvent": { "@id": "schema:OnDemandEvent" },
		"OnSitePickup": { "@id": "schema:OnSitePickup" },
		"Oncologic": { "@id": "schema:Oncologic" },
		"OneTimePayments": { "@id": "schema:OneTimePayments" },
		"Online": { "@id": "schema:Online" },
		"OnlineBusiness": { "@id": "schema:OnlineBusiness" },
		"OnlineEventAttendanceMode": { "@id": "schema:OnlineEventAttendanceMode" },
		"OnlineFull": { "@id": "schema:OnlineFull" },
		"OnlineOnly": { "@id": "schema:OnlineOnly" },
		"OnlineStore": { "@id": "schema:OnlineStore" },
		"OpenTrial": { "@id": "schema:OpenTrial" },
		"OpeningHoursSpecification": { "@id": "schema:OpeningHoursSpecification" },
		"OpinionNewsArticle": { "@id": "schema:OpinionNewsArticle" },
		"Optician": { "@id": "schema:Optician" },
		"Optometric": { "@id": "schema:Optometric" },
		"Order": { "@id": "schema:Order" },
		"OrderAction": { "@id": "schema:OrderAction" },
		"OrderCancelled": { "@id": "schema:OrderCancelled" },
		"OrderDelivered": { "@id": "schema:OrderDelivered" },
		"OrderInTransit": { "@id": "schema:OrderInTransit" },
		"OrderItem": { "@id": "schema:OrderItem" },
		"OrderPaymentDue": { "@id": "schema:OrderPaymentDue" },
		"OrderPickupAvailable": { "@id": "schema:OrderPickupAvailable" },
		"OrderProblem": { "@id": "schema:OrderProblem" },
		"OrderProcessing": { "@id": "schema:OrderProcessing" },
		"OrderReturned": { "@id": "schema:OrderReturned" },
		"OrderStatus": { "@id": "schema:OrderStatus" },
		"Organization": { "@id": "schema:Organization" },
		"OrganizationRole": { "@id": "schema:OrganizationRole" },
		"OrganizeAction": { "@id": "schema:OrganizeAction" },
		"OriginalMediaContent": { "@id": "schema:OriginalMediaContent" },
		"OriginalShippingFees": { "@id": "schema:OriginalShippingFees" },
		"Osteopathic": { "@id": "schema:Osteopathic" },
		"Otolaryngologic": { "@id": "schema:Otolaryngologic" },
		"OutOfStock": { "@id": "schema:OutOfStock" },
		"OutletStore": { "@id": "schema:OutletStore" },
		"OverviewHealthAspect": { "@id": "schema:OverviewHealthAspect" },
		"OwnershipInfo": { "@id": "schema:OwnershipInfo" },
		"PET": { "@id": "schema:PET" },
		"PaidLeave": { "@id": "schema:PaidLeave" },
		"PaintAction": { "@id": "schema:PaintAction" },
		"Painting": { "@id": "schema:Painting" },
		"PalliativeProcedure": { "@id": "schema:PalliativeProcedure" },
		"Paperback": { "@id": "schema:Paperback" },
		"ParcelDelivery": { "@id": "schema:ParcelDelivery" },
		"ParcelService": { "@id": "schema:ParcelService" },
		"ParentAudience": { "@id": "schema:ParentAudience" },
		"ParentalSupport": { "@id": "schema:ParentalSupport" },
		"Park": { "@id": "schema:Park" },
		"ParkingFacility": { "@id": "schema:ParkingFacility" },
		"ParkingMap": { "@id": "schema:ParkingMap" },
		"PartiallyInForce": { "@id": "schema:PartiallyInForce" },
		"Pathology": { "@id": "schema:Pathology" },
		"PathologyTest": { "@id": "schema:PathologyTest" },
		"Patient": { "@id": "schema:Patient" },
		"PatientExperienceHealthAspect": { "@id": "schema:PatientExperienceHealthAspect" },
		"PawnShop": { "@id": "schema:PawnShop" },
		"PayAction": { "@id": "schema:PayAction" },
		"PaymentAutomaticallyApplied": { "@id": "schema:PaymentAutomaticallyApplied" },
		"PaymentCard": { "@id": "schema:PaymentCard" },
		"PaymentChargeSpecification": { "@id": "schema:PaymentChargeSpecification" },
		"PaymentComplete": { "@id": "schema:PaymentComplete" },
		"PaymentDeclined": { "@id": "schema:PaymentDeclined" },
		"PaymentDue": { "@id": "schema:PaymentDue" },
		"PaymentMethod": { "@id": "schema:PaymentMethod" },
		"PaymentMethodType": { "@id": "schema:PaymentMethodType" },
		"PaymentPastDue": { "@id": "schema:PaymentPastDue" },
		"PaymentService": { "@id": "schema:PaymentService" },
		"PaymentStatusType": { "@id": "schema:PaymentStatusType" },
		"Pediatric": { "@id": "schema:Pediatric" },
		"PeopleAudience": { "@id": "schema:PeopleAudience" },
		"PercutaneousProcedure": { "@id": "schema:PercutaneousProcedure" },
		"PerformAction": { "@id": "schema:PerformAction" },
		"PerformanceRole": { "@id": "schema:PerformanceRole" },
		"PerformingArtsTheater": { "@id": "schema:PerformingArtsTheater" },
		"PerformingGroup": { "@id": "schema:PerformingGroup" },
		"Periodical": { "@id": "schema:Periodical" },
		"Permit": { "@id": "schema:Permit" },
		"Person": { "@id": "schema:Person" },
		"PetStore": { "@id": "schema:PetStore" },
		"Pharmacy": { "@id": "schema:Pharmacy" },
		"PharmacySpecialty": { "@id": "schema:PharmacySpecialty" },
		"PhoneCarrierPayment": { "@id": "schema:PhoneCarrierPayment" },
		"Photograph": { "@id": "schema:Photograph" },
		"PhotographAction": { "@id": "schema:PhotographAction" },
		"PhysicalActivity": { "@id": "schema:PhysicalActivity" },
		"PhysicalActivityCategory": { "@id": "schema:PhysicalActivityCategory" },
		"PhysicalExam": { "@id": "schema:PhysicalExam" },
		"PhysicalTherapy": { "@id": "schema:PhysicalTherapy" },
		"Physician": { "@id": "schema:Physician" },
		"PhysiciansOffice": { "@id": "schema:PhysiciansOffice" },
		"Physiotherapy": { "@id": "schema:Physiotherapy" },
		"Place": { "@id": "schema:Place" },
		"PlaceOfWorship": { "@id": "schema:PlaceOfWorship" },
		"PlaceboControlledTrial": { "@id": "schema:PlaceboControlledTrial" },
		"PlanAction": { "@id": "schema:PlanAction" },
		"PlasticSurgery": { "@id": "schema:PlasticSurgery" },
		"Play": { "@id": "schema:Play" },
		"PlayAction": { "@id": "schema:PlayAction" },
		"PlayGameAction": { "@id": "schema:PlayGameAction" },
		"Playground": { "@id": "schema:Playground" },
		"Plumber": { "@id": "schema:Plumber" },
		"PodcastEpisode": { "@id": "schema:PodcastEpisode" },
		"PodcastSeason": { "@id": "schema:PodcastSeason" },
		"PodcastSeries": { "@id": "schema:PodcastSeries" },
		"Podiatric": { "@id": "schema:Podiatric" },
		"PoliceStation": { "@id": "schema:PoliceStation" },
		"PoliticalParty": { "@id": "schema:PoliticalParty" },
		"Pond": { "@id": "schema:Pond" },
		"PositiveFilmDigitalSource": { "@id": "schema:PositiveFilmDigitalSource" },
		"PostOffice": { "@id": "schema:PostOffice" },
		"PostalAddress": { "@id": "schema:PostalAddress" },
		"PostalCodeRangeSpecification": { "@id": "schema:PostalCodeRangeSpecification" },
		"Poster": { "@id": "schema:Poster" },
		"PotentialActionStatus": { "@id": "schema:PotentialActionStatus" },
		"PreOrder": { "@id": "schema:PreOrder" },
		"PreOrderAction": { "@id": "schema:PreOrderAction" },
		"PreSale": { "@id": "schema:PreSale" },
		"PregnancyHealthAspect": { "@id": "schema:PregnancyHealthAspect" },
		"PrependAction": { "@id": "schema:PrependAction" },
		"Preschool": { "@id": "schema:Preschool" },
		"PrescriptionOnly": { "@id": "schema:PrescriptionOnly" },
		"PresentationDigitalDocument": { "@id": "schema:PresentationDigitalDocument" },
		"PreventionHealthAspect": { "@id": "schema:PreventionHealthAspect" },
		"PreventionIndication": { "@id": "schema:PreventionIndication" },
		"PriceComponentTypeEnumeration": { "@id": "schema:PriceComponentTypeEnumeration" },
		"PriceSpecification": { "@id": "schema:PriceSpecification" },
		"PriceTypeEnumeration": { "@id": "schema:PriceTypeEnumeration" },
		"PrimaryCare": { "@id": "schema:PrimaryCare" },
		"PrintDigitalSource": { "@id": "schema:PrintDigitalSource" },
		"Prion": { "@id": "schema:Prion" },
		"Product": { "@id": "schema:Product" },
		"ProductCollection": { "@id": "schema:ProductCollection" },
		"ProductGroup": { "@id": "schema:ProductGroup" },
		"ProductModel": { "@id": "schema:ProductModel" },
		"ProductReturnEnumeration": { "@id": "schema:ProductReturnEnumeration" },
		"ProductReturnFiniteReturnWindow": { "@id": "schema:ProductReturnFiniteReturnWindow" },
		"ProductReturnNotPermitted": { "@id": "schema:ProductReturnNotPermitted" },
		"ProductReturnPolicy": { "@id": "schema:ProductReturnPolicy" },
		"ProductReturnUnlimitedWindow": { "@id": "schema:ProductReturnUnlimitedWindow" },
		"ProductReturnUnspecified": { "@id": "schema:ProductReturnUnspecified" },
		"ProfessionalService": { "@id": "schema:ProfessionalService" },
		"ProfilePage": { "@id": "schema:ProfilePage" },
		"PrognosisHealthAspect": { "@id": "schema:PrognosisHealthAspect" },
		"ProgramMembership": { "@id": "schema:ProgramMembership" },
		"Project": { "@id": "schema:Project" },
		"PronounceableText": { "@id": "schema:PronounceableText" },
		"Property": { "@id": "schema:Property" },
		"PropertyValue": { "@id": "schema:PropertyValue" },
		"PropertyValueSpecification": { "@id": "schema:PropertyValueSpecification" },
		"Protein": { "@id": "schema:Protein" },
		"Protozoa": { "@id": "schema:Protozoa" },
		"Psychiatric": { "@id": "schema:Psychiatric" },
		"PsychologicalTreatment": { "@id": "schema:PsychologicalTreatment" },
		"PublicHealth": { "@id": "schema:PublicHealth" },
		"PublicHolidays": { "@id": "schema:PublicHolidays" },
		"PublicSwimmingPool": { "@id": "schema:PublicSwimmingPool" },
		"PublicToilet": { "@id": "schema:PublicToilet" },
		"PublicationEvent": { "@id": "schema:PublicationEvent" },
		"PublicationIssue": { "@id": "schema:PublicationIssue" },
		"PublicationVolume": { "@id": "schema:PublicationVolume" },
		"Pulmonary": { "@id": "schema:Pulmonary" },
		"QAPage": { "@id": "schema:QAPage" },
		"QualitativeValue": { "@id": "schema:QualitativeValue" },
		"QuantitativeValue": { "@id": "schema:QuantitativeValue" },
		"QuantitativeValueDistribution": { "@id": "schema:QuantitativeValueDistribution" },
		"Quantity": { "@id": "schema:Quantity" },
		"Question": { "@id": "schema:Question" },
		"Quiz": { "@id": "schema:Quiz" },
		"Quotation": { "@id": "schema:Quotation" },
		"QuoteAction": { "@id": "schema:QuoteAction" },
		"RVPark": { "@id": "schema:RVPark" },
		"RadiationTherapy": { "@id": "schema:RadiationTherapy" },
		"RadioBroadcastService": { "@id": "schema:RadioBroadcastService" },
		"RadioChannel": { "@id": "schema:RadioChannel" },
		"RadioClip": { "@id": "schema:RadioClip" },
		"RadioEpisode": { "@id": "schema:RadioEpisode" },
		"RadioSeason": { "@id": "schema:RadioSeason" },
		"RadioSeries": { "@id": "schema:RadioSeries" },
		"RadioStation": { "@id": "schema:RadioStation" },
		"Radiography": { "@id": "schema:Radiography" },
		"RandomizedTrial": { "@id": "schema:RandomizedTrial" },
		"Rating": { "@id": "schema:Rating" },
		"ReactAction": { "@id": "schema:ReactAction" },
		"ReadAction": { "@id": "schema:ReadAction" },
		"ReadPermission": { "@id": "schema:ReadPermission" },
		"RealEstateAgent": { "@id": "schema:RealEstateAgent" },
		"RealEstateListing": { "@id": "schema:RealEstateListing" },
		"RearWheelDriveConfiguration": { "@id": "schema:RearWheelDriveConfiguration" },
		"ReceiveAction": { "@id": "schema:ReceiveAction" },
		"Recipe": { "@id": "schema:Recipe" },
		"Recommendation": { "@id": "schema:Recommendation" },
		"RecommendedDoseSchedule": { "@id": "schema:RecommendedDoseSchedule" },
		"Recruiting": { "@id": "schema:Recruiting" },
		"RecyclingCenter": { "@id": "schema:RecyclingCenter" },
		"ReducedRelevanceForChildrenConsideration": { "@id": "schema:ReducedRelevanceForChildrenConsideration" },
		"RefundTypeEnumeration": { "@id": "schema:RefundTypeEnumeration" },
		"RefurbishedCondition": { "@id": "schema:RefurbishedCondition" },
		"RegisterAction": { "@id": "schema:RegisterAction" },
		"Registry": { "@id": "schema:Registry" },
		"RegularPrice": { "@id": "schema:RegularPrice" },
		"ReimbursementCap": { "@id": "schema:ReimbursementCap" },
		"RejectAction": { "@id": "schema:RejectAction" },
		"RelatedTopicsHealthAspect": { "@id": "schema:RelatedTopicsHealthAspect" },
		"RemixAlbum": { "@id": "schema:RemixAlbum" },
		"Renal": { "@id": "schema:Renal" },
		"RentAction": { "@id": "schema:RentAction" },
		"RentalCarReservation": { "@id": "schema:RentalCarReservation" },
		"RentalVehicleUsage": { "@id": "schema:RentalVehicleUsage" },
		"RepaymentSpecification": { "@id": "schema:RepaymentSpecification" },
		"ReplaceAction": { "@id": "schema:ReplaceAction" },
		"ReplyAction": { "@id": "schema:ReplyAction" },
		"Report": { "@id": "schema:Report" },
		"ReportageNewsArticle": { "@id": "schema:ReportageNewsArticle" },
		"ReportedDoseSchedule": { "@id": "schema:ReportedDoseSchedule" },
		"ResearchOrganization": { "@id": "schema:ResearchOrganization" },
		"ResearchProject": { "@id": "schema:ResearchProject" },
		"Researcher": { "@id": "schema:Researcher" },
		"Reservation": { "@id": "schema:Reservation" },
		"ReservationCancelled": { "@id": "schema:ReservationCancelled" },
		"ReservationConfirmed": { "@id": "schema:ReservationConfirmed" },
		"ReservationHold": { "@id": "schema:ReservationHold" },
		"ReservationPackage": { "@id": "schema:ReservationPackage" },
		"ReservationPending": { "@id": "schema:ReservationPending" },
		"ReservationStatusType": { "@id": "schema:ReservationStatusType" },
		"ReserveAction": { "@id": "schema:ReserveAction" },
		"Reserved": { "@id": "schema:Reserved" },
		"Reservoir": { "@id": "schema:Reservoir" },
		"Residence": { "@id": "schema:Residence" },
		"Resort": { "@id": "schema:Resort" },
		"RespiratoryTherapy": { "@id": "schema:RespiratoryTherapy" },
		"Restaurant": { "@id": "schema:Restaurant" },
		"RestockingFees": { "@id": "schema:RestockingFees" },
		"RestrictedDiet": { "@id": "schema:RestrictedDiet" },
		"ResultsAvailable": { "@id": "schema:ResultsAvailable" },
		"ResultsNotAvailable": { "@id": "schema:ResultsNotAvailable" },
		"ResumeAction": { "@id": "schema:ResumeAction" },
		"Retail": { "@id": "schema:Retail" },
		"ReturnAction": { "@id": "schema:ReturnAction" },
		"ReturnAtKiosk": { "@id": "schema:ReturnAtKiosk" },
		"ReturnByMail": { "@id": "schema:ReturnByMail" },
		"ReturnFeesCustomerResponsibility": { "@id": "schema:ReturnFeesCustomerResponsibility" },
		"ReturnFeesEnumeration": { "@id": "schema:ReturnFeesEnumeration" },
		"ReturnInStore": { "@id": "schema:ReturnInStore" },
		"ReturnLabelCustomerResponsibility": { "@id": "schema:ReturnLabelCustomerResponsibility" },
		"ReturnLabelDownloadAndPrint": { "@id": "schema:ReturnLabelDownloadAndPrint" },
		"ReturnLabelInBox": { "@id": "schema:ReturnLabelInBox" },
		"ReturnLabelSourceEnumeration": { "@id": "schema:ReturnLabelSourceEnumeration" },
		"ReturnMethodEnumeration": { "@id": "schema:ReturnMethodEnumeration" },
		"ReturnShippingFees": { "@id": "schema:ReturnShippingFees" },
		"Review": { "@id": "schema:Review" },
		"ReviewAction": { "@id": "schema:ReviewAction" },
		"ReviewNewsArticle": { "@id": "schema:ReviewNewsArticle" },
		"Rheumatologic": { "@id": "schema:Rheumatologic" },
		"RightHandDriving": { "@id": "schema:RightHandDriving" },
		"RisksOrComplicationsHealthAspect": { "@id": "schema:RisksOrComplicationsHealthAspect" },
		"RiverBodyOfWater": { "@id": "schema:RiverBodyOfWater" },
		"Role": { "@id": "schema:Role" },
		"RoofingContractor": { "@id": "schema:RoofingContractor" },
		"Room": { "@id": "schema:Room" },
		"RsvpAction": { "@id": "schema:RsvpAction" },
		"RsvpResponseMaybe": { "@id": "schema:RsvpResponseMaybe" },
		"RsvpResponseNo": { "@id": "schema:RsvpResponseNo" },
		"RsvpResponseType": { "@id": "schema:RsvpResponseType" },
		"RsvpResponseYes": { "@id": "schema:RsvpResponseYes" },
		"SRP": { "@id": "schema:SRP" },
		"SafetyHealthAspect": { "@id": "schema:SafetyHealthAspect" },
		"SaleEvent": { "@id": "schema:SaleEvent" },
		"SalePrice": { "@id": "schema:SalePrice" },
		"SatireOrParodyContent": { "@id": "schema:SatireOrParodyContent" },
		"SatiricalArticle": { "@id": "schema:SatiricalArticle" },
		"Saturday": { "@id": "schema:Saturday" },
		"Schedule": { "@id": "schema:Schedule" },
		"ScheduleAction": { "@id": "schema:ScheduleAction" },
		"ScholarlyArticle": { "@id": "schema:ScholarlyArticle" },
		"School": { "@id": "schema:School" },
		"SchoolDistrict": { "@id": "schema:SchoolDistrict" },
		"ScreeningEvent": { "@id": "schema:ScreeningEvent" },
		"ScreeningHealthAspect": { "@id": "schema:ScreeningHealthAspect" },
		"Sculpture": { "@id": "schema:Sculpture" },
		"SeaBodyOfWater": { "@id": "schema:SeaBodyOfWater" },
		"SearchAction": { "@id": "schema:SearchAction" },
		"SearchRescueOrganization": { "@id": "schema:SearchRescueOrganization" },
		"SearchResultsPage": { "@id": "schema:SearchResultsPage" },
		"Season": { "@id": "schema:Season" },
		"Seat": { "@id": "schema:Seat" },
		"SeatingMap": { "@id": "schema:SeatingMap" },
		"SeeDoctorHealthAspect": { "@id": "schema:SeeDoctorHealthAspect" },
		"SeekToAction": { "@id": "schema:SeekToAction" },
		"SelfCareHealthAspect": { "@id": "schema:SelfCareHealthAspect" },
		"SelfStorage": { "@id": "schema:SelfStorage" },
		"SellAction": { "@id": "schema:SellAction" },
		"SendAction": { "@id": "schema:SendAction" },
		"Series": { "@id": "schema:Series" },
		"Service": { "@id": "schema:Service" },
		"ServiceChannel": { "@id": "schema:ServiceChannel" },
		"SexualContentConsideration": { "@id": "schema:SexualContentConsideration" },
		"ShareAction": { "@id": "schema:ShareAction" },
		"SheetMusic": { "@id": "schema:SheetMusic" },
		"ShippingDeliveryTime": { "@id": "schema:ShippingDeliveryTime" },
		"ShippingRateSettings": { "@id": "schema:ShippingRateSettings" },
		"ShoeStore": { "@id": "schema:ShoeStore" },
		"ShoppingCenter": { "@id": "schema:ShoppingCenter" },
		"ShortStory": { "@id": "schema:ShortStory" },
		"SideEffectsHealthAspect": { "@id": "schema:SideEffectsHealthAspect" },
		"SingleBlindedTrial": { "@id": "schema:SingleBlindedTrial" },
		"SingleCenterTrial": { "@id": "schema:SingleCenterTrial" },
		"SingleFamilyResidence": { "@id": "schema:SingleFamilyResidence" },
		"SinglePlayer": { "@id": "schema:SinglePlayer" },
		"SingleRelease": { "@id": "schema:SingleRelease" },
		"SiteNavigationElement": { "@id": "schema:SiteNavigationElement" },
		"SizeGroupEnumeration": { "@id": "schema:SizeGroupEnumeration" },
		"SizeSpecification": { "@id": "schema:SizeSpecification" },
		"SizeSystemEnumeration": { "@id": "schema:SizeSystemEnumeration" },
		"SizeSystemImperial": { "@id": "schema:SizeSystemImperial" },
		"SizeSystemMetric": { "@id": "schema:SizeSystemMetric" },
		"SkiResort": { "@id": "schema:SkiResort" },
		"Skin": { "@id": "schema:Skin" },
		"SocialEvent": { "@id": "schema:SocialEvent" },
		"SocialMediaPosting": { "@id": "schema:SocialMediaPosting" },
		"SoftwareApplication": { "@id": "schema:SoftwareApplication" },
		"SoftwareSourceCode": { "@id": "schema:SoftwareSourceCode" },
		"SoldOut": { "@id": "schema:SoldOut" },
		"SolveMathAction": { "@id": "schema:SolveMathAction" },
		"SomeProducts": { "@id": "schema:SomeProducts" },
		"SoundtrackAlbum": { "@id": "schema:SoundtrackAlbum" },
		"SpeakableSpecification": { "@id": "schema:SpeakableSpecification" },
		"SpecialAnnouncement": { "@id": "schema:SpecialAnnouncement" },
		"Specialty": { "@id": "schema:Specialty" },
		"SpeechPathology": { "@id": "schema:SpeechPathology" },
		"SpokenWordAlbum": { "@id": "schema:SpokenWordAlbum" },
		"SportingGoodsStore": { "@id": "schema:SportingGoodsStore" },
		"SportsActivityLocation": { "@id": "schema:SportsActivityLocation" },
		"SportsClub": { "@id": "schema:SportsClub" },
		"SportsEvent": { "@id": "schema:SportsEvent" },
		"SportsOrganization": { "@id": "schema:SportsOrganization" },
		"SportsTeam": { "@id": "schema:SportsTeam" },
		"SpreadsheetDigitalDocument": { "@id": "schema:SpreadsheetDigitalDocument" },
		"StadiumOrArena": { "@id": "schema:StadiumOrArena" },
		"StagedContent": { "@id": "schema:StagedContent" },
		"StagesHealthAspect": { "@id": "schema:StagesHealthAspect" },
		"State": { "@id": "schema:State" },
		"Statement": { "@id": "schema:Statement" },
		"StatisticalPopulation": { "@id": "schema:StatisticalPopulation" },
		"StatisticalVariable": { "@id": "schema:StatisticalVariable" },
		"StatusEnumeration": { "@id": "schema:StatusEnumeration" },
		"SteeringPositionValue": { "@id": "schema:SteeringPositionValue" },
		"Store": { "@id": "schema:Store" },
		"StoreCreditRefund": { "@id": "schema:StoreCreditRefund" },
		"StrengthTraining": { "@id": "schema:StrengthTraining" },
		"StructuredValue": { "@id": "schema:StructuredValue" },
		"StudioAlbum": { "@id": "schema:StudioAlbum" },
		"StupidType": { "@id": "schema:StupidType" },
		"SubscribeAction": { "@id": "schema:SubscribeAction" },
		"Subscription": { "@id": "schema:Subscription" },
		"Substance": { "@id": "schema:Substance" },
		"SubwayStation": { "@id": "schema:SubwayStation" },
		"Suite": { "@id": "schema:Suite" },
		"Sunday": { "@id": "schema:Sunday" },
		"SuperficialAnatomy": { "@id": "schema:SuperficialAnatomy" },
		"Surgical": { "@id": "schema:Surgical" },
		"SurgicalProcedure": { "@id": "schema:SurgicalProcedure" },
		"SuspendAction": { "@id": "schema:SuspendAction" },
		"Suspended": { "@id": "schema:Suspended" },
		"Syllabus": { "@id": "schema:Syllabus" },
		"SymptomsHealthAspect": { "@id": "schema:SymptomsHealthAspect" },
		"Synagogue": { "@id": "schema:Synagogue" },
		"TVClip": { "@id": "schema:TVClip" },
		"TVEpisode": { "@id": "schema:TVEpisode" },
		"TVSeason": { "@id": "schema:TVSeason" },
		"TVSeries": { "@id": "schema:TVSeries" },
		"Table": { "@id": "schema:Table" },
		"TakeAction": { "@id": "schema:TakeAction" },
		"TattooParlor": { "@id": "schema:TattooParlor" },
		"Taxi": { "@id": "schema:Taxi" },
		"TaxiReservation": { "@id": "schema:TaxiReservation" },
		"TaxiService": { "@id": "schema:TaxiService" },
		"TaxiStand": { "@id": "schema:TaxiStand" },
		"TaxiVehicleUsage": { "@id": "schema:TaxiVehicleUsage" },
		"Taxon": { "@id": "schema:Taxon" },
		"TechArticle": { "@id": "schema:TechArticle" },
		"TelevisionChannel": { "@id": "schema:TelevisionChannel" },
		"TelevisionStation": { "@id": "schema:TelevisionStation" },
		"TennisComplex": { "@id": "schema:TennisComplex" },
		"Terminated": { "@id": "schema:Terminated" },
		"Text": { "@id": "schema:Text" },
		"TextDigitalDocument": { "@id": "schema:TextDigitalDocument" },
		"TextObject": { "@id": "schema:TextObject" },
		"TheaterEvent": { "@id": "schema:TheaterEvent" },
		"TheaterGroup": { "@id": "schema:TheaterGroup" },
		"Therapeutic": { "@id": "schema:Therapeutic" },
		"TherapeuticProcedure": { "@id": "schema:TherapeuticProcedure" },
		"Thesis": { "@id": "schema:Thesis" },
		"Thing": { "@id": "schema:Thing" },
		"Throat": { "@id": "schema:Throat" },
		"Thursday": { "@id": "schema:Thursday" },
		"Ticket": { "@id": "schema:Ticket" },
		"TieAction": { "@id": "schema:TieAction" },
		"TierBenefitEnumeration": { "@id": "schema:TierBenefitEnumeration" },
		"TierBenefitLoyaltyPoints": { "@id": "schema:TierBenefitLoyaltyPoints" },
		"TierBenefitLoyaltyPrice": { "@id": "schema:TierBenefitLoyaltyPrice" },
		"TierBenefitLoyaltyReturns": { "@id": "schema:TierBenefitLoyaltyReturns" },
		"TierBenefitLoyaltyShipping": { "@id": "schema:TierBenefitLoyaltyShipping" },
		"Time": { "@id": "schema:Time" },
		"TipAction": { "@id": "schema:TipAction" },
		"TireShop": { "@id": "schema:TireShop" },
		"TobaccoNicotineConsideration": { "@id": "schema:TobaccoNicotineConsideration" },
		"TollFree": { "@id": "schema:TollFree" },
		"TouristAttraction": { "@id": "schema:TouristAttraction" },
		"TouristDestination": { "@id": "schema:TouristDestination" },
		"TouristInformationCenter": { "@id": "schema:TouristInformationCenter" },
		"TouristTrip": { "@id": "schema:TouristTrip" },
		"Toxicologic": { "@id": "schema:Toxicologic" },
		"ToyStore": { "@id": "schema:ToyStore" },
		"TrackAction": { "@id": "schema:TrackAction" },
		"TradeAction": { "@id": "schema:TradeAction" },
		"TraditionalChinese": { "@id": "schema:TraditionalChinese" },
		"TrainReservation": { "@id": "schema:TrainReservation" },
		"TrainStation": { "@id": "schema:TrainStation" },
		"TrainTrip": { "@id": "schema:TrainTrip" },
		"TrainedAlgorithmicMediaDigitalSource": { "@id": "schema:TrainedAlgorithmicMediaDigitalSource" },
		"TransferAction": { "@id": "schema:TransferAction" },
		"TransformedContent": { "@id": "schema:TransformedContent" },
		"TransitMap": { "@id": "schema:TransitMap" },
		"TravelAction": { "@id": "schema:TravelAction" },
		"TravelAgency": { "@id": "schema:TravelAgency" },
		"TreatmentIndication": { "@id": "schema:TreatmentIndication" },
		"TreatmentsHealthAspect": { "@id": "schema:TreatmentsHealthAspect" },
		"Trip": { "@id": "schema:Trip" },
		"TripleBlindedTrial": { "@id": "schema:TripleBlindedTrial" },
		"True": { "@id": "schema:True" },
		"Tuesday": { "@id": "schema:Tuesday" },
		"TypeAndQuantityNode": { "@id": "schema:TypeAndQuantityNode" },
		"TypesHealthAspect": { "@id": "schema:TypesHealthAspect" },
		"UKNonprofitType": { "@id": "schema:UKNonprofitType" },
		"UKTrust": { "@id": "schema:UKTrust" },
		"URL": { "@id": "schema:URL" },
		"USNonprofitType": { "@id": "schema:USNonprofitType" },
		"Ultrasound": { "@id": "schema:Ultrasound" },
		"UnRegisterAction": { "@id": "schema:UnRegisterAction" },
		"UnclassifiedAdultConsideration": { "@id": "schema:UnclassifiedAdultConsideration" },
		"UnemploymentSupport": { "@id": "schema:UnemploymentSupport" },
		"UnincorporatedAssociationCharity": { "@id": "schema:UnincorporatedAssociationCharity" },
		"UnitPriceSpecification": { "@id": "schema:UnitPriceSpecification" },
		"UnofficialLegalValue": { "@id": "schema:UnofficialLegalValue" },
		"UpdateAction": { "@id": "schema:UpdateAction" },
		"Urologic": { "@id": "schema:Urologic" },
		"UsageOrScheduleHealthAspect": { "@id": "schema:UsageOrScheduleHealthAspect" },
		"UseAction": { "@id": "schema:UseAction" },
		"UsedCondition": { "@id": "schema:UsedCondition" },
		"UserBlocks": { "@id": "schema:UserBlocks" },
		"UserCheckins": { "@id": "schema:UserCheckins" },
		"UserComments": { "@id": "schema:UserComments" },
		"UserDownloads": { "@id": "schema:UserDownloads" },
		"UserInteraction": { "@id": "schema:UserInteraction" },
		"UserLikes": { "@id": "schema:UserLikes" },
		"UserPageVisits": { "@id": "schema:UserPageVisits" },
		"UserPlays": { "@id": "schema:UserPlays" },
		"UserPlusOnes": { "@id": "schema:UserPlusOnes" },
		"UserReview": { "@id": "schema:UserReview" },
		"UserTweets": { "@id": "schema:UserTweets" },
		"VacationRental": { "@id": "schema:VacationRental" },
		"VeganDiet": { "@id": "schema:VeganDiet" },
		"VegetarianDiet": { "@id": "schema:VegetarianDiet" },
		"Vehicle": { "@id": "schema:Vehicle" },
		"Vein": { "@id": "schema:Vein" },
		"VenueMap": { "@id": "schema:VenueMap" },
		"Vessel": { "@id": "schema:Vessel" },
		"VeterinaryCare": { "@id": "schema:VeterinaryCare" },
		"VideoGallery": { "@id": "schema:VideoGallery" },
		"VideoGame": { "@id": "schema:VideoGame" },
		"VideoGameClip": { "@id": "schema:VideoGameClip" },
		"VideoGameSeries": { "@id": "schema:VideoGameSeries" },
		"VideoObject": { "@id": "schema:VideoObject" },
		"VideoObjectSnapshot": { "@id": "schema:VideoObjectSnapshot" },
		"ViewAction": { "@id": "schema:ViewAction" },
		"VinylFormat": { "@id": "schema:VinylFormat" },
		"ViolenceConsideration": { "@id": "schema:ViolenceConsideration" },
		"VirtualLocation": { "@id": "schema:VirtualLocation" },
		"VirtualRecordingDigitalSource": { "@id": "schema:VirtualRecordingDigitalSource" },
		"Virus": { "@id": "schema:Virus" },
		"VisualArtsEvent": { "@id": "schema:VisualArtsEvent" },
		"VisualArtwork": { "@id": "schema:VisualArtwork" },
		"VitalSign": { "@id": "schema:VitalSign" },
		"Volcano": { "@id": "schema:Volcano" },
		"VoteAction": { "@id": "schema:VoteAction" },
		"WPAdBlock": { "@id": "schema:WPAdBlock" },
		"WPFooter": { "@id": "schema:WPFooter" },
		"WPHeader": { "@id": "schema:WPHeader" },
		"WPSideBar": { "@id": "schema:WPSideBar" },
		"WantAction": { "@id": "schema:WantAction" },
		"WarrantyPromise": { "@id": "schema:WarrantyPromise" },
		"WarrantyScope": { "@id": "schema:WarrantyScope" },
		"WatchAction": { "@id": "schema:WatchAction" },
		"Waterfall": { "@id": "schema:Waterfall" },
		"WeaponConsideration": { "@id": "schema:WeaponConsideration" },
		"WearAction": { "@id": "schema:WearAction" },
		"WearableMeasurementBack": { "@id": "schema:WearableMeasurementBack" },
		"WearableMeasurementChestOrBust": { "@id": "schema:WearableMeasurementChestOrBust" },
		"WearableMeasurementCollar": { "@id": "schema:WearableMeasurementCollar" },
		"WearableMeasurementCup": { "@id": "schema:WearableMeasurementCup" },
		"WearableMeasurementHeight": { "@id": "schema:WearableMeasurementHeight" },
		"WearableMeasurementHips": { "@id": "schema:WearableMeasurementHips" },
		"WearableMeasurementInseam": { "@id": "schema:WearableMeasurementInseam" },
		"WearableMeasurementLength": { "@id": "schema:WearableMeasurementLength" },
		"WearableMeasurementOutsideLeg": { "@id": "schema:WearableMeasurementOutsideLeg" },
		"WearableMeasurementSleeve": { "@id": "schema:WearableMeasurementSleeve" },
		"WearableMeasurementTypeEnumeration": { "@id": "schema:WearableMeasurementTypeEnumeration" },
		"WearableMeasurementWaist": { "@id": "schema:WearableMeasurementWaist" },
		"WearableMeasurementWidth": { "@id": "schema:WearableMeasurementWidth" },
		"WearableSizeGroupBig": { "@id": "schema:WearableSizeGroupBig" },
		"WearableSizeGroupBoys": { "@id": "schema:WearableSizeGroupBoys" },
		"WearableSizeGroupEnumeration": { "@id": "schema:WearableSizeGroupEnumeration" },
		"WearableSizeGroupExtraShort": { "@id": "schema:WearableSizeGroupExtraShort" },
		"WearableSizeGroupExtraTall": { "@id": "schema:WearableSizeGroupExtraTall" },
		"WearableSizeGroupGirls": { "@id": "schema:WearableSizeGroupGirls" },
		"WearableSizeGroupHusky": { "@id": "schema:WearableSizeGroupHusky" },
		"WearableSizeGroupInfants": { "@id": "schema:WearableSizeGroupInfants" },
		"WearableSizeGroupJuniors": { "@id": "schema:WearableSizeGroupJuniors" },
		"WearableSizeGroupMaternity": { "@id": "schema:WearableSizeGroupMaternity" },
		"WearableSizeGroupMens": { "@id": "schema:WearableSizeGroupMens" },
		"WearableSizeGroupMisses": { "@id": "schema:WearableSizeGroupMisses" },
		"WearableSizeGroupPetite": { "@id": "schema:WearableSizeGroupPetite" },
		"WearableSizeGroupPlus": { "@id": "schema:WearableSizeGroupPlus" },
		"WearableSizeGroupRegular": { "@id": "schema:WearableSizeGroupRegular" },
		"WearableSizeGroupShort": { "@id": "schema:WearableSizeGroupShort" },
		"WearableSizeGroupTall": { "@id": "schema:WearableSizeGroupTall" },
		"WearableSizeGroupWomens": { "@id": "schema:WearableSizeGroupWomens" },
		"WearableSizeSystemAU": { "@id": "schema:WearableSizeSystemAU" },
		"WearableSizeSystemBR": { "@id": "schema:WearableSizeSystemBR" },
		"WearableSizeSystemCN": { "@id": "schema:WearableSizeSystemCN" },
		"WearableSizeSystemContinental": { "@id": "schema:WearableSizeSystemContinental" },
		"WearableSizeSystemDE": { "@id": "schema:WearableSizeSystemDE" },
		"WearableSizeSystemEN13402": { "@id": "schema:WearableSizeSystemEN13402" },
		"WearableSizeSystemEnumeration": { "@id": "schema:WearableSizeSystemEnumeration" },
		"WearableSizeSystemEurope": { "@id": "schema:WearableSizeSystemEurope" },
		"WearableSizeSystemFR": { "@id": "schema:WearableSizeSystemFR" },
		"WearableSizeSystemGS1": { "@id": "schema:WearableSizeSystemGS1" },
		"WearableSizeSystemIT": { "@id": "schema:WearableSizeSystemIT" },
		"WearableSizeSystemJP": { "@id": "schema:WearableSizeSystemJP" },
		"WearableSizeSystemMX": { "@id": "schema:WearableSizeSystemMX" },
		"WearableSizeSystemUK": { "@id": "schema:WearableSizeSystemUK" },
		"WearableSizeSystemUS": { "@id": "schema:WearableSizeSystemUS" },
		"WebAPI": { "@id": "schema:WebAPI" },
		"WebApplication": { "@id": "schema:WebApplication" },
		"WebContent": { "@id": "schema:WebContent" },
		"WebPage": { "@id": "schema:WebPage" },
		"WebPageElement": { "@id": "schema:WebPageElement" },
		"WebSite": { "@id": "schema:WebSite" },
		"Wednesday": { "@id": "schema:Wednesday" },
		"WesternConventional": { "@id": "schema:WesternConventional" },
		"Wholesale": { "@id": "schema:Wholesale" },
		"WholesaleStore": { "@id": "schema:WholesaleStore" },
		"WinAction": { "@id": "schema:WinAction" },
		"Winery": { "@id": "schema:Winery" },
		"Withdrawn": { "@id": "schema:Withdrawn" },
		"WorkBasedProgram": { "@id": "schema:WorkBasedProgram" },
		"WorkersUnion": { "@id": "schema:WorkersUnion" },
		"WriteAction": { "@id": "schema:WriteAction" },
		"WritePermission": { "@id": "schema:WritePermission" },
		"XPathType": { "@id": "schema:XPathType" },
		"XRay": { "@id": "schema:XRay" },
		"ZoneBoardingPolicy": { "@id": "schema:ZoneBoardingPolicy" },
		"Zoo": { "@id": "schema:Zoo" },
		"about": { "@id": "schema:about" },
		"abridged": { "@id": "schema:abridged" },
		"abstract": { "@id": "schema:abstract" },
		"accelerationTime": { "@id": "schema:accelerationTime" },
		"acceptedAnswer": { "@id": "schema:acceptedAnswer" },
		"acceptedOffer": { "@id": "schema:acceptedOffer" },
		"acceptedPaymentMethod": { "@id": "schema:acceptedPaymentMethod" },
		"acceptsReservations": { "@id": "schema:acceptsReservations" },
		"accessCode": { "@id": "schema:accessCode" },
		"accessMode": { "@id": "schema:accessMode" },
		"accessModeSufficient": { "@id": "schema:accessModeSufficient" },
		"accessibilityAPI": { "@id": "schema:accessibilityAPI" },
		"accessibilityControl": { "@id": "schema:accessibilityControl" },
		"accessibilityFeature": { "@id": "schema:accessibilityFeature" },
		"accessibilityHazard": { "@id": "schema:accessibilityHazard" },
		"accessibilitySummary": { "@id": "schema:accessibilitySummary" },
		"accommodationCategory": { "@id": "schema:accommodationCategory" },
		"accommodationFloorPlan": { "@id": "schema:accommodationFloorPlan" },
		"accountId": { "@id": "schema:accountId" },
		"accountMinimumInflow": { "@id": "schema:accountMinimumInflow" },
		"accountOverdraftLimit": { "@id": "schema:accountOverdraftLimit" },
		"accountablePerson": { "@id": "schema:accountablePerson" },
		"acquireLicensePage": {
			"@id": "schema:acquireLicensePage",
			"@type": "@id"
		},
		"acquiredFrom": { "@id": "schema:acquiredFrom" },
		"acrissCode": { "@id": "schema:acrissCode" },
		"actionAccessibilityRequirement": { "@id": "schema:actionAccessibilityRequirement" },
		"actionApplication": { "@id": "schema:actionApplication" },
		"actionOption": { "@id": "schema:actionOption" },
		"actionPlatform": { "@id": "schema:actionPlatform" },
		"actionStatus": { "@id": "schema:actionStatus" },
		"actionableFeedbackPolicy": {
			"@id": "schema:actionableFeedbackPolicy",
			"@type": "@id"
		},
		"activeIngredient": { "@id": "schema:activeIngredient" },
		"activityDuration": { "@id": "schema:activityDuration" },
		"activityFrequency": { "@id": "schema:activityFrequency" },
		"actor": { "@id": "schema:actor" },
		"actors": { "@id": "schema:actors" },
		"addOn": { "@id": "schema:addOn" },
		"additionalName": { "@id": "schema:additionalName" },
		"additionalNumberOfGuests": { "@id": "schema:additionalNumberOfGuests" },
		"additionalProperty": { "@id": "schema:additionalProperty" },
		"additionalType": { "@id": "schema:additionalType" },
		"additionalVariable": { "@id": "schema:additionalVariable" },
		"address": { "@id": "schema:address" },
		"addressCountry": { "@id": "schema:addressCountry" },
		"addressLocality": { "@id": "schema:addressLocality" },
		"addressRegion": { "@id": "schema:addressRegion" },
		"administrationRoute": { "@id": "schema:administrationRoute" },
		"advanceBookingRequirement": { "@id": "schema:advanceBookingRequirement" },
		"adverseOutcome": { "@id": "schema:adverseOutcome" },
		"affectedBy": { "@id": "schema:affectedBy" },
		"affiliation": { "@id": "schema:affiliation" },
		"afterMedia": {
			"@id": "schema:afterMedia",
			"@type": "@id"
		},
		"agent": { "@id": "schema:agent" },
		"agentInteractionStatistic": { "@id": "schema:agentInteractionStatistic" },
		"aggregateRating": { "@id": "schema:aggregateRating" },
		"aircraft": { "@id": "schema:aircraft" },
		"album": { "@id": "schema:album" },
		"albumProductionType": { "@id": "schema:albumProductionType" },
		"albumRelease": { "@id": "schema:albumRelease" },
		"albumReleaseType": { "@id": "schema:albumReleaseType" },
		"albums": { "@id": "schema:albums" },
		"alcoholWarning": { "@id": "schema:alcoholWarning" },
		"algorithm": { "@id": "schema:algorithm" },
		"alignmentType": { "@id": "schema:alignmentType" },
		"alternateName": { "@id": "schema:alternateName" },
		"alternativeHeadline": { "@id": "schema:alternativeHeadline" },
		"alternativeOf": { "@id": "schema:alternativeOf" },
		"alumni": { "@id": "schema:alumni" },
		"alumniOf": { "@id": "schema:alumniOf" },
		"amenityFeature": { "@id": "schema:amenityFeature" },
		"amount": { "@id": "schema:amount" },
		"amountOfThisGood": { "@id": "schema:amountOfThisGood" },
		"announcementLocation": { "@id": "schema:announcementLocation" },
		"annualPercentageRate": { "@id": "schema:annualPercentageRate" },
		"answerCount": { "@id": "schema:answerCount" },
		"answerExplanation": { "@id": "schema:answerExplanation" },
		"antagonist": { "@id": "schema:antagonist" },
		"appearance": { "@id": "schema:appearance" },
		"applicableCountry": { "@id": "schema:applicableCountry" },
		"applicableLocation": { "@id": "schema:applicableLocation" },
		"applicantLocationRequirements": { "@id": "schema:applicantLocationRequirements" },
		"application": { "@id": "schema:application" },
		"applicationCategory": { "@id": "schema:applicationCategory" },
		"applicationContact": { "@id": "schema:applicationContact" },
		"applicationDeadline": {
			"@id": "schema:applicationDeadline",
			"@type": "Date"
		},
		"applicationStartDate": {
			"@id": "schema:applicationStartDate",
			"@type": "Date"
		},
		"applicationSubCategory": { "@id": "schema:applicationSubCategory" },
		"applicationSuite": { "@id": "schema:applicationSuite" },
		"appliesToDeliveryMethod": { "@id": "schema:appliesToDeliveryMethod" },
		"appliesToPaymentMethod": { "@id": "schema:appliesToPaymentMethod" },
		"archiveHeld": { "@id": "schema:archiveHeld" },
		"archivedAt": {
			"@id": "schema:archivedAt",
			"@type": "@id"
		},
		"area": { "@id": "schema:area" },
		"areaServed": { "@id": "schema:areaServed" },
		"arrivalAirport": { "@id": "schema:arrivalAirport" },
		"arrivalBoatTerminal": { "@id": "schema:arrivalBoatTerminal" },
		"arrivalBusStop": { "@id": "schema:arrivalBusStop" },
		"arrivalGate": { "@id": "schema:arrivalGate" },
		"arrivalPlatform": { "@id": "schema:arrivalPlatform" },
		"arrivalStation": { "@id": "schema:arrivalStation" },
		"arrivalTerminal": { "@id": "schema:arrivalTerminal" },
		"arrivalTime": { "@id": "schema:arrivalTime" },
		"artEdition": { "@id": "schema:artEdition" },
		"artMedium": { "@id": "schema:artMedium" },
		"arterialBranch": { "@id": "schema:arterialBranch" },
		"artform": { "@id": "schema:artform" },
		"articleBody": { "@id": "schema:articleBody" },
		"articleSection": { "@id": "schema:articleSection" },
		"artist": { "@id": "schema:artist" },
		"artworkSurface": { "@id": "schema:artworkSurface" },
		"asin": { "@id": "schema:asin" },
		"aspect": { "@id": "schema:aspect" },
		"assembly": { "@id": "schema:assembly" },
		"assemblyVersion": { "@id": "schema:assemblyVersion" },
		"assesses": { "@id": "schema:assesses" },
		"associatedAnatomy": { "@id": "schema:associatedAnatomy" },
		"associatedArticle": { "@id": "schema:associatedArticle" },
		"associatedClaimReview": { "@id": "schema:associatedClaimReview" },
		"associatedDisease": {
			"@id": "schema:associatedDisease",
			"@type": "@id"
		},
		"associatedMedia": { "@id": "schema:associatedMedia" },
		"associatedMediaReview": { "@id": "schema:associatedMediaReview" },
		"associatedPathophysiology": { "@id": "schema:associatedPathophysiology" },
		"associatedReview": { "@id": "schema:associatedReview" },
		"athlete": { "@id": "schema:athlete" },
		"attendee": { "@id": "schema:attendee" },
		"attendees": { "@id": "schema:attendees" },
		"audience": { "@id": "schema:audience" },
		"audienceType": { "@id": "schema:audienceType" },
		"audio": { "@id": "schema:audio" },
		"auditDate": {
			"@id": "schema:auditDate",
			"@type": "Date"
		},
		"authenticator": { "@id": "schema:authenticator" },
		"author": { "@id": "schema:author" },
		"availability": { "@id": "schema:availability" },
		"availabilityEnds": {
			"@id": "schema:availabilityEnds",
			"@type": "Date"
		},
		"availabilityStarts": {
			"@id": "schema:availabilityStarts",
			"@type": "Date"
		},
		"availableAtOrFrom": { "@id": "schema:availableAtOrFrom" },
		"availableChannel": { "@id": "schema:availableChannel" },
		"availableDeliveryMethod": { "@id": "schema:availableDeliveryMethod" },
		"availableFrom": { "@id": "schema:availableFrom" },
		"availableIn": { "@id": "schema:availableIn" },
		"availableLanguage": { "@id": "schema:availableLanguage" },
		"availableOnDevice": { "@id": "schema:availableOnDevice" },
		"availableService": { "@id": "schema:availableService" },
		"availableStrength": { "@id": "schema:availableStrength" },
		"availableTest": { "@id": "schema:availableTest" },
		"availableThrough": { "@id": "schema:availableThrough" },
		"award": { "@id": "schema:award" },
		"awards": { "@id": "schema:awards" },
		"awayTeam": { "@id": "schema:awayTeam" },
		"backstory": { "@id": "schema:backstory" },
		"bankAccountType": { "@id": "schema:bankAccountType" },
		"baseSalary": { "@id": "schema:baseSalary" },
		"bccRecipient": { "@id": "schema:bccRecipient" },
		"bed": { "@id": "schema:bed" },
		"beforeMedia": {
			"@id": "schema:beforeMedia",
			"@type": "@id"
		},
		"beneficiaryBank": { "@id": "schema:beneficiaryBank" },
		"benefits": { "@id": "schema:benefits" },
		"benefitsSummaryUrl": {
			"@id": "schema:benefitsSummaryUrl",
			"@type": "@id"
		},
		"bestRating": { "@id": "schema:bestRating" },
		"billingAddress": { "@id": "schema:billingAddress" },
		"billingDuration": { "@id": "schema:billingDuration" },
		"billingIncrement": { "@id": "schema:billingIncrement" },
		"billingPeriod": { "@id": "schema:billingPeriod" },
		"billingStart": { "@id": "schema:billingStart" },
		"bioChemInteraction": { "@id": "schema:bioChemInteraction" },
		"bioChemSimilarity": { "@id": "schema:bioChemSimilarity" },
		"biologicalRole": { "@id": "schema:biologicalRole" },
		"biomechnicalClass": { "@id": "schema:biomechnicalClass" },
		"birthDate": {
			"@id": "schema:birthDate",
			"@type": "Date"
		},
		"birthPlace": { "@id": "schema:birthPlace" },
		"bitrate": { "@id": "schema:bitrate" },
		"blogPost": { "@id": "schema:blogPost" },
		"blogPosts": { "@id": "schema:blogPosts" },
		"bloodSupply": { "@id": "schema:bloodSupply" },
		"boardingGroup": { "@id": "schema:boardingGroup" },
		"boardingPolicy": { "@id": "schema:boardingPolicy" },
		"bodyLocation": { "@id": "schema:bodyLocation" },
		"bodyType": { "@id": "schema:bodyType" },
		"bookEdition": { "@id": "schema:bookEdition" },
		"bookFormat": { "@id": "schema:bookFormat" },
		"bookingAgent": { "@id": "schema:bookingAgent" },
		"bookingTime": { "@id": "schema:bookingTime" },
		"borrower": { "@id": "schema:borrower" },
		"box": { "@id": "schema:box" },
		"branch": { "@id": "schema:branch" },
		"branchCode": { "@id": "schema:branchCode" },
		"branchOf": { "@id": "schema:branchOf" },
		"brand": { "@id": "schema:brand" },
		"breadcrumb": { "@id": "schema:breadcrumb" },
		"breastfeedingWarning": { "@id": "schema:breastfeedingWarning" },
		"broadcastAffiliateOf": { "@id": "schema:broadcastAffiliateOf" },
		"broadcastChannelId": { "@id": "schema:broadcastChannelId" },
		"broadcastDisplayName": { "@id": "schema:broadcastDisplayName" },
		"broadcastFrequency": { "@id": "schema:broadcastFrequency" },
		"broadcastFrequencyValue": { "@id": "schema:broadcastFrequencyValue" },
		"broadcastOfEvent": { "@id": "schema:broadcastOfEvent" },
		"broadcastServiceTier": { "@id": "schema:broadcastServiceTier" },
		"broadcastSignalModulation": { "@id": "schema:broadcastSignalModulation" },
		"broadcastSubChannel": { "@id": "schema:broadcastSubChannel" },
		"broadcastTimezone": { "@id": "schema:broadcastTimezone" },
		"broadcaster": { "@id": "schema:broadcaster" },
		"broker": { "@id": "schema:broker" },
		"browserRequirements": { "@id": "schema:browserRequirements" },
		"busName": { "@id": "schema:busName" },
		"busNumber": { "@id": "schema:busNumber" },
		"businessDays": { "@id": "schema:businessDays" },
		"businessFunction": { "@id": "schema:businessFunction" },
		"buyer": { "@id": "schema:buyer" },
		"byArtist": { "@id": "schema:byArtist" },
		"byDay": { "@id": "schema:byDay" },
		"byMonth": { "@id": "schema:byMonth" },
		"byMonthDay": { "@id": "schema:byMonthDay" },
		"byMonthWeek": { "@id": "schema:byMonthWeek" },
		"callSign": { "@id": "schema:callSign" },
		"calories": { "@id": "schema:calories" },
		"candidate": { "@id": "schema:candidate" },
		"caption": { "@id": "schema:caption" },
		"carbohydrateContent": { "@id": "schema:carbohydrateContent" },
		"cargoVolume": { "@id": "schema:cargoVolume" },
		"carrier": { "@id": "schema:carrier" },
		"carrierRequirements": { "@id": "schema:carrierRequirements" },
		"cashBack": { "@id": "schema:cashBack" },
		"catalog": { "@id": "schema:catalog" },
		"catalogNumber": { "@id": "schema:catalogNumber" },
		"category": { "@id": "schema:category" },
		"causeOf": { "@id": "schema:causeOf" },
		"ccRecipient": { "@id": "schema:ccRecipient" },
		"certificationIdentification": { "@id": "schema:certificationIdentification" },
		"certificationRating": { "@id": "schema:certificationRating" },
		"certificationStatus": { "@id": "schema:certificationStatus" },
		"character": { "@id": "schema:character" },
		"characterAttribute": { "@id": "schema:characterAttribute" },
		"characterName": { "@id": "schema:characterName" },
		"cheatCode": { "@id": "schema:cheatCode" },
		"checkinTime": { "@id": "schema:checkinTime" },
		"checkoutPageURLTemplate": { "@id": "schema:checkoutPageURLTemplate" },
		"checkoutTime": { "@id": "schema:checkoutTime" },
		"chemicalComposition": { "@id": "schema:chemicalComposition" },
		"chemicalRole": { "@id": "schema:chemicalRole" },
		"childMaxAge": { "@id": "schema:childMaxAge" },
		"childMinAge": { "@id": "schema:childMinAge" },
		"childTaxon": { "@id": "schema:childTaxon" },
		"children": { "@id": "schema:children" },
		"cholesterolContent": { "@id": "schema:cholesterolContent" },
		"circle": { "@id": "schema:circle" },
		"citation": { "@id": "schema:citation" },
		"claimInterpreter": { "@id": "schema:claimInterpreter" },
		"claimReviewed": { "@id": "schema:claimReviewed" },
		"clincalPharmacology": { "@id": "schema:clincalPharmacology" },
		"clinicalPharmacology": { "@id": "schema:clinicalPharmacology" },
		"clipNumber": { "@id": "schema:clipNumber" },
		"closes": { "@id": "schema:closes" },
		"coach": { "@id": "schema:coach" },
		"code": { "@id": "schema:code" },
		"codeRepository": {
			"@id": "schema:codeRepository",
			"@type": "@id"
		},
		"codeSampleType": { "@id": "schema:codeSampleType" },
		"codeValue": { "@id": "schema:codeValue" },
		"codingSystem": { "@id": "schema:codingSystem" },
		"colleague": {
			"@id": "schema:colleague",
			"@type": "@id"
		},
		"colleagues": { "@id": "schema:colleagues" },
		"collection": { "@id": "schema:collection" },
		"collectionSize": { "@id": "schema:collectionSize" },
		"color": { "@id": "schema:color" },
		"colorSwatch": {
			"@id": "schema:colorSwatch",
			"@type": "@id"
		},
		"colorist": { "@id": "schema:colorist" },
		"comment": { "@id": "schema:comment" },
		"commentCount": { "@id": "schema:commentCount" },
		"commentText": { "@id": "schema:commentText" },
		"commentTime": {
			"@id": "schema:commentTime",
			"@type": "Date"
		},
		"competencyRequired": { "@id": "schema:competencyRequired" },
		"competitor": { "@id": "schema:competitor" },
		"composer": { "@id": "schema:composer" },
		"comprisedOf": { "@id": "schema:comprisedOf" },
		"conditionsOfAccess": { "@id": "schema:conditionsOfAccess" },
		"confirmationNumber": { "@id": "schema:confirmationNumber" },
		"connectedTo": { "@id": "schema:connectedTo" },
		"constraintProperty": {
			"@id": "schema:constraintProperty",
			"@type": "@id"
		},
		"contactOption": { "@id": "schema:contactOption" },
		"contactPoint": { "@id": "schema:contactPoint" },
		"contactPoints": { "@id": "schema:contactPoints" },
		"contactType": { "@id": "schema:contactType" },
		"contactlessPayment": { "@id": "schema:contactlessPayment" },
		"containedIn": { "@id": "schema:containedIn" },
		"containedInPlace": { "@id": "schema:containedInPlace" },
		"containsPlace": { "@id": "schema:containsPlace" },
		"containsSeason": { "@id": "schema:containsSeason" },
		"contentLocation": { "@id": "schema:contentLocation" },
		"contentRating": { "@id": "schema:contentRating" },
		"contentReferenceTime": { "@id": "schema:contentReferenceTime" },
		"contentSize": { "@id": "schema:contentSize" },
		"contentType": { "@id": "schema:contentType" },
		"contentUrl": {
			"@id": "schema:contentUrl",
			"@type": "@id"
		},
		"contraindication": { "@id": "schema:contraindication" },
		"contributor": { "@id": "schema:contributor" },
		"cookTime": { "@id": "schema:cookTime" },
		"cookingMethod": { "@id": "schema:cookingMethod" },
		"copyrightHolder": { "@id": "schema:copyrightHolder" },
		"copyrightNotice": { "@id": "schema:copyrightNotice" },
		"copyrightYear": { "@id": "schema:copyrightYear" },
		"correction": { "@id": "schema:correction" },
		"correctionsPolicy": {
			"@id": "schema:correctionsPolicy",
			"@type": "@id"
		},
		"costCategory": { "@id": "schema:costCategory" },
		"costCurrency": { "@id": "schema:costCurrency" },
		"costOrigin": { "@id": "schema:costOrigin" },
		"costPerUnit": { "@id": "schema:costPerUnit" },
		"countriesNotSupported": { "@id": "schema:countriesNotSupported" },
		"countriesSupported": { "@id": "schema:countriesSupported" },
		"countryOfAssembly": { "@id": "schema:countryOfAssembly" },
		"countryOfLastProcessing": { "@id": "schema:countryOfLastProcessing" },
		"countryOfOrigin": { "@id": "schema:countryOfOrigin" },
		"course": { "@id": "schema:course" },
		"courseCode": { "@id": "schema:courseCode" },
		"courseMode": { "@id": "schema:courseMode" },
		"coursePrerequisites": { "@id": "schema:coursePrerequisites" },
		"courseSchedule": { "@id": "schema:courseSchedule" },
		"courseWorkload": { "@id": "schema:courseWorkload" },
		"coverageEndTime": { "@id": "schema:coverageEndTime" },
		"coverageStartTime": { "@id": "schema:coverageStartTime" },
		"creativeWorkStatus": { "@id": "schema:creativeWorkStatus" },
		"creator": { "@id": "schema:creator" },
		"credentialCategory": { "@id": "schema:credentialCategory" },
		"creditText": { "@id": "schema:creditText" },
		"creditedTo": { "@id": "schema:creditedTo" },
		"cssSelector": { "@id": "schema:cssSelector" },
		"currenciesAccepted": { "@id": "schema:currenciesAccepted" },
		"currency": { "@id": "schema:currency" },
		"currentExchangeRate": { "@id": "schema:currentExchangeRate" },
		"customer": { "@id": "schema:customer" },
		"customerRemorseReturnFees": { "@id": "schema:customerRemorseReturnFees" },
		"customerRemorseReturnLabelSource": { "@id": "schema:customerRemorseReturnLabelSource" },
		"customerRemorseReturnShippingFeesAmount": { "@id": "schema:customerRemorseReturnShippingFeesAmount" },
		"cutoffTime": { "@id": "schema:cutoffTime" },
		"cvdCollectionDate": { "@id": "schema:cvdCollectionDate" },
		"cvdFacilityCounty": { "@id": "schema:cvdFacilityCounty" },
		"cvdFacilityId": { "@id": "schema:cvdFacilityId" },
		"cvdNumBeds": { "@id": "schema:cvdNumBeds" },
		"cvdNumBedsOcc": { "@id": "schema:cvdNumBedsOcc" },
		"cvdNumC19Died": { "@id": "schema:cvdNumC19Died" },
		"cvdNumC19HOPats": { "@id": "schema:cvdNumC19HOPats" },
		"cvdNumC19HospPats": { "@id": "schema:cvdNumC19HospPats" },
		"cvdNumC19MechVentPats": { "@id": "schema:cvdNumC19MechVentPats" },
		"cvdNumC19OFMechVentPats": { "@id": "schema:cvdNumC19OFMechVentPats" },
		"cvdNumC19OverflowPats": { "@id": "schema:cvdNumC19OverflowPats" },
		"cvdNumICUBeds": { "@id": "schema:cvdNumICUBeds" },
		"cvdNumICUBedsOcc": { "@id": "schema:cvdNumICUBedsOcc" },
		"cvdNumTotBeds": { "@id": "schema:cvdNumTotBeds" },
		"cvdNumVent": { "@id": "schema:cvdNumVent" },
		"cvdNumVentUse": { "@id": "schema:cvdNumVentUse" },
		"dataFeedElement": { "@id": "schema:dataFeedElement" },
		"dataset": { "@id": "schema:dataset" },
		"datasetTimeInterval": { "@id": "schema:datasetTimeInterval" },
		"dateCreated": {
			"@id": "schema:dateCreated",
			"@type": "Date"
		},
		"dateDeleted": {
			"@id": "schema:dateDeleted",
			"@type": "Date"
		},
		"dateIssued": {
			"@id": "schema:dateIssued",
			"@type": "Date"
		},
		"dateModified": {
			"@id": "schema:dateModified",
			"@type": "Date"
		},
		"datePosted": {
			"@id": "schema:datePosted",
			"@type": "Date"
		},
		"datePublished": {
			"@id": "schema:datePublished",
			"@type": "Date"
		},
		"dateRead": {
			"@id": "schema:dateRead",
			"@type": "Date"
		},
		"dateReceived": { "@id": "schema:dateReceived" },
		"dateSent": { "@id": "schema:dateSent" },
		"dateVehicleFirstRegistered": {
			"@id": "schema:dateVehicleFirstRegistered",
			"@type": "Date"
		},
		"dateline": { "@id": "schema:dateline" },
		"dayOfWeek": { "@id": "schema:dayOfWeek" },
		"deathDate": {
			"@id": "schema:deathDate",
			"@type": "Date"
		},
		"deathPlace": { "@id": "schema:deathPlace" },
		"defaultValue": { "@id": "schema:defaultValue" },
		"deliveryAddress": { "@id": "schema:deliveryAddress" },
		"deliveryLeadTime": { "@id": "schema:deliveryLeadTime" },
		"deliveryMethod": { "@id": "schema:deliveryMethod" },
		"deliveryStatus": { "@id": "schema:deliveryStatus" },
		"deliveryTime": { "@id": "schema:deliveryTime" },
		"department": { "@id": "schema:department" },
		"departureAirport": { "@id": "schema:departureAirport" },
		"departureBoatTerminal": { "@id": "schema:departureBoatTerminal" },
		"departureBusStop": { "@id": "schema:departureBusStop" },
		"departureGate": { "@id": "schema:departureGate" },
		"departurePlatform": { "@id": "schema:departurePlatform" },
		"departureStation": { "@id": "schema:departureStation" },
		"departureTerminal": { "@id": "schema:departureTerminal" },
		"departureTime": { "@id": "schema:departureTime" },
		"dependencies": { "@id": "schema:dependencies" },
		"depth": { "@id": "schema:depth" },
		"description": { "@id": "schema:description" },
		"device": { "@id": "schema:device" },
		"diagnosis": { "@id": "schema:diagnosis" },
		"diagram": { "@id": "schema:diagram" },
		"diet": { "@id": "schema:diet" },
		"dietFeatures": { "@id": "schema:dietFeatures" },
		"differentialDiagnosis": { "@id": "schema:differentialDiagnosis" },
		"digitalSourceType": { "@id": "schema:digitalSourceType" },
		"directApply": { "@id": "schema:directApply" },
		"director": { "@id": "schema:director" },
		"directors": { "@id": "schema:directors" },
		"disambiguatingDescription": { "@id": "schema:disambiguatingDescription" },
		"discount": { "@id": "schema:discount" },
		"discountCode": { "@id": "schema:discountCode" },
		"discountCurrency": { "@id": "schema:discountCurrency" },
		"discusses": { "@id": "schema:discusses" },
		"discussionUrl": {
			"@id": "schema:discussionUrl",
			"@type": "@id"
		},
		"diseasePreventionInfo": {
			"@id": "schema:diseasePreventionInfo",
			"@type": "@id"
		},
		"diseaseSpreadStatistics": {
			"@id": "schema:diseaseSpreadStatistics",
			"@type": "@id"
		},
		"dissolutionDate": {
			"@id": "schema:dissolutionDate",
			"@type": "Date"
		},
		"distance": { "@id": "schema:distance" },
		"distinguishingSign": { "@id": "schema:distinguishingSign" },
		"distribution": { "@id": "schema:distribution" },
		"diversityPolicy": {
			"@id": "schema:diversityPolicy",
			"@type": "@id"
		},
		"diversityStaffingReport": {
			"@id": "schema:diversityStaffingReport",
			"@type": "@id"
		},
		"documentation": {
			"@id": "schema:documentation",
			"@type": "@id"
		},
		"doesNotShip": { "@id": "schema:doesNotShip" },
		"domainIncludes": { "@id": "schema:domainIncludes" },
		"domiciledMortgage": { "@id": "schema:domiciledMortgage" },
		"doorTime": { "@id": "schema:doorTime" },
		"dosageForm": { "@id": "schema:dosageForm" },
		"doseSchedule": { "@id": "schema:doseSchedule" },
		"doseUnit": { "@id": "schema:doseUnit" },
		"doseValue": { "@id": "schema:doseValue" },
		"downPayment": { "@id": "schema:downPayment" },
		"downloadUrl": {
			"@id": "schema:downloadUrl",
			"@type": "@id"
		},
		"downvoteCount": { "@id": "schema:downvoteCount" },
		"drainsTo": { "@id": "schema:drainsTo" },
		"driveWheelConfiguration": { "@id": "schema:driveWheelConfiguration" },
		"dropoffLocation": { "@id": "schema:dropoffLocation" },
		"dropoffTime": { "@id": "schema:dropoffTime" },
		"drug": { "@id": "schema:drug" },
		"drugClass": { "@id": "schema:drugClass" },
		"drugUnit": { "@id": "schema:drugUnit" },
		"duns": { "@id": "schema:duns" },
		"duplicateTherapy": { "@id": "schema:duplicateTherapy" },
		"duration": { "@id": "schema:duration" },
		"durationOfWarranty": { "@id": "schema:durationOfWarranty" },
		"duringMedia": {
			"@id": "schema:duringMedia",
			"@type": "@id"
		},
		"earlyPrepaymentPenalty": { "@id": "schema:earlyPrepaymentPenalty" },
		"editEIDR": { "@id": "schema:editEIDR" },
		"editor": { "@id": "schema:editor" },
		"eduQuestionType": { "@id": "schema:eduQuestionType" },
		"educationRequirements": { "@id": "schema:educationRequirements" },
		"educationalAlignment": { "@id": "schema:educationalAlignment" },
		"educationalCredentialAwarded": { "@id": "schema:educationalCredentialAwarded" },
		"educationalFramework": { "@id": "schema:educationalFramework" },
		"educationalLevel": { "@id": "schema:educationalLevel" },
		"educationalProgramMode": { "@id": "schema:educationalProgramMode" },
		"educationalRole": { "@id": "schema:educationalRole" },
		"educationalUse": { "@id": "schema:educationalUse" },
		"elevation": { "@id": "schema:elevation" },
		"eligibilityToWorkRequirement": { "@id": "schema:eligibilityToWorkRequirement" },
		"eligibleCustomerType": { "@id": "schema:eligibleCustomerType" },
		"eligibleDuration": { "@id": "schema:eligibleDuration" },
		"eligibleQuantity": { "@id": "schema:eligibleQuantity" },
		"eligibleRegion": { "@id": "schema:eligibleRegion" },
		"eligibleTransactionVolume": { "@id": "schema:eligibleTransactionVolume" },
		"email": { "@id": "schema:email" },
		"embedUrl": {
			"@id": "schema:embedUrl",
			"@type": "@id"
		},
		"embeddedTextCaption": { "@id": "schema:embeddedTextCaption" },
		"emissionsCO2": { "@id": "schema:emissionsCO2" },
		"employee": { "@id": "schema:employee" },
		"employees": { "@id": "schema:employees" },
		"employerOverview": { "@id": "schema:employerOverview" },
		"employmentType": { "@id": "schema:employmentType" },
		"employmentUnit": { "@id": "schema:employmentUnit" },
		"encodesBioChemEntity": { "@id": "schema:encodesBioChemEntity" },
		"encodesCreativeWork": { "@id": "schema:encodesCreativeWork" },
		"encoding": { "@id": "schema:encoding" },
		"encodingFormat": { "@id": "schema:encodingFormat" },
		"encodingType": { "@id": "schema:encodingType" },
		"encodings": { "@id": "schema:encodings" },
		"endDate": {
			"@id": "schema:endDate",
			"@type": "Date"
		},
		"endOffset": { "@id": "schema:endOffset" },
		"endTime": { "@id": "schema:endTime" },
		"endorsee": { "@id": "schema:endorsee" },
		"endorsers": { "@id": "schema:endorsers" },
		"energyEfficiencyScaleMax": { "@id": "schema:energyEfficiencyScaleMax" },
		"energyEfficiencyScaleMin": { "@id": "schema:energyEfficiencyScaleMin" },
		"engineDisplacement": { "@id": "schema:engineDisplacement" },
		"enginePower": { "@id": "schema:enginePower" },
		"engineType": { "@id": "schema:engineType" },
		"entertainmentBusiness": { "@id": "schema:entertainmentBusiness" },
		"epidemiology": { "@id": "schema:epidemiology" },
		"episode": { "@id": "schema:episode" },
		"episodeNumber": { "@id": "schema:episodeNumber" },
		"episodes": { "@id": "schema:episodes" },
		"equal": { "@id": "schema:equal" },
		"error": { "@id": "schema:error" },
		"estimatedCost": { "@id": "schema:estimatedCost" },
		"estimatedFlightDuration": { "@id": "schema:estimatedFlightDuration" },
		"estimatedSalary": { "@id": "schema:estimatedSalary" },
		"estimatesRiskOf": { "@id": "schema:estimatesRiskOf" },
		"ethicsPolicy": {
			"@id": "schema:ethicsPolicy",
			"@type": "@id"
		},
		"event": { "@id": "schema:event" },
		"eventAttendanceMode": { "@id": "schema:eventAttendanceMode" },
		"eventSchedule": { "@id": "schema:eventSchedule" },
		"eventStatus": { "@id": "schema:eventStatus" },
		"events": { "@id": "schema:events" },
		"evidenceLevel": { "@id": "schema:evidenceLevel" },
		"evidenceOrigin": { "@id": "schema:evidenceOrigin" },
		"exampleOfWork": { "@id": "schema:exampleOfWork" },
		"exceptDate": {
			"@id": "schema:exceptDate",
			"@type": "Date"
		},
		"exchangeRateSpread": { "@id": "schema:exchangeRateSpread" },
		"executableLibraryName": { "@id": "schema:executableLibraryName" },
		"exerciseCourse": { "@id": "schema:exerciseCourse" },
		"exercisePlan": { "@id": "schema:exercisePlan" },
		"exerciseRelatedDiet": { "@id": "schema:exerciseRelatedDiet" },
		"exerciseType": { "@id": "schema:exerciseType" },
		"exifData": { "@id": "schema:exifData" },
		"expectedArrivalFrom": {
			"@id": "schema:expectedArrivalFrom",
			"@type": "Date"
		},
		"expectedArrivalUntil": {
			"@id": "schema:expectedArrivalUntil",
			"@type": "Date"
		},
		"expectedPrognosis": { "@id": "schema:expectedPrognosis" },
		"expectsAcceptanceOf": { "@id": "schema:expectsAcceptanceOf" },
		"experienceInPlaceOfEducation": { "@id": "schema:experienceInPlaceOfEducation" },
		"experienceRequirements": { "@id": "schema:experienceRequirements" },
		"expertConsiderations": { "@id": "schema:expertConsiderations" },
		"expires": {
			"@id": "schema:expires",
			"@type": "Date"
		},
		"expressedIn": { "@id": "schema:expressedIn" },
		"familyName": { "@id": "schema:familyName" },
		"fatContent": { "@id": "schema:fatContent" },
		"faxNumber": { "@id": "schema:faxNumber" },
		"featureList": { "@id": "schema:featureList" },
		"feesAndCommissionsSpecification": { "@id": "schema:feesAndCommissionsSpecification" },
		"fiberContent": { "@id": "schema:fiberContent" },
		"fileFormat": { "@id": "schema:fileFormat" },
		"fileSize": { "@id": "schema:fileSize" },
		"financialAidEligible": { "@id": "schema:financialAidEligible" },
		"firstAppearance": { "@id": "schema:firstAppearance" },
		"firstPerformance": { "@id": "schema:firstPerformance" },
		"flightDistance": { "@id": "schema:flightDistance" },
		"flightNumber": { "@id": "schema:flightNumber" },
		"floorLevel": { "@id": "schema:floorLevel" },
		"floorLimit": { "@id": "schema:floorLimit" },
		"floorSize": { "@id": "schema:floorSize" },
		"followee": { "@id": "schema:followee" },
		"follows": { "@id": "schema:follows" },
		"followup": { "@id": "schema:followup" },
		"foodEstablishment": { "@id": "schema:foodEstablishment" },
		"foodEvent": { "@id": "schema:foodEvent" },
		"foodWarning": { "@id": "schema:foodWarning" },
		"founder": { "@id": "schema:founder" },
		"founders": { "@id": "schema:founders" },
		"foundingDate": {
			"@id": "schema:foundingDate",
			"@type": "Date"
		},
		"foundingLocation": { "@id": "schema:foundingLocation" },
		"free": { "@id": "schema:free" },
		"freeShippingThreshold": { "@id": "schema:freeShippingThreshold" },
		"frequency": { "@id": "schema:frequency" },
		"fromLocation": { "@id": "schema:fromLocation" },
		"fuelCapacity": { "@id": "schema:fuelCapacity" },
		"fuelConsumption": { "@id": "schema:fuelConsumption" },
		"fuelEfficiency": { "@id": "schema:fuelEfficiency" },
		"fuelType": { "@id": "schema:fuelType" },
		"functionalClass": { "@id": "schema:functionalClass" },
		"fundedItem": { "@id": "schema:fundedItem" },
		"funder": { "@id": "schema:funder" },
		"funding": { "@id": "schema:funding" },
		"game": { "@id": "schema:game" },
		"gameAvailabilityType": { "@id": "schema:gameAvailabilityType" },
		"gameEdition": { "@id": "schema:gameEdition" },
		"gameItem": { "@id": "schema:gameItem" },
		"gameLocation": {
			"@id": "schema:gameLocation",
			"@type": "@id"
		},
		"gamePlatform": { "@id": "schema:gamePlatform" },
		"gameServer": { "@id": "schema:gameServer" },
		"gameTip": { "@id": "schema:gameTip" },
		"gender": { "@id": "schema:gender" },
		"genre": { "@id": "schema:genre" },
		"geo": { "@id": "schema:geo" },
		"geoContains": { "@id": "schema:geoContains" },
		"geoCoveredBy": { "@id": "schema:geoCoveredBy" },
		"geoCovers": { "@id": "schema:geoCovers" },
		"geoCrosses": { "@id": "schema:geoCrosses" },
		"geoDisjoint": { "@id": "schema:geoDisjoint" },
		"geoEquals": { "@id": "schema:geoEquals" },
		"geoIntersects": { "@id": "schema:geoIntersects" },
		"geoMidpoint": { "@id": "schema:geoMidpoint" },
		"geoOverlaps": { "@id": "schema:geoOverlaps" },
		"geoRadius": { "@id": "schema:geoRadius" },
		"geoTouches": { "@id": "schema:geoTouches" },
		"geoWithin": { "@id": "schema:geoWithin" },
		"geographicArea": { "@id": "schema:geographicArea" },
		"gettingTestedInfo": {
			"@id": "schema:gettingTestedInfo",
			"@type": "@id"
		},
		"givenName": { "@id": "schema:givenName" },
		"globalLocationNumber": { "@id": "schema:globalLocationNumber" },
		"governmentBenefitsInfo": { "@id": "schema:governmentBenefitsInfo" },
		"gracePeriod": { "@id": "schema:gracePeriod" },
		"grantee": { "@id": "schema:grantee" },
		"greater": { "@id": "schema:greater" },
		"greaterOrEqual": { "@id": "schema:greaterOrEqual" },
		"gtin": { "@id": "schema:gtin" },
		"gtin12": { "@id": "schema:gtin12" },
		"gtin13": { "@id": "schema:gtin13" },
		"gtin14": { "@id": "schema:gtin14" },
		"gtin8": { "@id": "schema:gtin8" },
		"guideline": { "@id": "schema:guideline" },
		"guidelineDate": {
			"@id": "schema:guidelineDate",
			"@type": "Date"
		},
		"guidelineSubject": { "@id": "schema:guidelineSubject" },
		"handlingTime": { "@id": "schema:handlingTime" },
		"hasAdultConsideration": { "@id": "schema:hasAdultConsideration" },
		"hasBioChemEntityPart": { "@id": "schema:hasBioChemEntityPart" },
		"hasBioPolymerSequence": { "@id": "schema:hasBioPolymerSequence" },
		"hasBroadcastChannel": { "@id": "schema:hasBroadcastChannel" },
		"hasCategoryCode": { "@id": "schema:hasCategoryCode" },
		"hasCertification": { "@id": "schema:hasCertification" },
		"hasCourse": { "@id": "schema:hasCourse" },
		"hasCourseInstance": { "@id": "schema:hasCourseInstance" },
		"hasCredential": { "@id": "schema:hasCredential" },
		"hasDefinedTerm": { "@id": "schema:hasDefinedTerm" },
		"hasDeliveryMethod": { "@id": "schema:hasDeliveryMethod" },
		"hasDigitalDocumentPermission": { "@id": "schema:hasDigitalDocumentPermission" },
		"hasDriveThroughService": { "@id": "schema:hasDriveThroughService" },
		"hasEnergyConsumptionDetails": { "@id": "schema:hasEnergyConsumptionDetails" },
		"hasEnergyEfficiencyCategory": { "@id": "schema:hasEnergyEfficiencyCategory" },
		"hasGS1DigitalLink": {
			"@id": "schema:hasGS1DigitalLink",
			"@type": "@id"
		},
		"hasHealthAspect": { "@id": "schema:hasHealthAspect" },
		"hasMap": {
			"@id": "schema:hasMap",
			"@type": "@id"
		},
		"hasMeasurement": { "@id": "schema:hasMeasurement" },
		"hasMemberProgram": { "@id": "schema:hasMemberProgram" },
		"hasMenu": { "@id": "schema:hasMenu" },
		"hasMenuItem": { "@id": "schema:hasMenuItem" },
		"hasMenuSection": { "@id": "schema:hasMenuSection" },
		"hasMerchantReturnPolicy": { "@id": "schema:hasMerchantReturnPolicy" },
		"hasMolecularFunction": {
			"@id": "schema:hasMolecularFunction",
			"@type": "@id"
		},
		"hasOccupation": { "@id": "schema:hasOccupation" },
		"hasOfferCatalog": { "@id": "schema:hasOfferCatalog" },
		"hasPOS": { "@id": "schema:hasPOS" },
		"hasPart": { "@id": "schema:hasPart" },
		"hasProductReturnPolicy": { "@id": "schema:hasProductReturnPolicy" },
		"hasRepresentation": { "@id": "schema:hasRepresentation" },
		"hasTierBenefit": { "@id": "schema:hasTierBenefit" },
		"hasTierRequirement": { "@id": "schema:hasTierRequirement" },
		"hasTiers": { "@id": "schema:hasTiers" },
		"hasVariant": { "@id": "schema:hasVariant" },
		"headline": { "@id": "schema:headline" },
		"healthCondition": { "@id": "schema:healthCondition" },
		"healthPlanCoinsuranceOption": { "@id": "schema:healthPlanCoinsuranceOption" },
		"healthPlanCoinsuranceRate": { "@id": "schema:healthPlanCoinsuranceRate" },
		"healthPlanCopay": { "@id": "schema:healthPlanCopay" },
		"healthPlanCopayOption": { "@id": "schema:healthPlanCopayOption" },
		"healthPlanCostSharing": { "@id": "schema:healthPlanCostSharing" },
		"healthPlanDrugOption": { "@id": "schema:healthPlanDrugOption" },
		"healthPlanDrugTier": { "@id": "schema:healthPlanDrugTier" },
		"healthPlanId": { "@id": "schema:healthPlanId" },
		"healthPlanMarketingUrl": {
			"@id": "schema:healthPlanMarketingUrl",
			"@type": "@id"
		},
		"healthPlanNetworkId": { "@id": "schema:healthPlanNetworkId" },
		"healthPlanNetworkTier": { "@id": "schema:healthPlanNetworkTier" },
		"healthPlanPharmacyCategory": { "@id": "schema:healthPlanPharmacyCategory" },
		"healthcareReportingData": { "@id": "schema:healthcareReportingData" },
		"height": { "@id": "schema:height" },
		"highPrice": { "@id": "schema:highPrice" },
		"hiringOrganization": { "@id": "schema:hiringOrganization" },
		"holdingArchive": { "@id": "schema:holdingArchive" },
		"homeLocation": { "@id": "schema:homeLocation" },
		"homeTeam": { "@id": "schema:homeTeam" },
		"honorificPrefix": { "@id": "schema:honorificPrefix" },
		"honorificSuffix": { "@id": "schema:honorificSuffix" },
		"hospitalAffiliation": { "@id": "schema:hospitalAffiliation" },
		"hostingOrganization": { "@id": "schema:hostingOrganization" },
		"hoursAvailable": { "@id": "schema:hoursAvailable" },
		"howPerformed": { "@id": "schema:howPerformed" },
		"httpMethod": { "@id": "schema:httpMethod" },
		"iataCode": { "@id": "schema:iataCode" },
		"icaoCode": { "@id": "schema:icaoCode" },
		"identifier": { "@id": "schema:identifier" },
		"identifyingExam": { "@id": "schema:identifyingExam" },
		"identifyingTest": { "@id": "schema:identifyingTest" },
		"illustrator": { "@id": "schema:illustrator" },
		"image": {
			"@id": "schema:image",
			"@type": "@id"
		},
		"imagingTechnique": { "@id": "schema:imagingTechnique" },
		"inAlbum": { "@id": "schema:inAlbum" },
		"inBroadcastLineup": { "@id": "schema:inBroadcastLineup" },
		"inChI": { "@id": "schema:inChI" },
		"inChIKey": { "@id": "schema:inChIKey" },
		"inCodeSet": {
			"@id": "schema:inCodeSet",
			"@type": "@id"
		},
		"inDefinedTermSet": {
			"@id": "schema:inDefinedTermSet",
			"@type": "@id"
		},
		"inLanguage": { "@id": "schema:inLanguage" },
		"inPlaylist": { "@id": "schema:inPlaylist" },
		"inProductGroupWithID": { "@id": "schema:inProductGroupWithID" },
		"inStoreReturnsOffered": { "@id": "schema:inStoreReturnsOffered" },
		"inSupportOf": { "@id": "schema:inSupportOf" },
		"incentiveCompensation": { "@id": "schema:incentiveCompensation" },
		"incentives": { "@id": "schema:incentives" },
		"includedComposition": { "@id": "schema:includedComposition" },
		"includedDataCatalog": { "@id": "schema:includedDataCatalog" },
		"includedInDataCatalog": { "@id": "schema:includedInDataCatalog" },
		"includedInHealthInsurancePlan": { "@id": "schema:includedInHealthInsurancePlan" },
		"includedRiskFactor": { "@id": "schema:includedRiskFactor" },
		"includesAttraction": { "@id": "schema:includesAttraction" },
		"includesHealthPlanFormulary": { "@id": "schema:includesHealthPlanFormulary" },
		"includesHealthPlanNetwork": { "@id": "schema:includesHealthPlanNetwork" },
		"includesObject": { "@id": "schema:includesObject" },
		"increasesRiskOf": { "@id": "schema:increasesRiskOf" },
		"industry": { "@id": "schema:industry" },
		"ineligibleRegion": { "@id": "schema:ineligibleRegion" },
		"infectiousAgent": { "@id": "schema:infectiousAgent" },
		"infectiousAgentClass": { "@id": "schema:infectiousAgentClass" },
		"ingredients": { "@id": "schema:ingredients" },
		"inker": { "@id": "schema:inker" },
		"insertion": { "@id": "schema:insertion" },
		"installUrl": {
			"@id": "schema:installUrl",
			"@type": "@id"
		},
		"instructor": { "@id": "schema:instructor" },
		"instrument": { "@id": "schema:instrument" },
		"intensity": { "@id": "schema:intensity" },
		"interactingDrug": { "@id": "schema:interactingDrug" },
		"interactionCount": { "@id": "schema:interactionCount" },
		"interactionService": { "@id": "schema:interactionService" },
		"interactionStatistic": { "@id": "schema:interactionStatistic" },
		"interactionType": { "@id": "schema:interactionType" },
		"interactivityType": { "@id": "schema:interactivityType" },
		"interestRate": { "@id": "schema:interestRate" },
		"interpretedAsClaim": { "@id": "schema:interpretedAsClaim" },
		"inventoryLevel": { "@id": "schema:inventoryLevel" },
		"inverseOf": { "@id": "schema:inverseOf" },
		"isAcceptingNewPatients": { "@id": "schema:isAcceptingNewPatients" },
		"isAccessibleForFree": { "@id": "schema:isAccessibleForFree" },
		"isAccessoryOrSparePartFor": { "@id": "schema:isAccessoryOrSparePartFor" },
		"isAvailableGenerically": { "@id": "schema:isAvailableGenerically" },
		"isBasedOn": {
			"@id": "schema:isBasedOn",
			"@type": "@id"
		},
		"isBasedOnUrl": {
			"@id": "schema:isBasedOnUrl",
			"@type": "@id"
		},
		"isConsumableFor": { "@id": "schema:isConsumableFor" },
		"isEncodedByBioChemEntity": { "@id": "schema:isEncodedByBioChemEntity" },
		"isFamilyFriendly": { "@id": "schema:isFamilyFriendly" },
		"isGift": { "@id": "schema:isGift" },
		"isInvolvedInBiologicalProcess": {
			"@id": "schema:isInvolvedInBiologicalProcess",
			"@type": "@id"
		},
		"isLiveBroadcast": { "@id": "schema:isLiveBroadcast" },
		"isLocatedInSubcellularLocation": {
			"@id": "schema:isLocatedInSubcellularLocation",
			"@type": "@id"
		},
		"isPartOf": {
			"@id": "schema:isPartOf",
			"@type": "@id"
		},
		"isPartOfBioChemEntity": { "@id": "schema:isPartOfBioChemEntity" },
		"isPlanForApartment": { "@id": "schema:isPlanForApartment" },
		"isProprietary": { "@id": "schema:isProprietary" },
		"isRelatedTo": { "@id": "schema:isRelatedTo" },
		"isResizable": { "@id": "schema:isResizable" },
		"isSimilarTo": { "@id": "schema:isSimilarTo" },
		"isTierOf": { "@id": "schema:isTierOf" },
		"isUnlabelledFallback": { "@id": "schema:isUnlabelledFallback" },
		"isVariantOf": { "@id": "schema:isVariantOf" },
		"isbn": { "@id": "schema:isbn" },
		"isicV4": { "@id": "schema:isicV4" },
		"iso6523Code": { "@id": "schema:iso6523Code" },
		"isrcCode": { "@id": "schema:isrcCode" },
		"issn": { "@id": "schema:issn" },
		"issueNumber": { "@id": "schema:issueNumber" },
		"issuedBy": { "@id": "schema:issuedBy" },
		"issuedThrough": { "@id": "schema:issuedThrough" },
		"iswcCode": { "@id": "schema:iswcCode" },
		"item": { "@id": "schema:item" },
		"itemCondition": { "@id": "schema:itemCondition" },
		"itemDefectReturnFees": { "@id": "schema:itemDefectReturnFees" },
		"itemDefectReturnLabelSource": { "@id": "schema:itemDefectReturnLabelSource" },
		"itemDefectReturnShippingFeesAmount": { "@id": "schema:itemDefectReturnShippingFeesAmount" },
		"itemListElement": { "@id": "schema:itemListElement" },
		"itemListOrder": { "@id": "schema:itemListOrder" },
		"itemLocation": { "@id": "schema:itemLocation" },
		"itemOffered": { "@id": "schema:itemOffered" },
		"itemReviewed": { "@id": "schema:itemReviewed" },
		"itemShipped": { "@id": "schema:itemShipped" },
		"itinerary": { "@id": "schema:itinerary" },
		"iupacName": { "@id": "schema:iupacName" },
		"jobBenefits": { "@id": "schema:jobBenefits" },
		"jobImmediateStart": { "@id": "schema:jobImmediateStart" },
		"jobLocation": { "@id": "schema:jobLocation" },
		"jobLocationType": { "@id": "schema:jobLocationType" },
		"jobStartDate": { "@id": "schema:jobStartDate" },
		"jobTitle": { "@id": "schema:jobTitle" },
		"jurisdiction": { "@id": "schema:jurisdiction" },
		"keywords": { "@id": "schema:keywords" },
		"knownVehicleDamages": { "@id": "schema:knownVehicleDamages" },
		"knows": { "@id": "schema:knows" },
		"knowsAbout": { "@id": "schema:knowsAbout" },
		"knowsLanguage": { "@id": "schema:knowsLanguage" },
		"labelDetails": {
			"@id": "schema:labelDetails",
			"@type": "@id"
		},
		"landlord": { "@id": "schema:landlord" },
		"language": { "@id": "schema:language" },
		"lastReviewed": {
			"@id": "schema:lastReviewed",
			"@type": "Date"
		},
		"latitude": { "@id": "schema:latitude" },
		"layoutImage": {
			"@id": "schema:layoutImage",
			"@type": "@id"
		},
		"learningResourceType": { "@id": "schema:learningResourceType" },
		"leaseLength": { "@id": "schema:leaseLength" },
		"legalName": { "@id": "schema:legalName" },
		"legalStatus": { "@id": "schema:legalStatus" },
		"legislationApplies": { "@id": "schema:legislationApplies" },
		"legislationChanges": { "@id": "schema:legislationChanges" },
		"legislationConsolidates": { "@id": "schema:legislationConsolidates" },
		"legislationDate": {
			"@id": "schema:legislationDate",
			"@type": "Date"
		},
		"legislationDateVersion": {
			"@id": "schema:legislationDateVersion",
			"@type": "Date"
		},
		"legislationIdentifier": { "@id": "schema:legislationIdentifier" },
		"legislationJurisdiction": { "@id": "schema:legislationJurisdiction" },
		"legislationLegalForce": { "@id": "schema:legislationLegalForce" },
		"legislationLegalValue": { "@id": "schema:legislationLegalValue" },
		"legislationPassedBy": { "@id": "schema:legislationPassedBy" },
		"legislationResponsible": { "@id": "schema:legislationResponsible" },
		"legislationTransposes": { "@id": "schema:legislationTransposes" },
		"legislationType": { "@id": "schema:legislationType" },
		"leiCode": { "@id": "schema:leiCode" },
		"lender": { "@id": "schema:lender" },
		"lesser": { "@id": "schema:lesser" },
		"lesserOrEqual": { "@id": "schema:lesserOrEqual" },
		"letterer": { "@id": "schema:letterer" },
		"license": {
			"@id": "schema:license",
			"@type": "@id"
		},
		"line": { "@id": "schema:line" },
		"linkRelationship": { "@id": "schema:linkRelationship" },
		"liveBlogUpdate": { "@id": "schema:liveBlogUpdate" },
		"loanMortgageMandateAmount": { "@id": "schema:loanMortgageMandateAmount" },
		"loanPaymentAmount": { "@id": "schema:loanPaymentAmount" },
		"loanPaymentFrequency": { "@id": "schema:loanPaymentFrequency" },
		"loanRepaymentForm": { "@id": "schema:loanRepaymentForm" },
		"loanTerm": { "@id": "schema:loanTerm" },
		"loanType": { "@id": "schema:loanType" },
		"location": { "@id": "schema:location" },
		"locationCreated": { "@id": "schema:locationCreated" },
		"lodgingUnitDescription": { "@id": "schema:lodgingUnitDescription" },
		"lodgingUnitType": { "@id": "schema:lodgingUnitType" },
		"logo": {
			"@id": "schema:logo",
			"@type": "@id"
		},
		"longitude": { "@id": "schema:longitude" },
		"loser": { "@id": "schema:loser" },
		"lowPrice": { "@id": "schema:lowPrice" },
		"lyricist": { "@id": "schema:lyricist" },
		"lyrics": { "@id": "schema:lyrics" },
		"mainContentOfPage": { "@id": "schema:mainContentOfPage" },
		"mainEntity": { "@id": "schema:mainEntity" },
		"mainEntityOfPage": {
			"@id": "schema:mainEntityOfPage",
			"@type": "@id"
		},
		"maintainer": { "@id": "schema:maintainer" },
		"makesOffer": { "@id": "schema:makesOffer" },
		"manufacturer": { "@id": "schema:manufacturer" },
		"map": {
			"@id": "schema:map",
			"@type": "@id"
		},
		"mapType": { "@id": "schema:mapType" },
		"maps": {
			"@id": "schema:maps",
			"@type": "@id"
		},
		"marginOfError": { "@id": "schema:marginOfError" },
		"masthead": {
			"@id": "schema:masthead",
			"@type": "@id"
		},
		"material": { "@id": "schema:material" },
		"materialExtent": { "@id": "schema:materialExtent" },
		"mathExpression": { "@id": "schema:mathExpression" },
		"maxPrice": { "@id": "schema:maxPrice" },
		"maxValue": { "@id": "schema:maxValue" },
		"maximumAttendeeCapacity": { "@id": "schema:maximumAttendeeCapacity" },
		"maximumEnrollment": { "@id": "schema:maximumEnrollment" },
		"maximumIntake": { "@id": "schema:maximumIntake" },
		"maximumPhysicalAttendeeCapacity": { "@id": "schema:maximumPhysicalAttendeeCapacity" },
		"maximumVirtualAttendeeCapacity": { "@id": "schema:maximumVirtualAttendeeCapacity" },
		"mealService": { "@id": "schema:mealService" },
		"measuredProperty": { "@id": "schema:measuredProperty" },
		"measurementDenominator": { "@id": "schema:measurementDenominator" },
		"measurementMethod": { "@id": "schema:measurementMethod" },
		"measurementQualifier": { "@id": "schema:measurementQualifier" },
		"measurementTechnique": { "@id": "schema:measurementTechnique" },
		"mechanismOfAction": { "@id": "schema:mechanismOfAction" },
		"mediaAuthenticityCategory": { "@id": "schema:mediaAuthenticityCategory" },
		"mediaItemAppearance": { "@id": "schema:mediaItemAppearance" },
		"median": { "@id": "schema:median" },
		"medicalAudience": { "@id": "schema:medicalAudience" },
		"medicalSpecialty": { "@id": "schema:medicalSpecialty" },
		"medicineSystem": { "@id": "schema:medicineSystem" },
		"meetsEmissionStandard": { "@id": "schema:meetsEmissionStandard" },
		"member": { "@id": "schema:member" },
		"memberOf": { "@id": "schema:memberOf" },
		"members": { "@id": "schema:members" },
		"membershipNumber": { "@id": "schema:membershipNumber" },
		"membershipPointsEarned": { "@id": "schema:membershipPointsEarned" },
		"memoryRequirements": { "@id": "schema:memoryRequirements" },
		"mentions": { "@id": "schema:mentions" },
		"menu": { "@id": "schema:menu" },
		"menuAddOn": { "@id": "schema:menuAddOn" },
		"merchant": { "@id": "schema:merchant" },
		"merchantReturnDays": {
			"@id": "schema:merchantReturnDays",
			"@type": "Date"
		},
		"merchantReturnLink": {
			"@id": "schema:merchantReturnLink",
			"@type": "@id"
		},
		"messageAttachment": { "@id": "schema:messageAttachment" },
		"mileageFromOdometer": { "@id": "schema:mileageFromOdometer" },
		"minPrice": { "@id": "schema:minPrice" },
		"minValue": { "@id": "schema:minValue" },
		"minimumPaymentDue": { "@id": "schema:minimumPaymentDue" },
		"missionCoveragePrioritiesPolicy": {
			"@id": "schema:missionCoveragePrioritiesPolicy",
			"@type": "@id"
		},
		"mobileUrl": { "@id": "schema:mobileUrl" },
		"model": { "@id": "schema:model" },
		"modelDate": {
			"@id": "schema:modelDate",
			"@type": "Date"
		},
		"modifiedTime": { "@id": "schema:modifiedTime" },
		"molecularFormula": { "@id": "schema:molecularFormula" },
		"molecularWeight": { "@id": "schema:molecularWeight" },
		"monoisotopicMolecularWeight": { "@id": "schema:monoisotopicMolecularWeight" },
		"monthlyMinimumRepaymentAmount": { "@id": "schema:monthlyMinimumRepaymentAmount" },
		"monthsOfExperience": { "@id": "schema:monthsOfExperience" },
		"mpn": { "@id": "schema:mpn" },
		"multipleValues": { "@id": "schema:multipleValues" },
		"muscleAction": { "@id": "schema:muscleAction" },
		"musicArrangement": { "@id": "schema:musicArrangement" },
		"musicBy": { "@id": "schema:musicBy" },
		"musicCompositionForm": { "@id": "schema:musicCompositionForm" },
		"musicGroupMember": { "@id": "schema:musicGroupMember" },
		"musicReleaseFormat": { "@id": "schema:musicReleaseFormat" },
		"musicalKey": { "@id": "schema:musicalKey" },
		"naics": { "@id": "schema:naics" },
		"name": { "@id": "schema:name" },
		"namedPosition": { "@id": "schema:namedPosition" },
		"nationality": { "@id": "schema:nationality" },
		"naturalProgression": { "@id": "schema:naturalProgression" },
		"negativeNotes": { "@id": "schema:negativeNotes" },
		"nerve": { "@id": "schema:nerve" },
		"nerveMotor": { "@id": "schema:nerveMotor" },
		"netWorth": { "@id": "schema:netWorth" },
		"newsUpdatesAndGuidelines": {
			"@id": "schema:newsUpdatesAndGuidelines",
			"@type": "@id"
		},
		"nextItem": { "@id": "schema:nextItem" },
		"noBylinesPolicy": {
			"@id": "schema:noBylinesPolicy",
			"@type": "@id"
		},
		"nonEqual": { "@id": "schema:nonEqual" },
		"nonProprietaryName": { "@id": "schema:nonProprietaryName" },
		"nonprofitStatus": { "@id": "schema:nonprofitStatus" },
		"normalRange": { "@id": "schema:normalRange" },
		"nsn": { "@id": "schema:nsn" },
		"numAdults": { "@id": "schema:numAdults" },
		"numChildren": { "@id": "schema:numChildren" },
		"numConstraints": { "@id": "schema:numConstraints" },
		"numTracks": { "@id": "schema:numTracks" },
		"numberOfAccommodationUnits": { "@id": "schema:numberOfAccommodationUnits" },
		"numberOfAirbags": { "@id": "schema:numberOfAirbags" },
		"numberOfAvailableAccommodationUnits": { "@id": "schema:numberOfAvailableAccommodationUnits" },
		"numberOfAxles": { "@id": "schema:numberOfAxles" },
		"numberOfBathroomsTotal": { "@id": "schema:numberOfBathroomsTotal" },
		"numberOfBedrooms": { "@id": "schema:numberOfBedrooms" },
		"numberOfBeds": { "@id": "schema:numberOfBeds" },
		"numberOfCredits": { "@id": "schema:numberOfCredits" },
		"numberOfDoors": { "@id": "schema:numberOfDoors" },
		"numberOfEmployees": { "@id": "schema:numberOfEmployees" },
		"numberOfEpisodes": { "@id": "schema:numberOfEpisodes" },
		"numberOfForwardGears": { "@id": "schema:numberOfForwardGears" },
		"numberOfFullBathrooms": { "@id": "schema:numberOfFullBathrooms" },
		"numberOfItems": { "@id": "schema:numberOfItems" },
		"numberOfLoanPayments": { "@id": "schema:numberOfLoanPayments" },
		"numberOfPages": { "@id": "schema:numberOfPages" },
		"numberOfPartialBathrooms": { "@id": "schema:numberOfPartialBathrooms" },
		"numberOfPlayers": { "@id": "schema:numberOfPlayers" },
		"numberOfPreviousOwners": { "@id": "schema:numberOfPreviousOwners" },
		"numberOfRooms": { "@id": "schema:numberOfRooms" },
		"numberOfSeasons": { "@id": "schema:numberOfSeasons" },
		"numberedPosition": { "@id": "schema:numberedPosition" },
		"nutrition": { "@id": "schema:nutrition" },
		"object": { "@id": "schema:object" },
		"observationAbout": { "@id": "schema:observationAbout" },
		"observationDate": { "@id": "schema:observationDate" },
		"observationPeriod": { "@id": "schema:observationPeriod" },
		"occupancy": { "@id": "schema:occupancy" },
		"occupationLocation": { "@id": "schema:occupationLocation" },
		"occupationalCategory": { "@id": "schema:occupationalCategory" },
		"occupationalCredentialAwarded": { "@id": "schema:occupationalCredentialAwarded" },
		"offerCount": { "@id": "schema:offerCount" },
		"offeredBy": { "@id": "schema:offeredBy" },
		"offers": { "@id": "schema:offers" },
		"offersPrescriptionByMail": { "@id": "schema:offersPrescriptionByMail" },
		"openingHours": { "@id": "schema:openingHours" },
		"openingHoursSpecification": { "@id": "schema:openingHoursSpecification" },
		"opens": { "@id": "schema:opens" },
		"operatingSystem": { "@id": "schema:operatingSystem" },
		"opponent": { "@id": "schema:opponent" },
		"option": { "@id": "schema:option" },
		"orderDate": {
			"@id": "schema:orderDate",
			"@type": "Date"
		},
		"orderDelivery": { "@id": "schema:orderDelivery" },
		"orderItemNumber": { "@id": "schema:orderItemNumber" },
		"orderItemStatus": { "@id": "schema:orderItemStatus" },
		"orderNumber": { "@id": "schema:orderNumber" },
		"orderQuantity": { "@id": "schema:orderQuantity" },
		"orderStatus": { "@id": "schema:orderStatus" },
		"orderedItem": { "@id": "schema:orderedItem" },
		"organizer": { "@id": "schema:organizer" },
		"originAddress": { "@id": "schema:originAddress" },
		"originalMediaContextDescription": { "@id": "schema:originalMediaContextDescription" },
		"originalMediaLink": {
			"@id": "schema:originalMediaLink",
			"@type": "@id"
		},
		"originatesFrom": { "@id": "schema:originatesFrom" },
		"overdosage": { "@id": "schema:overdosage" },
		"ownedFrom": { "@id": "schema:ownedFrom" },
		"ownedThrough": { "@id": "schema:ownedThrough" },
		"ownershipFundingInfo": { "@id": "schema:ownershipFundingInfo" },
		"owns": { "@id": "schema:owns" },
		"pageEnd": { "@id": "schema:pageEnd" },
		"pageStart": { "@id": "schema:pageStart" },
		"pagination": { "@id": "schema:pagination" },
		"parent": { "@id": "schema:parent" },
		"parentItem": { "@id": "schema:parentItem" },
		"parentOrganization": { "@id": "schema:parentOrganization" },
		"parentService": { "@id": "schema:parentService" },
		"parentTaxon": { "@id": "schema:parentTaxon" },
		"parents": { "@id": "schema:parents" },
		"partOfEpisode": { "@id": "schema:partOfEpisode" },
		"partOfInvoice": { "@id": "schema:partOfInvoice" },
		"partOfOrder": { "@id": "schema:partOfOrder" },
		"partOfSeason": { "@id": "schema:partOfSeason" },
		"partOfSeries": { "@id": "schema:partOfSeries" },
		"partOfSystem": { "@id": "schema:partOfSystem" },
		"partOfTVSeries": { "@id": "schema:partOfTVSeries" },
		"partOfTrip": { "@id": "schema:partOfTrip" },
		"participant": { "@id": "schema:participant" },
		"partySize": { "@id": "schema:partySize" },
		"passengerPriorityStatus": { "@id": "schema:passengerPriorityStatus" },
		"passengerSequenceNumber": { "@id": "schema:passengerSequenceNumber" },
		"pathophysiology": { "@id": "schema:pathophysiology" },
		"pattern": { "@id": "schema:pattern" },
		"payload": { "@id": "schema:payload" },
		"paymentAccepted": { "@id": "schema:paymentAccepted" },
		"paymentDue": { "@id": "schema:paymentDue" },
		"paymentDueDate": {
			"@id": "schema:paymentDueDate",
			"@type": "Date"
		},
		"paymentMethod": { "@id": "schema:paymentMethod" },
		"paymentMethodId": { "@id": "schema:paymentMethodId" },
		"paymentMethodType": { "@id": "schema:paymentMethodType" },
		"paymentStatus": { "@id": "schema:paymentStatus" },
		"paymentUrl": {
			"@id": "schema:paymentUrl",
			"@type": "@id"
		},
		"penciler": { "@id": "schema:penciler" },
		"percentile10": { "@id": "schema:percentile10" },
		"percentile25": { "@id": "schema:percentile25" },
		"percentile75": { "@id": "schema:percentile75" },
		"percentile90": { "@id": "schema:percentile90" },
		"performTime": { "@id": "schema:performTime" },
		"performer": { "@id": "schema:performer" },
		"performerIn": { "@id": "schema:performerIn" },
		"performers": { "@id": "schema:performers" },
		"permissionType": { "@id": "schema:permissionType" },
		"permissions": { "@id": "schema:permissions" },
		"permitAudience": { "@id": "schema:permitAudience" },
		"permittedUsage": { "@id": "schema:permittedUsage" },
		"petsAllowed": { "@id": "schema:petsAllowed" },
		"phoneticText": { "@id": "schema:phoneticText" },
		"photo": { "@id": "schema:photo" },
		"photos": { "@id": "schema:photos" },
		"physicalRequirement": { "@id": "schema:physicalRequirement" },
		"physiologicalBenefits": { "@id": "schema:physiologicalBenefits" },
		"pickupLocation": { "@id": "schema:pickupLocation" },
		"pickupTime": { "@id": "schema:pickupTime" },
		"playMode": { "@id": "schema:playMode" },
		"playerType": { "@id": "schema:playerType" },
		"playersOnline": { "@id": "schema:playersOnline" },
		"polygon": { "@id": "schema:polygon" },
		"populationType": { "@id": "schema:populationType" },
		"position": { "@id": "schema:position" },
		"positiveNotes": { "@id": "schema:positiveNotes" },
		"possibleComplication": { "@id": "schema:possibleComplication" },
		"possibleTreatment": { "@id": "schema:possibleTreatment" },
		"postOfficeBoxNumber": { "@id": "schema:postOfficeBoxNumber" },
		"postOp": { "@id": "schema:postOp" },
		"postalCode": { "@id": "schema:postalCode" },
		"postalCodeBegin": { "@id": "schema:postalCodeBegin" },
		"postalCodeEnd": { "@id": "schema:postalCodeEnd" },
		"postalCodePrefix": { "@id": "schema:postalCodePrefix" },
		"postalCodeRange": { "@id": "schema:postalCodeRange" },
		"potentialAction": { "@id": "schema:potentialAction" },
		"potentialUse": { "@id": "schema:potentialUse" },
		"practicesAt": { "@id": "schema:practicesAt" },
		"preOp": { "@id": "schema:preOp" },
		"predecessorOf": { "@id": "schema:predecessorOf" },
		"pregnancyCategory": { "@id": "schema:pregnancyCategory" },
		"pregnancyWarning": { "@id": "schema:pregnancyWarning" },
		"prepTime": { "@id": "schema:prepTime" },
		"preparation": { "@id": "schema:preparation" },
		"prescribingInfo": {
			"@id": "schema:prescribingInfo",
			"@type": "@id"
		},
		"prescriptionStatus": { "@id": "schema:prescriptionStatus" },
		"previousItem": { "@id": "schema:previousItem" },
		"previousStartDate": {
			"@id": "schema:previousStartDate",
			"@type": "Date"
		},
		"price": { "@id": "schema:price" },
		"priceComponent": { "@id": "schema:priceComponent" },
		"priceComponentType": { "@id": "schema:priceComponentType" },
		"priceCurrency": { "@id": "schema:priceCurrency" },
		"priceRange": { "@id": "schema:priceRange" },
		"priceSpecification": { "@id": "schema:priceSpecification" },
		"priceType": { "@id": "schema:priceType" },
		"priceValidUntil": {
			"@id": "schema:priceValidUntil",
			"@type": "Date"
		},
		"primaryImageOfPage": { "@id": "schema:primaryImageOfPage" },
		"primaryPrevention": { "@id": "schema:primaryPrevention" },
		"printColumn": { "@id": "schema:printColumn" },
		"printEdition": { "@id": "schema:printEdition" },
		"printPage": { "@id": "schema:printPage" },
		"printSection": { "@id": "schema:printSection" },
		"procedure": { "@id": "schema:procedure" },
		"procedureType": { "@id": "schema:procedureType" },
		"processingTime": { "@id": "schema:processingTime" },
		"processorRequirements": { "@id": "schema:processorRequirements" },
		"producer": { "@id": "schema:producer" },
		"produces": { "@id": "schema:produces" },
		"productGroupID": { "@id": "schema:productGroupID" },
		"productID": { "@id": "schema:productID" },
		"productReturnDays": { "@id": "schema:productReturnDays" },
		"productReturnLink": {
			"@id": "schema:productReturnLink",
			"@type": "@id"
		},
		"productSupported": { "@id": "schema:productSupported" },
		"productionCompany": { "@id": "schema:productionCompany" },
		"productionDate": {
			"@id": "schema:productionDate",
			"@type": "Date"
		},
		"proficiencyLevel": { "@id": "schema:proficiencyLevel" },
		"program": { "@id": "schema:program" },
		"programMembershipUsed": { "@id": "schema:programMembershipUsed" },
		"programName": { "@id": "schema:programName" },
		"programPrerequisites": { "@id": "schema:programPrerequisites" },
		"programType": { "@id": "schema:programType" },
		"programmingLanguage": { "@id": "schema:programmingLanguage" },
		"programmingModel": { "@id": "schema:programmingModel" },
		"propertyID": { "@id": "schema:propertyID" },
		"proprietaryName": { "@id": "schema:proprietaryName" },
		"proteinContent": { "@id": "schema:proteinContent" },
		"provider": { "@id": "schema:provider" },
		"providerMobility": { "@id": "schema:providerMobility" },
		"providesBroadcastService": { "@id": "schema:providesBroadcastService" },
		"providesService": { "@id": "schema:providesService" },
		"publicAccess": { "@id": "schema:publicAccess" },
		"publicTransportClosuresInfo": {
			"@id": "schema:publicTransportClosuresInfo",
			"@type": "@id"
		},
		"publication": { "@id": "schema:publication" },
		"publicationType": { "@id": "schema:publicationType" },
		"publishedBy": { "@id": "schema:publishedBy" },
		"publishedOn": { "@id": "schema:publishedOn" },
		"publisher": { "@id": "schema:publisher" },
		"publisherImprint": { "@id": "schema:publisherImprint" },
		"publishingPrinciples": {
			"@id": "schema:publishingPrinciples",
			"@type": "@id"
		},
		"purchaseDate": {
			"@id": "schema:purchaseDate",
			"@type": "Date"
		},
		"qualifications": { "@id": "schema:qualifications" },
		"quarantineGuidelines": {
			"@id": "schema:quarantineGuidelines",
			"@type": "@id"
		},
		"query": { "@id": "schema:query" },
		"quest": { "@id": "schema:quest" },
		"question": { "@id": "schema:question" },
		"rangeIncludes": { "@id": "schema:rangeIncludes" },
		"ratingCount": { "@id": "schema:ratingCount" },
		"ratingExplanation": { "@id": "schema:ratingExplanation" },
		"ratingValue": { "@id": "schema:ratingValue" },
		"readBy": { "@id": "schema:readBy" },
		"readonlyValue": { "@id": "schema:readonlyValue" },
		"realEstateAgent": { "@id": "schema:realEstateAgent" },
		"recipe": { "@id": "schema:recipe" },
		"recipeCategory": { "@id": "schema:recipeCategory" },
		"recipeCuisine": { "@id": "schema:recipeCuisine" },
		"recipeIngredient": { "@id": "schema:recipeIngredient" },
		"recipeInstructions": { "@id": "schema:recipeInstructions" },
		"recipeYield": { "@id": "schema:recipeYield" },
		"recipient": { "@id": "schema:recipient" },
		"recognizedBy": { "@id": "schema:recognizedBy" },
		"recognizingAuthority": { "@id": "schema:recognizingAuthority" },
		"recommendationStrength": { "@id": "schema:recommendationStrength" },
		"recommendedIntake": { "@id": "schema:recommendedIntake" },
		"recordLabel": { "@id": "schema:recordLabel" },
		"recordedAs": { "@id": "schema:recordedAs" },
		"recordedAt": { "@id": "schema:recordedAt" },
		"recordedIn": { "@id": "schema:recordedIn" },
		"recordingOf": { "@id": "schema:recordingOf" },
		"recourseLoan": { "@id": "schema:recourseLoan" },
		"referenceQuantity": { "@id": "schema:referenceQuantity" },
		"referencesOrder": { "@id": "schema:referencesOrder" },
		"refundType": { "@id": "schema:refundType" },
		"regionDrained": { "@id": "schema:regionDrained" },
		"regionsAllowed": { "@id": "schema:regionsAllowed" },
		"relatedAnatomy": { "@id": "schema:relatedAnatomy" },
		"relatedCondition": { "@id": "schema:relatedCondition" },
		"relatedDrug": { "@id": "schema:relatedDrug" },
		"relatedLink": {
			"@id": "schema:relatedLink",
			"@type": "@id"
		},
		"relatedStructure": { "@id": "schema:relatedStructure" },
		"relatedTherapy": { "@id": "schema:relatedTherapy" },
		"relatedTo": { "@id": "schema:relatedTo" },
		"releaseDate": {
			"@id": "schema:releaseDate",
			"@type": "Date"
		},
		"releaseNotes": { "@id": "schema:releaseNotes" },
		"releaseOf": { "@id": "schema:releaseOf" },
		"releasedEvent": { "@id": "schema:releasedEvent" },
		"relevantOccupation": { "@id": "schema:relevantOccupation" },
		"relevantSpecialty": { "@id": "schema:relevantSpecialty" },
		"remainingAttendeeCapacity": { "@id": "schema:remainingAttendeeCapacity" },
		"renegotiableLoan": { "@id": "schema:renegotiableLoan" },
		"repeatCount": { "@id": "schema:repeatCount" },
		"repeatFrequency": { "@id": "schema:repeatFrequency" },
		"repetitions": { "@id": "schema:repetitions" },
		"replacee": { "@id": "schema:replacee" },
		"replacer": { "@id": "schema:replacer" },
		"replyToUrl": {
			"@id": "schema:replyToUrl",
			"@type": "@id"
		},
		"reportNumber": { "@id": "schema:reportNumber" },
		"representativeOfPage": { "@id": "schema:representativeOfPage" },
		"requiredCollateral": { "@id": "schema:requiredCollateral" },
		"requiredGender": { "@id": "schema:requiredGender" },
		"requiredMaxAge": { "@id": "schema:requiredMaxAge" },
		"requiredMinAge": { "@id": "schema:requiredMinAge" },
		"requiredQuantity": { "@id": "schema:requiredQuantity" },
		"requirements": { "@id": "schema:requirements" },
		"requiresSubscription": { "@id": "schema:requiresSubscription" },
		"reservationFor": { "@id": "schema:reservationFor" },
		"reservationId": { "@id": "schema:reservationId" },
		"reservationStatus": { "@id": "schema:reservationStatus" },
		"reservedTicket": { "@id": "schema:reservedTicket" },
		"responsibilities": { "@id": "schema:responsibilities" },
		"restPeriods": { "@id": "schema:restPeriods" },
		"restockingFee": { "@id": "schema:restockingFee" },
		"result": { "@id": "schema:result" },
		"resultComment": { "@id": "schema:resultComment" },
		"resultReview": { "@id": "schema:resultReview" },
		"returnFees": { "@id": "schema:returnFees" },
		"returnLabelSource": { "@id": "schema:returnLabelSource" },
		"returnMethod": { "@id": "schema:returnMethod" },
		"returnPolicyCategory": { "@id": "schema:returnPolicyCategory" },
		"returnPolicyCountry": { "@id": "schema:returnPolicyCountry" },
		"returnPolicySeasonalOverride": { "@id": "schema:returnPolicySeasonalOverride" },
		"returnShippingFeesAmount": { "@id": "schema:returnShippingFeesAmount" },
		"review": { "@id": "schema:review" },
		"reviewAspect": { "@id": "schema:reviewAspect" },
		"reviewBody": { "@id": "schema:reviewBody" },
		"reviewCount": { "@id": "schema:reviewCount" },
		"reviewRating": { "@id": "schema:reviewRating" },
		"reviewedBy": { "@id": "schema:reviewedBy" },
		"reviews": { "@id": "schema:reviews" },
		"riskFactor": { "@id": "schema:riskFactor" },
		"risks": { "@id": "schema:risks" },
		"roleName": { "@id": "schema:roleName" },
		"roofLoad": { "@id": "schema:roofLoad" },
		"rsvpResponse": { "@id": "schema:rsvpResponse" },
		"runsTo": { "@id": "schema:runsTo" },
		"runtime": { "@id": "schema:runtime" },
		"runtimePlatform": { "@id": "schema:runtimePlatform" },
		"rxcui": { "@id": "schema:rxcui" },
		"safetyConsideration": { "@id": "schema:safetyConsideration" },
		"salaryCurrency": { "@id": "schema:salaryCurrency" },
		"salaryUponCompletion": { "@id": "schema:salaryUponCompletion" },
		"sameAs": {
			"@id": "schema:sameAs",
			"@type": "@id"
		},
		"sampleType": { "@id": "schema:sampleType" },
		"saturatedFatContent": { "@id": "schema:saturatedFatContent" },
		"scheduleTimezone": { "@id": "schema:scheduleTimezone" },
		"scheduledPaymentDate": {
			"@id": "schema:scheduledPaymentDate",
			"@type": "Date"
		},
		"scheduledTime": {
			"@id": "schema:scheduledTime",
			"@type": "Date"
		},
		"schemaVersion": { "@id": "schema:schemaVersion" },
		"schoolClosuresInfo": {
			"@id": "schema:schoolClosuresInfo",
			"@type": "@id"
		},
		"screenCount": { "@id": "schema:screenCount" },
		"screenshot": {
			"@id": "schema:screenshot",
			"@type": "@id"
		},
		"sdDatePublished": {
			"@id": "schema:sdDatePublished",
			"@type": "Date"
		},
		"sdLicense": {
			"@id": "schema:sdLicense",
			"@type": "@id"
		},
		"sdPublisher": { "@id": "schema:sdPublisher" },
		"season": {
			"@id": "schema:season",
			"@type": "@id"
		},
		"seasonNumber": { "@id": "schema:seasonNumber" },
		"seasons": { "@id": "schema:seasons" },
		"seatNumber": { "@id": "schema:seatNumber" },
		"seatRow": { "@id": "schema:seatRow" },
		"seatSection": { "@id": "schema:seatSection" },
		"seatingCapacity": { "@id": "schema:seatingCapacity" },
		"seatingType": { "@id": "schema:seatingType" },
		"secondaryPrevention": { "@id": "schema:secondaryPrevention" },
		"securityClearanceRequirement": { "@id": "schema:securityClearanceRequirement" },
		"securityScreening": { "@id": "schema:securityScreening" },
		"seeks": { "@id": "schema:seeks" },
		"seller": { "@id": "schema:seller" },
		"sender": { "@id": "schema:sender" },
		"sensoryRequirement": { "@id": "schema:sensoryRequirement" },
		"sensoryUnit": { "@id": "schema:sensoryUnit" },
		"serialNumber": { "@id": "schema:serialNumber" },
		"seriousAdverseOutcome": { "@id": "schema:seriousAdverseOutcome" },
		"serverStatus": { "@id": "schema:serverStatus" },
		"servesCuisine": { "@id": "schema:servesCuisine" },
		"serviceArea": { "@id": "schema:serviceArea" },
		"serviceAudience": { "@id": "schema:serviceAudience" },
		"serviceLocation": { "@id": "schema:serviceLocation" },
		"serviceOperator": { "@id": "schema:serviceOperator" },
		"serviceOutput": { "@id": "schema:serviceOutput" },
		"servicePhone": { "@id": "schema:servicePhone" },
		"servicePostalAddress": { "@id": "schema:servicePostalAddress" },
		"serviceSmsNumber": { "@id": "schema:serviceSmsNumber" },
		"serviceType": { "@id": "schema:serviceType" },
		"serviceUrl": {
			"@id": "schema:serviceUrl",
			"@type": "@id"
		},
		"servingSize": { "@id": "schema:servingSize" },
		"sha256": { "@id": "schema:sha256" },
		"sharedContent": { "@id": "schema:sharedContent" },
		"shippingDestination": { "@id": "schema:shippingDestination" },
		"shippingDetails": { "@id": "schema:shippingDetails" },
		"shippingLabel": { "@id": "schema:shippingLabel" },
		"shippingOrigin": { "@id": "schema:shippingOrigin" },
		"shippingRate": { "@id": "schema:shippingRate" },
		"shippingSettingsLink": {
			"@id": "schema:shippingSettingsLink",
			"@type": "@id"
		},
		"sibling": { "@id": "schema:sibling" },
		"siblings": { "@id": "schema:siblings" },
		"signDetected": { "@id": "schema:signDetected" },
		"signOrSymptom": { "@id": "schema:signOrSymptom" },
		"significance": { "@id": "schema:significance" },
		"significantLink": {
			"@id": "schema:significantLink",
			"@type": "@id"
		},
		"significantLinks": {
			"@id": "schema:significantLinks",
			"@type": "@id"
		},
		"size": { "@id": "schema:size" },
		"sizeGroup": { "@id": "schema:sizeGroup" },
		"sizeSystem": { "@id": "schema:sizeSystem" },
		"skills": { "@id": "schema:skills" },
		"sku": { "@id": "schema:sku" },
		"slogan": { "@id": "schema:slogan" },
		"smiles": { "@id": "schema:smiles" },
		"smokingAllowed": { "@id": "schema:smokingAllowed" },
		"sodiumContent": { "@id": "schema:sodiumContent" },
		"softwareAddOn": { "@id": "schema:softwareAddOn" },
		"softwareHelp": { "@id": "schema:softwareHelp" },
		"softwareRequirements": { "@id": "schema:softwareRequirements" },
		"softwareVersion": { "@id": "schema:softwareVersion" },
		"sourceOrganization": { "@id": "schema:sourceOrganization" },
		"sourcedFrom": { "@id": "schema:sourcedFrom" },
		"spatial": { "@id": "schema:spatial" },
		"spatialCoverage": { "@id": "schema:spatialCoverage" },
		"speakable": {
			"@id": "schema:speakable",
			"@type": "@id"
		},
		"specialCommitments": { "@id": "schema:specialCommitments" },
		"specialOpeningHoursSpecification": { "@id": "schema:specialOpeningHoursSpecification" },
		"specialty": { "@id": "schema:specialty" },
		"speechToTextMarkup": { "@id": "schema:speechToTextMarkup" },
		"speed": { "@id": "schema:speed" },
		"spokenByCharacter": { "@id": "schema:spokenByCharacter" },
		"sponsor": { "@id": "schema:sponsor" },
		"sport": { "@id": "schema:sport" },
		"sportsActivityLocation": { "@id": "schema:sportsActivityLocation" },
		"sportsEvent": { "@id": "schema:sportsEvent" },
		"sportsTeam": { "@id": "schema:sportsTeam" },
		"spouse": { "@id": "schema:spouse" },
		"stage": { "@id": "schema:stage" },
		"stageAsNumber": { "@id": "schema:stageAsNumber" },
		"starRating": { "@id": "schema:starRating" },
		"startDate": {
			"@id": "schema:startDate",
			"@type": "Date"
		},
		"startOffset": { "@id": "schema:startOffset" },
		"startTime": { "@id": "schema:startTime" },
		"statType": { "@id": "schema:statType" },
		"status": { "@id": "schema:status" },
		"steeringPosition": { "@id": "schema:steeringPosition" },
		"step": { "@id": "schema:step" },
		"stepValue": { "@id": "schema:stepValue" },
		"steps": { "@id": "schema:steps" },
		"storageRequirements": { "@id": "schema:storageRequirements" },
		"streetAddress": { "@id": "schema:streetAddress" },
		"strengthUnit": { "@id": "schema:strengthUnit" },
		"strengthValue": { "@id": "schema:strengthValue" },
		"structuralClass": { "@id": "schema:structuralClass" },
		"study": { "@id": "schema:study" },
		"studyDesign": { "@id": "schema:studyDesign" },
		"studyLocation": { "@id": "schema:studyLocation" },
		"studySubject": { "@id": "schema:studySubject" },
		"stupidProperty": { "@id": "schema:stupidProperty" },
		"subEvent": { "@id": "schema:subEvent" },
		"subEvents": { "@id": "schema:subEvents" },
		"subOrganization": { "@id": "schema:subOrganization" },
		"subReservation": { "@id": "schema:subReservation" },
		"subStageSuffix": { "@id": "schema:subStageSuffix" },
		"subStructure": { "@id": "schema:subStructure" },
		"subTest": { "@id": "schema:subTest" },
		"subTrip": { "@id": "schema:subTrip" },
		"subjectOf": { "@id": "schema:subjectOf" },
		"subtitleLanguage": { "@id": "schema:subtitleLanguage" },
		"successorOf": { "@id": "schema:successorOf" },
		"sugarContent": { "@id": "schema:sugarContent" },
		"suggestedAge": { "@id": "schema:suggestedAge" },
		"suggestedAnswer": { "@id": "schema:suggestedAnswer" },
		"suggestedGender": { "@id": "schema:suggestedGender" },
		"suggestedMaxAge": { "@id": "schema:suggestedMaxAge" },
		"suggestedMeasurement": { "@id": "schema:suggestedMeasurement" },
		"suggestedMinAge": { "@id": "schema:suggestedMinAge" },
		"suitableForDiet": { "@id": "schema:suitableForDiet" },
		"superEvent": { "@id": "schema:superEvent" },
		"supersededBy": { "@id": "schema:supersededBy" },
		"supply": { "@id": "schema:supply" },
		"supplyTo": { "@id": "schema:supplyTo" },
		"supportingData": { "@id": "schema:supportingData" },
		"surface": { "@id": "schema:surface" },
		"syllabusSections": { "@id": "schema:syllabusSections" },
		"target": {
			"@id": "schema:target",
			"@type": "@id"
		},
		"targetCollection": { "@id": "schema:targetCollection" },
		"targetDescription": { "@id": "schema:targetDescription" },
		"targetName": { "@id": "schema:targetName" },
		"targetPlatform": { "@id": "schema:targetPlatform" },
		"targetPopulation": { "@id": "schema:targetPopulation" },
		"targetProduct": { "@id": "schema:targetProduct" },
		"targetUrl": {
			"@id": "schema:targetUrl",
			"@type": "@id"
		},
		"taxID": { "@id": "schema:taxID" },
		"taxonRank": { "@id": "schema:taxonRank" },
		"taxonomicRange": { "@id": "schema:taxonomicRange" },
		"teaches": { "@id": "schema:teaches" },
		"telephone": { "@id": "schema:telephone" },
		"temporal": { "@id": "schema:temporal" },
		"temporalCoverage": { "@id": "schema:temporalCoverage" },
		"termCode": { "@id": "schema:termCode" },
		"termDuration": { "@id": "schema:termDuration" },
		"termsOfService": { "@id": "schema:termsOfService" },
		"termsPerYear": { "@id": "schema:termsPerYear" },
		"text": { "@id": "schema:text" },
		"textValue": { "@id": "schema:textValue" },
		"thumbnail": { "@id": "schema:thumbnail" },
		"thumbnailUrl": {
			"@id": "schema:thumbnailUrl",
			"@type": "@id"
		},
		"tickerSymbol": { "@id": "schema:tickerSymbol" },
		"ticketNumber": { "@id": "schema:ticketNumber" },
		"ticketToken": { "@id": "schema:ticketToken" },
		"ticketedSeat": { "@id": "schema:ticketedSeat" },
		"timeOfDay": { "@id": "schema:timeOfDay" },
		"timeRequired": { "@id": "schema:timeRequired" },
		"timeToComplete": { "@id": "schema:timeToComplete" },
		"tissueSample": { "@id": "schema:tissueSample" },
		"title": { "@id": "schema:title" },
		"titleEIDR": { "@id": "schema:titleEIDR" },
		"toLocation": { "@id": "schema:toLocation" },
		"toRecipient": { "@id": "schema:toRecipient" },
		"tocContinuation": { "@id": "schema:tocContinuation" },
		"tocEntry": { "@id": "schema:tocEntry" },
		"tongueWeight": { "@id": "schema:tongueWeight" },
		"tool": { "@id": "schema:tool" },
		"torque": { "@id": "schema:torque" },
		"totalHistoricalEnrollment": { "@id": "schema:totalHistoricalEnrollment" },
		"totalJobOpenings": { "@id": "schema:totalJobOpenings" },
		"totalPaymentDue": { "@id": "schema:totalPaymentDue" },
		"totalPrice": { "@id": "schema:totalPrice" },
		"totalTime": { "@id": "schema:totalTime" },
		"tourBookingPage": {
			"@id": "schema:tourBookingPage",
			"@type": "@id"
		},
		"touristType": { "@id": "schema:touristType" },
		"track": { "@id": "schema:track" },
		"trackingNumber": { "@id": "schema:trackingNumber" },
		"trackingUrl": {
			"@id": "schema:trackingUrl",
			"@type": "@id"
		},
		"tracks": { "@id": "schema:tracks" },
		"trailer": { "@id": "schema:trailer" },
		"trailerWeight": { "@id": "schema:trailerWeight" },
		"trainName": { "@id": "schema:trainName" },
		"trainNumber": { "@id": "schema:trainNumber" },
		"trainingSalary": { "@id": "schema:trainingSalary" },
		"transFatContent": { "@id": "schema:transFatContent" },
		"transcript": { "@id": "schema:transcript" },
		"transitTime": { "@id": "schema:transitTime" },
		"transitTimeLabel": { "@id": "schema:transitTimeLabel" },
		"translationOfWork": { "@id": "schema:translationOfWork" },
		"translator": { "@id": "schema:translator" },
		"transmissionMethod": { "@id": "schema:transmissionMethod" },
		"travelBans": {
			"@id": "schema:travelBans",
			"@type": "@id"
		},
		"trialDesign": { "@id": "schema:trialDesign" },
		"tributary": { "@id": "schema:tributary" },
		"tripOrigin": { "@id": "schema:tripOrigin" },
		"typeOfBed": { "@id": "schema:typeOfBed" },
		"typeOfGood": { "@id": "schema:typeOfGood" },
		"typicalAgeRange": { "@id": "schema:typicalAgeRange" },
		"typicalCreditsPerTerm": { "@id": "schema:typicalCreditsPerTerm" },
		"typicalTest": { "@id": "schema:typicalTest" },
		"underName": { "@id": "schema:underName" },
		"unitCode": { "@id": "schema:unitCode" },
		"unitText": { "@id": "schema:unitText" },
		"unnamedSourcesPolicy": {
			"@id": "schema:unnamedSourcesPolicy",
			"@type": "@id"
		},
		"unsaturatedFatContent": { "@id": "schema:unsaturatedFatContent" },
		"uploadDate": {
			"@id": "schema:uploadDate",
			"@type": "Date"
		},
		"upvoteCount": { "@id": "schema:upvoteCount" },
		"url": {
			"@id": "schema:url",
			"@type": "@id"
		},
		"urlTemplate": { "@id": "schema:urlTemplate" },
		"usNPI": { "@id": "schema:usNPI" },
		"usageInfo": {
			"@id": "schema:usageInfo",
			"@type": "@id"
		},
		"usedToDiagnose": { "@id": "schema:usedToDiagnose" },
		"userInteractionCount": { "@id": "schema:userInteractionCount" },
		"usesDevice": { "@id": "schema:usesDevice" },
		"usesHealthPlanIdStandard": { "@id": "schema:usesHealthPlanIdStandard" },
		"utterances": { "@id": "schema:utterances" },
		"validFor": { "@id": "schema:validFor" },
		"validForMemberTier": { "@id": "schema:validForMemberTier" },
		"validFrom": {
			"@id": "schema:validFrom",
			"@type": "Date"
		},
		"validIn": { "@id": "schema:validIn" },
		"validThrough": {
			"@id": "schema:validThrough",
			"@type": "Date"
		},
		"validUntil": {
			"@id": "schema:validUntil",
			"@type": "Date"
		},
		"value": { "@id": "schema:value" },
		"valueAddedTaxIncluded": { "@id": "schema:valueAddedTaxIncluded" },
		"valueMaxLength": { "@id": "schema:valueMaxLength" },
		"valueMinLength": { "@id": "schema:valueMinLength" },
		"valueName": { "@id": "schema:valueName" },
		"valuePattern": { "@id": "schema:valuePattern" },
		"valueReference": { "@id": "schema:valueReference" },
		"valueRequired": { "@id": "schema:valueRequired" },
		"variableMeasured": { "@id": "schema:variableMeasured" },
		"variablesMeasured": { "@id": "schema:variablesMeasured" },
		"variantCover": { "@id": "schema:variantCover" },
		"variesBy": { "@id": "schema:variesBy" },
		"vatID": { "@id": "schema:vatID" },
		"vehicleConfiguration": { "@id": "schema:vehicleConfiguration" },
		"vehicleEngine": { "@id": "schema:vehicleEngine" },
		"vehicleIdentificationNumber": { "@id": "schema:vehicleIdentificationNumber" },
		"vehicleInteriorColor": { "@id": "schema:vehicleInteriorColor" },
		"vehicleInteriorType": { "@id": "schema:vehicleInteriorType" },
		"vehicleModelDate": {
			"@id": "schema:vehicleModelDate",
			"@type": "Date"
		},
		"vehicleSeatingCapacity": { "@id": "schema:vehicleSeatingCapacity" },
		"vehicleSpecialUsage": { "@id": "schema:vehicleSpecialUsage" },
		"vehicleTransmission": { "@id": "schema:vehicleTransmission" },
		"vendor": { "@id": "schema:vendor" },
		"verificationFactCheckingPolicy": {
			"@id": "schema:verificationFactCheckingPolicy",
			"@type": "@id"
		},
		"version": { "@id": "schema:version" },
		"video": { "@id": "schema:video" },
		"videoFormat": { "@id": "schema:videoFormat" },
		"videoFrameSize": { "@id": "schema:videoFrameSize" },
		"videoQuality": { "@id": "schema:videoQuality" },
		"volumeNumber": { "@id": "schema:volumeNumber" },
		"warning": { "@id": "schema:warning" },
		"warranty": { "@id": "schema:warranty" },
		"warrantyPromise": { "@id": "schema:warrantyPromise" },
		"warrantyScope": { "@id": "schema:warrantyScope" },
		"webCheckinTime": { "@id": "schema:webCheckinTime" },
		"webFeed": {
			"@id": "schema:webFeed",
			"@type": "@id"
		},
		"weight": { "@id": "schema:weight" },
		"weightTotal": { "@id": "schema:weightTotal" },
		"wheelbase": { "@id": "schema:wheelbase" },
		"width": { "@id": "schema:width" },
		"winner": { "@id": "schema:winner" },
		"wordCount": { "@id": "schema:wordCount" },
		"workExample": { "@id": "schema:workExample" },
		"workFeatured": { "@id": "schema:workFeatured" },
		"workHours": { "@id": "schema:workHours" },
		"workLocation": { "@id": "schema:workLocation" },
		"workPerformed": { "@id": "schema:workPerformed" },
		"workPresented": { "@id": "schema:workPresented" },
		"workTranslation": { "@id": "schema:workTranslation" },
		"workload": { "@id": "schema:workload" },
		"worksFor": { "@id": "schema:worksFor" },
		"worstRating": { "@id": "schema:worstRating" },
		"xpath": { "@id": "schema:xpath" },
		"yearBuilt": { "@id": "schema:yearBuilt" },
		"yearlyRevenue": { "@id": "schema:yearlyRevenue" },
		"yearsInOperation": { "@id": "schema:yearsInOperation" },
		"yield": { "@id": "schema:yield" }
	} },
	"https://gotosocial.org/ns": { "@context": {
		"gts": "https://gotosocial.org/ns#",
		"interactionPolicy": {
			"@id": "gts:interactionPolicy",
			"@type": "@id"
		},
		"canLike": {
			"@id": "gts:canLike",
			"@type": "@id"
		},
		"canReply": {
			"@id": "gts:canReply",
			"@type": "@id"
		},
		"canAnnounce": {
			"@id": "gts:canAnnounce",
			"@type": "@id"
		},
		"always": {
			"@id": "gts:always",
			"@type": "@id"
		},
		"approvalRequired": {
			"@id": "gts:approvalRequired",
			"@type": "@id"
		},
		"approvedBy": {
			"@id": "gts:approvedBy",
			"@type": "@id"
		}
	} },
	"https://w3id.org/fep/5711": { "@context": {
		"likesOf": {
			"@id": "https://w3id.org/fep/5711#likesOf",
			"@type": "@id"
		},
		"sharesOf": {
			"@id": "https://w3id.org/fep/5711#sharesOf",
			"@type": "@id"
		},
		"repliesOf": {
			"@id": "https://w3id.org/fep/5711#repliesOf",
			"@type": "@id"
		},
		"inboxOf": {
			"@id": "https://w3id.org/fep/5711#inboxOf",
			"@type": "@id"
		},
		"outboxOf": {
			"@id": "https://w3id.org/fep/5711#outboxOf",
			"@type": "@id"
		},
		"followersOf": {
			"@id": "https://w3id.org/fep/5711#followersOf",
			"@type": "@id"
		},
		"followingOf": {
			"@id": "https://w3id.org/fep/5711#followingOf",
			"@type": "@id"
		},
		"likedOf": {
			"@id": "https://w3id.org/fep/5711#likedOf",
			"@type": "@id"
		}
	} }
};
var contexts_default = preloadedContexts;

//#endregion
//#region src/runtime/link.ts
const parametersNeedLowerCase = ["rel", "type"];
const regexpLinkWhitespace = /[\n\r\s\t]/;
function validateURI(uri) {
	if (uri.includes("\n") || regexpLinkWhitespace.test(uri)) throw new SyntaxError(`\`${uri}\` is not a valid URI!`);
}
function* parseLinkFromString(input) {
	const inputFmt = input.replaceAll("\xA0", "").replaceAll("", "");
	for (let cursor = 0; cursor < inputFmt.length; cursor += 1) {
		while (regexpLinkWhitespace.test(inputFmt.charAt(cursor))) cursor += 1;
		if (inputFmt.charAt(cursor) !== "<") throw new SyntaxError(`Unexpected character \`${inputFmt.charAt(cursor)}\` at position ${cursor}; Expect character \`<\`!`);
		cursor += 1;
		const cursorEndUri = inputFmt.indexOf(">", cursor);
		if (cursorEndUri === -1) throw new SyntaxError(`Missing end of URI delimiter character \`>\` after position ${cursor}!`);
		if (cursorEndUri === cursor) throw new SyntaxError(`Missing URI at position ${cursor}!`);
		const uriSlice = inputFmt.slice(cursor, cursorEndUri);
		validateURI(uriSlice);
		const uri = decodeURI(uriSlice);
		const parameters = {};
		cursor = cursorEndUri + 1;
		while (regexpLinkWhitespace.test(inputFmt.charAt(cursor))) cursor += 1;
		if (cursor === inputFmt.length || inputFmt.charAt(cursor) === ",") {
			yield [uri, parameters];
			continue;
		}
		if (inputFmt.charAt(cursor) !== ";") throw new SyntaxError(`Unexpected character \`${inputFmt.charAt(cursor)}\` at position ${cursor}; Expect character \`;\`!`);
		cursor += 1;
		while (cursor < inputFmt.length) {
			while (regexpLinkWhitespace.test(inputFmt.charAt(cursor))) cursor += 1;
			const parameterKey = inputFmt.slice(cursor).match(/^[\w-]+\*?/)?.[0].toLowerCase();
			if (typeof parameterKey === "undefined") throw new SyntaxError(`Unexpected character \`${inputFmt.charAt(cursor)}\` at position ${cursor}; Expect a valid parameter key!`);
			cursor += parameterKey.length;
			while (regexpLinkWhitespace.test(inputFmt.charAt(cursor))) cursor += 1;
			if (cursor === inputFmt.length || inputFmt.charAt(cursor) === ",") {
				parameters[parameterKey] = "";
				break;
			}
			if (inputFmt.charAt(cursor) === ";") {
				parameters[parameterKey] = "";
				cursor += 1;
				continue;
			}
			if (inputFmt.charAt(cursor) !== "=") throw new SyntaxError(`Unexpected character \`${inputFmt.charAt(cursor)}\` at position ${cursor}; Expect character \`=\`!`);
			cursor += 1;
			while (regexpLinkWhitespace.test(inputFmt.charAt(cursor))) cursor += 1;
			let parameterValue = "";
			if (inputFmt.charAt(cursor) === "\"") {
				cursor += 1;
				while (cursor < inputFmt.length) {
					if (inputFmt.charAt(cursor) === "\"") {
						cursor += 1;
						break;
					}
					if (inputFmt.charAt(cursor) === "\\") cursor += 1;
					parameterValue += inputFmt.charAt(cursor);
					cursor += 1;
				}
			} else {
				const cursorDiffParameterValue = inputFmt.slice(cursor).search(/[\s;,]/);
				if (cursorDiffParameterValue === -1) {
					parameterValue += inputFmt.slice(cursor);
					cursor += parameterValue.length;
				} else {
					parameterValue += inputFmt.slice(cursor, cursorDiffParameterValue);
					cursor += cursorDiffParameterValue;
				}
			}
			parameters[parameterKey] = parametersNeedLowerCase.includes(parameterKey) ? parameterValue.toLowerCase() : parameterValue;
			while (regexpLinkWhitespace.test(inputFmt.charAt(cursor))) cursor += 1;
			if (cursor === inputFmt.length || inputFmt.charAt(cursor) === ",") break;
			if (inputFmt.charAt(cursor) === ";") {
				cursor += 1;
				continue;
			}
			throw new SyntaxError(`Unexpected character \`${inputFmt.charAt(cursor)}\` at position ${cursor}; Expect character \`,\`, character \`;\`, or end of the string!`);
		}
		yield [uri, parameters];
	}
}
/**
* Handle the HTTP header `Link` according to the specification RFC 8288.
*/
var HttpHeaderLink = class HttpHeaderLink {
	get [Symbol.toStringTag]() {
		return "HTTPHeaderLink";
	}
	#entries = [];
	/**
	* Handle the HTTP header `Link` according to the specification RFC 8288.
	* @param {...(string | Headers | HttpHeaderLink | HttpHeaderLinkEntry[] | Response)} inputs Input.
	*/
	constructor(...inputs) {
		if (inputs.length > 0) this.add(...inputs);
	}
	/**
	* Add entries.
	* @param {...(string | Headers | HttpHeaderLink | HttpHeaderLinkEntry[] | Response)} inputs Input.
	* @returns {this}
	*/
	add(...inputs) {
		for (const input of inputs) if (input instanceof HttpHeaderLink) this.#entries.push(...structuredClone(input.#entries));
		else if (Array.isArray(input)) this.#entries.push(...input.map(([uri, parameters]) => {
			validateURI(uri);
			Object.entries(parameters).forEach(([key, value]) => {
				if (key !== key.toLowerCase() || !/^[\w-]+\*?$/.test(key)) throw new SyntaxError(`\`${key}\` is not a valid parameter key!`);
				if (parametersNeedLowerCase.includes(key) && value !== value.toLowerCase()) throw new SyntaxError(`\`${value}\` is not a valid parameter value!`);
			});
			return [uri, structuredClone(parameters)];
		}));
		else for (const entry of parseLinkFromString((input instanceof Headers || input instanceof Response ? (input instanceof Headers ? input : input.headers).get("Link") : input) ?? "")) this.#entries.push(entry);
		return this;
	}
	/**
	* Return all of the entries.
	* @returns {HttpHeaderLinkEntry[]} Entries.
	*/
	entries() {
		return structuredClone(this.#entries);
	}
	/**
	* Get entries by parameter.
	* @param {string} key Key of the parameter.
	* @param {string} value Value of the parameter.
	* @returns {HttpHeaderLinkEntry[]} Entries which match the parameter.
	*/
	getByParameter(key, value) {
		if (key !== key.toLowerCase()) throw new SyntaxError(`\`${key}\` is not a valid parameter key!`);
		if (key === "rel") return this.getByRel(value);
		return structuredClone(this.#entries.filter((entry) => {
			return entry[1][key] === value;
		}));
	}
	/**
	* Get entries by parameter `rel`.
	* @param {string} value Value of the parameter `rel`.
	* @returns {HttpHeaderLinkEntry[]} Entries which match the parameter.
	*/
	getByRel(value) {
		if (value !== value.toLowerCase()) throw new SyntaxError(`\`${value}\` is not a valid parameter \`rel\` value!`);
		return structuredClone(this.#entries.filter((entity) => {
			return entity[1].rel?.toLowerCase() === value;
		}));
	}
	/**
	* Whether have entries that match parameter.
	* @param {string} key Key of the parameter.
	* @param {string} value Value of the parameter.
	* @returns {boolean} Determine result.
	*/
	hasParameter(key, value) {
		return this.getByParameter(key, value).length > 0;
	}
	/**
	* Stringify entries.
	* @returns {string} Stringified entries.
	*/
	toString() {
		return this.#entries.map(([uri, parameters]) => {
			return [`<${encodeURI(uri)}>`, ...Object.entries(parameters).map(([key, value]) => {
				return value.length > 0 ? `${key}="${value.replaceAll("\"", "\\\"")}"` : key;
			})].join("; ");
		}).join(", ");
	}
	/**
	* Parse the HTTP header `Link` according to the specification RFC 8288.
	* @param {...(string | Headers | HttpHeaderLink | HttpHeaderLinkEntry[] | Response)} inputs Input.
	* @returns {HttpHeaderLink}
	*/
	static parse(...inputs) {
		return new this(...inputs);
	}
	/**
	* Stringify as the HTTP header `Link` according to the specification RFC 8288.
	* @param {...(string | Headers | HttpHeaderLink | HttpHeaderLinkEntry[] | Response)} inputs Input.
	* @returns {string}
	*/
	static stringify(...inputs) {
		return new this(...inputs).toString();
	}
};

//#endregion
//#region src/runtime/url.ts
var UrlError = class extends Error {
	constructor(message) {
		super(message);
		this.name = "UrlError";
	}
};
/**
* Validates a URL to prevent SSRF attacks.
*/
async function validatePublicUrl(url) {
	const parsed = new URL(url);
	if (parsed.protocol !== "http:" && parsed.protocol !== "https:") throw new UrlError(`Unsupported protocol: ${parsed.protocol}`);
	let hostname = parsed.hostname;
	if (hostname.startsWith("[") && hostname.endsWith("]")) hostname = hostname.substring(1, hostname.length - 2);
	if (hostname === "localhost") throw new UrlError("Localhost is not allowed");
	if ("Deno" in globalThis && !isIP(hostname)) {
		const netPermission = await Deno.permissions.query({ name: "net" });
		if (netPermission.state !== "granted") return;
	}
	if ("Bun" in globalThis) {
		if (hostname === "example.com" || hostname.endsWith(".example.com")) return;
		else if (hostname === "fedify-test.internal") throw new UrlError("Invalid or private address: fedify-test.internal");
	}
	let addresses;
	try {
		addresses = await lookup(hostname, { all: true });
	} catch {
		addresses = [];
	}
	for (const { address, family } of addresses) if (family === 4 && !isValidPublicIPv4Address(address) || family === 6 && !isValidPublicIPv6Address(address) || family < 4 || family === 5 || family > 6) throw new UrlError(`Invalid or private address: ${address}`);
}
function isValidPublicIPv4Address(address) {
	const parts = address.split(".");
	const first = parseInt(parts[0]);
	if (first === 0 || first === 10 || first === 127) return false;
	const second = parseInt(parts[1]);
	if (first === 169 && second === 254) return false;
	if (first === 172 && second >= 16 && second <= 31) return false;
	if (first === 192 && second === 168) return false;
	return true;
}
function isValidPublicIPv6Address(address) {
	address = expandIPv6Address(address);
	if (address.at(4) !== ":") return false;
	const firstWord = parseInt(address.substring(0, 4), 16);
	return !(firstWord >= 64512 && firstWord <= 65023 || firstWord >= 65152 && firstWord <= 65215 || firstWord === 0 || firstWord >= 65280);
}
function expandIPv6Address(address) {
	address = address.toLowerCase();
	if (address === "::") return "0000:0000:0000:0000:0000:0000:0000:0000";
	if (address.startsWith("::")) address = "0000" + address;
	if (address.endsWith("::")) address = address + "0000";
	address = address.replace("::", ":0000".repeat(8 - (address.match(/:/g) || []).length) + ":");
	const parts = address.split(":");
	return parts.map((part) => part.padStart(4, "0")).join(":");
}

//#endregion
//#region src/runtime/docloader.ts
const logger$1 = getLogger([
	"fedify",
	"runtime",
	"docloader"
]);
/**
* Error thrown when fetching a JSON-LD document failed.
*/
var FetchError = class extends Error {
	/**
	* The URL that failed to fetch.
	*/
	url;
	/**
	* Constructs a new `FetchError`.
	*
	* @param url The URL that failed to fetch.
	* @param message Error message.
	*/
	constructor(url, message) {
		super(message == null ? url.toString() : `${url}: ${message}`);
		this.name = "FetchError";
		this.url = typeof url === "string" ? new URL(url) : url;
	}
};
/**
* Creates a request for the given URL.
* @param url The URL to create the request for.
* @param options The options for the request.
* @returns The created request.
* @internal
*/
function createRequest(url, options = {}) {
	return new Request(url, {
		headers: {
			Accept: "application/activity+json, application/ld+json",
			"User-Agent": typeof options.userAgent === "string" ? options.userAgent : getUserAgent(options.userAgent)
		},
		redirect: "manual"
	});
}
/**
* Logs the request.
* @param request The request to log.
* @internal
*/
function logRequest(request) {
	logger$1.debug("Fetching document: {method} {url} {headers}", {
		method: request.method,
		url: request.url,
		headers: Object.fromEntries(request.headers.entries())
	});
}
/**
* Gets a {@link RemoteDocument} from the given response.
* @param url The URL of the document to load.
* @param response The response to get the document from.
* @param fetch The function to fetch the document.
* @returns The loaded remote document.
* @throws {FetchError} If the response is not OK.
* @internal
*/
async function getRemoteDocument(url, response, fetch$1) {
	const documentUrl = response.url === "" ? url : response.url;
	const docUrl = new URL(documentUrl);
	if (!response.ok) {
		logger$1.error("Failed to fetch document: {status} {url} {headers}", {
			status: response.status,
			url: documentUrl,
			headers: Object.fromEntries(response.headers.entries())
		});
		throw new FetchError(documentUrl, `HTTP ${response.status}: ${documentUrl}`);
	}
	const contentType = response.headers.get("Content-Type");
	const jsonLd = contentType == null || contentType === "application/activity+json" || contentType.startsWith("application/activity+json;") || contentType === "application/ld+json" || contentType.startsWith("application/ld+json;");
	const linkHeader = response.headers.get("Link");
	let contextUrl = null;
	if (linkHeader != null) {
		let link;
		try {
			link = new HttpHeaderLink(linkHeader);
		} catch (e) {
			if (e instanceof SyntaxError) link = new HttpHeaderLink();
			else throw e;
		}
		if (jsonLd) {
			const entries = link.getByRel("http://www.w3.org/ns/json-ld#context");
			for (const [uri, params] of entries) if ("type" in params && params.type === "application/ld+json") {
				contextUrl = uri;
				break;
			}
		} else {
			const entries = link.getByRel("alternate");
			for (const [uri, params] of entries) {
				const altUri = new URL(uri, docUrl);
				if ("type" in params && (params.type === "application/activity+json" || params.type === "application/ld+json" || params.type.startsWith("application/ld+json;")) && altUri.href !== docUrl.href) {
					logger$1.debug("Found alternate document: {alternateUrl} from {url}", {
						alternateUrl: altUri.href,
						url: documentUrl
					});
					return await fetch$1(altUri.href);
				}
			}
		}
	}
	let document;
	if (!jsonLd && (contentType === "text/html" || contentType?.startsWith("text/html;") || contentType === "application/xhtml+xml" || contentType?.startsWith("application/xhtml+xml;"))) {
		const MAX_HTML_SIZE = 1024 * 1024;
		const html = await response.text();
		if (html.length > MAX_HTML_SIZE) {
			logger$1.warn("HTML response too large, skipping alternate link discovery: {url}", {
				url: documentUrl,
				size: html.length
			});
			document = JSON.parse(html);
		} else {
			const tagPattern = /<(a|link)\s+([^>]*?)\s*\/?>/gi;
			const attrPattern = /([a-z][a-z:_-]*)=(?:"([^"]*)"|'([^']*)'|([^\s>]+))/gi;
			let tagMatch;
			while ((tagMatch = tagPattern.exec(html)) !== null) {
				const tagContent = tagMatch[2];
				let attrMatch;
				const attribs = {};
				attrPattern.lastIndex = 0;
				while ((attrMatch = attrPattern.exec(tagContent)) !== null) {
					const key = attrMatch[1].toLowerCase();
					const value = attrMatch[2] ?? attrMatch[3] ?? attrMatch[4] ?? "";
					attribs[key] = value;
				}
				if (attribs.rel === "alternate" && "type" in attribs && (attribs.type === "application/activity+json" || attribs.type === "application/ld+json" || attribs.type.startsWith("application/ld+json;")) && "href" in attribs && new URL(attribs.href, docUrl).href !== docUrl.href) {
					logger$1.debug("Found alternate document: {alternateUrl} from {url}", {
						alternateUrl: attribs.href,
						url: documentUrl
					});
					return await fetch$1(new URL(attribs.href, docUrl).href);
				}
			}
			document = JSON.parse(html);
		}
	} else document = await response.json();
	logger$1.debug("Fetched document: {status} {url} {headers}", {
		status: response.status,
		url: documentUrl,
		headers: Object.fromEntries(response.headers.entries())
	});
	return {
		contextUrl,
		document,
		documentUrl
	};
}
/**
* Creates a JSON-LD document loader that utilizes the browser's `fetch` API.
*
* The created loader preloads the below frequently used contexts by default
* (unless `options.ignorePreloadedContexts` is set to `true`):
*
* - <https://www.w3.org/ns/activitystreams>
* - <https://w3id.org/security/v1>
* - <https://w3id.org/security/data-integrity/v1>
* - <https://www.w3.org/ns/did/v1>
* - <https://w3id.org/security/multikey/v1>
* - <https://purl.archive.org/socialweb/webfinger>
* - <http://schema.org/>
* @param options Options for the document loader.
* @returns The document loader.
* @since 1.3.0
*/
function getDocumentLoader({ allowPrivateAddress, skipPreloadedContexts, userAgent } = {}) {
	const tracerProvider = trace.getTracerProvider();
	const tracer = tracerProvider.getTracer(deno_default.name, deno_default.version);
	async function load(url, options) {
		options?.signal?.throwIfAborted();
		if (!skipPreloadedContexts && url in contexts_default) {
			logger$1.debug("Using preloaded context: {url}.", { url });
			return {
				contextUrl: null,
				document: contexts_default[url],
				documentUrl: url
			};
		}
		if (!allowPrivateAddress) try {
			await validatePublicUrl(url);
		} catch (error) {
			if (error instanceof UrlError) logger$1.error("Disallowed private URL: {url}", {
				url,
				error
			});
			throw error;
		}
		return await tracer.startActiveSpan("activitypub.fetch_document", {
			kind: SpanKind.CLIENT,
			attributes: { "url.full": url }
		}, async (span) => {
			try {
				const request = createRequest(url, { userAgent });
				logRequest(request);
				const response = await fetch(request, {
					redirect: "manual",
					signal: options?.signal
				});
				span.setAttribute("http.response.status_code", response.status);
				if (response.status >= 300 && response.status < 400 && response.headers.has("Location")) {
					const redirectUrl = response.headers.get("Location");
					span.setAttribute("http.redirect.url", redirectUrl);
					return await load(redirectUrl, options);
				}
				const result = await getRemoteDocument(url, response, load);
				span.setAttribute("docloader.document_url", result.documentUrl);
				if (result.contextUrl != null) span.setAttribute("docloader.context_url", result.contextUrl);
				return result;
			} catch (error) {
				span.recordException(error);
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	return load;
}
const _fetchDocumentLoader = getDocumentLoader();
const _fetchDocumentLoader_allowPrivateAddress = getDocumentLoader({ allowPrivateAddress: true });
function fetchDocumentLoader(url, arg = false) {
	const allowPrivateAddress = typeof arg === "boolean" ? arg : false;
	logger$1.warn("fetchDocumentLoader() function is deprecated.  Use getDocumentLoader() function instead.");
	const loader = allowPrivateAddress ? _fetchDocumentLoader_allowPrivateAddress : _fetchDocumentLoader;
	return loader(url);
}
/**
* Decorates a {@link DocumentLoader} with a cache backed by a {@link Deno.Kv}.
* @param parameters The parameters for the cache.
* @returns The decorated document loader which is cache-enabled.
*/
function kvCache({ loader, kv, prefix, rules }) {
	const keyPrefix = prefix ?? ["_fedify", "remoteDocument"];
	rules ??= [[new URLPattern({}), Temporal.Duration.from({ minutes: 5 })]];
	for (const [p, duration] of rules) if (Temporal.Duration.compare(duration, { days: 30 }) > 0) throw new TypeError("The maximum cache duration is 30 days: " + (p instanceof URLPattern ? `${p.protocol}://${p.username}:${p.password}@${p.hostname}:${p.port}/${p.pathname}?${p.search}#${p.hash}` : p.toString()));
	function matchRule(url) {
		for (const [pattern, duration] of rules) {
			if (typeof pattern === "string") {
				if (url === pattern) return duration;
				continue;
			}
			if (pattern instanceof URL) {
				if (pattern.href == url) return duration;
				continue;
			}
			if (pattern.test(url)) return duration;
		}
		return null;
	}
	return async (url, options) => {
		if (url in contexts_default) {
			logger$1.debug("Using preloaded context: {url}.", { url });
			return {
				contextUrl: null,
				document: contexts_default[url],
				documentUrl: url
			};
		}
		const match = matchRule(url);
		if (match == null) return await loader(url, options);
		const key = [...keyPrefix, url];
		let cache = void 0;
		try {
			cache = await kv.get(key);
		} catch (error) {
			if (error instanceof Error) logger$1.warn("Failed to get the document of {url} from the KV cache: {error}", {
				url,
				error
			});
		}
		if (cache == null) {
			const remoteDoc = await loader(url, options);
			try {
				await kv.set(key, remoteDoc, { ttl: match });
			} catch (error) {
				logger$1.warn("Failed to save the document of {url} to the KV cache: {error}", {
					url,
					error
				});
			}
			return remoteDoc;
		}
		return cache;
	};
}
/**
* Gets the user agent string for the given application and URL.
* @param options The options for making the user agent string.
* @returns The user agent string.
* @since 1.3.0
*/
function getUserAgent({ software, url } = {}) {
	const fedify = `Fedify/${deno_default.version}`;
	const runtime = globalThis.Deno?.version?.deno != null ? `Deno/${Deno.version.deno}` : globalThis.process?.versions?.bun != null ? `Bun/${process.versions.bun}` : "navigator" in globalThis && navigator.userAgent === "Cloudflare-Workers" ? navigator.userAgent : globalThis.process?.versions?.node != null ? `Node.js/${process.versions.node}` : null;
	const userAgent = software == null ? [fedify] : [software, fedify];
	if (runtime != null) userAgent.push(runtime);
	if (url != null) userAgent.push(`+${url.toString()}`);
	const first = userAgent.shift();
	return `${first} (${userAgent.join("; ")})`;
}

//#endregion
//#region src/runtime/multibase/util.ts
const textDecoder = new TextDecoder();
const decodeText = (bytes) => textDecoder.decode(bytes);
const textEncoder = new TextEncoder();
const encodeText = (text) => textEncoder.encode(text);
function concat(arrs, length) {
	const output = new Uint8Array(length);
	let offset = 0;
	for (const arr of arrs) {
		output.set(arr, offset);
		offset += arr.length;
	}
	return output;
}

//#endregion
//#region src/runtime/multibase/base.ts
/**
* Class to encode/decode in the supported Bases
*/
var Base = class {
	codeBuf;
	codec;
	constructor(name$1, code, factory, alphabet) {
		this.name = name$1;
		this.code = code;
		this.alphabet = alphabet;
		this.codeBuf = encodeText(this.code);
		this.alphabet = alphabet;
		this.codec = factory(alphabet);
	}
	encode(buf) {
		return this.codec.encode(buf);
	}
	decode(string) {
		for (const char of string) if (this.alphabet && this.alphabet.indexOf(char) < 0) throw new Error(`invalid character '${char}' in '${string}'`);
		return this.codec.decode(string);
	}
};

//#endregion
//#region src/runtime/multibase/rfc4648.ts
const decode$1 = (string, alphabet, bitsPerChar) => {
	const codes$1 = {};
	for (let i = 0; i < alphabet.length; ++i) codes$1[alphabet[i]] = i;
	let end = string.length;
	while (string[end - 1] === "=") --end;
	const out = new Uint8Array(end * bitsPerChar / 8 | 0);
	let bits = 0;
	let buffer = 0;
	let written = 0;
	for (let i = 0; i < end; ++i) {
		const value = codes$1[string[i]];
		if (value === void 0) throw new SyntaxError("Invalid character " + string[i]);
		buffer = buffer << bitsPerChar | value;
		bits += bitsPerChar;
		if (bits >= 8) {
			bits -= 8;
			out[written++] = 255 & buffer >> bits;
		}
	}
	if (bits >= bitsPerChar || 255 & buffer << 8 - bits) throw new SyntaxError("Unexpected end of data");
	return out;
};
const encode$1 = (data, alphabet, bitsPerChar) => {
	const pad = alphabet[alphabet.length - 1] === "=";
	const mask = (1 << bitsPerChar) - 1;
	let out = "";
	let bits = 0;
	let buffer = 0;
	for (let i = 0; i < data.length; ++i) {
		buffer = buffer << 8 | data[i];
		bits += 8;
		while (bits > bitsPerChar) {
			bits -= bitsPerChar;
			out += alphabet[mask & buffer >> bits];
		}
	}
	if (bits) out += alphabet[mask & buffer << bitsPerChar - bits];
	if (pad) while (out.length * bitsPerChar & 7) out += "=";
	return out;
};
/**
* RFC4648 Factory
*/
const rfc4648 = (bitsPerChar) => (alphabet) => {
	return {
		encode(input) {
			return encode$1(input, alphabet, bitsPerChar);
		},
		decode(input) {
			return decode$1(input, alphabet, bitsPerChar);
		}
	};
};

//#endregion
//#region src/runtime/multibase/constants.ts
const identity = () => {
	return {
		encode: decodeText,
		decode: encodeText
	};
};
/**
* name, code, implementation, alphabet
*
* @type {Array<[BaseName, BaseCode, CodecFactory, string]>}
*/
const constants = [
	[
		"identity",
		"\0",
		identity,
		""
	],
	[
		"base2",
		"0",
		rfc4648(1),
		"01"
	],
	[
		"base8",
		"7",
		rfc4648(3),
		"01234567"
	],
	[
		"base10",
		"9",
		baseX,
		"0123456789"
	],
	[
		"base16",
		"f",
		rfc4648(4),
		"0123456789abcdef"
	],
	[
		"base16upper",
		"F",
		rfc4648(4),
		"0123456789ABCDEF"
	],
	[
		"base32hex",
		"v",
		rfc4648(5),
		"0123456789abcdefghijklmnopqrstuv"
	],
	[
		"base32hexupper",
		"V",
		rfc4648(5),
		"0123456789ABCDEFGHIJKLMNOPQRSTUV"
	],
	[
		"base32hexpad",
		"t",
		rfc4648(5),
		"0123456789abcdefghijklmnopqrstuv="
	],
	[
		"base32hexpadupper",
		"T",
		rfc4648(5),
		"0123456789ABCDEFGHIJKLMNOPQRSTUV="
	],
	[
		"base32",
		"b",
		rfc4648(5),
		"abcdefghijklmnopqrstuvwxyz234567"
	],
	[
		"base32upper",
		"B",
		rfc4648(5),
		"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"
	],
	[
		"base32pad",
		"c",
		rfc4648(5),
		"abcdefghijklmnopqrstuvwxyz234567="
	],
	[
		"base32padupper",
		"C",
		rfc4648(5),
		"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567="
	],
	[
		"base32z",
		"h",
		rfc4648(5),
		"ybndrfg8ejkmcpqxot1uwisza345h769"
	],
	[
		"base36",
		"k",
		baseX,
		"0123456789abcdefghijklmnopqrstuvwxyz"
	],
	[
		"base36upper",
		"K",
		baseX,
		"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
	],
	[
		"base58btc",
		"z",
		baseX,
		"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
	],
	[
		"base58flickr",
		"Z",
		baseX,
		"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
	],
	[
		"base64",
		"m",
		rfc4648(6),
		"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
	],
	[
		"base64pad",
		"M",
		rfc4648(6),
		"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
	],
	[
		"base64url",
		"u",
		rfc4648(6),
		"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
	],
	[
		"base64urlpad",
		"U",
		rfc4648(6),
		"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_="
	]
];
const names = constants.reduce((prev, tupple) => {
	prev[tupple[0]] = new Base(tupple[0], tupple[1], tupple[2], tupple[3]);
	return prev;
}, {});
const codes = constants.reduce((prev, tupple) => {
	prev[tupple[1]] = names[tupple[0]];
	return prev;
}, {});

//#endregion
//#region src/runtime/multibase/index.ts
/**
* Encode data with the specified base and add the multibase prefix.
*
* @throws {Error} Will throw if the encoding is not supported
*/
function encode(nameOrCode, buf) {
	const enc = encoding(nameOrCode);
	const data = encodeText(enc.encode(buf));
	return concat([enc.codeBuf, data], enc.codeBuf.length + data.length);
}
/**
* Takes a Uint8Array or string encoded with multibase header, decodes it and
* returns the decoded buffer
*
* @throws {Error} Will throw if the encoding is not supported
*/
function decode(data) {
	if (data instanceof Uint8Array) data = decodeText(data);
	const prefix = data[0];
	if ([
		"f",
		"F",
		"v",
		"V",
		"t",
		"T",
		"b",
		"B",
		"c",
		"C",
		"h",
		"k",
		"K"
	].includes(prefix)) data = data.toLowerCase();
	const enc = encoding(data[0]);
	return enc.decode(data.substring(1));
}
/**
* Get the encoding by name or code
* @throws {Error} Will throw if the encoding is not supported
*/
function encoding(nameOrCode) {
	if (Object.prototype.hasOwnProperty.call(names, nameOrCode)) return names[nameOrCode];
	else if (Object.prototype.hasOwnProperty.call(codes, nameOrCode)) return codes[nameOrCode];
	else throw new Error(`Unsupported encoding: ${nameOrCode}`);
}

//#endregion
//#region src/runtime/key.ts
const algorithms = {
	"1.2.840.113549.1.1.1": {
		name: "RSASSA-PKCS1-v1_5",
		hash: "SHA-256"
	},
	"1.3.101.112": "Ed25519"
};
/**
* Imports a PEM-SPKI formatted public key.
* @param pem The PEM-SPKI formatted public key.
* @returns The imported public key.
* @throws {TypeError} If the key is invalid or unsupported.
* @since 0.5.0
*/
async function importSpki(pem) {
	pem = pem.replace(/(?:-----(?:BEGIN|END) PUBLIC KEY-----|\s)/g, "");
	let spki;
	try {
		spki = decodeBase64(pem);
	} catch (_) {
		throw new TypeError("Invalid PEM-SPKI format.");
	}
	const pki = PublicKeyInfo.fromBER(spki);
	const oid = pki.algorithm.algorithmId;
	const algorithm = algorithms[oid];
	if (algorithm == null) throw new TypeError("Unsupported algorithm: " + oid);
	return await crypto.subtle.importKey("spki", spki, algorithm, true, ["verify"]);
}
/**
* Exports a public key in PEM-SPKI format.
* @param key The public key to export.
* @returns The exported public key in PEM-SPKI format.
* @throws {TypeError} If the key is invalid or unsupported.
* @since 0.5.0
*/
async function exportSpki(key) {
	const { validateCryptoKey } = await import("./key-Kt3kKq85.js");
	validateCryptoKey(key);
	const spki = await crypto.subtle.exportKey("spki", key);
	let pem = encodeBase64(spki);
	pem = (pem.match(/.{1,64}/g) || []).join("\n");
	return `-----BEGIN PUBLIC KEY-----\n${pem}\n-----END PUBLIC KEY-----\n`;
}
/**
* Imports a PEM-PKCS#1 formatted public key.
* @param pem The PEM-PKCS#1 formatted public key.
* @returns The imported public key.
* @throws {TypeError} If the key is invalid or unsupported.
* @since 1.5.0
*/
function importPkcs1(pem) {
	const key = createPublicKey({
		key: pem,
		format: "pem",
		type: "pkcs1"
	});
	const spki = key.export({
		type: "spki",
		format: "pem"
	});
	return importSpki(spki);
}
const PKCS1_HEADER = /^\s*-----BEGIN\s+RSA\s+PUBLIC\s+KEY-----\s*\n/;
/**
* Imports a PEM formatted public key (SPKI or PKCS#1).
* @param pem The PEM formatted public key to import (SPKI or PKCS#1).
* @returns The imported public key.
* @throws {TypeError} If the key is invalid or unsupported.
* @since 1.5.0
*/
function importPem(pem) {
	return PKCS1_HEADER.test(pem) ? importPkcs1(pem) : importSpki(pem);
}
/**
* Imports a [Multibase]-encoded public key.
*
* [Multibase]: https://www.w3.org/TR/vc-data-integrity/#multibase-0
* @param key The Multibase-encoded public key.
* @returns The imported public key.
* @throws {TypeError} If the key is invalid or unsupported.
* @since 0.10.0
*/
async function importMultibaseKey(key) {
	const decoded = decode(key);
	const code = getCodeFromData(decoded);
	const content = rmPrefix(decoded);
	if (code === 4613) {
		const keyObject = createPublicKey({
			key: content,
			format: "der",
			type: "pkcs1"
		});
		const exported = keyObject.export({
			type: "spki",
			format: "der"
		});
		const spki = exported instanceof Uint8Array ? exported : new Uint8Array(exported);
		return await crypto.subtle.importKey("spki", new Uint8Array(spki), {
			name: "RSASSA-PKCS1-v1_5",
			hash: "SHA-256"
		}, true, ["verify"]);
	} else if (code === 237) return await crypto.subtle.importKey("raw", content.slice(), "Ed25519", true, ["verify"]);
	else throw new TypeError("Unsupported key type: 0x" + code.toString(16));
}
/**
* Exports a public key in [Multibase] format.
*
* [Multibase]: https://www.w3.org/TR/vc-data-integrity/#multibase-0
* @param key The public key to export.
* @returns The exported public key in Multibase format.
* @throws {TypeError} If the key is invalid or unsupported.
* @since 0.10.0
*/
async function exportMultibaseKey(key) {
	let content;
	let code;
	if (key.algorithm.name === "Ed25519") {
		content = await crypto.subtle.exportKey("raw", key);
		code = 237;
	} else if (key.algorithm.name === "RSASSA-PKCS1-v1_5" && key.algorithm.hash.name === "SHA-256") {
		const jwk = await crypto.subtle.exportKey("jwk", key);
		const decodedN = decodeBase64Url(jwk.n);
		const n = new Uint8Array(decodedN.length + 1);
		n.set(decodedN, 1);
		const sequence = new Sequence({ value: [new Integer({
			isHexOnly: true,
			valueHex: n
		}), new Integer({
			isHexOnly: true,
			valueHex: decodeBase64Url(jwk.e)
		})] });
		content = sequence.toBER(false);
		code = 4613;
	} else throw new TypeError("Unsupported key type: " + JSON.stringify(key.algorithm));
	const codeHex = code.toString(16);
	const codeBytes = decodeHex(codeHex.length % 2 < 1 ? codeHex : "0" + codeHex);
	const prefixed = addPrefix(codeBytes, new Uint8Array(content));
	const encoded = encode("base58btc", prefixed);
	return new TextDecoder().decode(encoded);
}

//#endregion
//#region src/runtime/langstr.ts
/**
* A language-tagged string which corresponds to the `rdf:langString` type.
*/
var LanguageString = class extends String {
	language;
	/**
	* Constructs a new `LanguageString`.
	* @param value A string value written in the given language.
	* @param language The language of the string.  If a string is given, it will
	*                 be parsed as a `LanguageTag`.
	*/
	constructor(value, language) {
		super(value);
		this.language = typeof language === "string" ? parseLanguageTag(language) : language;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		return `<${this.language.compact()}> ${inspect(this.toString(), options)}`;
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		return `<${this.language.compact()}> ${inspect(this.toString(), options)}`;
	}
};

//#endregion
//#region src/vocab/vocab.ts
var vocab_exports = {};
__export(vocab_exports, {
	Accept: () => Accept,
	Activity: () => Activity,
	Add: () => Add,
	Announce: () => Announce,
	Application: () => Application,
	Arrive: () => Arrive,
	Article: () => Article,
	Audio: () => Audio,
	Block: () => Block,
	ChatMessage: () => ChatMessage,
	Collection: () => Collection,
	CollectionPage: () => CollectionPage,
	Create: () => Create,
	CryptographicKey: () => CryptographicKey,
	DataIntegrityProof: () => DataIntegrityProof,
	Delete: () => Delete,
	DidService: () => DidService,
	Dislike: () => Dislike,
	Document: () => Document,
	Emoji: () => Emoji,
	EmojiReact: () => EmojiReact,
	Endpoints: () => Endpoints,
	Event: () => Event,
	Export: () => Export,
	Flag: () => Flag,
	Follow: () => Follow,
	Group: () => Group,
	Hashtag: () => Hashtag,
	Ignore: () => Ignore,
	Image: () => Image,
	IntransitiveActivity: () => IntransitiveActivity,
	Invite: () => Invite,
	Join: () => Join,
	Leave: () => Leave,
	Like: () => Like,
	Link: () => Link,
	Listen: () => Listen,
	Mention: () => Mention,
	Move: () => Move,
	Multikey: () => Multikey,
	Note: () => Note,
	Object: () => Object$1,
	Offer: () => Offer,
	OrderedCollection: () => OrderedCollection,
	OrderedCollectionPage: () => OrderedCollectionPage,
	Organization: () => Organization,
	Page: () => Page,
	Person: () => Person,
	Place: () => Place,
	Profile: () => Profile,
	PropertyValue: () => PropertyValue,
	Question: () => Question,
	Read: () => Read,
	Reject: () => Reject,
	Relationship: () => Relationship,
	Remove: () => Remove,
	Service: () => Service,
	Source: () => Source,
	TentativeAccept: () => TentativeAccept,
	TentativeReject: () => TentativeReject,
	Tombstone: () => Tombstone,
	Travel: () => Travel,
	Undo: () => Undo,
	Update: () => Update,
	Video: () => Video,
	View: () => View
});
/** Describes an object of any kind. The Object type serves as the base type for
* most of the other kinds of objects defined in the Activity Vocabulary,
* including other Core types such as {@link Activity},
* {@link IntransitiveActivity}, {@link Collection} and
* {@link OrderedCollection}.
*/
var Object$1 = class Object$1 {
	#documentLoader;
	#contextLoader;
	#tracerProvider;
	#warning;
	#cachedJsonLd;
	id;
	get _documentLoader() {
		return this.#documentLoader;
	}
	get _contextLoader() {
		return this.#contextLoader;
	}
	get _tracerProvider() {
		return this.#tracerProvider;
	}
	get _warning() {
		return this.#warning;
	}
	get _cachedJsonLd() {
		return this.#cachedJsonLd;
	}
	set _cachedJsonLd(value) {
		this.#cachedJsonLd = value;
	}
	/**
	* The type URI of {@link Object}: `https://www.w3.org/ns/activitystreams#Object`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#Object");
	}
	#_49BipA5dq9eoH8LX8xdsVumveTca_attachment = [];
	#_trust_49BipA5dq9eoH8LX8xdsVumveTca_attachment = /* @__PURE__ */ new Set();
	#_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo = [];
	#_trust_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo = /* @__PURE__ */ new Set();
	#_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience = [];
	#_trust_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience = /* @__PURE__ */ new Set();
	#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content = [];
	#_3mhZzGXSpQ431mBSz2kvych22v4e_context = [];
	#_trust_3mhZzGXSpQ431mBSz2kvych22v4e_context = /* @__PURE__ */ new Set();
	#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name = [];
	#_219RwDanjScTv5tYCjwGZVCM7KZ9_endTime = [];
	#_86xFhmgBapoMvYqjbjRuDPayTrS_generator = [];
	#_trust_86xFhmgBapoMvYqjbjRuDPayTrS_generator = /* @__PURE__ */ new Set();
	#_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon = [];
	#_trust_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon = /* @__PURE__ */ new Set();
	#_3dXrUdkARxwyJLtJcYi1AJ92H41U_image = [];
	#_trust_3dXrUdkARxwyJLtJcYi1AJ92H41U_image = /* @__PURE__ */ new Set();
	#_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo = [];
	#_trust_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo = /* @__PURE__ */ new Set();
	#_31k5MUZJsnsPNg8dQQJieWaXTFnR_location = [];
	#_trust_31k5MUZJsnsPNg8dQQJieWaXTFnR_location = /* @__PURE__ */ new Set();
	#_gCVTegXxWWCw6wWRxa1QF65zusg_preview = [];
	#_trust_gCVTegXxWWCw6wWRxa1QF65zusg_preview = /* @__PURE__ */ new Set();
	#_5e258TDXtuhaFRPZiGoDfEpjdMr_published = [];
	#_7UpwM3JWcXhADcscukEehBorf6k_replies = [];
	#_trust_7UpwM3JWcXhADcscukEehBorf6k_replies = /* @__PURE__ */ new Set();
	#_3kAfck9PcEYt2L7xug5y99YPbANs_shares = [];
	#_trust_3kAfck9PcEYt2L7xug5y99YPbANs_shares = /* @__PURE__ */ new Set();
	#_S3ceDnpMdzoTRCccB9FkJWrEzYW_likes = [];
	#_trust_S3ceDnpMdzoTRCccB9FkJWrEzYW_likes = /* @__PURE__ */ new Set();
	#_kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions = [];
	#_trust_kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions = /* @__PURE__ */ new Set();
	#_2w3Jmue4up8iVDUA51WZqomEF438_startTime = [];
	#_4LqirZspQbFWWQEbFcXAxm7tTDN1_summary = [];
	#_5chuqj6s95p5gg2sk1HntGfarRf_tag = [];
	#_trust_5chuqj6s95p5gg2sk1HntGfarRf_tag = /* @__PURE__ */ new Set();
	#_385aB7ySixcf5Un6z3VsWmThgCzQ_updated = [];
	#_2oPEH9MQ3aj8JVwyYuWkqoVwV865_url = [];
	#_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to = [];
	#_trust_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to = /* @__PURE__ */ new Set();
	#_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto = [];
	#_trust_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto = /* @__PURE__ */ new Set();
	#_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc = [];
	#_trust_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc = /* @__PURE__ */ new Set();
	#_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc = [];
	#_trust_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc = /* @__PURE__ */ new Set();
	#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType = [];
	#_3bNvLMBN1bCJETiTihM3wvi1B2JX_duration = [];
	#_u8gdcDTtChQ4tbSQMXc4cYWyum7_sensitive = [];
	#_2ZwCFoS787v8y8bXKjMoE6MAbrEB_source = [];
	#_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof = [];
	#_trust_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof = /* @__PURE__ */ new Set();
	/**
	* Constructs a new instance of Object with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		this.#documentLoader = options.documentLoader;
		this.#contextLoader = options.contextLoader;
		this.#tracerProvider = options.tracerProvider;
		if ("$warning" in options) this.#warning = options.$warning;
		if (values.id == null || values.id instanceof URL) this.id = values.id ?? null;
		else throw new TypeError("The id must be a URL.");
		if ("attachments" in values && values.attachments != null) if (Array.isArray(values.attachments) && values.attachments.every((v) => v instanceof Object$1 || v instanceof Link || v instanceof PropertyValue || v instanceof URL)) {
			this.#_49BipA5dq9eoH8LX8xdsVumveTca_attachment = values.attachments;
			for (let i = 0; i < values.attachments.length; i++) this.#_trust_49BipA5dq9eoH8LX8xdsVumveTca_attachment.add(i);
		} else throw new TypeError("The attachments must be an array of type Object | Link | PropertyValue | URL.");
		if ("attribution" in values && values.attribution != null) if (values.attribution instanceof Application || values.attribution instanceof Group || values.attribution instanceof Organization || values.attribution instanceof Person || values.attribution instanceof Service || values.attribution instanceof URL) {
			this.#_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo = [values.attribution];
			this.#_trust_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo.add(0);
		} else throw new TypeError("The attribution must be of type Application | Group | Organization | Person | Service | URL.");
		if ("attributions" in values && values.attributions != null) {
			if ("attribution" in values && values.attribution != null) throw new TypeError("Cannot initialize both attribution and attributions at the same time.");
			if (Array.isArray(values.attributions) && values.attributions.every((v) => v instanceof Application || v instanceof Group || v instanceof Organization || v instanceof Person || v instanceof Service || v instanceof URL)) {
				this.#_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo = values.attributions;
				for (let i = 0; i < values.attributions.length; i++) this.#_trust_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo.add(i);
			} else throw new TypeError("The attributions must be an array of type Application | Group | Organization | Person | Service | URL.");
		}
		if ("audience" in values && values.audience != null) if (values.audience instanceof Object$1 || values.audience instanceof URL) {
			this.#_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience = [values.audience];
			this.#_trust_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience.add(0);
		} else throw new TypeError("The audience must be of type Object | URL.");
		if ("audiences" in values && values.audiences != null) {
			if ("audience" in values && values.audience != null) throw new TypeError("Cannot initialize both audience and audiences at the same time.");
			if (Array.isArray(values.audiences) && values.audiences.every((v) => v instanceof Object$1 || v instanceof URL)) {
				this.#_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience = values.audiences;
				for (let i = 0; i < values.audiences.length; i++) this.#_trust_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience.add(i);
			} else throw new TypeError("The audiences must be an array of type Object | URL.");
		}
		if ("content" in values && values.content != null) if (typeof values.content === "string" || values.content instanceof LanguageString) this.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content = [values.content];
		else throw new TypeError("The content must be of type string | LanguageString.");
		if ("contents" in values && values.contents != null) {
			if ("content" in values && values.content != null) throw new TypeError("Cannot initialize both content and contents at the same time.");
			if (Array.isArray(values.contents) && values.contents.every((v) => typeof v === "string" || v instanceof LanguageString)) this.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content = values.contents;
			else throw new TypeError("The contents must be an array of type string | LanguageString.");
		}
		if ("contexts" in values && values.contexts != null) if (Array.isArray(values.contexts) && values.contexts.every((v) => v instanceof Object$1 || v instanceof Link || v instanceof URL)) {
			this.#_3mhZzGXSpQ431mBSz2kvych22v4e_context = values.contexts;
			for (let i = 0; i < values.contexts.length; i++) this.#_trust_3mhZzGXSpQ431mBSz2kvych22v4e_context.add(i);
		} else throw new TypeError("The contexts must be an array of type Object | Link | URL.");
		if ("name" in values && values.name != null) if (typeof values.name === "string" || values.name instanceof LanguageString) this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name = [values.name];
		else throw new TypeError("The name must be of type string | LanguageString.");
		if ("names" in values && values.names != null) {
			if ("name" in values && values.name != null) throw new TypeError("Cannot initialize both name and names at the same time.");
			if (Array.isArray(values.names) && values.names.every((v) => typeof v === "string" || v instanceof LanguageString)) this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name = values.names;
			else throw new TypeError("The names must be an array of type string | LanguageString.");
		}
		if ("endTime" in values && values.endTime != null) if (values.endTime instanceof Temporal.Instant) this.#_219RwDanjScTv5tYCjwGZVCM7KZ9_endTime = [values.endTime];
		else throw new TypeError("The endTime must be of type Temporal.Instant.");
		if ("generators" in values && values.generators != null) if (Array.isArray(values.generators) && values.generators.every((v) => v instanceof Object$1 || v instanceof Link || v instanceof URL)) {
			this.#_86xFhmgBapoMvYqjbjRuDPayTrS_generator = values.generators;
			for (let i = 0; i < values.generators.length; i++) this.#_trust_86xFhmgBapoMvYqjbjRuDPayTrS_generator.add(i);
		} else throw new TypeError("The generators must be an array of type Object | Link | URL.");
		if ("icon" in values && values.icon != null) if (values.icon instanceof Image || values.icon instanceof URL) {
			this.#_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon = [values.icon];
			this.#_trust_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon.add(0);
		} else throw new TypeError("The icon must be of type Image | URL.");
		if ("icons" in values && values.icons != null) {
			if ("icon" in values && values.icon != null) throw new TypeError("Cannot initialize both icon and icons at the same time.");
			if (Array.isArray(values.icons) && values.icons.every((v) => v instanceof Image || v instanceof URL)) {
				this.#_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon = values.icons;
				for (let i = 0; i < values.icons.length; i++) this.#_trust_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon.add(i);
			} else throw new TypeError("The icons must be an array of type Image | URL.");
		}
		if ("image" in values && values.image != null) if (values.image instanceof Image || values.image instanceof URL) {
			this.#_3dXrUdkARxwyJLtJcYi1AJ92H41U_image = [values.image];
			this.#_trust_3dXrUdkARxwyJLtJcYi1AJ92H41U_image.add(0);
		} else throw new TypeError("The image must be of type Image | URL.");
		if ("images" in values && values.images != null) {
			if ("image" in values && values.image != null) throw new TypeError("Cannot initialize both image and images at the same time.");
			if (Array.isArray(values.images) && values.images.every((v) => v instanceof Image || v instanceof URL)) {
				this.#_3dXrUdkARxwyJLtJcYi1AJ92H41U_image = values.images;
				for (let i = 0; i < values.images.length; i++) this.#_trust_3dXrUdkARxwyJLtJcYi1AJ92H41U_image.add(i);
			} else throw new TypeError("The images must be an array of type Image | URL.");
		}
		if ("replyTarget" in values && values.replyTarget != null) if (values.replyTarget instanceof Object$1 || values.replyTarget instanceof Link || values.replyTarget instanceof URL) {
			this.#_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo = [values.replyTarget];
			this.#_trust_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo.add(0);
		} else throw new TypeError("The replyTarget must be of type Object | Link | URL.");
		if ("replyTargets" in values && values.replyTargets != null) {
			if ("replyTarget" in values && values.replyTarget != null) throw new TypeError("Cannot initialize both replyTarget and replyTargets at the same time.");
			if (Array.isArray(values.replyTargets) && values.replyTargets.every((v) => v instanceof Object$1 || v instanceof Link || v instanceof URL)) {
				this.#_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo = values.replyTargets;
				for (let i = 0; i < values.replyTargets.length; i++) this.#_trust_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo.add(i);
			} else throw new TypeError("The replyTargets must be an array of type Object | Link | URL.");
		}
		if ("location" in values && values.location != null) if (values.location instanceof Object$1 || values.location instanceof Link || values.location instanceof URL) {
			this.#_31k5MUZJsnsPNg8dQQJieWaXTFnR_location = [values.location];
			this.#_trust_31k5MUZJsnsPNg8dQQJieWaXTFnR_location.add(0);
		} else throw new TypeError("The location must be of type Object | Link | URL.");
		if ("locations" in values && values.locations != null) {
			if ("location" in values && values.location != null) throw new TypeError("Cannot initialize both location and locations at the same time.");
			if (Array.isArray(values.locations) && values.locations.every((v) => v instanceof Object$1 || v instanceof Link || v instanceof URL)) {
				this.#_31k5MUZJsnsPNg8dQQJieWaXTFnR_location = values.locations;
				for (let i = 0; i < values.locations.length; i++) this.#_trust_31k5MUZJsnsPNg8dQQJieWaXTFnR_location.add(i);
			} else throw new TypeError("The locations must be an array of type Object | Link | URL.");
		}
		if ("preview" in values && values.preview != null) if (values.preview instanceof Link || values.preview instanceof Object$1 || values.preview instanceof URL) {
			this.#_gCVTegXxWWCw6wWRxa1QF65zusg_preview = [values.preview];
			this.#_trust_gCVTegXxWWCw6wWRxa1QF65zusg_preview.add(0);
		} else throw new TypeError("The preview must be of type Link | Object | URL.");
		if ("previews" in values && values.previews != null) {
			if ("preview" in values && values.preview != null) throw new TypeError("Cannot initialize both preview and previews at the same time.");
			if (Array.isArray(values.previews) && values.previews.every((v) => v instanceof Link || v instanceof Object$1 || v instanceof URL)) {
				this.#_gCVTegXxWWCw6wWRxa1QF65zusg_preview = values.previews;
				for (let i = 0; i < values.previews.length; i++) this.#_trust_gCVTegXxWWCw6wWRxa1QF65zusg_preview.add(i);
			} else throw new TypeError("The previews must be an array of type Link | Object | URL.");
		}
		if ("published" in values && values.published != null) if (values.published instanceof Temporal.Instant) this.#_5e258TDXtuhaFRPZiGoDfEpjdMr_published = [values.published];
		else throw new TypeError("The published must be of type Temporal.Instant.");
		if ("replies" in values && values.replies != null) if (values.replies instanceof Collection || values.replies instanceof URL) {
			this.#_7UpwM3JWcXhADcscukEehBorf6k_replies = [values.replies];
			this.#_trust_7UpwM3JWcXhADcscukEehBorf6k_replies.add(0);
		} else throw new TypeError("The replies must be of type Collection | URL.");
		if ("shares" in values && values.shares != null) if (values.shares instanceof Collection || values.shares instanceof URL) {
			this.#_3kAfck9PcEYt2L7xug5y99YPbANs_shares = [values.shares];
			this.#_trust_3kAfck9PcEYt2L7xug5y99YPbANs_shares.add(0);
		} else throw new TypeError("The shares must be of type Collection | URL.");
		if ("likes" in values && values.likes != null) if (values.likes instanceof Collection || values.likes instanceof URL) {
			this.#_S3ceDnpMdzoTRCccB9FkJWrEzYW_likes = [values.likes];
			this.#_trust_S3ceDnpMdzoTRCccB9FkJWrEzYW_likes.add(0);
		} else throw new TypeError("The likes must be of type Collection | URL.");
		if ("emojiReactions" in values && values.emojiReactions != null) if (values.emojiReactions instanceof Collection || values.emojiReactions instanceof URL) {
			this.#_kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions = [values.emojiReactions];
			this.#_trust_kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions.add(0);
		} else throw new TypeError("The emojiReactions must be of type Collection | URL.");
		if ("startTime" in values && values.startTime != null) if (values.startTime instanceof Temporal.Instant) this.#_2w3Jmue4up8iVDUA51WZqomEF438_startTime = [values.startTime];
		else throw new TypeError("The startTime must be of type Temporal.Instant.");
		if ("summary" in values && values.summary != null) if (typeof values.summary === "string" || values.summary instanceof LanguageString) this.#_4LqirZspQbFWWQEbFcXAxm7tTDN1_summary = [values.summary];
		else throw new TypeError("The summary must be of type string | LanguageString.");
		if ("summaries" in values && values.summaries != null) {
			if ("summary" in values && values.summary != null) throw new TypeError("Cannot initialize both summary and summaries at the same time.");
			if (Array.isArray(values.summaries) && values.summaries.every((v) => typeof v === "string" || v instanceof LanguageString)) this.#_4LqirZspQbFWWQEbFcXAxm7tTDN1_summary = values.summaries;
			else throw new TypeError("The summaries must be an array of type string | LanguageString.");
		}
		if ("tags" in values && values.tags != null) if (Array.isArray(values.tags) && values.tags.every((v) => v instanceof Object$1 || v instanceof Link || v instanceof URL)) {
			this.#_5chuqj6s95p5gg2sk1HntGfarRf_tag = values.tags;
			for (let i = 0; i < values.tags.length; i++) this.#_trust_5chuqj6s95p5gg2sk1HntGfarRf_tag.add(i);
		} else throw new TypeError("The tags must be an array of type Object | Link | URL.");
		if ("updated" in values && values.updated != null) if (values.updated instanceof Temporal.Instant) this.#_385aB7ySixcf5Un6z3VsWmThgCzQ_updated = [values.updated];
		else throw new TypeError("The updated must be of type Temporal.Instant.");
		if ("url" in values && values.url != null) if (values.url instanceof URL || values.url instanceof Link) this.#_2oPEH9MQ3aj8JVwyYuWkqoVwV865_url = [values.url];
		else throw new TypeError("The url must be of type URL | Link.");
		if ("urls" in values && values.urls != null) {
			if ("url" in values && values.url != null) throw new TypeError("Cannot initialize both url and urls at the same time.");
			if (Array.isArray(values.urls) && values.urls.every((v) => v instanceof URL || v instanceof Link)) this.#_2oPEH9MQ3aj8JVwyYuWkqoVwV865_url = values.urls;
			else throw new TypeError("The urls must be an array of type URL | Link.");
		}
		if ("to" in values && values.to != null) if (values.to instanceof Object$1 || values.to instanceof URL) {
			this.#_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to = [values.to];
			this.#_trust_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to.add(0);
		} else throw new TypeError("The to must be of type Object | URL.");
		if ("tos" in values && values.tos != null) {
			if ("to" in values && values.to != null) throw new TypeError("Cannot initialize both to and tos at the same time.");
			if (Array.isArray(values.tos) && values.tos.every((v) => v instanceof Object$1 || v instanceof URL)) {
				this.#_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to = values.tos;
				for (let i = 0; i < values.tos.length; i++) this.#_trust_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to.add(i);
			} else throw new TypeError("The tos must be an array of type Object | URL.");
		}
		if ("bto" in values && values.bto != null) if (values.bto instanceof Object$1 || values.bto instanceof URL) {
			this.#_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto = [values.bto];
			this.#_trust_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto.add(0);
		} else throw new TypeError("The bto must be of type Object | URL.");
		if ("btos" in values && values.btos != null) {
			if ("bto" in values && values.bto != null) throw new TypeError("Cannot initialize both bto and btos at the same time.");
			if (Array.isArray(values.btos) && values.btos.every((v) => v instanceof Object$1 || v instanceof URL)) {
				this.#_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto = values.btos;
				for (let i = 0; i < values.btos.length; i++) this.#_trust_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto.add(i);
			} else throw new TypeError("The btos must be an array of type Object | URL.");
		}
		if ("cc" in values && values.cc != null) if (values.cc instanceof Object$1 || values.cc instanceof URL) {
			this.#_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc = [values.cc];
			this.#_trust_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc.add(0);
		} else throw new TypeError("The cc must be of type Object | URL.");
		if ("ccs" in values && values.ccs != null) {
			if ("cc" in values && values.cc != null) throw new TypeError("Cannot initialize both cc and ccs at the same time.");
			if (Array.isArray(values.ccs) && values.ccs.every((v) => v instanceof Object$1 || v instanceof URL)) {
				this.#_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc = values.ccs;
				for (let i = 0; i < values.ccs.length; i++) this.#_trust_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc.add(i);
			} else throw new TypeError("The ccs must be an array of type Object | URL.");
		}
		if ("bcc" in values && values.bcc != null) if (values.bcc instanceof Object$1 || values.bcc instanceof URL) {
			this.#_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc = [values.bcc];
			this.#_trust_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc.add(0);
		} else throw new TypeError("The bcc must be of type Object | URL.");
		if ("bccs" in values && values.bccs != null) {
			if ("bcc" in values && values.bcc != null) throw new TypeError("Cannot initialize both bcc and bccs at the same time.");
			if (Array.isArray(values.bccs) && values.bccs.every((v) => v instanceof Object$1 || v instanceof URL)) {
				this.#_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc = values.bccs;
				for (let i = 0; i < values.bccs.length; i++) this.#_trust_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc.add(i);
			} else throw new TypeError("The bccs must be an array of type Object | URL.");
		}
		if ("mediaType" in values && values.mediaType != null) if (typeof values.mediaType === "string") this.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType = [values.mediaType];
		else throw new TypeError("The mediaType must be of type string.");
		if ("duration" in values && values.duration != null) if (values.duration instanceof Temporal.Duration) this.#_3bNvLMBN1bCJETiTihM3wvi1B2JX_duration = [values.duration];
		else throw new TypeError("The duration must be of type Temporal.Duration.");
		if ("sensitive" in values && values.sensitive != null) if (typeof values.sensitive === "boolean") this.#_u8gdcDTtChQ4tbSQMXc4cYWyum7_sensitive = [values.sensitive];
		else throw new TypeError("The sensitive must be of type boolean.");
		if ("source" in values && values.source != null) if (values.source instanceof Source) this.#_2ZwCFoS787v8y8bXKjMoE6MAbrEB_source = [values.source];
		else throw new TypeError("The source must be of type Source.");
		if ("proof" in values && values.proof != null) if (values.proof instanceof DataIntegrityProof || values.proof instanceof URL) {
			this.#_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof = [values.proof];
			this.#_trust_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof.add(0);
		} else throw new TypeError("The proof must be of type DataIntegrityProof | URL.");
		if ("proofs" in values && values.proofs != null) {
			if ("proof" in values && values.proof != null) throw new TypeError("Cannot initialize both proof and proofs at the same time.");
			if (Array.isArray(values.proofs) && values.proofs.every((v) => v instanceof DataIntegrityProof || v instanceof URL)) {
				this.#_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof = values.proofs;
				for (let i = 0; i < values.proofs.length; i++) this.#_trust_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof.add(i);
			} else throw new TypeError("The proofs must be an array of type DataIntegrityProof | URL.");
		}
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = new this.constructor({ id: values.id ?? this.id }, options);
		clone.#_49BipA5dq9eoH8LX8xdsVumveTca_attachment = this.#_49BipA5dq9eoH8LX8xdsVumveTca_attachment;
		clone.#_trust_49BipA5dq9eoH8LX8xdsVumveTca_attachment = new Set(this.#_trust_49BipA5dq9eoH8LX8xdsVumveTca_attachment);
		if ("attachments" in values && values.attachments != null) if (Array.isArray(values.attachments) && values.attachments.every((v) => v instanceof Object$1 || v instanceof Link || v instanceof PropertyValue || v instanceof URL)) {
			clone.#_49BipA5dq9eoH8LX8xdsVumveTca_attachment = values.attachments;
			clone.#_trust_49BipA5dq9eoH8LX8xdsVumveTca_attachment = /* @__PURE__ */ new Set();
			for (let i = 0; i < values.attachments.length; i++) clone.#_trust_49BipA5dq9eoH8LX8xdsVumveTca_attachment.add(i);
		} else throw new TypeError("The attachments must be an array of type Object | Link | PropertyValue | URL.");
		clone.#_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo = this.#_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo;
		clone.#_trust_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo = new Set(this.#_trust_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo);
		if ("attribution" in values && values.attribution != null) if (values.attribution instanceof Application || values.attribution instanceof Group || values.attribution instanceof Organization || values.attribution instanceof Person || values.attribution instanceof Service || values.attribution instanceof URL) {
			clone.#_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo = [values.attribution];
			clone.#_trust_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo = new Set([0]);
		} else throw new TypeError("The attribution must be of type Application | Group | Organization | Person | Service | URL.");
		if ("attributions" in values && values.attributions != null) {
			if ("attribution" in values && values.attribution != null) throw new TypeError("Cannot update both attribution and attributions at the same time.");
			if (Array.isArray(values.attributions) && values.attributions.every((v) => v instanceof Application || v instanceof Group || v instanceof Organization || v instanceof Person || v instanceof Service || v instanceof URL)) {
				clone.#_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo = values.attributions;
				clone.#_trust_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo = /* @__PURE__ */ new Set();
				for (let i = 0; i < values.attributions.length; i++) clone.#_trust_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo.add(i);
			} else throw new TypeError("The attributions must be an array of type Application | Group | Organization | Person | Service | URL.");
		}
		clone.#_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience = this.#_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience;
		clone.#_trust_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience = new Set(this.#_trust_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience);
		if ("audience" in values && values.audience != null) if (values.audience instanceof Object$1 || values.audience instanceof URL) {
			clone.#_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience = [values.audience];
			clone.#_trust_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience = new Set([0]);
		} else throw new TypeError("The audience must be of type Object | URL.");
		if ("audiences" in values && values.audiences != null) {
			if ("audience" in values && values.audience != null) throw new TypeError("Cannot update both audience and audiences at the same time.");
			if (Array.isArray(values.audiences) && values.audiences.every((v) => v instanceof Object$1 || v instanceof URL)) {
				clone.#_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience = values.audiences;
				clone.#_trust_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience = /* @__PURE__ */ new Set();
				for (let i = 0; i < values.audiences.length; i++) clone.#_trust_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience.add(i);
			} else throw new TypeError("The audiences must be an array of type Object | URL.");
		}
		clone.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content = this.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content;
		if ("content" in values && values.content != null) if (typeof values.content === "string" || values.content instanceof LanguageString) clone.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content = [values.content];
		else throw new TypeError("The content must be of type string | LanguageString.");
		if ("contents" in values && values.contents != null) {
			if ("content" in values && values.content != null) throw new TypeError("Cannot update both content and contents at the same time.");
			if (Array.isArray(values.contents) && values.contents.every((v) => typeof v === "string" || v instanceof LanguageString)) clone.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content = values.contents;
			else throw new TypeError("The contents must be an array of type string | LanguageString.");
		}
		clone.#_3mhZzGXSpQ431mBSz2kvych22v4e_context = this.#_3mhZzGXSpQ431mBSz2kvych22v4e_context;
		clone.#_trust_3mhZzGXSpQ431mBSz2kvych22v4e_context = new Set(this.#_trust_3mhZzGXSpQ431mBSz2kvych22v4e_context);
		if ("contexts" in values && values.contexts != null) if (Array.isArray(values.contexts) && values.contexts.every((v) => v instanceof Object$1 || v instanceof Link || v instanceof URL)) {
			clone.#_3mhZzGXSpQ431mBSz2kvych22v4e_context = values.contexts;
			clone.#_trust_3mhZzGXSpQ431mBSz2kvych22v4e_context = /* @__PURE__ */ new Set();
			for (let i = 0; i < values.contexts.length; i++) clone.#_trust_3mhZzGXSpQ431mBSz2kvych22v4e_context.add(i);
		} else throw new TypeError("The contexts must be an array of type Object | Link | URL.");
		clone.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name = this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name;
		if ("name" in values && values.name != null) if (typeof values.name === "string" || values.name instanceof LanguageString) clone.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name = [values.name];
		else throw new TypeError("The name must be of type string | LanguageString.");
		if ("names" in values && values.names != null) {
			if ("name" in values && values.name != null) throw new TypeError("Cannot update both name and names at the same time.");
			if (Array.isArray(values.names) && values.names.every((v) => typeof v === "string" || v instanceof LanguageString)) clone.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name = values.names;
			else throw new TypeError("The names must be an array of type string | LanguageString.");
		}
		clone.#_219RwDanjScTv5tYCjwGZVCM7KZ9_endTime = this.#_219RwDanjScTv5tYCjwGZVCM7KZ9_endTime;
		if ("endTime" in values && values.endTime != null) if (values.endTime instanceof Temporal.Instant) clone.#_219RwDanjScTv5tYCjwGZVCM7KZ9_endTime = [values.endTime];
		else throw new TypeError("The endTime must be of type Temporal.Instant.");
		clone.#_86xFhmgBapoMvYqjbjRuDPayTrS_generator = this.#_86xFhmgBapoMvYqjbjRuDPayTrS_generator;
		clone.#_trust_86xFhmgBapoMvYqjbjRuDPayTrS_generator = new Set(this.#_trust_86xFhmgBapoMvYqjbjRuDPayTrS_generator);
		if ("generators" in values && values.generators != null) if (Array.isArray(values.generators) && values.generators.every((v) => v instanceof Object$1 || v instanceof Link || v instanceof URL)) {
			clone.#_86xFhmgBapoMvYqjbjRuDPayTrS_generator = values.generators;
			clone.#_trust_86xFhmgBapoMvYqjbjRuDPayTrS_generator = /* @__PURE__ */ new Set();
			for (let i = 0; i < values.generators.length; i++) clone.#_trust_86xFhmgBapoMvYqjbjRuDPayTrS_generator.add(i);
		} else throw new TypeError("The generators must be an array of type Object | Link | URL.");
		clone.#_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon = this.#_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon;
		clone.#_trust_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon = new Set(this.#_trust_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon);
		if ("icon" in values && values.icon != null) if (values.icon instanceof Image || values.icon instanceof URL) {
			clone.#_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon = [values.icon];
			clone.#_trust_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon = new Set([0]);
		} else throw new TypeError("The icon must be of type Image | URL.");
		if ("icons" in values && values.icons != null) {
			if ("icon" in values && values.icon != null) throw new TypeError("Cannot update both icon and icons at the same time.");
			if (Array.isArray(values.icons) && values.icons.every((v) => v instanceof Image || v instanceof URL)) {
				clone.#_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon = values.icons;
				clone.#_trust_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon = /* @__PURE__ */ new Set();
				for (let i = 0; i < values.icons.length; i++) clone.#_trust_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon.add(i);
			} else throw new TypeError("The icons must be an array of type Image | URL.");
		}
		clone.#_3dXrUdkARxwyJLtJcYi1AJ92H41U_image = this.#_3dXrUdkARxwyJLtJcYi1AJ92H41U_image;
		clone.#_trust_3dXrUdkARxwyJLtJcYi1AJ92H41U_image = new Set(this.#_trust_3dXrUdkARxwyJLtJcYi1AJ92H41U_image);
		if ("image" in values && values.image != null) if (values.image instanceof Image || values.image instanceof URL) {
			clone.#_3dXrUdkARxwyJLtJcYi1AJ92H41U_image = [values.image];
			clone.#_trust_3dXrUdkARxwyJLtJcYi1AJ92H41U_image = new Set([0]);
		} else throw new TypeError("The image must be of type Image | URL.");
		if ("images" in values && values.images != null) {
			if ("image" in values && values.image != null) throw new TypeError("Cannot update both image and images at the same time.");
			if (Array.isArray(values.images) && values.images.every((v) => v instanceof Image || v instanceof URL)) {
				clone.#_3dXrUdkARxwyJLtJcYi1AJ92H41U_image = values.images;
				clone.#_trust_3dXrUdkARxwyJLtJcYi1AJ92H41U_image = /* @__PURE__ */ new Set();
				for (let i = 0; i < values.images.length; i++) clone.#_trust_3dXrUdkARxwyJLtJcYi1AJ92H41U_image.add(i);
			} else throw new TypeError("The images must be an array of type Image | URL.");
		}
		clone.#_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo = this.#_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo;
		clone.#_trust_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo = new Set(this.#_trust_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo);
		if ("replyTarget" in values && values.replyTarget != null) if (values.replyTarget instanceof Object$1 || values.replyTarget instanceof Link || values.replyTarget instanceof URL) {
			clone.#_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo = [values.replyTarget];
			clone.#_trust_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo = new Set([0]);
		} else throw new TypeError("The replyTarget must be of type Object | Link | URL.");
		if ("replyTargets" in values && values.replyTargets != null) {
			if ("replyTarget" in values && values.replyTarget != null) throw new TypeError("Cannot update both replyTarget and replyTargets at the same time.");
			if (Array.isArray(values.replyTargets) && values.replyTargets.every((v) => v instanceof Object$1 || v instanceof Link || v instanceof URL)) {
				clone.#_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo = values.replyTargets;
				clone.#_trust_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo = /* @__PURE__ */ new Set();
				for (let i = 0; i < values.replyTargets.length; i++) clone.#_trust_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo.add(i);
			} else throw new TypeError("The replyTargets must be an array of type Object | Link | URL.");
		}
		clone.#_31k5MUZJsnsPNg8dQQJieWaXTFnR_location = this.#_31k5MUZJsnsPNg8dQQJieWaXTFnR_location;
		clone.#_trust_31k5MUZJsnsPNg8dQQJieWaXTFnR_location = new Set(this.#_trust_31k5MUZJsnsPNg8dQQJieWaXTFnR_location);
		if ("location" in values && values.location != null) if (values.location instanceof Object$1 || values.location instanceof Link || values.location instanceof URL) {
			clone.#_31k5MUZJsnsPNg8dQQJieWaXTFnR_location = [values.location];
			clone.#_trust_31k5MUZJsnsPNg8dQQJieWaXTFnR_location = new Set([0]);
		} else throw new TypeError("The location must be of type Object | Link | URL.");
		if ("locations" in values && values.locations != null) {
			if ("location" in values && values.location != null) throw new TypeError("Cannot update both location and locations at the same time.");
			if (Array.isArray(values.locations) && values.locations.every((v) => v instanceof Object$1 || v instanceof Link || v instanceof URL)) {
				clone.#_31k5MUZJsnsPNg8dQQJieWaXTFnR_location = values.locations;
				clone.#_trust_31k5MUZJsnsPNg8dQQJieWaXTFnR_location = /* @__PURE__ */ new Set();
				for (let i = 0; i < values.locations.length; i++) clone.#_trust_31k5MUZJsnsPNg8dQQJieWaXTFnR_location.add(i);
			} else throw new TypeError("The locations must be an array of type Object | Link | URL.");
		}
		clone.#_gCVTegXxWWCw6wWRxa1QF65zusg_preview = this.#_gCVTegXxWWCw6wWRxa1QF65zusg_preview;
		clone.#_trust_gCVTegXxWWCw6wWRxa1QF65zusg_preview = new Set(this.#_trust_gCVTegXxWWCw6wWRxa1QF65zusg_preview);
		if ("preview" in values && values.preview != null) if (values.preview instanceof Link || values.preview instanceof Object$1 || values.preview instanceof URL) {
			clone.#_gCVTegXxWWCw6wWRxa1QF65zusg_preview = [values.preview];
			clone.#_trust_gCVTegXxWWCw6wWRxa1QF65zusg_preview = new Set([0]);
		} else throw new TypeError("The preview must be of type Link | Object | URL.");
		if ("previews" in values && values.previews != null) {
			if ("preview" in values && values.preview != null) throw new TypeError("Cannot update both preview and previews at the same time.");
			if (Array.isArray(values.previews) && values.previews.every((v) => v instanceof Link || v instanceof Object$1 || v instanceof URL)) {
				clone.#_gCVTegXxWWCw6wWRxa1QF65zusg_preview = values.previews;
				clone.#_trust_gCVTegXxWWCw6wWRxa1QF65zusg_preview = /* @__PURE__ */ new Set();
				for (let i = 0; i < values.previews.length; i++) clone.#_trust_gCVTegXxWWCw6wWRxa1QF65zusg_preview.add(i);
			} else throw new TypeError("The previews must be an array of type Link | Object | URL.");
		}
		clone.#_5e258TDXtuhaFRPZiGoDfEpjdMr_published = this.#_5e258TDXtuhaFRPZiGoDfEpjdMr_published;
		if ("published" in values && values.published != null) if (values.published instanceof Temporal.Instant) clone.#_5e258TDXtuhaFRPZiGoDfEpjdMr_published = [values.published];
		else throw new TypeError("The published must be of type Temporal.Instant.");
		clone.#_7UpwM3JWcXhADcscukEehBorf6k_replies = this.#_7UpwM3JWcXhADcscukEehBorf6k_replies;
		clone.#_trust_7UpwM3JWcXhADcscukEehBorf6k_replies = new Set(this.#_trust_7UpwM3JWcXhADcscukEehBorf6k_replies);
		if ("replies" in values && values.replies != null) if (values.replies instanceof Collection || values.replies instanceof URL) {
			clone.#_7UpwM3JWcXhADcscukEehBorf6k_replies = [values.replies];
			clone.#_trust_7UpwM3JWcXhADcscukEehBorf6k_replies = new Set([0]);
		} else throw new TypeError("The replies must be of type Collection | URL.");
		clone.#_3kAfck9PcEYt2L7xug5y99YPbANs_shares = this.#_3kAfck9PcEYt2L7xug5y99YPbANs_shares;
		clone.#_trust_3kAfck9PcEYt2L7xug5y99YPbANs_shares = new Set(this.#_trust_3kAfck9PcEYt2L7xug5y99YPbANs_shares);
		if ("shares" in values && values.shares != null) if (values.shares instanceof Collection || values.shares instanceof URL) {
			clone.#_3kAfck9PcEYt2L7xug5y99YPbANs_shares = [values.shares];
			clone.#_trust_3kAfck9PcEYt2L7xug5y99YPbANs_shares = new Set([0]);
		} else throw new TypeError("The shares must be of type Collection | URL.");
		clone.#_S3ceDnpMdzoTRCccB9FkJWrEzYW_likes = this.#_S3ceDnpMdzoTRCccB9FkJWrEzYW_likes;
		clone.#_trust_S3ceDnpMdzoTRCccB9FkJWrEzYW_likes = new Set(this.#_trust_S3ceDnpMdzoTRCccB9FkJWrEzYW_likes);
		if ("likes" in values && values.likes != null) if (values.likes instanceof Collection || values.likes instanceof URL) {
			clone.#_S3ceDnpMdzoTRCccB9FkJWrEzYW_likes = [values.likes];
			clone.#_trust_S3ceDnpMdzoTRCccB9FkJWrEzYW_likes = new Set([0]);
		} else throw new TypeError("The likes must be of type Collection | URL.");
		clone.#_kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions = this.#_kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions;
		clone.#_trust_kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions = new Set(this.#_trust_kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions);
		if ("emojiReactions" in values && values.emojiReactions != null) if (values.emojiReactions instanceof Collection || values.emojiReactions instanceof URL) {
			clone.#_kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions = [values.emojiReactions];
			clone.#_trust_kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions = new Set([0]);
		} else throw new TypeError("The emojiReactions must be of type Collection | URL.");
		clone.#_2w3Jmue4up8iVDUA51WZqomEF438_startTime = this.#_2w3Jmue4up8iVDUA51WZqomEF438_startTime;
		if ("startTime" in values && values.startTime != null) if (values.startTime instanceof Temporal.Instant) clone.#_2w3Jmue4up8iVDUA51WZqomEF438_startTime = [values.startTime];
		else throw new TypeError("The startTime must be of type Temporal.Instant.");
		clone.#_4LqirZspQbFWWQEbFcXAxm7tTDN1_summary = this.#_4LqirZspQbFWWQEbFcXAxm7tTDN1_summary;
		if ("summary" in values && values.summary != null) if (typeof values.summary === "string" || values.summary instanceof LanguageString) clone.#_4LqirZspQbFWWQEbFcXAxm7tTDN1_summary = [values.summary];
		else throw new TypeError("The summary must be of type string | LanguageString.");
		if ("summaries" in values && values.summaries != null) {
			if ("summary" in values && values.summary != null) throw new TypeError("Cannot update both summary and summaries at the same time.");
			if (Array.isArray(values.summaries) && values.summaries.every((v) => typeof v === "string" || v instanceof LanguageString)) clone.#_4LqirZspQbFWWQEbFcXAxm7tTDN1_summary = values.summaries;
			else throw new TypeError("The summaries must be an array of type string | LanguageString.");
		}
		clone.#_5chuqj6s95p5gg2sk1HntGfarRf_tag = this.#_5chuqj6s95p5gg2sk1HntGfarRf_tag;
		clone.#_trust_5chuqj6s95p5gg2sk1HntGfarRf_tag = new Set(this.#_trust_5chuqj6s95p5gg2sk1HntGfarRf_tag);
		if ("tags" in values && values.tags != null) if (Array.isArray(values.tags) && values.tags.every((v) => v instanceof Object$1 || v instanceof Link || v instanceof URL)) {
			clone.#_5chuqj6s95p5gg2sk1HntGfarRf_tag = values.tags;
			clone.#_trust_5chuqj6s95p5gg2sk1HntGfarRf_tag = /* @__PURE__ */ new Set();
			for (let i = 0; i < values.tags.length; i++) clone.#_trust_5chuqj6s95p5gg2sk1HntGfarRf_tag.add(i);
		} else throw new TypeError("The tags must be an array of type Object | Link | URL.");
		clone.#_385aB7ySixcf5Un6z3VsWmThgCzQ_updated = this.#_385aB7ySixcf5Un6z3VsWmThgCzQ_updated;
		if ("updated" in values && values.updated != null) if (values.updated instanceof Temporal.Instant) clone.#_385aB7ySixcf5Un6z3VsWmThgCzQ_updated = [values.updated];
		else throw new TypeError("The updated must be of type Temporal.Instant.");
		clone.#_2oPEH9MQ3aj8JVwyYuWkqoVwV865_url = this.#_2oPEH9MQ3aj8JVwyYuWkqoVwV865_url;
		if ("url" in values && values.url != null) if (values.url instanceof URL || values.url instanceof Link) clone.#_2oPEH9MQ3aj8JVwyYuWkqoVwV865_url = [values.url];
		else throw new TypeError("The url must be of type URL | Link.");
		if ("urls" in values && values.urls != null) {
			if ("url" in values && values.url != null) throw new TypeError("Cannot update both url and urls at the same time.");
			if (Array.isArray(values.urls) && values.urls.every((v) => v instanceof URL || v instanceof Link)) clone.#_2oPEH9MQ3aj8JVwyYuWkqoVwV865_url = values.urls;
			else throw new TypeError("The urls must be an array of type URL | Link.");
		}
		clone.#_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to = this.#_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to;
		clone.#_trust_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to = new Set(this.#_trust_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to);
		if ("to" in values && values.to != null) if (values.to instanceof Object$1 || values.to instanceof URL) {
			clone.#_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to = [values.to];
			clone.#_trust_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to = new Set([0]);
		} else throw new TypeError("The to must be of type Object | URL.");
		if ("tos" in values && values.tos != null) {
			if ("to" in values && values.to != null) throw new TypeError("Cannot update both to and tos at the same time.");
			if (Array.isArray(values.tos) && values.tos.every((v) => v instanceof Object$1 || v instanceof URL)) {
				clone.#_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to = values.tos;
				clone.#_trust_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to = /* @__PURE__ */ new Set();
				for (let i = 0; i < values.tos.length; i++) clone.#_trust_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to.add(i);
			} else throw new TypeError("The tos must be an array of type Object | URL.");
		}
		clone.#_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto = this.#_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto;
		clone.#_trust_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto = new Set(this.#_trust_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto);
		if ("bto" in values && values.bto != null) if (values.bto instanceof Object$1 || values.bto instanceof URL) {
			clone.#_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto = [values.bto];
			clone.#_trust_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto = new Set([0]);
		} else throw new TypeError("The bto must be of type Object | URL.");
		if ("btos" in values && values.btos != null) {
			if ("bto" in values && values.bto != null) throw new TypeError("Cannot update both bto and btos at the same time.");
			if (Array.isArray(values.btos) && values.btos.every((v) => v instanceof Object$1 || v instanceof URL)) {
				clone.#_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto = values.btos;
				clone.#_trust_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto = /* @__PURE__ */ new Set();
				for (let i = 0; i < values.btos.length; i++) clone.#_trust_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto.add(i);
			} else throw new TypeError("The btos must be an array of type Object | URL.");
		}
		clone.#_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc = this.#_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc;
		clone.#_trust_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc = new Set(this.#_trust_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc);
		if ("cc" in values && values.cc != null) if (values.cc instanceof Object$1 || values.cc instanceof URL) {
			clone.#_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc = [values.cc];
			clone.#_trust_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc = new Set([0]);
		} else throw new TypeError("The cc must be of type Object | URL.");
		if ("ccs" in values && values.ccs != null) {
			if ("cc" in values && values.cc != null) throw new TypeError("Cannot update both cc and ccs at the same time.");
			if (Array.isArray(values.ccs) && values.ccs.every((v) => v instanceof Object$1 || v instanceof URL)) {
				clone.#_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc = values.ccs;
				clone.#_trust_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc = /* @__PURE__ */ new Set();
				for (let i = 0; i < values.ccs.length; i++) clone.#_trust_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc.add(i);
			} else throw new TypeError("The ccs must be an array of type Object | URL.");
		}
		clone.#_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc = this.#_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc;
		clone.#_trust_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc = new Set(this.#_trust_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc);
		if ("bcc" in values && values.bcc != null) if (values.bcc instanceof Object$1 || values.bcc instanceof URL) {
			clone.#_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc = [values.bcc];
			clone.#_trust_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc = new Set([0]);
		} else throw new TypeError("The bcc must be of type Object | URL.");
		if ("bccs" in values && values.bccs != null) {
			if ("bcc" in values && values.bcc != null) throw new TypeError("Cannot update both bcc and bccs at the same time.");
			if (Array.isArray(values.bccs) && values.bccs.every((v) => v instanceof Object$1 || v instanceof URL)) {
				clone.#_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc = values.bccs;
				clone.#_trust_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc = /* @__PURE__ */ new Set();
				for (let i = 0; i < values.bccs.length; i++) clone.#_trust_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc.add(i);
			} else throw new TypeError("The bccs must be an array of type Object | URL.");
		}
		clone.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType = this.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType;
		if ("mediaType" in values && values.mediaType != null) if (typeof values.mediaType === "string") clone.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType = [values.mediaType];
		else throw new TypeError("The mediaType must be of type string.");
		clone.#_3bNvLMBN1bCJETiTihM3wvi1B2JX_duration = this.#_3bNvLMBN1bCJETiTihM3wvi1B2JX_duration;
		if ("duration" in values && values.duration != null) if (values.duration instanceof Temporal.Duration) clone.#_3bNvLMBN1bCJETiTihM3wvi1B2JX_duration = [values.duration];
		else throw new TypeError("The duration must be of type Temporal.Duration.");
		clone.#_u8gdcDTtChQ4tbSQMXc4cYWyum7_sensitive = this.#_u8gdcDTtChQ4tbSQMXc4cYWyum7_sensitive;
		if ("sensitive" in values && values.sensitive != null) if (typeof values.sensitive === "boolean") clone.#_u8gdcDTtChQ4tbSQMXc4cYWyum7_sensitive = [values.sensitive];
		else throw new TypeError("The sensitive must be of type boolean.");
		clone.#_2ZwCFoS787v8y8bXKjMoE6MAbrEB_source = this.#_2ZwCFoS787v8y8bXKjMoE6MAbrEB_source;
		if ("source" in values && values.source != null) if (values.source instanceof Source) clone.#_2ZwCFoS787v8y8bXKjMoE6MAbrEB_source = [values.source];
		else throw new TypeError("The source must be of type Source.");
		clone.#_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof = this.#_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof;
		clone.#_trust_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof = new Set(this.#_trust_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof);
		if ("proof" in values && values.proof != null) if (values.proof instanceof DataIntegrityProof || values.proof instanceof URL) {
			clone.#_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof = [values.proof];
			clone.#_trust_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof = new Set([0]);
		} else throw new TypeError("The proof must be of type DataIntegrityProof | URL.");
		if ("proofs" in values && values.proofs != null) {
			if ("proof" in values && values.proof != null) throw new TypeError("Cannot update both proof and proofs at the same time.");
			if (Array.isArray(values.proofs) && values.proofs.every((v) => v instanceof DataIntegrityProof || v instanceof URL)) {
				clone.#_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof = values.proofs;
				clone.#_trust_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof = /* @__PURE__ */ new Set();
				for (let i = 0; i < values.proofs.length; i++) clone.#_trust_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof.add(i);
			} else throw new TypeError("The proofs must be an array of type DataIntegrityProof | URL.");
		}
		return clone;
	}
	async #fetchAttachment(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#attachment_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #attachment_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Object$1.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Link.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await PropertyValue.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + [
			"https://www.w3.org/ns/activitystreams#Object",
			"https://www.w3.org/ns/activitystreams#Link",
			"http://schema.org#PropertyValue"
		].join(", "));
	}
	/**
	* Similar to
	* {@link Object.getAttachments},
	* but returns their `@id`s instead of the objects themselves.
	*/
	get attachmentIds() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		return this.#_49BipA5dq9eoH8LX8xdsVumveTca_attachment.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
	}
	/** Identifies a resource attached or related to an object that potentially
	* requires special handling.  The intent is to provide a model that is at
	* least semantically similar to attachments in email.
	*/
	async *getAttachments(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		const vs = this.#_49BipA5dq9eoH8LX8xdsVumveTca_attachment;
		for (let i = 0; i < vs.length; i++) {
			let v = vs[i];
			if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_49BipA5dq9eoH8LX8xdsVumveTca_attachment.has(i)) v = v.id;
			if (v instanceof URL) {
				const fetched = await this.#fetchAttachment(v, options);
				if (fetched == null) continue;
				vs[i] = fetched;
				this.#_trust_49BipA5dq9eoH8LX8xdsVumveTca_attachment.add(i);
				this._cachedJsonLd = void 0;
				yield fetched;
				continue;
			}
			if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "attachment" in this._cachedJsonLd) {
				const prop = this._cachedJsonLd["attachment"];
				const obj = Array.isArray(prop) ? prop[i] : prop;
				if (obj != null && typeof obj === "object" && "@context" in obj) v = await this.#attachment_fromJsonLd(obj, options);
			}
			if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_49BipA5dq9eoH8LX8xdsVumveTca_attachment.has(0)) {
				if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
				getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
					objectId: v.id.href,
					parentObjectId: this.id.href
				});
				continue;
			}
			yield v;
		}
	}
	async #fetchAttribution(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#attribution_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #attribution_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Application.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Group.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Organization.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Person.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Service.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + [
			"https://www.w3.org/ns/activitystreams#Application",
			"https://www.w3.org/ns/activitystreams#Group",
			"https://www.w3.org/ns/activitystreams#Organization",
			"https://www.w3.org/ns/activitystreams#Person",
			"https://www.w3.org/ns/activitystreams#Service"
		].join(", "));
	}
	/**
	* Similar to
	* {@link Object.getAttribution},
	* but returns its `@id` URL instead of the object itself.
	*/
	get attributionId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo.length < 1) return null;
		const v = this.#_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** Identifies one or more entities to which this object is attributed.
	* The attributed entities might not be Actors.  For instance,
	* an object might be attributed to the completion of another activity.
	*/
	async getAttribution(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo.length < 1) return null;
		let v = this.#_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchAttribution(v, options);
			if (fetched == null) return null;
			this.#_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo[0] = fetched;
			this.#_trust_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "attributedTo" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["attributedTo"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#attribution_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	/**
	* Similar to
	* {@link Object.getAttributions},
	* but returns their `@id`s instead of the objects themselves.
	*/
	get attributionIds() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		return this.#_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
	}
	/** Identifies one or more entities to which this object is attributed.
	* The attributed entities might not be Actors.  For instance,
	* an object might be attributed to the completion of another activity.
	*/
	async *getAttributions(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		const vs = this.#_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo;
		for (let i = 0; i < vs.length; i++) {
			let v = vs[i];
			if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo.has(i)) v = v.id;
			if (v instanceof URL) {
				const fetched = await this.#fetchAttribution(v, options);
				if (fetched == null) continue;
				vs[i] = fetched;
				this.#_trust_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo.add(i);
				this._cachedJsonLd = void 0;
				yield fetched;
				continue;
			}
			if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "attributedTo" in this._cachedJsonLd) {
				const prop = this._cachedJsonLd["attributedTo"];
				const obj = Array.isArray(prop) ? prop[i] : prop;
				if (obj != null && typeof obj === "object" && "@context" in obj) v = await this.#attribution_fromJsonLd(obj, options);
			}
			if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo.has(0)) {
				if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
				getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
					objectId: v.id.href,
					parentObjectId: this.id.href
				});
				continue;
			}
			yield v;
		}
	}
	async #fetchAudience(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#audience_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #audience_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Object$1.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Object"].join(", "));
	}
	/**
	* Similar to
	* {@link Object.getAudience},
	* but returns its `@id` URL instead of the object itself.
	*/
	get audienceId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience.length < 1) return null;
		const v = this.#_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** Identifies one or more entities that represent the total population of
	* entities for which the object can considered to be relevant.
	*/
	async getAudience(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience.length < 1) return null;
		let v = this.#_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchAudience(v, options);
			if (fetched == null) return null;
			this.#_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience[0] = fetched;
			this.#_trust_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "audience" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["audience"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#audience_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	/**
	* Similar to
	* {@link Object.getAudiences},
	* but returns their `@id`s instead of the objects themselves.
	*/
	get audienceIds() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		return this.#_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
	}
	/** Identifies one or more entities that represent the total population of
	* entities for which the object can considered to be relevant.
	*/
	async *getAudiences(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		const vs = this.#_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience;
		for (let i = 0; i < vs.length; i++) {
			let v = vs[i];
			if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience.has(i)) v = v.id;
			if (v instanceof URL) {
				const fetched = await this.#fetchAudience(v, options);
				if (fetched == null) continue;
				vs[i] = fetched;
				this.#_trust_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience.add(i);
				this._cachedJsonLd = void 0;
				yield fetched;
				continue;
			}
			if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "audience" in this._cachedJsonLd) {
				const prop = this._cachedJsonLd["audience"];
				const obj = Array.isArray(prop) ? prop[i] : prop;
				if (obj != null && typeof obj === "object" && "@context" in obj) v = await this.#audience_fromJsonLd(obj, options);
			}
			if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience.has(0)) {
				if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
				getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
					objectId: v.id.href,
					parentObjectId: this.id.href
				});
				continue;
			}
			yield v;
		}
	}
	/** The content or textual representation of the Object encoded as a JSON
	* string.  By default, the value of `content` is HTML.  The `mediaType`
	* property can be used in the object to indicate a different content type.
	*
	* The content MAY be expressed using multiple language-tagged values.
	*/
	get content() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content.length < 1) return null;
		return this.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content[0];
	}
	/** The content or textual representation of the Object encoded as a JSON
	* string.  By default, the value of `content` is HTML.  The `mediaType`
	* property can be used in the object to indicate a different content type.
	*
	* The content MAY be expressed using multiple language-tagged values.
	*/
	get contents() {
		return this.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content;
	}
	async #fetchContext(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#context_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #context_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Object$1.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Link.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Object", "https://www.w3.org/ns/activitystreams#Link"].join(", "));
	}
	/**
	* Similar to
	* {@link Object.getContexts},
	* but returns their `@id`s instead of the objects themselves.
	*/
	get contextIds() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		return this.#_3mhZzGXSpQ431mBSz2kvych22v4e_context.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
	}
	/** Identifies the context within which the object exists or an activity was
	* performed.
	*
	* The notion of "context" used is intentionally vague.  The intended function
	* is to serve as a means of grouping objects and activities that share
	* a common originating context or purpose.  An example could be all activities
	* relating to a common project or event.
	*/
	async *getContexts(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		const vs = this.#_3mhZzGXSpQ431mBSz2kvych22v4e_context;
		for (let i = 0; i < vs.length; i++) {
			let v = vs[i];
			if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_3mhZzGXSpQ431mBSz2kvych22v4e_context.has(i)) v = v.id;
			if (v instanceof URL) {
				const fetched = await this.#fetchContext(v, options);
				if (fetched == null) continue;
				vs[i] = fetched;
				this.#_trust_3mhZzGXSpQ431mBSz2kvych22v4e_context.add(i);
				this._cachedJsonLd = void 0;
				yield fetched;
				continue;
			}
			if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "context" in this._cachedJsonLd) {
				const prop = this._cachedJsonLd["context"];
				const obj = Array.isArray(prop) ? prop[i] : prop;
				if (obj != null && typeof obj === "object" && "@context" in obj) v = await this.#context_fromJsonLd(obj, options);
			}
			if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_3mhZzGXSpQ431mBSz2kvych22v4e_context.has(0)) {
				if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
				getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
					objectId: v.id.href,
					parentObjectId: this.id.href
				});
				continue;
			}
			yield v;
		}
	}
	/** A simple, human-readable, plain-text name for the object. HTML markup MUST
	* NOT be included. The name MAY be expressed using multiple language-tagged
	* values.
	*/
	get name() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name.length < 1) return null;
		return this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name[0];
	}
	/** A simple, human-readable, plain-text name for the object. HTML markup MUST
	* NOT be included. The name MAY be expressed using multiple language-tagged
	* values.
	*/
	get names() {
		return this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name;
	}
	/** The date and time describing the actual or expected ending time of
	* the object.  When used with an {@link Activity} object, for instance,
	* the `endTime`` property specifies the moment the activity concluded
	* or is expected to conclude.
	*/
	get endTime() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_219RwDanjScTv5tYCjwGZVCM7KZ9_endTime.length < 1) return null;
		return this.#_219RwDanjScTv5tYCjwGZVCM7KZ9_endTime[0];
	}
	async #fetchGenerator(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#generator_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #generator_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Object$1.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Link.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Object", "https://www.w3.org/ns/activitystreams#Link"].join(", "));
	}
	/**
	* Similar to
	* {@link Object.getGenerators},
	* but returns their `@id`s instead of the objects themselves.
	*/
	get generatorIds() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		return this.#_86xFhmgBapoMvYqjbjRuDPayTrS_generator.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
	}
	/** Identifies the entity (e.g. an application) that generated the object.
	*/
	async *getGenerators(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		const vs = this.#_86xFhmgBapoMvYqjbjRuDPayTrS_generator;
		for (let i = 0; i < vs.length; i++) {
			let v = vs[i];
			if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_86xFhmgBapoMvYqjbjRuDPayTrS_generator.has(i)) v = v.id;
			if (v instanceof URL) {
				const fetched = await this.#fetchGenerator(v, options);
				if (fetched == null) continue;
				vs[i] = fetched;
				this.#_trust_86xFhmgBapoMvYqjbjRuDPayTrS_generator.add(i);
				this._cachedJsonLd = void 0;
				yield fetched;
				continue;
			}
			if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "generator" in this._cachedJsonLd) {
				const prop = this._cachedJsonLd["generator"];
				const obj = Array.isArray(prop) ? prop[i] : prop;
				if (obj != null && typeof obj === "object" && "@context" in obj) v = await this.#generator_fromJsonLd(obj, options);
			}
			if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_86xFhmgBapoMvYqjbjRuDPayTrS_generator.has(0)) {
				if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
				getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
					objectId: v.id.href,
					parentObjectId: this.id.href
				});
				continue;
			}
			yield v;
		}
	}
	async #fetchIcon(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#icon_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #icon_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Image.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Image"].join(", "));
	}
	/**
	* Similar to
	* {@link Object.getIcon},
	* but returns its `@id` URL instead of the object itself.
	*/
	get iconId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon.length < 1) return null;
		const v = this.#_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** Indicates an entity that describes an icon for this object.
	* The image should have an aspect ratio of one (horizontal) to one
	* (vertical) and should be suitable for presentation at a small size.
	*/
	async getIcon(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon.length < 1) return null;
		let v = this.#_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchIcon(v, options);
			if (fetched == null) return null;
			this.#_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon[0] = fetched;
			this.#_trust_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "icon" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["icon"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#icon_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	/**
	* Similar to
	* {@link Object.getIcons},
	* but returns their `@id`s instead of the objects themselves.
	*/
	get iconIds() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		return this.#_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
	}
	/** Indicates an entity that describes an icon for this object.
	* The image should have an aspect ratio of one (horizontal) to one
	* (vertical) and should be suitable for presentation at a small size.
	*/
	async *getIcons(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		const vs = this.#_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon;
		for (let i = 0; i < vs.length; i++) {
			let v = vs[i];
			if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon.has(i)) v = v.id;
			if (v instanceof URL) {
				const fetched = await this.#fetchIcon(v, options);
				if (fetched == null) continue;
				vs[i] = fetched;
				this.#_trust_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon.add(i);
				this._cachedJsonLd = void 0;
				yield fetched;
				continue;
			}
			if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "icon" in this._cachedJsonLd) {
				const prop = this._cachedJsonLd["icon"];
				const obj = Array.isArray(prop) ? prop[i] : prop;
				if (obj != null && typeof obj === "object" && "@context" in obj) v = await this.#icon_fromJsonLd(obj, options);
			}
			if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon.has(0)) {
				if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
				getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
					objectId: v.id.href,
					parentObjectId: this.id.href
				});
				continue;
			}
			yield v;
		}
	}
	async #fetchImage(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#image_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #image_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Image.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Image"].join(", "));
	}
	/**
	* Similar to
	* {@link Object.getImage},
	* but returns its `@id` URL instead of the object itself.
	*/
	get imageId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3dXrUdkARxwyJLtJcYi1AJ92H41U_image.length < 1) return null;
		const v = this.#_3dXrUdkARxwyJLtJcYi1AJ92H41U_image[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** Indicates an entity that describes an image for this object.
	* Unlike the icon property, there are no aspect ratio or display size
	* limitations assumed.
	*/
	async getImage(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3dXrUdkARxwyJLtJcYi1AJ92H41U_image.length < 1) return null;
		let v = this.#_3dXrUdkARxwyJLtJcYi1AJ92H41U_image[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_3dXrUdkARxwyJLtJcYi1AJ92H41U_image.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchImage(v, options);
			if (fetched == null) return null;
			this.#_3dXrUdkARxwyJLtJcYi1AJ92H41U_image[0] = fetched;
			this.#_trust_3dXrUdkARxwyJLtJcYi1AJ92H41U_image.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "image" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["image"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#image_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_3dXrUdkARxwyJLtJcYi1AJ92H41U_image.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	/**
	* Similar to
	* {@link Object.getImages},
	* but returns their `@id`s instead of the objects themselves.
	*/
	get imageIds() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		return this.#_3dXrUdkARxwyJLtJcYi1AJ92H41U_image.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
	}
	/** Indicates an entity that describes an image for this object.
	* Unlike the icon property, there are no aspect ratio or display size
	* limitations assumed.
	*/
	async *getImages(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		const vs = this.#_3dXrUdkARxwyJLtJcYi1AJ92H41U_image;
		for (let i = 0; i < vs.length; i++) {
			let v = vs[i];
			if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_3dXrUdkARxwyJLtJcYi1AJ92H41U_image.has(i)) v = v.id;
			if (v instanceof URL) {
				const fetched = await this.#fetchImage(v, options);
				if (fetched == null) continue;
				vs[i] = fetched;
				this.#_trust_3dXrUdkARxwyJLtJcYi1AJ92H41U_image.add(i);
				this._cachedJsonLd = void 0;
				yield fetched;
				continue;
			}
			if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "image" in this._cachedJsonLd) {
				const prop = this._cachedJsonLd["image"];
				const obj = Array.isArray(prop) ? prop[i] : prop;
				if (obj != null && typeof obj === "object" && "@context" in obj) v = await this.#image_fromJsonLd(obj, options);
			}
			if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_3dXrUdkARxwyJLtJcYi1AJ92H41U_image.has(0)) {
				if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
				getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
					objectId: v.id.href,
					parentObjectId: this.id.href
				});
				continue;
			}
			yield v;
		}
	}
	async #fetchReplyTarget(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#replyTarget_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #replyTarget_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Object$1.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Link.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Object", "https://www.w3.org/ns/activitystreams#Link"].join(", "));
	}
	/**
	* Similar to
	* {@link Object.getReplyTarget},
	* but returns its `@id` URL instead of the object itself.
	*/
	get replyTargetId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo.length < 1) return null;
		const v = this.#_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** Indicates one or more entities for which this object is considered
	* a response.
	*/
	async getReplyTarget(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo.length < 1) return null;
		let v = this.#_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchReplyTarget(v, options);
			if (fetched == null) return null;
			this.#_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo[0] = fetched;
			this.#_trust_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "inReplyTo" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["inReplyTo"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#replyTarget_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	/**
	* Similar to
	* {@link Object.getReplyTargets},
	* but returns their `@id`s instead of the objects themselves.
	*/
	get replyTargetIds() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		return this.#_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
	}
	/** Indicates one or more entities for which this object is considered
	* a response.
	*/
	async *getReplyTargets(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		const vs = this.#_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo;
		for (let i = 0; i < vs.length; i++) {
			let v = vs[i];
			if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo.has(i)) v = v.id;
			if (v instanceof URL) {
				const fetched = await this.#fetchReplyTarget(v, options);
				if (fetched == null) continue;
				vs[i] = fetched;
				this.#_trust_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo.add(i);
				this._cachedJsonLd = void 0;
				yield fetched;
				continue;
			}
			if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "inReplyTo" in this._cachedJsonLd) {
				const prop = this._cachedJsonLd["inReplyTo"];
				const obj = Array.isArray(prop) ? prop[i] : prop;
				if (obj != null && typeof obj === "object" && "@context" in obj) v = await this.#replyTarget_fromJsonLd(obj, options);
			}
			if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo.has(0)) {
				if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
				getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
					objectId: v.id.href,
					parentObjectId: this.id.href
				});
				continue;
			}
			yield v;
		}
	}
	async #fetchLocation(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#location_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #location_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Object$1.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Link.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Object", "https://www.w3.org/ns/activitystreams#Link"].join(", "));
	}
	/**
	* Similar to
	* {@link Object.getLocation},
	* but returns its `@id` URL instead of the object itself.
	*/
	get locationId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_31k5MUZJsnsPNg8dQQJieWaXTFnR_location.length < 1) return null;
		const v = this.#_31k5MUZJsnsPNg8dQQJieWaXTFnR_location[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** Indicates one or more physical or logical locations associated with
	* the object.
	*/
	async getLocation(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_31k5MUZJsnsPNg8dQQJieWaXTFnR_location.length < 1) return null;
		let v = this.#_31k5MUZJsnsPNg8dQQJieWaXTFnR_location[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_31k5MUZJsnsPNg8dQQJieWaXTFnR_location.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchLocation(v, options);
			if (fetched == null) return null;
			this.#_31k5MUZJsnsPNg8dQQJieWaXTFnR_location[0] = fetched;
			this.#_trust_31k5MUZJsnsPNg8dQQJieWaXTFnR_location.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "location" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["location"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#location_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_31k5MUZJsnsPNg8dQQJieWaXTFnR_location.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	/**
	* Similar to
	* {@link Object.getLocations},
	* but returns their `@id`s instead of the objects themselves.
	*/
	get locationIds() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		return this.#_31k5MUZJsnsPNg8dQQJieWaXTFnR_location.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
	}
	/** Indicates one or more physical or logical locations associated with
	* the object.
	*/
	async *getLocations(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		const vs = this.#_31k5MUZJsnsPNg8dQQJieWaXTFnR_location;
		for (let i = 0; i < vs.length; i++) {
			let v = vs[i];
			if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_31k5MUZJsnsPNg8dQQJieWaXTFnR_location.has(i)) v = v.id;
			if (v instanceof URL) {
				const fetched = await this.#fetchLocation(v, options);
				if (fetched == null) continue;
				vs[i] = fetched;
				this.#_trust_31k5MUZJsnsPNg8dQQJieWaXTFnR_location.add(i);
				this._cachedJsonLd = void 0;
				yield fetched;
				continue;
			}
			if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "location" in this._cachedJsonLd) {
				const prop = this._cachedJsonLd["location"];
				const obj = Array.isArray(prop) ? prop[i] : prop;
				if (obj != null && typeof obj === "object" && "@context" in obj) v = await this.#location_fromJsonLd(obj, options);
			}
			if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_31k5MUZJsnsPNg8dQQJieWaXTFnR_location.has(0)) {
				if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
				getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
					objectId: v.id.href,
					parentObjectId: this.id.href
				});
				continue;
			}
			yield v;
		}
	}
	async #fetchPreview(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#preview_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #preview_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Link.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Object$1.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Link", "https://www.w3.org/ns/activitystreams#Object"].join(", "));
	}
	/**
	* Similar to
	* {@link Object.getPreview},
	* but returns its `@id` URL instead of the object itself.
	*/
	get previewId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_gCVTegXxWWCw6wWRxa1QF65zusg_preview.length < 1) return null;
		const v = this.#_gCVTegXxWWCw6wWRxa1QF65zusg_preview[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** Identifies an entity that provides a preview of this object.
	*/
	async getPreview(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_gCVTegXxWWCw6wWRxa1QF65zusg_preview.length < 1) return null;
		let v = this.#_gCVTegXxWWCw6wWRxa1QF65zusg_preview[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_gCVTegXxWWCw6wWRxa1QF65zusg_preview.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchPreview(v, options);
			if (fetched == null) return null;
			this.#_gCVTegXxWWCw6wWRxa1QF65zusg_preview[0] = fetched;
			this.#_trust_gCVTegXxWWCw6wWRxa1QF65zusg_preview.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "preview" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["preview"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#preview_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_gCVTegXxWWCw6wWRxa1QF65zusg_preview.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	/**
	* Similar to
	* {@link Object.getPreviews},
	* but returns their `@id`s instead of the objects themselves.
	*/
	get previewIds() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		return this.#_gCVTegXxWWCw6wWRxa1QF65zusg_preview.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
	}
	/** Identifies an entity that provides a preview of this object.
	*/
	async *getPreviews(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		const vs = this.#_gCVTegXxWWCw6wWRxa1QF65zusg_preview;
		for (let i = 0; i < vs.length; i++) {
			let v = vs[i];
			if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_gCVTegXxWWCw6wWRxa1QF65zusg_preview.has(i)) v = v.id;
			if (v instanceof URL) {
				const fetched = await this.#fetchPreview(v, options);
				if (fetched == null) continue;
				vs[i] = fetched;
				this.#_trust_gCVTegXxWWCw6wWRxa1QF65zusg_preview.add(i);
				this._cachedJsonLd = void 0;
				yield fetched;
				continue;
			}
			if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "preview" in this._cachedJsonLd) {
				const prop = this._cachedJsonLd["preview"];
				const obj = Array.isArray(prop) ? prop[i] : prop;
				if (obj != null && typeof obj === "object" && "@context" in obj) v = await this.#preview_fromJsonLd(obj, options);
			}
			if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_gCVTegXxWWCw6wWRxa1QF65zusg_preview.has(0)) {
				if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
				getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
					objectId: v.id.href,
					parentObjectId: this.id.href
				});
				continue;
			}
			yield v;
		}
	}
	/** The date and time at which the object was published.
	*/
	get published() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_5e258TDXtuhaFRPZiGoDfEpjdMr_published.length < 1) return null;
		return this.#_5e258TDXtuhaFRPZiGoDfEpjdMr_published[0];
	}
	async #fetchReplies(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#replies_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #replies_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Collection.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
	}
	/**
	* Similar to
	* {@link Object.getReplies},
	* but returns its `@id` URL instead of the object itself.
	*/
	get repliesId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_7UpwM3JWcXhADcscukEehBorf6k_replies.length < 1) return null;
		const v = this.#_7UpwM3JWcXhADcscukEehBorf6k_replies[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** Identifies a {@link Collection} containing objects considered to be
	* responses to this object.
	*/
	async getReplies(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_7UpwM3JWcXhADcscukEehBorf6k_replies.length < 1) return null;
		let v = this.#_7UpwM3JWcXhADcscukEehBorf6k_replies[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_7UpwM3JWcXhADcscukEehBorf6k_replies.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchReplies(v, options);
			if (fetched == null) return null;
			this.#_7UpwM3JWcXhADcscukEehBorf6k_replies[0] = fetched;
			this.#_trust_7UpwM3JWcXhADcscukEehBorf6k_replies.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "replies" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["replies"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#replies_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_7UpwM3JWcXhADcscukEehBorf6k_replies.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchShares(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#shares_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #shares_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Collection.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
	}
	/**
	* Similar to
	* {@link Object.getShares},
	* but returns its `@id` URL instead of the object itself.
	*/
	get sharesId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3kAfck9PcEYt2L7xug5y99YPbANs_shares.length < 1) return null;
		const v = this.#_3kAfck9PcEYt2L7xug5y99YPbANs_shares[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** Every object *may* have a `shares` collection. This is a list of all
	* {@link Announce} activities with this object as the `object` property,
	* added as a [side effect]. The `shares` collection *must* be either
	* an {@link OrderedCollection} or a {@link Collection} and *may* be filtered
	* on privileges of an authenticated user or as appropriate
	* when no authentication is given.
	*
	* [side effect]: https://www.w3.org/TR/activitypub/#announce-activity-inbox
	*/
	async getShares(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3kAfck9PcEYt2L7xug5y99YPbANs_shares.length < 1) return null;
		let v = this.#_3kAfck9PcEYt2L7xug5y99YPbANs_shares[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_3kAfck9PcEYt2L7xug5y99YPbANs_shares.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchShares(v, options);
			if (fetched == null) return null;
			this.#_3kAfck9PcEYt2L7xug5y99YPbANs_shares[0] = fetched;
			this.#_trust_3kAfck9PcEYt2L7xug5y99YPbANs_shares.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "shares" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["shares"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#shares_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_3kAfck9PcEYt2L7xug5y99YPbANs_shares.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchLikes(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#likes_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #likes_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Collection.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
	}
	/**
	* Similar to
	* {@link Object.getLikes},
	* but returns its `@id` URL instead of the object itself.
	*/
	get likesId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_S3ceDnpMdzoTRCccB9FkJWrEzYW_likes.length < 1) return null;
		const v = this.#_S3ceDnpMdzoTRCccB9FkJWrEzYW_likes[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** Every object *may* have a `likes` collection. This is a list of all
	* {@link Like} activities with this object as the `object` property,
	* added as a [side effect]. The `likes` collection *must* be either
	* an {@link OrderedCollection} or a {@link Collection} and *may* be filtered
	* on privileges of an authenticated user or as appropriate
	* when no authentication is given.
	*
	* [side effect]: https://www.w3.org/TR/activitypub/#announce-activity-inbox
	*/
	async getLikes(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_S3ceDnpMdzoTRCccB9FkJWrEzYW_likes.length < 1) return null;
		let v = this.#_S3ceDnpMdzoTRCccB9FkJWrEzYW_likes[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_S3ceDnpMdzoTRCccB9FkJWrEzYW_likes.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchLikes(v, options);
			if (fetched == null) return null;
			this.#_S3ceDnpMdzoTRCccB9FkJWrEzYW_likes[0] = fetched;
			this.#_trust_S3ceDnpMdzoTRCccB9FkJWrEzYW_likes.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "likes" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["likes"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#likes_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_S3ceDnpMdzoTRCccB9FkJWrEzYW_likes.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchEmojiReactions(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#emojiReactions_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #emojiReactions_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Collection.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
	}
	/**
	* Similar to
	* {@link Object.getEmojiReactions},
	* but returns its `@id` URL instead of the object itself.
	*/
	get emojiReactionsId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions.length < 1) return null;
		const v = this.#_kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** Identifies a {@link Collection} containing objects considered to be
	* emoji reactions to this object.
	*/
	async getEmojiReactions(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions.length < 1) return null;
		let v = this.#_kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchEmojiReactions(v, options);
			if (fetched == null) return null;
			this.#_kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions[0] = fetched;
			this.#_trust_kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "emojiReactions" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["emojiReactions"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#emojiReactions_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	/** The date and time describing the actual or expected starting time of
	* the object.  When used with an {@link Activity} object, for instance,
	* the `startTime` property specifies the moment the activity began or
	* is scheduled to begin.
	*/
	get startTime() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2w3Jmue4up8iVDUA51WZqomEF438_startTime.length < 1) return null;
		return this.#_2w3Jmue4up8iVDUA51WZqomEF438_startTime[0];
	}
	/** A natural language summarization of the object encoded as HTML.
	* Multiple language tagged summaries MAY be provided.
	*/
	get summary() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_4LqirZspQbFWWQEbFcXAxm7tTDN1_summary.length < 1) return null;
		return this.#_4LqirZspQbFWWQEbFcXAxm7tTDN1_summary[0];
	}
	/** A natural language summarization of the object encoded as HTML.
	* Multiple language tagged summaries MAY be provided.
	*/
	get summaries() {
		return this.#_4LqirZspQbFWWQEbFcXAxm7tTDN1_summary;
	}
	async #fetchTag(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#tag_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #tag_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Object$1.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Link.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Object", "https://www.w3.org/ns/activitystreams#Link"].join(", "));
	}
	/**
	* Similar to
	* {@link Object.getTags},
	* but returns their `@id`s instead of the objects themselves.
	*/
	get tagIds() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		return this.#_5chuqj6s95p5gg2sk1HntGfarRf_tag.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
	}
	/** One or more "tags" that have been associated with an objects.
	* A tag can be any kind of Object.  The key difference between `attachment`
	* and `tag` is that the former implies association by inclusion,
	* while the latter implies associated by reference.
	*/
	async *getTags(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		const vs = this.#_5chuqj6s95p5gg2sk1HntGfarRf_tag;
		for (let i = 0; i < vs.length; i++) {
			let v = vs[i];
			if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_5chuqj6s95p5gg2sk1HntGfarRf_tag.has(i)) v = v.id;
			if (v instanceof URL) {
				const fetched = await this.#fetchTag(v, options);
				if (fetched == null) continue;
				vs[i] = fetched;
				this.#_trust_5chuqj6s95p5gg2sk1HntGfarRf_tag.add(i);
				this._cachedJsonLd = void 0;
				yield fetched;
				continue;
			}
			if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "tag" in this._cachedJsonLd) {
				const prop = this._cachedJsonLd["tag"];
				const obj = Array.isArray(prop) ? prop[i] : prop;
				if (obj != null && typeof obj === "object" && "@context" in obj) v = await this.#tag_fromJsonLd(obj, options);
			}
			if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_5chuqj6s95p5gg2sk1HntGfarRf_tag.has(0)) {
				if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
				getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
					objectId: v.id.href,
					parentObjectId: this.id.href
				});
				continue;
			}
			yield v;
		}
	}
	/** The date and time at which the object was updated.
	*/
	get updated() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_385aB7ySixcf5Un6z3VsWmThgCzQ_updated.length < 1) return null;
		return this.#_385aB7ySixcf5Un6z3VsWmThgCzQ_updated[0];
	}
	/** Identifies one or more links to representations of the object.
	*/
	get url() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2oPEH9MQ3aj8JVwyYuWkqoVwV865_url.length < 1) return null;
		return this.#_2oPEH9MQ3aj8JVwyYuWkqoVwV865_url[0];
	}
	/** Identifies one or more links to representations of the object.
	*/
	get urls() {
		return this.#_2oPEH9MQ3aj8JVwyYuWkqoVwV865_url;
	}
	async #fetchTo(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#to_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #to_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Object$1.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Object"].join(", "));
	}
	/**
	* Similar to
	* {@link Object.getTo},
	* but returns its `@id` URL instead of the object itself.
	*/
	get toId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to.length < 1) return null;
		const v = this.#_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** Identifies an entity considered to be part of the public primary audience
	* of an Object.
	*/
	async getTo(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to.length < 1) return null;
		let v = this.#_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchTo(v, options);
			if (fetched == null) return null;
			this.#_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to[0] = fetched;
			this.#_trust_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "to" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["to"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#to_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	/**
	* Similar to
	* {@link Object.getTos},
	* but returns their `@id`s instead of the objects themselves.
	*/
	get toIds() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		return this.#_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
	}
	/** Identifies an entity considered to be part of the public primary audience
	* of an Object.
	*/
	async *getTos(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		const vs = this.#_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to;
		for (let i = 0; i < vs.length; i++) {
			let v = vs[i];
			if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to.has(i)) v = v.id;
			if (v instanceof URL) {
				const fetched = await this.#fetchTo(v, options);
				if (fetched == null) continue;
				vs[i] = fetched;
				this.#_trust_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to.add(i);
				this._cachedJsonLd = void 0;
				yield fetched;
				continue;
			}
			if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "to" in this._cachedJsonLd) {
				const prop = this._cachedJsonLd["to"];
				const obj = Array.isArray(prop) ? prop[i] : prop;
				if (obj != null && typeof obj === "object" && "@context" in obj) v = await this.#to_fromJsonLd(obj, options);
			}
			if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to.has(0)) {
				if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
				getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
					objectId: v.id.href,
					parentObjectId: this.id.href
				});
				continue;
			}
			yield v;
		}
	}
	async #fetchBto(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#bto_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #bto_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Object$1.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Object"].join(", "));
	}
	/**
	* Similar to
	* {@link Object.getBto},
	* but returns its `@id` URL instead of the object itself.
	*/
	get btoId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto.length < 1) return null;
		const v = this.#_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** Identifies an Object that is part of the private primary audience of
	* this Object.
	*/
	async getBto(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto.length < 1) return null;
		let v = this.#_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchBto(v, options);
			if (fetched == null) return null;
			this.#_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto[0] = fetched;
			this.#_trust_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "bto" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["bto"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#bto_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	/**
	* Similar to
	* {@link Object.getBtos},
	* but returns their `@id`s instead of the objects themselves.
	*/
	get btoIds() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		return this.#_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
	}
	/** Identifies an Object that is part of the private primary audience of
	* this Object.
	*/
	async *getBtos(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		const vs = this.#_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto;
		for (let i = 0; i < vs.length; i++) {
			let v = vs[i];
			if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto.has(i)) v = v.id;
			if (v instanceof URL) {
				const fetched = await this.#fetchBto(v, options);
				if (fetched == null) continue;
				vs[i] = fetched;
				this.#_trust_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto.add(i);
				this._cachedJsonLd = void 0;
				yield fetched;
				continue;
			}
			if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "bto" in this._cachedJsonLd) {
				const prop = this._cachedJsonLd["bto"];
				const obj = Array.isArray(prop) ? prop[i] : prop;
				if (obj != null && typeof obj === "object" && "@context" in obj) v = await this.#bto_fromJsonLd(obj, options);
			}
			if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto.has(0)) {
				if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
				getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
					objectId: v.id.href,
					parentObjectId: this.id.href
				});
				continue;
			}
			yield v;
		}
	}
	async #fetchCc(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#cc_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #cc_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Object$1.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Object"].join(", "));
	}
	/**
	* Similar to
	* {@link Object.getCc},
	* but returns its `@id` URL instead of the object itself.
	*/
	get ccId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc.length < 1) return null;
		const v = this.#_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** Identifies an Object that is part of the public secondary audience of
	* this Object.
	*/
	async getCc(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc.length < 1) return null;
		let v = this.#_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchCc(v, options);
			if (fetched == null) return null;
			this.#_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc[0] = fetched;
			this.#_trust_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "cc" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["cc"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#cc_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	/**
	* Similar to
	* {@link Object.getCcs},
	* but returns their `@id`s instead of the objects themselves.
	*/
	get ccIds() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		return this.#_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
	}
	/** Identifies an Object that is part of the public secondary audience of
	* this Object.
	*/
	async *getCcs(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		const vs = this.#_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc;
		for (let i = 0; i < vs.length; i++) {
			let v = vs[i];
			if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc.has(i)) v = v.id;
			if (v instanceof URL) {
				const fetched = await this.#fetchCc(v, options);
				if (fetched == null) continue;
				vs[i] = fetched;
				this.#_trust_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc.add(i);
				this._cachedJsonLd = void 0;
				yield fetched;
				continue;
			}
			if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "cc" in this._cachedJsonLd) {
				const prop = this._cachedJsonLd["cc"];
				const obj = Array.isArray(prop) ? prop[i] : prop;
				if (obj != null && typeof obj === "object" && "@context" in obj) v = await this.#cc_fromJsonLd(obj, options);
			}
			if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc.has(0)) {
				if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
				getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
					objectId: v.id.href,
					parentObjectId: this.id.href
				});
				continue;
			}
			yield v;
		}
	}
	async #fetchBcc(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#bcc_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #bcc_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Object$1.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Object"].join(", "));
	}
	/**
	* Similar to
	* {@link Object.getBcc},
	* but returns its `@id` URL instead of the object itself.
	*/
	get bccId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc.length < 1) return null;
		const v = this.#_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** Identifies one or more Objects that are part of the private secondary
	* audience of this Object.
	*/
	async getBcc(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc.length < 1) return null;
		let v = this.#_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchBcc(v, options);
			if (fetched == null) return null;
			this.#_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc[0] = fetched;
			this.#_trust_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "bcc" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["bcc"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#bcc_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	/**
	* Similar to
	* {@link Object.getBccs},
	* but returns their `@id`s instead of the objects themselves.
	*/
	get bccIds() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		return this.#_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
	}
	/** Identifies one or more Objects that are part of the private secondary
	* audience of this Object.
	*/
	async *getBccs(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		const vs = this.#_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc;
		for (let i = 0; i < vs.length; i++) {
			let v = vs[i];
			if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc.has(i)) v = v.id;
			if (v instanceof URL) {
				const fetched = await this.#fetchBcc(v, options);
				if (fetched == null) continue;
				vs[i] = fetched;
				this.#_trust_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc.add(i);
				this._cachedJsonLd = void 0;
				yield fetched;
				continue;
			}
			if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "bcc" in this._cachedJsonLd) {
				const prop = this._cachedJsonLd["bcc"];
				const obj = Array.isArray(prop) ? prop[i] : prop;
				if (obj != null && typeof obj === "object" && "@context" in obj) v = await this.#bcc_fromJsonLd(obj, options);
			}
			if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc.has(0)) {
				if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
				getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
					objectId: v.id.href,
					parentObjectId: this.id.href
				});
				continue;
			}
			yield v;
		}
	}
	/** When used on an {@link Object}, identifies the MIME media type of the value
	* of the `content` property.  If not specified, the `content` property is
	* assumed to contain `text/html` content.
	*/
	get mediaType() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType.length < 1) return null;
		return this.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType[0];
	}
	/** When the object describes a time-bound resource, such as an audio or video,
	* a meeting, etc, the `duration` property indicates the object's approximate
	* duration.  The value MUST be expressed as an `xsd:duration` as defined by
	* W3C XML Schema Definition Language (XSD) 1.1 Part 2: DataTypes, section
	* 3.3.6 (e.g. a period of 5 seconds is represented as `PT5S`).
	*/
	get duration() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3bNvLMBN1bCJETiTihM3wvi1B2JX_duration.length < 1) return null;
		return this.#_3bNvLMBN1bCJETiTihM3wvi1B2JX_duration[0];
	}
	/** Whether it contains any sensitive contents.
	*/
	get sensitive() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_u8gdcDTtChQ4tbSQMXc4cYWyum7_sensitive.length < 1) return null;
		return this.#_u8gdcDTtChQ4tbSQMXc4cYWyum7_sensitive[0];
	}
	/** The `source` property is intended to convey some sort of source from which
	* the `content` markup was derived, as a form of provenance, or to support
	* future editing by clients.  In general, clients do the conversion from
	* `source` to `content`, not the other way around.
	*/
	get source() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2ZwCFoS787v8y8bXKjMoE6MAbrEB_source.length < 1) return null;
		return this.#_2ZwCFoS787v8y8bXKjMoE6MAbrEB_source[0];
	}
	async #fetchProof(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#proof_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #proof_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await DataIntegrityProof.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://w3id.org/security#DataIntegrityProof"].join(", "));
	}
	/**
	* Similar to
	* {@link Object.getProof},
	* but returns its `@id` URL instead of the object itself.
	*/
	get proofId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof.length < 1) return null;
		const v = this.#_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** A cryptographic proof that can be used to verify the integrity of an object.
	*/
	async getProof(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof.length < 1) return null;
		let v = this.#_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchProof(v, options);
			if (fetched == null) return null;
			this.#_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof[0] = fetched;
			this.#_trust_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "proof" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["proof"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#proof_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	/**
	* Similar to
	* {@link Object.getProofs},
	* but returns their `@id`s instead of the objects themselves.
	*/
	get proofIds() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		return this.#_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
	}
	/** A cryptographic proof that can be used to verify the integrity of an object.
	*/
	async *getProofs(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		const vs = this.#_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof;
		for (let i = 0; i < vs.length; i++) {
			let v = vs[i];
			if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof.has(i)) v = v.id;
			if (v instanceof URL) {
				const fetched = await this.#fetchProof(v, options);
				if (fetched == null) continue;
				vs[i] = fetched;
				this.#_trust_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof.add(i);
				this._cachedJsonLd = void 0;
				yield fetched;
				continue;
			}
			if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "proof" in this._cachedJsonLd) {
				const prop = this._cachedJsonLd["proof"];
				const obj = Array.isArray(prop) ? prop[i] : prop;
				if (obj != null && typeof obj === "object" && "@context" in obj) v = await this.#proof_fromJsonLd(obj, options);
			}
			if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof.has(0)) {
				if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
				getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
					objectId: v.id.href,
					parentObjectId: this.id.href
				});
				continue;
			}
			yield v;
		}
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		if (options.format == null && this.isCompactable()) {
			const result = {};
			let compactItems;
			compactItems = [];
			for (const v of this.#_49BipA5dq9eoH8LX8xdsVumveTca_attachment) {
				const item = v instanceof URL ? v.href : v instanceof Object$1 ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : v instanceof Link ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["attachment"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo) {
				const item = v instanceof URL ? v.href : v instanceof Application ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : v instanceof Group ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : v instanceof Organization ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : v instanceof Person ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["attributedTo"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["audience"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content) {
				const item = typeof v === "string" ? v : {
					"@value": v.toString(),
					"@language": v.language.compact()
				};
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["content"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_3mhZzGXSpQ431mBSz2kvych22v4e_context) {
				const item = v instanceof URL ? v.href : v instanceof Object$1 ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["context"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name) {
				const item = typeof v === "string" ? v : {
					"@value": v.toString(),
					"@language": v.language.compact()
				};
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["name"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_219RwDanjScTv5tYCjwGZVCM7KZ9_endTime) {
				const item = v.toString();
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["endTime"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_86xFhmgBapoMvYqjbjRuDPayTrS_generator) {
				const item = v instanceof URL ? v.href : v instanceof Object$1 ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["generator"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["icon"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_3dXrUdkARxwyJLtJcYi1AJ92H41U_image) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["image"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo) {
				const item = v instanceof URL ? v.href : v instanceof Object$1 ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["inReplyTo"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_31k5MUZJsnsPNg8dQQJieWaXTFnR_location) {
				const item = v instanceof URL ? v.href : v instanceof Object$1 ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["location"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_gCVTegXxWWCw6wWRxa1QF65zusg_preview) {
				const item = v instanceof URL ? v.href : v instanceof Link ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["preview"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_5e258TDXtuhaFRPZiGoDfEpjdMr_published) {
				const item = v.toString();
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["published"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_7UpwM3JWcXhADcscukEehBorf6k_replies) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["replies"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_3kAfck9PcEYt2L7xug5y99YPbANs_shares) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["shares"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_S3ceDnpMdzoTRCccB9FkJWrEzYW_likes) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["likes"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["emojiReactions"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_2w3Jmue4up8iVDUA51WZqomEF438_startTime) {
				const item = v.toString();
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["startTime"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_4LqirZspQbFWWQEbFcXAxm7tTDN1_summary) {
				const item = typeof v === "string" ? v : {
					"@value": v.toString(),
					"@language": v.language.compact()
				};
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["summary"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_5chuqj6s95p5gg2sk1HntGfarRf_tag) {
				const item = v instanceof URL ? v.href : v instanceof Object$1 ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["tag"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_385aB7ySixcf5Un6z3VsWmThgCzQ_updated) {
				const item = v.toString();
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["updated"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_2oPEH9MQ3aj8JVwyYuWkqoVwV865_url) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["url"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["to"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["bto"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["cc"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["bcc"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType) {
				const item = v;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["mediaType"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_3bNvLMBN1bCJETiTihM3wvi1B2JX_duration) {
				const item = v.toString();
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["duration"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_u8gdcDTtChQ4tbSQMXc4cYWyum7_sensitive) {
				const item = v;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["sensitive"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_2ZwCFoS787v8y8bXKjMoE6MAbrEB_source) {
				const item = await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["source"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["proof"] = compactItems.length > 1 ? compactItems : compactItems[0];
			result["type"] = "Object";
			if (this.id != null) result["id"] = this.id.href;
			result["@context"] = [
				"https://www.w3.org/ns/activitystreams",
				"https://w3id.org/security/data-integrity/v1",
				{
					"fedibird": "http://fedibird.com/ns#",
					"sensitive": "as:sensitive",
					"emojiReactions": {
						"@id": "fedibird:emojiReactions",
						"@type": "@id"
					}
				}
			];
			return result;
		}
		let array;
		const values = {};
		array = [];
		for (const v of this.#_49BipA5dq9eoH8LX8xdsVumveTca_attachment) {
			const element = v instanceof URL ? { "@id": v.href } : v instanceof Object$1 ? await v.toJsonLd(options) : v instanceof Link ? await v.toJsonLd(options) : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#attachment"] = propValue;
		}
		array = [];
		for (const v of this.#_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo) {
			const element = v instanceof URL ? { "@id": v.href } : v instanceof Application ? await v.toJsonLd(options) : v instanceof Group ? await v.toJsonLd(options) : v instanceof Organization ? await v.toJsonLd(options) : v instanceof Person ? await v.toJsonLd(options) : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#attributedTo"] = propValue;
		}
		array = [];
		for (const v of this.#_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#audience"] = propValue;
		}
		array = [];
		for (const v of this.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content) {
			const element = typeof v === "string" ? { "@value": v } : {
				"@value": v.toString(),
				"@language": v.language.compact()
			};
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#content"] = propValue;
		}
		array = [];
		for (const v of this.#_3mhZzGXSpQ431mBSz2kvych22v4e_context) {
			const element = v instanceof URL ? { "@id": v.href } : v instanceof Object$1 ? await v.toJsonLd(options) : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#context"] = propValue;
		}
		array = [];
		for (const v of this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name) {
			const element = typeof v === "string" ? { "@value": v } : {
				"@value": v.toString(),
				"@language": v.language.compact()
			};
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#name"] = propValue;
		}
		array = [];
		for (const v of this.#_219RwDanjScTv5tYCjwGZVCM7KZ9_endTime) {
			const element = {
				"@type": "http://www.w3.org/2001/XMLSchema#dateTime",
				"@value": v.toString()
			};
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#endTime"] = propValue;
		}
		array = [];
		for (const v of this.#_86xFhmgBapoMvYqjbjRuDPayTrS_generator) {
			const element = v instanceof URL ? { "@id": v.href } : v instanceof Object$1 ? await v.toJsonLd(options) : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#generator"] = propValue;
		}
		array = [];
		for (const v of this.#_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#icon"] = propValue;
		}
		array = [];
		for (const v of this.#_3dXrUdkARxwyJLtJcYi1AJ92H41U_image) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#image"] = propValue;
		}
		array = [];
		for (const v of this.#_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo) {
			const element = v instanceof URL ? { "@id": v.href } : v instanceof Object$1 ? await v.toJsonLd(options) : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#inReplyTo"] = propValue;
		}
		array = [];
		for (const v of this.#_31k5MUZJsnsPNg8dQQJieWaXTFnR_location) {
			const element = v instanceof URL ? { "@id": v.href } : v instanceof Object$1 ? await v.toJsonLd(options) : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#location"] = propValue;
		}
		array = [];
		for (const v of this.#_gCVTegXxWWCw6wWRxa1QF65zusg_preview) {
			const element = v instanceof URL ? { "@id": v.href } : v instanceof Link ? await v.toJsonLd(options) : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#preview"] = propValue;
		}
		array = [];
		for (const v of this.#_5e258TDXtuhaFRPZiGoDfEpjdMr_published) {
			const element = {
				"@type": "http://www.w3.org/2001/XMLSchema#dateTime",
				"@value": v.toString()
			};
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#published"] = propValue;
		}
		array = [];
		for (const v of this.#_7UpwM3JWcXhADcscukEehBorf6k_replies) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#replies"] = propValue;
		}
		array = [];
		for (const v of this.#_3kAfck9PcEYt2L7xug5y99YPbANs_shares) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#shares"] = propValue;
		}
		array = [];
		for (const v of this.#_S3ceDnpMdzoTRCccB9FkJWrEzYW_likes) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#likes"] = propValue;
		}
		array = [];
		for (const v of this.#_kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["http://fedibird.com/ns#emojiReactions"] = propValue;
		}
		array = [];
		for (const v of this.#_2w3Jmue4up8iVDUA51WZqomEF438_startTime) {
			const element = {
				"@type": "http://www.w3.org/2001/XMLSchema#dateTime",
				"@value": v.toString()
			};
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#startTime"] = propValue;
		}
		array = [];
		for (const v of this.#_4LqirZspQbFWWQEbFcXAxm7tTDN1_summary) {
			const element = typeof v === "string" ? { "@value": v } : {
				"@value": v.toString(),
				"@language": v.language.compact()
			};
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#summary"] = propValue;
		}
		array = [];
		for (const v of this.#_5chuqj6s95p5gg2sk1HntGfarRf_tag) {
			const element = v instanceof URL ? { "@id": v.href } : v instanceof Object$1 ? await v.toJsonLd(options) : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#tag"] = propValue;
		}
		array = [];
		for (const v of this.#_385aB7ySixcf5Un6z3VsWmThgCzQ_updated) {
			const element = {
				"@type": "http://www.w3.org/2001/XMLSchema#dateTime",
				"@value": v.toString()
			};
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#updated"] = propValue;
		}
		array = [];
		for (const v of this.#_2oPEH9MQ3aj8JVwyYuWkqoVwV865_url) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#url"] = propValue;
		}
		array = [];
		for (const v of this.#_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#to"] = propValue;
		}
		array = [];
		for (const v of this.#_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#bto"] = propValue;
		}
		array = [];
		for (const v of this.#_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#cc"] = propValue;
		}
		array = [];
		for (const v of this.#_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#bcc"] = propValue;
		}
		array = [];
		for (const v of this.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType) {
			const element = { "@value": v };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#mediaType"] = propValue;
		}
		array = [];
		for (const v of this.#_3bNvLMBN1bCJETiTihM3wvi1B2JX_duration) {
			const element = {
				"@type": "http://www.w3.org/2001/XMLSchema#duration",
				"@value": v.toString()
			};
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#duration"] = propValue;
		}
		array = [];
		for (const v of this.#_u8gdcDTtChQ4tbSQMXc4cYWyum7_sensitive) {
			const element = { "@value": v };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#sensitive"] = propValue;
		}
		array = [];
		for (const v of this.#_2ZwCFoS787v8y8bXKjMoE6MAbrEB_source) {
			const element = await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#source"] = propValue;
		}
		array = [];
		for (const v of this.#_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push({ "@graph": element });
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://w3id.org/security#proof"] = propValue;
		}
		values["@type"] = ["https://www.w3.org/ns/activitystreams#Object"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? [
			"https://www.w3.org/ns/activitystreams",
			"https://w3id.org/security/data-integrity/v1",
			{
				"fedibird": "http://fedibird.com/ns#",
				"sensitive": "as:sensitive",
				"emojiReactions": {
					"@id": "fedibird:emojiReactions",
					"@type": "@id"
				}
			}
		];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {
			if ("proof" in compacted && compacted.proof != null) if (Array.isArray(compacted.proof)) for (const element of compacted.proof) element["@context"] = docContext;
			else compacted.proof["@context"] = docContext;
		}
		return compacted;
	}
	isCompactable() {
		if (this.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content != null && this.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content.length > 0) return false;
		if (this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name != null && this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name.length > 0) return false;
		if (this.#_4LqirZspQbFWWQEbFcXAxm7tTDN1_summary != null && this.#_4LqirZspQbFWWQEbFcXAxm7tTDN1_summary.length > 0) return false;
		if (this.#_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof != null && this.#_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof.length > 0) return false;
		return true;
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__Object__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__Object__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (values["@type"].includes("http://joinmastodon.org/ns#Emoji")) return await Emoji.fromJsonLd(json, options);
			if (values["@type"].includes("http://litepub.social/ns#ChatMessage")) return await ChatMessage.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Activity")) return await Activity.fromJsonLd(json, options);
			if (values["@type"].includes("http://litepub.social/ns#EmojiReact")) return await EmojiReact.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Accept")) return await Accept.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#TentativeAccept")) return await TentativeAccept.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Add")) return await Add.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Announce")) return await Announce.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Create")) return await Create.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Delete")) return await Delete.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Dislike")) return await Dislike.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Flag")) return await Flag.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Follow")) return await Follow.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Ignore")) return await Ignore.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Block")) return await Block.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#IntransitiveActivity")) return await IntransitiveActivity.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Arrive")) return await Arrive.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Question")) return await Question.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Travel")) return await Travel.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Join")) return await Join.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Leave")) return await Leave.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Like")) return await Like.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Listen")) return await Listen.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Move")) return await Move.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Offer")) return await Offer.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Invite")) return await Invite.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Read")) return await Read.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Reject")) return await Reject.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#TentativeReject")) return await TentativeReject.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Remove")) return await Remove.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Undo")) return await Undo.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Update")) return await Update.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#View")) return await View.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Application")) return await Application.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Article")) return await Article.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Collection")) return await Collection.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#CollectionPage")) return await CollectionPage.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#OrderedCollectionPage")) return await OrderedCollectionPage.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#OrderedCollection")) return await OrderedCollection.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Document")) return await Document.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Audio")) return await Audio.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Image")) return await Image.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Page")) return await Page.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Video")) return await Video.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Event")) return await Event.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Group")) return await Group.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Note")) return await Note.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Organization")) return await Organization.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Person")) return await Person.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Place")) return await Place.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Profile")) return await Profile.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Relationship")) return await Relationship.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Service")) return await Service.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Tombstone")) return await Tombstone.fromJsonLd(json, options);
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Object")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		const instance = new this({ id: "@id" in values ? new URL(values["@id"]) : void 0 }, options);
		const _49BipA5dq9eoH8LX8xdsVumveTca_attachment = [];
		const _trust_49BipA5dq9eoH8LX8xdsVumveTca_attachment = /* @__PURE__ */ new Set();
		let _49BipA5dq9eoH8LX8xdsVumveTca_attachment__array = values["https://www.w3.org/ns/activitystreams#attachment"];
		for (const v of _49BipA5dq9eoH8LX8xdsVumveTca_attachment__array == null ? [] : _49BipA5dq9eoH8LX8xdsVumveTca_attachment__array.length === 1 && "@list" in _49BipA5dq9eoH8LX8xdsVumveTca_attachment__array[0] ? _49BipA5dq9eoH8LX8xdsVumveTca_attachment__array[0]["@list"] : _49BipA5dq9eoH8LX8xdsVumveTca_attachment__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_49BipA5dq9eoH8LX8xdsVumveTca_attachment.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			const decoded = typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && [
				"https://www.w3.org/ns/activitystreams#Object",
				"http://joinmastodon.org/ns#Emoji",
				"http://litepub.social/ns#ChatMessage",
				"https://www.w3.org/ns/activitystreams#Activity",
				"http://litepub.social/ns#EmojiReact",
				"https://www.w3.org/ns/activitystreams#Accept",
				"https://www.w3.org/ns/activitystreams#TentativeAccept",
				"https://www.w3.org/ns/activitystreams#Add",
				"https://www.w3.org/ns/activitystreams#Announce",
				"https://www.w3.org/ns/activitystreams#Create",
				"https://www.w3.org/ns/activitystreams#Delete",
				"https://www.w3.org/ns/activitystreams#Dislike",
				"https://www.w3.org/ns/activitystreams#Flag",
				"https://www.w3.org/ns/activitystreams#Follow",
				"https://www.w3.org/ns/activitystreams#Ignore",
				"https://www.w3.org/ns/activitystreams#Block",
				"https://www.w3.org/ns/activitystreams#IntransitiveActivity",
				"https://www.w3.org/ns/activitystreams#Arrive",
				"https://www.w3.org/ns/activitystreams#Question",
				"https://www.w3.org/ns/activitystreams#Travel",
				"https://www.w3.org/ns/activitystreams#Join",
				"https://www.w3.org/ns/activitystreams#Leave",
				"https://www.w3.org/ns/activitystreams#Like",
				"https://www.w3.org/ns/activitystreams#Listen",
				"https://www.w3.org/ns/activitystreams#Move",
				"https://www.w3.org/ns/activitystreams#Offer",
				"https://www.w3.org/ns/activitystreams#Invite",
				"https://www.w3.org/ns/activitystreams#Read",
				"https://www.w3.org/ns/activitystreams#Reject",
				"https://www.w3.org/ns/activitystreams#TentativeReject",
				"https://www.w3.org/ns/activitystreams#Remove",
				"https://www.w3.org/ns/activitystreams#Undo",
				"https://www.w3.org/ns/activitystreams#Update",
				"https://www.w3.org/ns/activitystreams#View",
				"https://www.w3.org/ns/activitystreams#Application",
				"https://www.w3.org/ns/activitystreams#Article",
				"https://www.w3.org/ns/activitystreams#Collection",
				"https://www.w3.org/ns/activitystreams#CollectionPage",
				"https://www.w3.org/ns/activitystreams#OrderedCollectionPage",
				"https://www.w3.org/ns/activitystreams#OrderedCollection",
				"https://www.w3.org/ns/activitystreams#Document",
				"https://www.w3.org/ns/activitystreams#Audio",
				"https://www.w3.org/ns/activitystreams#Image",
				"https://www.w3.org/ns/activitystreams#Page",
				"https://www.w3.org/ns/activitystreams#Video",
				"https://www.w3.org/ns/activitystreams#Event",
				"https://www.w3.org/ns/activitystreams#Group",
				"https://www.w3.org/ns/activitystreams#Note",
				"https://www.w3.org/ns/activitystreams#Organization",
				"https://www.w3.org/ns/activitystreams#Person",
				"https://www.w3.org/ns/activitystreams#Place",
				"https://www.w3.org/ns/activitystreams#Profile",
				"https://www.w3.org/ns/activitystreams#Relationship",
				"https://www.w3.org/ns/activitystreams#Service",
				"https://www.w3.org/ns/activitystreams#Tombstone"
			].some((t) => v["@type"].includes(t)) ? await Object$1.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && [
				"https://www.w3.org/ns/activitystreams#Link",
				"https://www.w3.org/ns/activitystreams#Hashtag",
				"https://www.w3.org/ns/activitystreams#Mention"
			].some((t) => v["@type"].includes(t)) ? await Link.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("http://schema.org#PropertyValue") ? await PropertyValue.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : void 0;
			if (typeof decoded === "undefined") continue;
			_49BipA5dq9eoH8LX8xdsVumveTca_attachment.push(decoded);
		}
		instance.#_49BipA5dq9eoH8LX8xdsVumveTca_attachment = _49BipA5dq9eoH8LX8xdsVumveTca_attachment;
		const _42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo = [];
		const _trust_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo = /* @__PURE__ */ new Set();
		let _42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo__array = values["https://www.w3.org/ns/activitystreams#attributedTo"];
		for (const v of _42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo__array == null ? [] : _42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo__array.length === 1 && "@list" in _42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo__array[0] ? _42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo__array[0]["@list"] : _42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			const decoded = typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Application") ? await Application.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Group") ? await Group.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Organization") ? await Organization.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Person") ? await Person.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Service") ? await Service.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : void 0;
			if (typeof decoded === "undefined") continue;
			_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo.push(decoded);
		}
		instance.#_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo = _42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo;
		const _3ocC3VVi88cEd5sPWL8djkZsvTN6_audience = [];
		const _trust_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience = /* @__PURE__ */ new Set();
		let _3ocC3VVi88cEd5sPWL8djkZsvTN6_audience__array = values["https://www.w3.org/ns/activitystreams#audience"];
		for (const v of _3ocC3VVi88cEd5sPWL8djkZsvTN6_audience__array == null ? [] : _3ocC3VVi88cEd5sPWL8djkZsvTN6_audience__array.length === 1 && "@list" in _3ocC3VVi88cEd5sPWL8djkZsvTN6_audience__array[0] ? _3ocC3VVi88cEd5sPWL8djkZsvTN6_audience__array[0]["@list"] : _3ocC3VVi88cEd5sPWL8djkZsvTN6_audience__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience.push(await Object$1.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience = _3ocC3VVi88cEd5sPWL8djkZsvTN6_audience;
		const _4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content = [];
		let _4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content__array = values["https://www.w3.org/ns/activitystreams#content"];
		for (const v of _4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content__array == null ? [] : _4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content__array.length === 1 && "@list" in _4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content__array[0] ? _4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content__array[0]["@list"] : _4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content__array) {
			if (v == null) continue;
			const decoded = typeof v === "object" && "@value" in v && typeof v["@value"] === "string" && !("@language" in v) ? v["@value"] : typeof v === "object" && "@language" in v && "@value" in v && typeof v["@language"] === "string" && typeof v["@value"] === "string" ? new LanguageString(v["@value"], v["@language"]) : void 0;
			if (typeof decoded === "undefined") continue;
			_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content.push(decoded);
		}
		instance.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content = _4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content;
		const _3mhZzGXSpQ431mBSz2kvych22v4e_context = [];
		const _trust_3mhZzGXSpQ431mBSz2kvych22v4e_context = /* @__PURE__ */ new Set();
		let _3mhZzGXSpQ431mBSz2kvych22v4e_context__array = values["https://www.w3.org/ns/activitystreams#context"];
		for (const v of _3mhZzGXSpQ431mBSz2kvych22v4e_context__array == null ? [] : _3mhZzGXSpQ431mBSz2kvych22v4e_context__array.length === 1 && "@list" in _3mhZzGXSpQ431mBSz2kvych22v4e_context__array[0] ? _3mhZzGXSpQ431mBSz2kvych22v4e_context__array[0]["@list"] : _3mhZzGXSpQ431mBSz2kvych22v4e_context__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_3mhZzGXSpQ431mBSz2kvych22v4e_context.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			const decoded = typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && [
				"https://www.w3.org/ns/activitystreams#Object",
				"http://joinmastodon.org/ns#Emoji",
				"http://litepub.social/ns#ChatMessage",
				"https://www.w3.org/ns/activitystreams#Activity",
				"http://litepub.social/ns#EmojiReact",
				"https://www.w3.org/ns/activitystreams#Accept",
				"https://www.w3.org/ns/activitystreams#TentativeAccept",
				"https://www.w3.org/ns/activitystreams#Add",
				"https://www.w3.org/ns/activitystreams#Announce",
				"https://www.w3.org/ns/activitystreams#Create",
				"https://www.w3.org/ns/activitystreams#Delete",
				"https://www.w3.org/ns/activitystreams#Dislike",
				"https://www.w3.org/ns/activitystreams#Flag",
				"https://www.w3.org/ns/activitystreams#Follow",
				"https://www.w3.org/ns/activitystreams#Ignore",
				"https://www.w3.org/ns/activitystreams#Block",
				"https://www.w3.org/ns/activitystreams#IntransitiveActivity",
				"https://www.w3.org/ns/activitystreams#Arrive",
				"https://www.w3.org/ns/activitystreams#Question",
				"https://www.w3.org/ns/activitystreams#Travel",
				"https://www.w3.org/ns/activitystreams#Join",
				"https://www.w3.org/ns/activitystreams#Leave",
				"https://www.w3.org/ns/activitystreams#Like",
				"https://www.w3.org/ns/activitystreams#Listen",
				"https://www.w3.org/ns/activitystreams#Move",
				"https://www.w3.org/ns/activitystreams#Offer",
				"https://www.w3.org/ns/activitystreams#Invite",
				"https://www.w3.org/ns/activitystreams#Read",
				"https://www.w3.org/ns/activitystreams#Reject",
				"https://www.w3.org/ns/activitystreams#TentativeReject",
				"https://www.w3.org/ns/activitystreams#Remove",
				"https://www.w3.org/ns/activitystreams#Undo",
				"https://www.w3.org/ns/activitystreams#Update",
				"https://www.w3.org/ns/activitystreams#View",
				"https://www.w3.org/ns/activitystreams#Application",
				"https://www.w3.org/ns/activitystreams#Article",
				"https://www.w3.org/ns/activitystreams#Collection",
				"https://www.w3.org/ns/activitystreams#CollectionPage",
				"https://www.w3.org/ns/activitystreams#OrderedCollectionPage",
				"https://www.w3.org/ns/activitystreams#OrderedCollection",
				"https://www.w3.org/ns/activitystreams#Document",
				"https://www.w3.org/ns/activitystreams#Audio",
				"https://www.w3.org/ns/activitystreams#Image",
				"https://www.w3.org/ns/activitystreams#Page",
				"https://www.w3.org/ns/activitystreams#Video",
				"https://www.w3.org/ns/activitystreams#Event",
				"https://www.w3.org/ns/activitystreams#Group",
				"https://www.w3.org/ns/activitystreams#Note",
				"https://www.w3.org/ns/activitystreams#Organization",
				"https://www.w3.org/ns/activitystreams#Person",
				"https://www.w3.org/ns/activitystreams#Place",
				"https://www.w3.org/ns/activitystreams#Profile",
				"https://www.w3.org/ns/activitystreams#Relationship",
				"https://www.w3.org/ns/activitystreams#Service",
				"https://www.w3.org/ns/activitystreams#Tombstone"
			].some((t) => v["@type"].includes(t)) ? await Object$1.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && [
				"https://www.w3.org/ns/activitystreams#Link",
				"https://www.w3.org/ns/activitystreams#Hashtag",
				"https://www.w3.org/ns/activitystreams#Mention"
			].some((t) => v["@type"].includes(t)) ? await Link.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : void 0;
			if (typeof decoded === "undefined") continue;
			_3mhZzGXSpQ431mBSz2kvych22v4e_context.push(decoded);
		}
		instance.#_3mhZzGXSpQ431mBSz2kvych22v4e_context = _3mhZzGXSpQ431mBSz2kvych22v4e_context;
		const _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name = [];
		let _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name__array = values["https://www.w3.org/ns/activitystreams#name"];
		for (const v of _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name__array == null ? [] : _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name__array.length === 1 && "@list" in _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name__array[0] ? _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name__array[0]["@list"] : _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name__array) {
			if (v == null) continue;
			const decoded = typeof v === "object" && "@value" in v && typeof v["@value"] === "string" && !("@language" in v) ? v["@value"] : typeof v === "object" && "@language" in v && "@value" in v && typeof v["@language"] === "string" && typeof v["@value"] === "string" ? new LanguageString(v["@value"], v["@language"]) : void 0;
			if (typeof decoded === "undefined") continue;
			_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name.push(decoded);
		}
		instance.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name = _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name;
		const _219RwDanjScTv5tYCjwGZVCM7KZ9_endTime = [];
		let _219RwDanjScTv5tYCjwGZVCM7KZ9_endTime__array = values["https://www.w3.org/ns/activitystreams#endTime"];
		for (const v of _219RwDanjScTv5tYCjwGZVCM7KZ9_endTime__array == null ? [] : _219RwDanjScTv5tYCjwGZVCM7KZ9_endTime__array.length === 1 && "@list" in _219RwDanjScTv5tYCjwGZVCM7KZ9_endTime__array[0] ? _219RwDanjScTv5tYCjwGZVCM7KZ9_endTime__array[0]["@list"] : _219RwDanjScTv5tYCjwGZVCM7KZ9_endTime__array) {
			if (v == null) continue;
			_219RwDanjScTv5tYCjwGZVCM7KZ9_endTime.push(Temporal.Instant.from(v["@value"].substring(19).match(/[Z+-]/) ? v["@value"] : v["@value"] + "Z"));
		}
		instance.#_219RwDanjScTv5tYCjwGZVCM7KZ9_endTime = _219RwDanjScTv5tYCjwGZVCM7KZ9_endTime;
		const _86xFhmgBapoMvYqjbjRuDPayTrS_generator = [];
		const _trust_86xFhmgBapoMvYqjbjRuDPayTrS_generator = /* @__PURE__ */ new Set();
		let _86xFhmgBapoMvYqjbjRuDPayTrS_generator__array = values["https://www.w3.org/ns/activitystreams#generator"];
		for (const v of _86xFhmgBapoMvYqjbjRuDPayTrS_generator__array == null ? [] : _86xFhmgBapoMvYqjbjRuDPayTrS_generator__array.length === 1 && "@list" in _86xFhmgBapoMvYqjbjRuDPayTrS_generator__array[0] ? _86xFhmgBapoMvYqjbjRuDPayTrS_generator__array[0]["@list"] : _86xFhmgBapoMvYqjbjRuDPayTrS_generator__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_86xFhmgBapoMvYqjbjRuDPayTrS_generator.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			const decoded = typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && [
				"https://www.w3.org/ns/activitystreams#Object",
				"http://joinmastodon.org/ns#Emoji",
				"http://litepub.social/ns#ChatMessage",
				"https://www.w3.org/ns/activitystreams#Activity",
				"http://litepub.social/ns#EmojiReact",
				"https://www.w3.org/ns/activitystreams#Accept",
				"https://www.w3.org/ns/activitystreams#TentativeAccept",
				"https://www.w3.org/ns/activitystreams#Add",
				"https://www.w3.org/ns/activitystreams#Announce",
				"https://www.w3.org/ns/activitystreams#Create",
				"https://www.w3.org/ns/activitystreams#Delete",
				"https://www.w3.org/ns/activitystreams#Dislike",
				"https://www.w3.org/ns/activitystreams#Flag",
				"https://www.w3.org/ns/activitystreams#Follow",
				"https://www.w3.org/ns/activitystreams#Ignore",
				"https://www.w3.org/ns/activitystreams#Block",
				"https://www.w3.org/ns/activitystreams#IntransitiveActivity",
				"https://www.w3.org/ns/activitystreams#Arrive",
				"https://www.w3.org/ns/activitystreams#Question",
				"https://www.w3.org/ns/activitystreams#Travel",
				"https://www.w3.org/ns/activitystreams#Join",
				"https://www.w3.org/ns/activitystreams#Leave",
				"https://www.w3.org/ns/activitystreams#Like",
				"https://www.w3.org/ns/activitystreams#Listen",
				"https://www.w3.org/ns/activitystreams#Move",
				"https://www.w3.org/ns/activitystreams#Offer",
				"https://www.w3.org/ns/activitystreams#Invite",
				"https://www.w3.org/ns/activitystreams#Read",
				"https://www.w3.org/ns/activitystreams#Reject",
				"https://www.w3.org/ns/activitystreams#TentativeReject",
				"https://www.w3.org/ns/activitystreams#Remove",
				"https://www.w3.org/ns/activitystreams#Undo",
				"https://www.w3.org/ns/activitystreams#Update",
				"https://www.w3.org/ns/activitystreams#View",
				"https://www.w3.org/ns/activitystreams#Application",
				"https://www.w3.org/ns/activitystreams#Article",
				"https://www.w3.org/ns/activitystreams#Collection",
				"https://www.w3.org/ns/activitystreams#CollectionPage",
				"https://www.w3.org/ns/activitystreams#OrderedCollectionPage",
				"https://www.w3.org/ns/activitystreams#OrderedCollection",
				"https://www.w3.org/ns/activitystreams#Document",
				"https://www.w3.org/ns/activitystreams#Audio",
				"https://www.w3.org/ns/activitystreams#Image",
				"https://www.w3.org/ns/activitystreams#Page",
				"https://www.w3.org/ns/activitystreams#Video",
				"https://www.w3.org/ns/activitystreams#Event",
				"https://www.w3.org/ns/activitystreams#Group",
				"https://www.w3.org/ns/activitystreams#Note",
				"https://www.w3.org/ns/activitystreams#Organization",
				"https://www.w3.org/ns/activitystreams#Person",
				"https://www.w3.org/ns/activitystreams#Place",
				"https://www.w3.org/ns/activitystreams#Profile",
				"https://www.w3.org/ns/activitystreams#Relationship",
				"https://www.w3.org/ns/activitystreams#Service",
				"https://www.w3.org/ns/activitystreams#Tombstone"
			].some((t) => v["@type"].includes(t)) ? await Object$1.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && [
				"https://www.w3.org/ns/activitystreams#Link",
				"https://www.w3.org/ns/activitystreams#Hashtag",
				"https://www.w3.org/ns/activitystreams#Mention"
			].some((t) => v["@type"].includes(t)) ? await Link.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : void 0;
			if (typeof decoded === "undefined") continue;
			_86xFhmgBapoMvYqjbjRuDPayTrS_generator.push(decoded);
		}
		instance.#_86xFhmgBapoMvYqjbjRuDPayTrS_generator = _86xFhmgBapoMvYqjbjRuDPayTrS_generator;
		const _33CjRLy5ujtsUrwRSCrsggvGdKuR_icon = [];
		const _trust_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon = /* @__PURE__ */ new Set();
		let _33CjRLy5ujtsUrwRSCrsggvGdKuR_icon__array = values["https://www.w3.org/ns/activitystreams#icon"];
		for (const v of _33CjRLy5ujtsUrwRSCrsggvGdKuR_icon__array == null ? [] : _33CjRLy5ujtsUrwRSCrsggvGdKuR_icon__array.length === 1 && "@list" in _33CjRLy5ujtsUrwRSCrsggvGdKuR_icon__array[0] ? _33CjRLy5ujtsUrwRSCrsggvGdKuR_icon__array[0]["@list"] : _33CjRLy5ujtsUrwRSCrsggvGdKuR_icon__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon.push(await Image.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon = _33CjRLy5ujtsUrwRSCrsggvGdKuR_icon;
		const _3dXrUdkARxwyJLtJcYi1AJ92H41U_image = [];
		const _trust_3dXrUdkARxwyJLtJcYi1AJ92H41U_image = /* @__PURE__ */ new Set();
		let _3dXrUdkARxwyJLtJcYi1AJ92H41U_image__array = values["https://www.w3.org/ns/activitystreams#image"];
		for (const v of _3dXrUdkARxwyJLtJcYi1AJ92H41U_image__array == null ? [] : _3dXrUdkARxwyJLtJcYi1AJ92H41U_image__array.length === 1 && "@list" in _3dXrUdkARxwyJLtJcYi1AJ92H41U_image__array[0] ? _3dXrUdkARxwyJLtJcYi1AJ92H41U_image__array[0]["@list"] : _3dXrUdkARxwyJLtJcYi1AJ92H41U_image__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_3dXrUdkARxwyJLtJcYi1AJ92H41U_image.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_3dXrUdkARxwyJLtJcYi1AJ92H41U_image.push(await Image.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_3dXrUdkARxwyJLtJcYi1AJ92H41U_image = _3dXrUdkARxwyJLtJcYi1AJ92H41U_image;
		const _3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo = [];
		const _trust_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo = /* @__PURE__ */ new Set();
		let _3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo__array = values["https://www.w3.org/ns/activitystreams#inReplyTo"];
		for (const v of _3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo__array == null ? [] : _3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo__array.length === 1 && "@list" in _3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo__array[0] ? _3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo__array[0]["@list"] : _3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			const decoded = typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && [
				"https://www.w3.org/ns/activitystreams#Object",
				"http://joinmastodon.org/ns#Emoji",
				"http://litepub.social/ns#ChatMessage",
				"https://www.w3.org/ns/activitystreams#Activity",
				"http://litepub.social/ns#EmojiReact",
				"https://www.w3.org/ns/activitystreams#Accept",
				"https://www.w3.org/ns/activitystreams#TentativeAccept",
				"https://www.w3.org/ns/activitystreams#Add",
				"https://www.w3.org/ns/activitystreams#Announce",
				"https://www.w3.org/ns/activitystreams#Create",
				"https://www.w3.org/ns/activitystreams#Delete",
				"https://www.w3.org/ns/activitystreams#Dislike",
				"https://www.w3.org/ns/activitystreams#Flag",
				"https://www.w3.org/ns/activitystreams#Follow",
				"https://www.w3.org/ns/activitystreams#Ignore",
				"https://www.w3.org/ns/activitystreams#Block",
				"https://www.w3.org/ns/activitystreams#IntransitiveActivity",
				"https://www.w3.org/ns/activitystreams#Arrive",
				"https://www.w3.org/ns/activitystreams#Question",
				"https://www.w3.org/ns/activitystreams#Travel",
				"https://www.w3.org/ns/activitystreams#Join",
				"https://www.w3.org/ns/activitystreams#Leave",
				"https://www.w3.org/ns/activitystreams#Like",
				"https://www.w3.org/ns/activitystreams#Listen",
				"https://www.w3.org/ns/activitystreams#Move",
				"https://www.w3.org/ns/activitystreams#Offer",
				"https://www.w3.org/ns/activitystreams#Invite",
				"https://www.w3.org/ns/activitystreams#Read",
				"https://www.w3.org/ns/activitystreams#Reject",
				"https://www.w3.org/ns/activitystreams#TentativeReject",
				"https://www.w3.org/ns/activitystreams#Remove",
				"https://www.w3.org/ns/activitystreams#Undo",
				"https://www.w3.org/ns/activitystreams#Update",
				"https://www.w3.org/ns/activitystreams#View",
				"https://www.w3.org/ns/activitystreams#Application",
				"https://www.w3.org/ns/activitystreams#Article",
				"https://www.w3.org/ns/activitystreams#Collection",
				"https://www.w3.org/ns/activitystreams#CollectionPage",
				"https://www.w3.org/ns/activitystreams#OrderedCollectionPage",
				"https://www.w3.org/ns/activitystreams#OrderedCollection",
				"https://www.w3.org/ns/activitystreams#Document",
				"https://www.w3.org/ns/activitystreams#Audio",
				"https://www.w3.org/ns/activitystreams#Image",
				"https://www.w3.org/ns/activitystreams#Page",
				"https://www.w3.org/ns/activitystreams#Video",
				"https://www.w3.org/ns/activitystreams#Event",
				"https://www.w3.org/ns/activitystreams#Group",
				"https://www.w3.org/ns/activitystreams#Note",
				"https://www.w3.org/ns/activitystreams#Organization",
				"https://www.w3.org/ns/activitystreams#Person",
				"https://www.w3.org/ns/activitystreams#Place",
				"https://www.w3.org/ns/activitystreams#Profile",
				"https://www.w3.org/ns/activitystreams#Relationship",
				"https://www.w3.org/ns/activitystreams#Service",
				"https://www.w3.org/ns/activitystreams#Tombstone"
			].some((t) => v["@type"].includes(t)) ? await Object$1.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && [
				"https://www.w3.org/ns/activitystreams#Link",
				"https://www.w3.org/ns/activitystreams#Hashtag",
				"https://www.w3.org/ns/activitystreams#Mention"
			].some((t) => v["@type"].includes(t)) ? await Link.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : void 0;
			if (typeof decoded === "undefined") continue;
			_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo.push(decoded);
		}
		instance.#_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo = _3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo;
		const _31k5MUZJsnsPNg8dQQJieWaXTFnR_location = [];
		const _trust_31k5MUZJsnsPNg8dQQJieWaXTFnR_location = /* @__PURE__ */ new Set();
		let _31k5MUZJsnsPNg8dQQJieWaXTFnR_location__array = values["https://www.w3.org/ns/activitystreams#location"];
		for (const v of _31k5MUZJsnsPNg8dQQJieWaXTFnR_location__array == null ? [] : _31k5MUZJsnsPNg8dQQJieWaXTFnR_location__array.length === 1 && "@list" in _31k5MUZJsnsPNg8dQQJieWaXTFnR_location__array[0] ? _31k5MUZJsnsPNg8dQQJieWaXTFnR_location__array[0]["@list"] : _31k5MUZJsnsPNg8dQQJieWaXTFnR_location__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_31k5MUZJsnsPNg8dQQJieWaXTFnR_location.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			const decoded = typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && [
				"https://www.w3.org/ns/activitystreams#Object",
				"http://joinmastodon.org/ns#Emoji",
				"http://litepub.social/ns#ChatMessage",
				"https://www.w3.org/ns/activitystreams#Activity",
				"http://litepub.social/ns#EmojiReact",
				"https://www.w3.org/ns/activitystreams#Accept",
				"https://www.w3.org/ns/activitystreams#TentativeAccept",
				"https://www.w3.org/ns/activitystreams#Add",
				"https://www.w3.org/ns/activitystreams#Announce",
				"https://www.w3.org/ns/activitystreams#Create",
				"https://www.w3.org/ns/activitystreams#Delete",
				"https://www.w3.org/ns/activitystreams#Dislike",
				"https://www.w3.org/ns/activitystreams#Flag",
				"https://www.w3.org/ns/activitystreams#Follow",
				"https://www.w3.org/ns/activitystreams#Ignore",
				"https://www.w3.org/ns/activitystreams#Block",
				"https://www.w3.org/ns/activitystreams#IntransitiveActivity",
				"https://www.w3.org/ns/activitystreams#Arrive",
				"https://www.w3.org/ns/activitystreams#Question",
				"https://www.w3.org/ns/activitystreams#Travel",
				"https://www.w3.org/ns/activitystreams#Join",
				"https://www.w3.org/ns/activitystreams#Leave",
				"https://www.w3.org/ns/activitystreams#Like",
				"https://www.w3.org/ns/activitystreams#Listen",
				"https://www.w3.org/ns/activitystreams#Move",
				"https://www.w3.org/ns/activitystreams#Offer",
				"https://www.w3.org/ns/activitystreams#Invite",
				"https://www.w3.org/ns/activitystreams#Read",
				"https://www.w3.org/ns/activitystreams#Reject",
				"https://www.w3.org/ns/activitystreams#TentativeReject",
				"https://www.w3.org/ns/activitystreams#Remove",
				"https://www.w3.org/ns/activitystreams#Undo",
				"https://www.w3.org/ns/activitystreams#Update",
				"https://www.w3.org/ns/activitystreams#View",
				"https://www.w3.org/ns/activitystreams#Application",
				"https://www.w3.org/ns/activitystreams#Article",
				"https://www.w3.org/ns/activitystreams#Collection",
				"https://www.w3.org/ns/activitystreams#CollectionPage",
				"https://www.w3.org/ns/activitystreams#OrderedCollectionPage",
				"https://www.w3.org/ns/activitystreams#OrderedCollection",
				"https://www.w3.org/ns/activitystreams#Document",
				"https://www.w3.org/ns/activitystreams#Audio",
				"https://www.w3.org/ns/activitystreams#Image",
				"https://www.w3.org/ns/activitystreams#Page",
				"https://www.w3.org/ns/activitystreams#Video",
				"https://www.w3.org/ns/activitystreams#Event",
				"https://www.w3.org/ns/activitystreams#Group",
				"https://www.w3.org/ns/activitystreams#Note",
				"https://www.w3.org/ns/activitystreams#Organization",
				"https://www.w3.org/ns/activitystreams#Person",
				"https://www.w3.org/ns/activitystreams#Place",
				"https://www.w3.org/ns/activitystreams#Profile",
				"https://www.w3.org/ns/activitystreams#Relationship",
				"https://www.w3.org/ns/activitystreams#Service",
				"https://www.w3.org/ns/activitystreams#Tombstone"
			].some((t) => v["@type"].includes(t)) ? await Object$1.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && [
				"https://www.w3.org/ns/activitystreams#Link",
				"https://www.w3.org/ns/activitystreams#Hashtag",
				"https://www.w3.org/ns/activitystreams#Mention"
			].some((t) => v["@type"].includes(t)) ? await Link.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : void 0;
			if (typeof decoded === "undefined") continue;
			_31k5MUZJsnsPNg8dQQJieWaXTFnR_location.push(decoded);
		}
		instance.#_31k5MUZJsnsPNg8dQQJieWaXTFnR_location = _31k5MUZJsnsPNg8dQQJieWaXTFnR_location;
		const _gCVTegXxWWCw6wWRxa1QF65zusg_preview = [];
		const _trust_gCVTegXxWWCw6wWRxa1QF65zusg_preview = /* @__PURE__ */ new Set();
		let _gCVTegXxWWCw6wWRxa1QF65zusg_preview__array = values["https://www.w3.org/ns/activitystreams#preview"];
		for (const v of _gCVTegXxWWCw6wWRxa1QF65zusg_preview__array == null ? [] : _gCVTegXxWWCw6wWRxa1QF65zusg_preview__array.length === 1 && "@list" in _gCVTegXxWWCw6wWRxa1QF65zusg_preview__array[0] ? _gCVTegXxWWCw6wWRxa1QF65zusg_preview__array[0]["@list"] : _gCVTegXxWWCw6wWRxa1QF65zusg_preview__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_gCVTegXxWWCw6wWRxa1QF65zusg_preview.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			const decoded = typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && [
				"https://www.w3.org/ns/activitystreams#Link",
				"https://www.w3.org/ns/activitystreams#Hashtag",
				"https://www.w3.org/ns/activitystreams#Mention"
			].some((t) => v["@type"].includes(t)) ? await Link.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && [
				"https://www.w3.org/ns/activitystreams#Object",
				"http://joinmastodon.org/ns#Emoji",
				"http://litepub.social/ns#ChatMessage",
				"https://www.w3.org/ns/activitystreams#Activity",
				"http://litepub.social/ns#EmojiReact",
				"https://www.w3.org/ns/activitystreams#Accept",
				"https://www.w3.org/ns/activitystreams#TentativeAccept",
				"https://www.w3.org/ns/activitystreams#Add",
				"https://www.w3.org/ns/activitystreams#Announce",
				"https://www.w3.org/ns/activitystreams#Create",
				"https://www.w3.org/ns/activitystreams#Delete",
				"https://www.w3.org/ns/activitystreams#Dislike",
				"https://www.w3.org/ns/activitystreams#Flag",
				"https://www.w3.org/ns/activitystreams#Follow",
				"https://www.w3.org/ns/activitystreams#Ignore",
				"https://www.w3.org/ns/activitystreams#Block",
				"https://www.w3.org/ns/activitystreams#IntransitiveActivity",
				"https://www.w3.org/ns/activitystreams#Arrive",
				"https://www.w3.org/ns/activitystreams#Question",
				"https://www.w3.org/ns/activitystreams#Travel",
				"https://www.w3.org/ns/activitystreams#Join",
				"https://www.w3.org/ns/activitystreams#Leave",
				"https://www.w3.org/ns/activitystreams#Like",
				"https://www.w3.org/ns/activitystreams#Listen",
				"https://www.w3.org/ns/activitystreams#Move",
				"https://www.w3.org/ns/activitystreams#Offer",
				"https://www.w3.org/ns/activitystreams#Invite",
				"https://www.w3.org/ns/activitystreams#Read",
				"https://www.w3.org/ns/activitystreams#Reject",
				"https://www.w3.org/ns/activitystreams#TentativeReject",
				"https://www.w3.org/ns/activitystreams#Remove",
				"https://www.w3.org/ns/activitystreams#Undo",
				"https://www.w3.org/ns/activitystreams#Update",
				"https://www.w3.org/ns/activitystreams#View",
				"https://www.w3.org/ns/activitystreams#Application",
				"https://www.w3.org/ns/activitystreams#Article",
				"https://www.w3.org/ns/activitystreams#Collection",
				"https://www.w3.org/ns/activitystreams#CollectionPage",
				"https://www.w3.org/ns/activitystreams#OrderedCollectionPage",
				"https://www.w3.org/ns/activitystreams#OrderedCollection",
				"https://www.w3.org/ns/activitystreams#Document",
				"https://www.w3.org/ns/activitystreams#Audio",
				"https://www.w3.org/ns/activitystreams#Image",
				"https://www.w3.org/ns/activitystreams#Page",
				"https://www.w3.org/ns/activitystreams#Video",
				"https://www.w3.org/ns/activitystreams#Event",
				"https://www.w3.org/ns/activitystreams#Group",
				"https://www.w3.org/ns/activitystreams#Note",
				"https://www.w3.org/ns/activitystreams#Organization",
				"https://www.w3.org/ns/activitystreams#Person",
				"https://www.w3.org/ns/activitystreams#Place",
				"https://www.w3.org/ns/activitystreams#Profile",
				"https://www.w3.org/ns/activitystreams#Relationship",
				"https://www.w3.org/ns/activitystreams#Service",
				"https://www.w3.org/ns/activitystreams#Tombstone"
			].some((t) => v["@type"].includes(t)) ? await Object$1.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : void 0;
			if (typeof decoded === "undefined") continue;
			_gCVTegXxWWCw6wWRxa1QF65zusg_preview.push(decoded);
		}
		instance.#_gCVTegXxWWCw6wWRxa1QF65zusg_preview = _gCVTegXxWWCw6wWRxa1QF65zusg_preview;
		const _5e258TDXtuhaFRPZiGoDfEpjdMr_published = [];
		let _5e258TDXtuhaFRPZiGoDfEpjdMr_published__array = values["https://www.w3.org/ns/activitystreams#published"];
		for (const v of _5e258TDXtuhaFRPZiGoDfEpjdMr_published__array == null ? [] : _5e258TDXtuhaFRPZiGoDfEpjdMr_published__array.length === 1 && "@list" in _5e258TDXtuhaFRPZiGoDfEpjdMr_published__array[0] ? _5e258TDXtuhaFRPZiGoDfEpjdMr_published__array[0]["@list"] : _5e258TDXtuhaFRPZiGoDfEpjdMr_published__array) {
			if (v == null) continue;
			_5e258TDXtuhaFRPZiGoDfEpjdMr_published.push(Temporal.Instant.from(v["@value"].substring(19).match(/[Z+-]/) ? v["@value"] : v["@value"] + "Z"));
		}
		instance.#_5e258TDXtuhaFRPZiGoDfEpjdMr_published = _5e258TDXtuhaFRPZiGoDfEpjdMr_published;
		const _7UpwM3JWcXhADcscukEehBorf6k_replies = [];
		const _trust_7UpwM3JWcXhADcscukEehBorf6k_replies = /* @__PURE__ */ new Set();
		let _7UpwM3JWcXhADcscukEehBorf6k_replies__array = values["https://www.w3.org/ns/activitystreams#replies"];
		for (const v of _7UpwM3JWcXhADcscukEehBorf6k_replies__array == null ? [] : _7UpwM3JWcXhADcscukEehBorf6k_replies__array.length === 1 && "@list" in _7UpwM3JWcXhADcscukEehBorf6k_replies__array[0] ? _7UpwM3JWcXhADcscukEehBorf6k_replies__array[0]["@list"] : _7UpwM3JWcXhADcscukEehBorf6k_replies__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_7UpwM3JWcXhADcscukEehBorf6k_replies.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_7UpwM3JWcXhADcscukEehBorf6k_replies.push(await Collection.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_7UpwM3JWcXhADcscukEehBorf6k_replies = _7UpwM3JWcXhADcscukEehBorf6k_replies;
		const _3kAfck9PcEYt2L7xug5y99YPbANs_shares = [];
		const _trust_3kAfck9PcEYt2L7xug5y99YPbANs_shares = /* @__PURE__ */ new Set();
		let _3kAfck9PcEYt2L7xug5y99YPbANs_shares__array = values["https://www.w3.org/ns/activitystreams#shares"];
		for (const v of _3kAfck9PcEYt2L7xug5y99YPbANs_shares__array == null ? [] : _3kAfck9PcEYt2L7xug5y99YPbANs_shares__array.length === 1 && "@list" in _3kAfck9PcEYt2L7xug5y99YPbANs_shares__array[0] ? _3kAfck9PcEYt2L7xug5y99YPbANs_shares__array[0]["@list"] : _3kAfck9PcEYt2L7xug5y99YPbANs_shares__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_3kAfck9PcEYt2L7xug5y99YPbANs_shares.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_3kAfck9PcEYt2L7xug5y99YPbANs_shares.push(await Collection.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_3kAfck9PcEYt2L7xug5y99YPbANs_shares = _3kAfck9PcEYt2L7xug5y99YPbANs_shares;
		const _S3ceDnpMdzoTRCccB9FkJWrEzYW_likes = [];
		const _trust_S3ceDnpMdzoTRCccB9FkJWrEzYW_likes = /* @__PURE__ */ new Set();
		let _S3ceDnpMdzoTRCccB9FkJWrEzYW_likes__array = values["https://www.w3.org/ns/activitystreams#likes"];
		for (const v of _S3ceDnpMdzoTRCccB9FkJWrEzYW_likes__array == null ? [] : _S3ceDnpMdzoTRCccB9FkJWrEzYW_likes__array.length === 1 && "@list" in _S3ceDnpMdzoTRCccB9FkJWrEzYW_likes__array[0] ? _S3ceDnpMdzoTRCccB9FkJWrEzYW_likes__array[0]["@list"] : _S3ceDnpMdzoTRCccB9FkJWrEzYW_likes__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_S3ceDnpMdzoTRCccB9FkJWrEzYW_likes.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_S3ceDnpMdzoTRCccB9FkJWrEzYW_likes.push(await Collection.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_S3ceDnpMdzoTRCccB9FkJWrEzYW_likes = _S3ceDnpMdzoTRCccB9FkJWrEzYW_likes;
		const _kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions = [];
		const _trust_kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions = /* @__PURE__ */ new Set();
		let _kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions__array = values["http://fedibird.com/ns#emojiReactions"];
		for (const v of _kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions__array == null ? [] : _kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions__array.length === 1 && "@list" in _kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions__array[0] ? _kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions__array[0]["@list"] : _kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions.push(await Collection.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions = _kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions;
		const _2w3Jmue4up8iVDUA51WZqomEF438_startTime = [];
		let _2w3Jmue4up8iVDUA51WZqomEF438_startTime__array = values["https://www.w3.org/ns/activitystreams#startTime"];
		for (const v of _2w3Jmue4up8iVDUA51WZqomEF438_startTime__array == null ? [] : _2w3Jmue4up8iVDUA51WZqomEF438_startTime__array.length === 1 && "@list" in _2w3Jmue4up8iVDUA51WZqomEF438_startTime__array[0] ? _2w3Jmue4up8iVDUA51WZqomEF438_startTime__array[0]["@list"] : _2w3Jmue4up8iVDUA51WZqomEF438_startTime__array) {
			if (v == null) continue;
			_2w3Jmue4up8iVDUA51WZqomEF438_startTime.push(Temporal.Instant.from(v["@value"].substring(19).match(/[Z+-]/) ? v["@value"] : v["@value"] + "Z"));
		}
		instance.#_2w3Jmue4up8iVDUA51WZqomEF438_startTime = _2w3Jmue4up8iVDUA51WZqomEF438_startTime;
		const _4LqirZspQbFWWQEbFcXAxm7tTDN1_summary = [];
		let _4LqirZspQbFWWQEbFcXAxm7tTDN1_summary__array = values["https://www.w3.org/ns/activitystreams#summary"];
		for (const v of _4LqirZspQbFWWQEbFcXAxm7tTDN1_summary__array == null ? [] : _4LqirZspQbFWWQEbFcXAxm7tTDN1_summary__array.length === 1 && "@list" in _4LqirZspQbFWWQEbFcXAxm7tTDN1_summary__array[0] ? _4LqirZspQbFWWQEbFcXAxm7tTDN1_summary__array[0]["@list"] : _4LqirZspQbFWWQEbFcXAxm7tTDN1_summary__array) {
			if (v == null) continue;
			const decoded = typeof v === "object" && "@value" in v && typeof v["@value"] === "string" && !("@language" in v) ? v["@value"] : typeof v === "object" && "@language" in v && "@value" in v && typeof v["@language"] === "string" && typeof v["@value"] === "string" ? new LanguageString(v["@value"], v["@language"]) : void 0;
			if (typeof decoded === "undefined") continue;
			_4LqirZspQbFWWQEbFcXAxm7tTDN1_summary.push(decoded);
		}
		instance.#_4LqirZspQbFWWQEbFcXAxm7tTDN1_summary = _4LqirZspQbFWWQEbFcXAxm7tTDN1_summary;
		const _5chuqj6s95p5gg2sk1HntGfarRf_tag = [];
		const _trust_5chuqj6s95p5gg2sk1HntGfarRf_tag = /* @__PURE__ */ new Set();
		let _5chuqj6s95p5gg2sk1HntGfarRf_tag__array = values["https://www.w3.org/ns/activitystreams#tag"];
		for (const v of _5chuqj6s95p5gg2sk1HntGfarRf_tag__array == null ? [] : _5chuqj6s95p5gg2sk1HntGfarRf_tag__array.length === 1 && "@list" in _5chuqj6s95p5gg2sk1HntGfarRf_tag__array[0] ? _5chuqj6s95p5gg2sk1HntGfarRf_tag__array[0]["@list"] : _5chuqj6s95p5gg2sk1HntGfarRf_tag__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_5chuqj6s95p5gg2sk1HntGfarRf_tag.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			const decoded = typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && [
				"https://www.w3.org/ns/activitystreams#Object",
				"http://joinmastodon.org/ns#Emoji",
				"http://litepub.social/ns#ChatMessage",
				"https://www.w3.org/ns/activitystreams#Activity",
				"http://litepub.social/ns#EmojiReact",
				"https://www.w3.org/ns/activitystreams#Accept",
				"https://www.w3.org/ns/activitystreams#TentativeAccept",
				"https://www.w3.org/ns/activitystreams#Add",
				"https://www.w3.org/ns/activitystreams#Announce",
				"https://www.w3.org/ns/activitystreams#Create",
				"https://www.w3.org/ns/activitystreams#Delete",
				"https://www.w3.org/ns/activitystreams#Dislike",
				"https://www.w3.org/ns/activitystreams#Flag",
				"https://www.w3.org/ns/activitystreams#Follow",
				"https://www.w3.org/ns/activitystreams#Ignore",
				"https://www.w3.org/ns/activitystreams#Block",
				"https://www.w3.org/ns/activitystreams#IntransitiveActivity",
				"https://www.w3.org/ns/activitystreams#Arrive",
				"https://www.w3.org/ns/activitystreams#Question",
				"https://www.w3.org/ns/activitystreams#Travel",
				"https://www.w3.org/ns/activitystreams#Join",
				"https://www.w3.org/ns/activitystreams#Leave",
				"https://www.w3.org/ns/activitystreams#Like",
				"https://www.w3.org/ns/activitystreams#Listen",
				"https://www.w3.org/ns/activitystreams#Move",
				"https://www.w3.org/ns/activitystreams#Offer",
				"https://www.w3.org/ns/activitystreams#Invite",
				"https://www.w3.org/ns/activitystreams#Read",
				"https://www.w3.org/ns/activitystreams#Reject",
				"https://www.w3.org/ns/activitystreams#TentativeReject",
				"https://www.w3.org/ns/activitystreams#Remove",
				"https://www.w3.org/ns/activitystreams#Undo",
				"https://www.w3.org/ns/activitystreams#Update",
				"https://www.w3.org/ns/activitystreams#View",
				"https://www.w3.org/ns/activitystreams#Application",
				"https://www.w3.org/ns/activitystreams#Article",
				"https://www.w3.org/ns/activitystreams#Collection",
				"https://www.w3.org/ns/activitystreams#CollectionPage",
				"https://www.w3.org/ns/activitystreams#OrderedCollectionPage",
				"https://www.w3.org/ns/activitystreams#OrderedCollection",
				"https://www.w3.org/ns/activitystreams#Document",
				"https://www.w3.org/ns/activitystreams#Audio",
				"https://www.w3.org/ns/activitystreams#Image",
				"https://www.w3.org/ns/activitystreams#Page",
				"https://www.w3.org/ns/activitystreams#Video",
				"https://www.w3.org/ns/activitystreams#Event",
				"https://www.w3.org/ns/activitystreams#Group",
				"https://www.w3.org/ns/activitystreams#Note",
				"https://www.w3.org/ns/activitystreams#Organization",
				"https://www.w3.org/ns/activitystreams#Person",
				"https://www.w3.org/ns/activitystreams#Place",
				"https://www.w3.org/ns/activitystreams#Profile",
				"https://www.w3.org/ns/activitystreams#Relationship",
				"https://www.w3.org/ns/activitystreams#Service",
				"https://www.w3.org/ns/activitystreams#Tombstone"
			].some((t) => v["@type"].includes(t)) ? await Object$1.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && [
				"https://www.w3.org/ns/activitystreams#Link",
				"https://www.w3.org/ns/activitystreams#Hashtag",
				"https://www.w3.org/ns/activitystreams#Mention"
			].some((t) => v["@type"].includes(t)) ? await Link.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : void 0;
			if (typeof decoded === "undefined") continue;
			_5chuqj6s95p5gg2sk1HntGfarRf_tag.push(decoded);
		}
		instance.#_5chuqj6s95p5gg2sk1HntGfarRf_tag = _5chuqj6s95p5gg2sk1HntGfarRf_tag;
		const _385aB7ySixcf5Un6z3VsWmThgCzQ_updated = [];
		let _385aB7ySixcf5Un6z3VsWmThgCzQ_updated__array = values["https://www.w3.org/ns/activitystreams#updated"];
		for (const v of _385aB7ySixcf5Un6z3VsWmThgCzQ_updated__array == null ? [] : _385aB7ySixcf5Un6z3VsWmThgCzQ_updated__array.length === 1 && "@list" in _385aB7ySixcf5Un6z3VsWmThgCzQ_updated__array[0] ? _385aB7ySixcf5Un6z3VsWmThgCzQ_updated__array[0]["@list"] : _385aB7ySixcf5Un6z3VsWmThgCzQ_updated__array) {
			if (v == null) continue;
			_385aB7ySixcf5Un6z3VsWmThgCzQ_updated.push(Temporal.Instant.from(v["@value"].substring(19).match(/[Z+-]/) ? v["@value"] : v["@value"] + "Z"));
		}
		instance.#_385aB7ySixcf5Un6z3VsWmThgCzQ_updated = _385aB7ySixcf5Un6z3VsWmThgCzQ_updated;
		const _2oPEH9MQ3aj8JVwyYuWkqoVwV865_url = [];
		let _2oPEH9MQ3aj8JVwyYuWkqoVwV865_url__array = values["https://www.w3.org/ns/activitystreams#url"];
		for (const v of _2oPEH9MQ3aj8JVwyYuWkqoVwV865_url__array == null ? [] : _2oPEH9MQ3aj8JVwyYuWkqoVwV865_url__array.length === 1 && "@list" in _2oPEH9MQ3aj8JVwyYuWkqoVwV865_url__array[0] ? _2oPEH9MQ3aj8JVwyYuWkqoVwV865_url__array[0]["@list"] : _2oPEH9MQ3aj8JVwyYuWkqoVwV865_url__array) {
			if (v == null) continue;
			const decoded = typeof v === "object" && "@id" in v && typeof v["@id"] === "string" && v["@id"] !== "" ? v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].includes("/", 5) ? v["@id"].slice(5, v["@id"].indexOf("/", 5)) : v["@id"].slice(5)) + (v["@id"].includes("/", 5) ? v["@id"].slice(v["@id"].indexOf("/", 5)) : "")) : URL.canParse(v["@id"]) && (values["@id"] == null ? options.baseUrl : new URL(values["@id"])) ? new URL(v["@id"]) : new URL(v["@id"], values["@id"] == null ? options.baseUrl : new URL(values["@id"])) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && [
				"https://www.w3.org/ns/activitystreams#Link",
				"https://www.w3.org/ns/activitystreams#Hashtag",
				"https://www.w3.org/ns/activitystreams#Mention"
			].some((t) => v["@type"].includes(t)) ? await Link.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : void 0;
			if (typeof decoded === "undefined") continue;
			_2oPEH9MQ3aj8JVwyYuWkqoVwV865_url.push(decoded);
		}
		instance.#_2oPEH9MQ3aj8JVwyYuWkqoVwV865_url = _2oPEH9MQ3aj8JVwyYuWkqoVwV865_url;
		const _3hFbw7DTpHhq3cvVhkY8njhcsXbd_to = [];
		const _trust_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to = /* @__PURE__ */ new Set();
		let _3hFbw7DTpHhq3cvVhkY8njhcsXbd_to__array = values["https://www.w3.org/ns/activitystreams#to"];
		for (const v of _3hFbw7DTpHhq3cvVhkY8njhcsXbd_to__array == null ? [] : _3hFbw7DTpHhq3cvVhkY8njhcsXbd_to__array.length === 1 && "@list" in _3hFbw7DTpHhq3cvVhkY8njhcsXbd_to__array[0] ? _3hFbw7DTpHhq3cvVhkY8njhcsXbd_to__array[0]["@list"] : _3hFbw7DTpHhq3cvVhkY8njhcsXbd_to__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to.push(await Object$1.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to = _3hFbw7DTpHhq3cvVhkY8njhcsXbd_to;
		const _aLZupjwL8XB7tzdLgCMXdjZ6qej_bto = [];
		const _trust_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto = /* @__PURE__ */ new Set();
		let _aLZupjwL8XB7tzdLgCMXdjZ6qej_bto__array = values["https://www.w3.org/ns/activitystreams#bto"];
		for (const v of _aLZupjwL8XB7tzdLgCMXdjZ6qej_bto__array == null ? [] : _aLZupjwL8XB7tzdLgCMXdjZ6qej_bto__array.length === 1 && "@list" in _aLZupjwL8XB7tzdLgCMXdjZ6qej_bto__array[0] ? _aLZupjwL8XB7tzdLgCMXdjZ6qej_bto__array[0]["@list"] : _aLZupjwL8XB7tzdLgCMXdjZ6qej_bto__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto.push(await Object$1.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto = _aLZupjwL8XB7tzdLgCMXdjZ6qej_bto;
		const _42a1SvBs24QSLzKcfjCyNTjW5a1g_cc = [];
		const _trust_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc = /* @__PURE__ */ new Set();
		let _42a1SvBs24QSLzKcfjCyNTjW5a1g_cc__array = values["https://www.w3.org/ns/activitystreams#cc"];
		for (const v of _42a1SvBs24QSLzKcfjCyNTjW5a1g_cc__array == null ? [] : _42a1SvBs24QSLzKcfjCyNTjW5a1g_cc__array.length === 1 && "@list" in _42a1SvBs24QSLzKcfjCyNTjW5a1g_cc__array[0] ? _42a1SvBs24QSLzKcfjCyNTjW5a1g_cc__array[0]["@list"] : _42a1SvBs24QSLzKcfjCyNTjW5a1g_cc__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc.push(await Object$1.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc = _42a1SvBs24QSLzKcfjCyNTjW5a1g_cc;
		const _3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc = [];
		const _trust_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc = /* @__PURE__ */ new Set();
		let _3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc__array = values["https://www.w3.org/ns/activitystreams#bcc"];
		for (const v of _3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc__array == null ? [] : _3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc__array.length === 1 && "@list" in _3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc__array[0] ? _3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc__array[0]["@list"] : _3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc.push(await Object$1.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc = _3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc;
		const _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType = [];
		let _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType__array = values["https://www.w3.org/ns/activitystreams#mediaType"];
		for (const v of _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType__array == null ? [] : _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType__array.length === 1 && "@list" in _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType__array[0] ? _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType__array[0]["@list"] : _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType__array) {
			if (v == null) continue;
			_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType.push(v["@value"]);
		}
		instance.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType = _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType;
		const _3bNvLMBN1bCJETiTihM3wvi1B2JX_duration = [];
		let _3bNvLMBN1bCJETiTihM3wvi1B2JX_duration__array = values["https://www.w3.org/ns/activitystreams#duration"];
		for (const v of _3bNvLMBN1bCJETiTihM3wvi1B2JX_duration__array == null ? [] : _3bNvLMBN1bCJETiTihM3wvi1B2JX_duration__array.length === 1 && "@list" in _3bNvLMBN1bCJETiTihM3wvi1B2JX_duration__array[0] ? _3bNvLMBN1bCJETiTihM3wvi1B2JX_duration__array[0]["@list"] : _3bNvLMBN1bCJETiTihM3wvi1B2JX_duration__array) {
			if (v == null) continue;
			_3bNvLMBN1bCJETiTihM3wvi1B2JX_duration.push(Temporal.Duration.from(v["@value"]));
		}
		instance.#_3bNvLMBN1bCJETiTihM3wvi1B2JX_duration = _3bNvLMBN1bCJETiTihM3wvi1B2JX_duration;
		const _u8gdcDTtChQ4tbSQMXc4cYWyum7_sensitive = [];
		let _u8gdcDTtChQ4tbSQMXc4cYWyum7_sensitive__array = values["https://www.w3.org/ns/activitystreams#sensitive"];
		for (const v of _u8gdcDTtChQ4tbSQMXc4cYWyum7_sensitive__array == null ? [] : _u8gdcDTtChQ4tbSQMXc4cYWyum7_sensitive__array.length === 1 && "@list" in _u8gdcDTtChQ4tbSQMXc4cYWyum7_sensitive__array[0] ? _u8gdcDTtChQ4tbSQMXc4cYWyum7_sensitive__array[0]["@list"] : _u8gdcDTtChQ4tbSQMXc4cYWyum7_sensitive__array) {
			if (v == null) continue;
			_u8gdcDTtChQ4tbSQMXc4cYWyum7_sensitive.push(v["@value"]);
		}
		instance.#_u8gdcDTtChQ4tbSQMXc4cYWyum7_sensitive = _u8gdcDTtChQ4tbSQMXc4cYWyum7_sensitive;
		const _2ZwCFoS787v8y8bXKjMoE6MAbrEB_source = [];
		let _2ZwCFoS787v8y8bXKjMoE6MAbrEB_source__array = values["https://www.w3.org/ns/activitystreams#source"];
		for (const v of _2ZwCFoS787v8y8bXKjMoE6MAbrEB_source__array == null ? [] : _2ZwCFoS787v8y8bXKjMoE6MAbrEB_source__array.length === 1 && "@list" in _2ZwCFoS787v8y8bXKjMoE6MAbrEB_source__array[0] ? _2ZwCFoS787v8y8bXKjMoE6MAbrEB_source__array[0]["@list"] : _2ZwCFoS787v8y8bXKjMoE6MAbrEB_source__array) {
			if (v == null) continue;
			_2ZwCFoS787v8y8bXKjMoE6MAbrEB_source.push(await Source.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_2ZwCFoS787v8y8bXKjMoE6MAbrEB_source = _2ZwCFoS787v8y8bXKjMoE6MAbrEB_source;
		const _42rPnotok1ivQ2RNCKNbeFJgx8b8_proof = [];
		const _trust_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof = /* @__PURE__ */ new Set();
		let _42rPnotok1ivQ2RNCKNbeFJgx8b8_proof__array = values["https://w3id.org/security#proof"];
		for (const v of _42rPnotok1ivQ2RNCKNbeFJgx8b8_proof__array == null ? [] : _42rPnotok1ivQ2RNCKNbeFJgx8b8_proof__array.length === 1 && "@list" in _42rPnotok1ivQ2RNCKNbeFJgx8b8_proof__array[0] ? _42rPnotok1ivQ2RNCKNbeFJgx8b8_proof__array[0]["@list"] : _42rPnotok1ivQ2RNCKNbeFJgx8b8_proof__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof.push(await DataIntegrityProof.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof = _42rPnotok1ivQ2RNCKNbeFJgx8b8_proof;
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = {};
		if (this.id != null) proxy.id = {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(this.id.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(this.id.href, options)
		};
		const _49BipA5dq9eoH8LX8xdsVumveTca_attachment = this.#_49BipA5dq9eoH8LX8xdsVumveTca_attachment.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_49BipA5dq9eoH8LX8xdsVumveTca_attachment.length > 1 || !("attachment" in proxy) && _49BipA5dq9eoH8LX8xdsVumveTca_attachment.length > 0) proxy.attachments = _49BipA5dq9eoH8LX8xdsVumveTca_attachment;
		const _42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo = this.#_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo.length == 1) proxy.attribution = _42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo[0];
		if (_42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo.length > 1 || !("attribution" in proxy) && _42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo.length > 0) proxy.attributions = _42CGqJ94zgQ3ZBbfHwD8Hrr2L5Py_attributedTo;
		const _3ocC3VVi88cEd5sPWL8djkZsvTN6_audience = this.#_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience.length == 1) proxy.audience = _3ocC3VVi88cEd5sPWL8djkZsvTN6_audience[0];
		if (_3ocC3VVi88cEd5sPWL8djkZsvTN6_audience.length > 1 || !("audience" in proxy) && _3ocC3VVi88cEd5sPWL8djkZsvTN6_audience.length > 0) proxy.audiences = _3ocC3VVi88cEd5sPWL8djkZsvTN6_audience;
		const _4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content = this.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content.length == 1) proxy.content = _4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content[0];
		if (_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content.length > 1 || !("content" in proxy) && _4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content.length > 0) proxy.contents = _4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content;
		const _3mhZzGXSpQ431mBSz2kvych22v4e_context = this.#_3mhZzGXSpQ431mBSz2kvych22v4e_context.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3mhZzGXSpQ431mBSz2kvych22v4e_context.length > 1 || !("context" in proxy) && _3mhZzGXSpQ431mBSz2kvych22v4e_context.length > 0) proxy.contexts = _3mhZzGXSpQ431mBSz2kvych22v4e_context;
		const _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name = this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name.length == 1) proxy.name = _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name[0];
		if (_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name.length > 1 || !("name" in proxy) && _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name.length > 0) proxy.names = _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name;
		const _219RwDanjScTv5tYCjwGZVCM7KZ9_endTime = this.#_219RwDanjScTv5tYCjwGZVCM7KZ9_endTime.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_219RwDanjScTv5tYCjwGZVCM7KZ9_endTime.length == 1) proxy.endTime = _219RwDanjScTv5tYCjwGZVCM7KZ9_endTime[0];
		const _86xFhmgBapoMvYqjbjRuDPayTrS_generator = this.#_86xFhmgBapoMvYqjbjRuDPayTrS_generator.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_86xFhmgBapoMvYqjbjRuDPayTrS_generator.length > 1 || !("generator" in proxy) && _86xFhmgBapoMvYqjbjRuDPayTrS_generator.length > 0) proxy.generators = _86xFhmgBapoMvYqjbjRuDPayTrS_generator;
		const _33CjRLy5ujtsUrwRSCrsggvGdKuR_icon = this.#_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon.length == 1) proxy.icon = _33CjRLy5ujtsUrwRSCrsggvGdKuR_icon[0];
		if (_33CjRLy5ujtsUrwRSCrsggvGdKuR_icon.length > 1 || !("icon" in proxy) && _33CjRLy5ujtsUrwRSCrsggvGdKuR_icon.length > 0) proxy.icons = _33CjRLy5ujtsUrwRSCrsggvGdKuR_icon;
		const _3dXrUdkARxwyJLtJcYi1AJ92H41U_image = this.#_3dXrUdkARxwyJLtJcYi1AJ92H41U_image.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3dXrUdkARxwyJLtJcYi1AJ92H41U_image.length == 1) proxy.image = _3dXrUdkARxwyJLtJcYi1AJ92H41U_image[0];
		if (_3dXrUdkARxwyJLtJcYi1AJ92H41U_image.length > 1 || !("image" in proxy) && _3dXrUdkARxwyJLtJcYi1AJ92H41U_image.length > 0) proxy.images = _3dXrUdkARxwyJLtJcYi1AJ92H41U_image;
		const _3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo = this.#_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo.length == 1) proxy.replyTarget = _3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo[0];
		if (_3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo.length > 1 || !("replyTarget" in proxy) && _3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo.length > 0) proxy.replyTargets = _3fpbDrvZgf3Kq1a5V9aByFn8kx3s_inReplyTo;
		const _31k5MUZJsnsPNg8dQQJieWaXTFnR_location = this.#_31k5MUZJsnsPNg8dQQJieWaXTFnR_location.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_31k5MUZJsnsPNg8dQQJieWaXTFnR_location.length == 1) proxy.location = _31k5MUZJsnsPNg8dQQJieWaXTFnR_location[0];
		if (_31k5MUZJsnsPNg8dQQJieWaXTFnR_location.length > 1 || !("location" in proxy) && _31k5MUZJsnsPNg8dQQJieWaXTFnR_location.length > 0) proxy.locations = _31k5MUZJsnsPNg8dQQJieWaXTFnR_location;
		const _gCVTegXxWWCw6wWRxa1QF65zusg_preview = this.#_gCVTegXxWWCw6wWRxa1QF65zusg_preview.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_gCVTegXxWWCw6wWRxa1QF65zusg_preview.length == 1) proxy.preview = _gCVTegXxWWCw6wWRxa1QF65zusg_preview[0];
		if (_gCVTegXxWWCw6wWRxa1QF65zusg_preview.length > 1 || !("preview" in proxy) && _gCVTegXxWWCw6wWRxa1QF65zusg_preview.length > 0) proxy.previews = _gCVTegXxWWCw6wWRxa1QF65zusg_preview;
		const _5e258TDXtuhaFRPZiGoDfEpjdMr_published = this.#_5e258TDXtuhaFRPZiGoDfEpjdMr_published.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_5e258TDXtuhaFRPZiGoDfEpjdMr_published.length == 1) proxy.published = _5e258TDXtuhaFRPZiGoDfEpjdMr_published[0];
		const _7UpwM3JWcXhADcscukEehBorf6k_replies = this.#_7UpwM3JWcXhADcscukEehBorf6k_replies.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_7UpwM3JWcXhADcscukEehBorf6k_replies.length == 1) proxy.replies = _7UpwM3JWcXhADcscukEehBorf6k_replies[0];
		const _3kAfck9PcEYt2L7xug5y99YPbANs_shares = this.#_3kAfck9PcEYt2L7xug5y99YPbANs_shares.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3kAfck9PcEYt2L7xug5y99YPbANs_shares.length == 1) proxy.shares = _3kAfck9PcEYt2L7xug5y99YPbANs_shares[0];
		const _S3ceDnpMdzoTRCccB9FkJWrEzYW_likes = this.#_S3ceDnpMdzoTRCccB9FkJWrEzYW_likes.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_S3ceDnpMdzoTRCccB9FkJWrEzYW_likes.length == 1) proxy.likes = _S3ceDnpMdzoTRCccB9FkJWrEzYW_likes[0];
		const _kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions = this.#_kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions.length == 1) proxy.emojiReactions = _kMatyyNAuxoTD8GQMBfA5ogThMR_emojiReactions[0];
		const _2w3Jmue4up8iVDUA51WZqomEF438_startTime = this.#_2w3Jmue4up8iVDUA51WZqomEF438_startTime.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_2w3Jmue4up8iVDUA51WZqomEF438_startTime.length == 1) proxy.startTime = _2w3Jmue4up8iVDUA51WZqomEF438_startTime[0];
		const _4LqirZspQbFWWQEbFcXAxm7tTDN1_summary = this.#_4LqirZspQbFWWQEbFcXAxm7tTDN1_summary.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_4LqirZspQbFWWQEbFcXAxm7tTDN1_summary.length == 1) proxy.summary = _4LqirZspQbFWWQEbFcXAxm7tTDN1_summary[0];
		if (_4LqirZspQbFWWQEbFcXAxm7tTDN1_summary.length > 1 || !("summary" in proxy) && _4LqirZspQbFWWQEbFcXAxm7tTDN1_summary.length > 0) proxy.summaries = _4LqirZspQbFWWQEbFcXAxm7tTDN1_summary;
		const _5chuqj6s95p5gg2sk1HntGfarRf_tag = this.#_5chuqj6s95p5gg2sk1HntGfarRf_tag.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_5chuqj6s95p5gg2sk1HntGfarRf_tag.length > 1 || !("tag" in proxy) && _5chuqj6s95p5gg2sk1HntGfarRf_tag.length > 0) proxy.tags = _5chuqj6s95p5gg2sk1HntGfarRf_tag;
		const _385aB7ySixcf5Un6z3VsWmThgCzQ_updated = this.#_385aB7ySixcf5Un6z3VsWmThgCzQ_updated.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_385aB7ySixcf5Un6z3VsWmThgCzQ_updated.length == 1) proxy.updated = _385aB7ySixcf5Un6z3VsWmThgCzQ_updated[0];
		const _2oPEH9MQ3aj8JVwyYuWkqoVwV865_url = this.#_2oPEH9MQ3aj8JVwyYuWkqoVwV865_url.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_2oPEH9MQ3aj8JVwyYuWkqoVwV865_url.length == 1) proxy.url = _2oPEH9MQ3aj8JVwyYuWkqoVwV865_url[0];
		if (_2oPEH9MQ3aj8JVwyYuWkqoVwV865_url.length > 1 || !("url" in proxy) && _2oPEH9MQ3aj8JVwyYuWkqoVwV865_url.length > 0) proxy.urls = _2oPEH9MQ3aj8JVwyYuWkqoVwV865_url;
		const _3hFbw7DTpHhq3cvVhkY8njhcsXbd_to = this.#_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to.length == 1) proxy.to = _3hFbw7DTpHhq3cvVhkY8njhcsXbd_to[0];
		if (_3hFbw7DTpHhq3cvVhkY8njhcsXbd_to.length > 1 || !("to" in proxy) && _3hFbw7DTpHhq3cvVhkY8njhcsXbd_to.length > 0) proxy.tos = _3hFbw7DTpHhq3cvVhkY8njhcsXbd_to;
		const _aLZupjwL8XB7tzdLgCMXdjZ6qej_bto = this.#_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto.length == 1) proxy.bto = _aLZupjwL8XB7tzdLgCMXdjZ6qej_bto[0];
		if (_aLZupjwL8XB7tzdLgCMXdjZ6qej_bto.length > 1 || !("bto" in proxy) && _aLZupjwL8XB7tzdLgCMXdjZ6qej_bto.length > 0) proxy.btos = _aLZupjwL8XB7tzdLgCMXdjZ6qej_bto;
		const _42a1SvBs24QSLzKcfjCyNTjW5a1g_cc = this.#_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc.length == 1) proxy.cc = _42a1SvBs24QSLzKcfjCyNTjW5a1g_cc[0];
		if (_42a1SvBs24QSLzKcfjCyNTjW5a1g_cc.length > 1 || !("cc" in proxy) && _42a1SvBs24QSLzKcfjCyNTjW5a1g_cc.length > 0) proxy.ccs = _42a1SvBs24QSLzKcfjCyNTjW5a1g_cc;
		const _3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc = this.#_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc.length == 1) proxy.bcc = _3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc[0];
		if (_3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc.length > 1 || !("bcc" in proxy) && _3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc.length > 0) proxy.bccs = _3qvegKUB8YLgTXRpEf8E6JZSkz2H_bcc;
		const _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType = this.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType.length == 1) proxy.mediaType = _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType[0];
		const _3bNvLMBN1bCJETiTihM3wvi1B2JX_duration = this.#_3bNvLMBN1bCJETiTihM3wvi1B2JX_duration.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3bNvLMBN1bCJETiTihM3wvi1B2JX_duration.length == 1) proxy.duration = _3bNvLMBN1bCJETiTihM3wvi1B2JX_duration[0];
		const _u8gdcDTtChQ4tbSQMXc4cYWyum7_sensitive = this.#_u8gdcDTtChQ4tbSQMXc4cYWyum7_sensitive.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_u8gdcDTtChQ4tbSQMXc4cYWyum7_sensitive.length == 1) proxy.sensitive = _u8gdcDTtChQ4tbSQMXc4cYWyum7_sensitive[0];
		const _2ZwCFoS787v8y8bXKjMoE6MAbrEB_source = this.#_2ZwCFoS787v8y8bXKjMoE6MAbrEB_source.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_2ZwCFoS787v8y8bXKjMoE6MAbrEB_source.length == 1) proxy.source = _2ZwCFoS787v8y8bXKjMoE6MAbrEB_source[0];
		const _42rPnotok1ivQ2RNCKNbeFJgx8b8_proof = this.#_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof.length == 1) proxy.proof = _42rPnotok1ivQ2RNCKNbeFJgx8b8_proof[0];
		if (_42rPnotok1ivQ2RNCKNbeFJgx8b8_proof.length > 1 || !("proof" in proxy) && _42rPnotok1ivQ2RNCKNbeFJgx8b8_proof.length > 0) proxy.proofs = _42rPnotok1ivQ2RNCKNbeFJgx8b8_proof;
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "Object " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "Object " + inspect(proxy, options);
	}
};
/** Represents a custom emoji.
*/
var Emoji = class Emoji extends Object$1 {
	/**
	* The type URI of {@link Emoji}: `http://joinmastodon.org/ns#Emoji`.
	*/
	static get typeId() {
		return new URL("http://joinmastodon.org/ns#Emoji");
	}
	/**
	* Constructs a new instance of Emoji with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		return clone;
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		if (options.format == null && this.isCompactable()) {
			const result = await super.toJsonLd({
				...options,
				format: void 0,
				context: void 0
			});
			let compactItems;
			result["type"] = "Emoji";
			if (this.id != null) result["id"] = this.id.href;
			result["@context"] = ["https://www.w3.org/ns/activitystreams", {
				"toot": "http://joinmastodon.org/ns#",
				"Emoji": "toot:Emoji"
			}];
			return result;
		}
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		values["@type"] = ["http://joinmastodon.org/ns#Emoji"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? ["https://www.w3.org/ns/activitystreams", {
			"toot": "http://joinmastodon.org/ns#",
			"Emoji": "toot:Emoji"
		}];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {
			if ("proof" in compacted && compacted.proof != null) if (Array.isArray(compacted.proof)) for (const element of compacted.proof) element["@context"] = docContext;
			else compacted.proof["@context"] = docContext;
		}
		return compacted;
	}
	isCompactable() {
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__Emoji__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__Emoji__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (!values["@type"].includes("http://joinmastodon.org/ns#Emoji")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof Emoji)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "Emoji " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "Emoji " + inspect(proxy, options);
	}
};
/** `ChatMessage`s are the messages sent in 1-on-1 chats.  They are similar to
* {@link Note}s, but the addressing is done by having a single AP actor in
* the `to` field.  Addressing multiple actors is not allowed.  These messages
* are always private, there is no public version of them.  They are created with
* a {@link Create} activity.
*/
var ChatMessage = class ChatMessage extends Object$1 {
	/**
	* The type URI of {@link ChatMessage}: `http://litepub.social/ns#ChatMessage`.
	*/
	static get typeId() {
		return new URL("http://litepub.social/ns#ChatMessage");
	}
	#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl = [];
	/**
	* Constructs a new instance of ChatMessage with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
		if ("quoteUrl" in values && values.quoteUrl != null) if (values.quoteUrl instanceof URL) this.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl = [values.quoteUrl];
		else throw new TypeError("The quoteUrl must be of type URL.");
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		clone.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl = this.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl;
		if ("quoteUrl" in values && values.quoteUrl != null) if (values.quoteUrl instanceof URL) clone.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl = [values.quoteUrl];
		else throw new TypeError("The quoteUrl must be of type URL.");
		return clone;
	}
	/** The URI of the ActivityStreams object that this object quotes.
	*
	* This property sets three JSON-LD properties at once under the hood:
	*
	* 1. https://www.w3.org/ns/activitystreams#quoteUrl
	* 2. https://misskey-hub.net/ns#_misskey_quote
	* 3. http://fedibird.com/ns#quoteUri
	*
	* When a JSON-LD object is parsed, this property is filled with one of
	* the values of those three properties in order.
	*/
	get quoteUrl() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl.length < 1) return null;
		return this.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl[0];
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		if (options.format == null && this.isCompactable()) {
			const result = await super.toJsonLd({
				...options,
				format: void 0,
				context: void 0
			});
			let compactItems;
			compactItems = [];
			for (const v of this.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl) {
				const item = v.href;
				compactItems.push(item);
			}
			if (compactItems.length > 0) {
				result["quoteUrl"] = compactItems.length > 1 ? compactItems : compactItems[0];
				result["_misskey_quote"] = compactItems.length > 1 ? compactItems : compactItems[0];
				result["quoteUri"] = compactItems.length > 1 ? compactItems : compactItems[0];
			}
			result["type"] = "ChatMessage";
			if (this.id != null) result["id"] = this.id.href;
			result["@context"] = [
				"https://www.w3.org/ns/activitystreams",
				"https://w3id.org/security/data-integrity/v1",
				{
					"toot": "http://joinmastodon.org/ns#",
					"misskey": "https://misskey-hub.net/ns#",
					"fedibird": "http://fedibird.com/ns#",
					"Emoji": "toot:Emoji",
					"ChatMessage": "http://litepub.social/ns#ChatMessage",
					"quoteUrl": "as:quoteUrl",
					"_misskey_quote": "misskey:_misskey_quote",
					"quoteUri": "fedibird:quoteUri",
					"emojiReactions": {
						"@id": "fedibird:emojiReactions",
						"@type": "@id"
					}
				}
			];
			return result;
		}
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		array = [];
		for (const v of this.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl) {
			const element = { "@value": v.href };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#quoteUrl"] = propValue;
			values["https://misskey-hub.net/ns#_misskey_quote"] = propValue;
			values["http://fedibird.com/ns#quoteUri"] = propValue;
		}
		values["@type"] = ["http://litepub.social/ns#ChatMessage"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? [
			"https://www.w3.org/ns/activitystreams",
			"https://w3id.org/security/data-integrity/v1",
			{
				"toot": "http://joinmastodon.org/ns#",
				"misskey": "https://misskey-hub.net/ns#",
				"fedibird": "http://fedibird.com/ns#",
				"Emoji": "toot:Emoji",
				"ChatMessage": "http://litepub.social/ns#ChatMessage",
				"quoteUrl": "as:quoteUrl",
				"_misskey_quote": "misskey:_misskey_quote",
				"quoteUri": "fedibird:quoteUri",
				"emojiReactions": {
					"@id": "fedibird:emojiReactions",
					"@type": "@id"
				}
			}
		];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {
			if ("proof" in compacted && compacted.proof != null) if (Array.isArray(compacted.proof)) for (const element of compacted.proof) element["@context"] = docContext;
			else compacted.proof["@context"] = docContext;
		}
		return compacted;
	}
	isCompactable() {
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__ChatMessage__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__ChatMessage__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (!values["@type"].includes("http://litepub.social/ns#ChatMessage")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof ChatMessage)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		const _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl = [];
		let _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array = values["https://www.w3.org/ns/activitystreams#quoteUrl"];
		if (_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array == null || _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array.length < 1) _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array = values["https://misskey-hub.net/ns#_misskey_quote"];
		if (_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array == null || _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array.length < 1) _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array = values["http://fedibird.com/ns#quoteUri"];
		for (const v of _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array == null ? [] : _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array.length === 1 && "@list" in _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array[0] ? _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array[0]["@list"] : _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array) {
			if (v == null) continue;
			_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl.push(new URL(v["@value"]));
		}
		instance.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl = _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl;
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		const _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl = this.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl.length == 1) proxy.quoteUrl = _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl[0];
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "ChatMessage " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "ChatMessage " + inspect(proxy, options);
	}
};
/** An Activity is a subtype of {@link Object} that describes some form of action
* that may happen, is currently happening, or has already happened.
* The {@link Activity} type itself serves as an abstract base type for all types
* of activities.  It is important to note that the {@link Activity} type itself
* does not carry any specific semantics about the kind of action being taken.
*/
var Activity = class Activity extends Object$1 {
	/**
	* The type URI of {@link Activity}: `https://www.w3.org/ns/activitystreams#Activity`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#Activity");
	}
	#_2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor = [];
	#_trust_2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor = /* @__PURE__ */ new Set();
	#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object = [];
	#_trust_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object = /* @__PURE__ */ new Set();
	#_3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target = [];
	#_trust_3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target = /* @__PURE__ */ new Set();
	#_u4QGFbRFcYmPEKGbPv1hpBR9r5G_result = [];
	#_trust_u4QGFbRFcYmPEKGbPv1hpBR9r5G_result = /* @__PURE__ */ new Set();
	#_25zu2s3VxVujgEKqrDycjE284XQR_origin = [];
	#_trust_25zu2s3VxVujgEKqrDycjE284XQR_origin = /* @__PURE__ */ new Set();
	#_3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument = [];
	#_trust_3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument = /* @__PURE__ */ new Set();
	/**
	* Constructs a new instance of Activity with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
		if ("actor" in values && values.actor != null) if (values.actor instanceof Application || values.actor instanceof Group || values.actor instanceof Organization || values.actor instanceof Person || values.actor instanceof Service || values.actor instanceof URL) {
			this.#_2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor = [values.actor];
			this.#_trust_2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor.add(0);
		} else throw new TypeError("The actor must be of type Application | Group | Organization | Person | Service | URL.");
		if ("actors" in values && values.actors != null) {
			if ("actor" in values && values.actor != null) throw new TypeError("Cannot initialize both actor and actors at the same time.");
			if (Array.isArray(values.actors) && values.actors.every((v) => v instanceof Application || v instanceof Group || v instanceof Organization || v instanceof Person || v instanceof Service || v instanceof URL)) {
				this.#_2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor = values.actors;
				for (let i = 0; i < values.actors.length; i++) this.#_trust_2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor.add(i);
			} else throw new TypeError("The actors must be an array of type Application | Group | Organization | Person | Service | URL.");
		}
		if ("object" in values && values.object != null) if (values.object instanceof Object$1 || values.object instanceof URL) {
			this.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object = [values.object];
			this.#_trust_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object.add(0);
		} else throw new TypeError("The object must be of type Object | URL.");
		if ("objects" in values && values.objects != null) {
			if ("object" in values && values.object != null) throw new TypeError("Cannot initialize both object and objects at the same time.");
			if (Array.isArray(values.objects) && values.objects.every((v) => v instanceof Object$1 || v instanceof URL)) {
				this.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object = values.objects;
				for (let i = 0; i < values.objects.length; i++) this.#_trust_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object.add(i);
			} else throw new TypeError("The objects must be an array of type Object | URL.");
		}
		if ("target" in values && values.target != null) if (values.target instanceof Object$1 || values.target instanceof URL) {
			this.#_3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target = [values.target];
			this.#_trust_3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target.add(0);
		} else throw new TypeError("The target must be of type Object | URL.");
		if ("targets" in values && values.targets != null) {
			if ("target" in values && values.target != null) throw new TypeError("Cannot initialize both target and targets at the same time.");
			if (Array.isArray(values.targets) && values.targets.every((v) => v instanceof Object$1 || v instanceof URL)) {
				this.#_3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target = values.targets;
				for (let i = 0; i < values.targets.length; i++) this.#_trust_3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target.add(i);
			} else throw new TypeError("The targets must be an array of type Object | URL.");
		}
		if ("result" in values && values.result != null) if (values.result instanceof Object$1 || values.result instanceof URL) {
			this.#_u4QGFbRFcYmPEKGbPv1hpBR9r5G_result = [values.result];
			this.#_trust_u4QGFbRFcYmPEKGbPv1hpBR9r5G_result.add(0);
		} else throw new TypeError("The result must be of type Object | URL.");
		if ("results" in values && values.results != null) {
			if ("result" in values && values.result != null) throw new TypeError("Cannot initialize both result and results at the same time.");
			if (Array.isArray(values.results) && values.results.every((v) => v instanceof Object$1 || v instanceof URL)) {
				this.#_u4QGFbRFcYmPEKGbPv1hpBR9r5G_result = values.results;
				for (let i = 0; i < values.results.length; i++) this.#_trust_u4QGFbRFcYmPEKGbPv1hpBR9r5G_result.add(i);
			} else throw new TypeError("The results must be an array of type Object | URL.");
		}
		if ("origin" in values && values.origin != null) if (values.origin instanceof Object$1 || values.origin instanceof URL) {
			this.#_25zu2s3VxVujgEKqrDycjE284XQR_origin = [values.origin];
			this.#_trust_25zu2s3VxVujgEKqrDycjE284XQR_origin.add(0);
		} else throw new TypeError("The origin must be of type Object | URL.");
		if ("origins" in values && values.origins != null) {
			if ("origin" in values && values.origin != null) throw new TypeError("Cannot initialize both origin and origins at the same time.");
			if (Array.isArray(values.origins) && values.origins.every((v) => v instanceof Object$1 || v instanceof URL)) {
				this.#_25zu2s3VxVujgEKqrDycjE284XQR_origin = values.origins;
				for (let i = 0; i < values.origins.length; i++) this.#_trust_25zu2s3VxVujgEKqrDycjE284XQR_origin.add(i);
			} else throw new TypeError("The origins must be an array of type Object | URL.");
		}
		if ("instrument" in values && values.instrument != null) if (values.instrument instanceof Object$1 || values.instrument instanceof URL) {
			this.#_3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument = [values.instrument];
			this.#_trust_3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument.add(0);
		} else throw new TypeError("The instrument must be of type Object | URL.");
		if ("instruments" in values && values.instruments != null) {
			if ("instrument" in values && values.instrument != null) throw new TypeError("Cannot initialize both instrument and instruments at the same time.");
			if (Array.isArray(values.instruments) && values.instruments.every((v) => v instanceof Object$1 || v instanceof URL)) {
				this.#_3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument = values.instruments;
				for (let i = 0; i < values.instruments.length; i++) this.#_trust_3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument.add(i);
			} else throw new TypeError("The instruments must be an array of type Object | URL.");
		}
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		clone.#_2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor = this.#_2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor;
		clone.#_trust_2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor = new Set(this.#_trust_2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor);
		if ("actor" in values && values.actor != null) if (values.actor instanceof Application || values.actor instanceof Group || values.actor instanceof Organization || values.actor instanceof Person || values.actor instanceof Service || values.actor instanceof URL) {
			clone.#_2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor = [values.actor];
			clone.#_trust_2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor = new Set([0]);
		} else throw new TypeError("The actor must be of type Application | Group | Organization | Person | Service | URL.");
		if ("actors" in values && values.actors != null) {
			if ("actor" in values && values.actor != null) throw new TypeError("Cannot update both actor and actors at the same time.");
			if (Array.isArray(values.actors) && values.actors.every((v) => v instanceof Application || v instanceof Group || v instanceof Organization || v instanceof Person || v instanceof Service || v instanceof URL)) {
				clone.#_2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor = values.actors;
				clone.#_trust_2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor = /* @__PURE__ */ new Set();
				for (let i = 0; i < values.actors.length; i++) clone.#_trust_2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor.add(i);
			} else throw new TypeError("The actors must be an array of type Application | Group | Organization | Person | Service | URL.");
		}
		clone.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object = this.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object;
		clone.#_trust_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object = new Set(this.#_trust_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object);
		if ("object" in values && values.object != null) if (values.object instanceof Object$1 || values.object instanceof URL) {
			clone.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object = [values.object];
			clone.#_trust_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object = new Set([0]);
		} else throw new TypeError("The object must be of type Object | URL.");
		if ("objects" in values && values.objects != null) {
			if ("object" in values && values.object != null) throw new TypeError("Cannot update both object and objects at the same time.");
			if (Array.isArray(values.objects) && values.objects.every((v) => v instanceof Object$1 || v instanceof URL)) {
				clone.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object = values.objects;
				clone.#_trust_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object = /* @__PURE__ */ new Set();
				for (let i = 0; i < values.objects.length; i++) clone.#_trust_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object.add(i);
			} else throw new TypeError("The objects must be an array of type Object | URL.");
		}
		clone.#_3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target = this.#_3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target;
		clone.#_trust_3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target = new Set(this.#_trust_3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target);
		if ("target" in values && values.target != null) if (values.target instanceof Object$1 || values.target instanceof URL) {
			clone.#_3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target = [values.target];
			clone.#_trust_3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target = new Set([0]);
		} else throw new TypeError("The target must be of type Object | URL.");
		if ("targets" in values && values.targets != null) {
			if ("target" in values && values.target != null) throw new TypeError("Cannot update both target and targets at the same time.");
			if (Array.isArray(values.targets) && values.targets.every((v) => v instanceof Object$1 || v instanceof URL)) {
				clone.#_3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target = values.targets;
				clone.#_trust_3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target = /* @__PURE__ */ new Set();
				for (let i = 0; i < values.targets.length; i++) clone.#_trust_3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target.add(i);
			} else throw new TypeError("The targets must be an array of type Object | URL.");
		}
		clone.#_u4QGFbRFcYmPEKGbPv1hpBR9r5G_result = this.#_u4QGFbRFcYmPEKGbPv1hpBR9r5G_result;
		clone.#_trust_u4QGFbRFcYmPEKGbPv1hpBR9r5G_result = new Set(this.#_trust_u4QGFbRFcYmPEKGbPv1hpBR9r5G_result);
		if ("result" in values && values.result != null) if (values.result instanceof Object$1 || values.result instanceof URL) {
			clone.#_u4QGFbRFcYmPEKGbPv1hpBR9r5G_result = [values.result];
			clone.#_trust_u4QGFbRFcYmPEKGbPv1hpBR9r5G_result = new Set([0]);
		} else throw new TypeError("The result must be of type Object | URL.");
		if ("results" in values && values.results != null) {
			if ("result" in values && values.result != null) throw new TypeError("Cannot update both result and results at the same time.");
			if (Array.isArray(values.results) && values.results.every((v) => v instanceof Object$1 || v instanceof URL)) {
				clone.#_u4QGFbRFcYmPEKGbPv1hpBR9r5G_result = values.results;
				clone.#_trust_u4QGFbRFcYmPEKGbPv1hpBR9r5G_result = /* @__PURE__ */ new Set();
				for (let i = 0; i < values.results.length; i++) clone.#_trust_u4QGFbRFcYmPEKGbPv1hpBR9r5G_result.add(i);
			} else throw new TypeError("The results must be an array of type Object | URL.");
		}
		clone.#_25zu2s3VxVujgEKqrDycjE284XQR_origin = this.#_25zu2s3VxVujgEKqrDycjE284XQR_origin;
		clone.#_trust_25zu2s3VxVujgEKqrDycjE284XQR_origin = new Set(this.#_trust_25zu2s3VxVujgEKqrDycjE284XQR_origin);
		if ("origin" in values && values.origin != null) if (values.origin instanceof Object$1 || values.origin instanceof URL) {
			clone.#_25zu2s3VxVujgEKqrDycjE284XQR_origin = [values.origin];
			clone.#_trust_25zu2s3VxVujgEKqrDycjE284XQR_origin = new Set([0]);
		} else throw new TypeError("The origin must be of type Object | URL.");
		if ("origins" in values && values.origins != null) {
			if ("origin" in values && values.origin != null) throw new TypeError("Cannot update both origin and origins at the same time.");
			if (Array.isArray(values.origins) && values.origins.every((v) => v instanceof Object$1 || v instanceof URL)) {
				clone.#_25zu2s3VxVujgEKqrDycjE284XQR_origin = values.origins;
				clone.#_trust_25zu2s3VxVujgEKqrDycjE284XQR_origin = /* @__PURE__ */ new Set();
				for (let i = 0; i < values.origins.length; i++) clone.#_trust_25zu2s3VxVujgEKqrDycjE284XQR_origin.add(i);
			} else throw new TypeError("The origins must be an array of type Object | URL.");
		}
		clone.#_3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument = this.#_3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument;
		clone.#_trust_3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument = new Set(this.#_trust_3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument);
		if ("instrument" in values && values.instrument != null) if (values.instrument instanceof Object$1 || values.instrument instanceof URL) {
			clone.#_3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument = [values.instrument];
			clone.#_trust_3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument = new Set([0]);
		} else throw new TypeError("The instrument must be of type Object | URL.");
		if ("instruments" in values && values.instruments != null) {
			if ("instrument" in values && values.instrument != null) throw new TypeError("Cannot update both instrument and instruments at the same time.");
			if (Array.isArray(values.instruments) && values.instruments.every((v) => v instanceof Object$1 || v instanceof URL)) {
				clone.#_3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument = values.instruments;
				clone.#_trust_3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument = /* @__PURE__ */ new Set();
				for (let i = 0; i < values.instruments.length; i++) clone.#_trust_3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument.add(i);
			} else throw new TypeError("The instruments must be an array of type Object | URL.");
		}
		return clone;
	}
	async #fetchActor(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#actor_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #actor_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Application.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Group.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Organization.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Person.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Service.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + [
			"https://www.w3.org/ns/activitystreams#Application",
			"https://www.w3.org/ns/activitystreams#Group",
			"https://www.w3.org/ns/activitystreams#Organization",
			"https://www.w3.org/ns/activitystreams#Person",
			"https://www.w3.org/ns/activitystreams#Service"
		].join(", "));
	}
	/**
	* Similar to
	* {@link Activity.getActor},
	* but returns its `@id` URL instead of the object itself.
	*/
	get actorId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor.length < 1) return null;
		const v = this.#_2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** Describes one or more entities that either performed or are expected to
	* perform the activity.  Any single activity can have multiple actors.
	* The actor MAY be specified using an indirect {@link Link}.
	*/
	async getActor(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor.length < 1) return null;
		let v = this.#_2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchActor(v, options);
			if (fetched == null) return null;
			this.#_2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor[0] = fetched;
			this.#_trust_2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "actor" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["actor"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#actor_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	/**
	* Similar to
	* {@link Activity.getActors},
	* but returns their `@id`s instead of the objects themselves.
	*/
	get actorIds() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		return this.#_2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
	}
	/** Describes one or more entities that either performed or are expected to
	* perform the activity.  Any single activity can have multiple actors.
	* The actor MAY be specified using an indirect {@link Link}.
	*/
	async *getActors(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		const vs = this.#_2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor;
		for (let i = 0; i < vs.length; i++) {
			let v = vs[i];
			if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor.has(i)) v = v.id;
			if (v instanceof URL) {
				const fetched = await this.#fetchActor(v, options);
				if (fetched == null) continue;
				vs[i] = fetched;
				this.#_trust_2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor.add(i);
				this._cachedJsonLd = void 0;
				yield fetched;
				continue;
			}
			if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "actor" in this._cachedJsonLd) {
				const prop = this._cachedJsonLd["actor"];
				const obj = Array.isArray(prop) ? prop[i] : prop;
				if (obj != null && typeof obj === "object" && "@context" in obj) v = await this.#actor_fromJsonLd(obj, options);
			}
			if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor.has(0)) {
				if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
				getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
					objectId: v.id.href,
					parentObjectId: this.id.href
				});
				continue;
			}
			yield v;
		}
	}
	async #fetchObject(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#object_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #object_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Object$1.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Object"].join(", "));
	}
	/**
	* Similar to
	* {@link Activity.getObject},
	* but returns its `@id` URL instead of the object itself.
	*/
	get objectId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object.length < 1) return null;
		const v = this.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** When used within an {@link Activity}, describes the direct object of
	* the activity.  For instance, in the activity "John added a movie to his
	* wishlist", the object of the activity is the movie added.
	*/
	async getObject(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object.length < 1) return null;
		let v = this.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchObject(v, options);
			if (fetched == null) return null;
			this.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object[0] = fetched;
			this.#_trust_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "object" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["object"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#object_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	/**
	* Similar to
	* {@link Activity.getObjects},
	* but returns their `@id`s instead of the objects themselves.
	*/
	get objectIds() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		return this.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
	}
	/** When used within an {@link Activity}, describes the direct object of
	* the activity.  For instance, in the activity "John added a movie to his
	* wishlist", the object of the activity is the movie added.
	*/
	async *getObjects(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		const vs = this.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object;
		for (let i = 0; i < vs.length; i++) {
			let v = vs[i];
			if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object.has(i)) v = v.id;
			if (v instanceof URL) {
				const fetched = await this.#fetchObject(v, options);
				if (fetched == null) continue;
				vs[i] = fetched;
				this.#_trust_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object.add(i);
				this._cachedJsonLd = void 0;
				yield fetched;
				continue;
			}
			if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "object" in this._cachedJsonLd) {
				const prop = this._cachedJsonLd["object"];
				const obj = Array.isArray(prop) ? prop[i] : prop;
				if (obj != null && typeof obj === "object" && "@context" in obj) v = await this.#object_fromJsonLd(obj, options);
			}
			if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object.has(0)) {
				if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
				getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
					objectId: v.id.href,
					parentObjectId: this.id.href
				});
				continue;
			}
			yield v;
		}
	}
	async #fetchTarget(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#target_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #target_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Object$1.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Object"].join(", "));
	}
	/**
	* Similar to
	* {@link Activity.getTarget},
	* but returns its `@id` URL instead of the object itself.
	*/
	get targetId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target.length < 1) return null;
		const v = this.#_3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** Describes the indirect object, or target, of the activity.  The precise
	* meaning of the target is largely dependent on the type of action being
	* described but will often be the object of the English preposition "to".
	* For instance, in the activity "John added a movie to his wishlist",
	* the target of the activity is John's wishlist.  An activity can have more
	* than one target.
	*/
	async getTarget(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target.length < 1) return null;
		let v = this.#_3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchTarget(v, options);
			if (fetched == null) return null;
			this.#_3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target[0] = fetched;
			this.#_trust_3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "target" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["target"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#target_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	/**
	* Similar to
	* {@link Activity.getTargets},
	* but returns their `@id`s instead of the objects themselves.
	*/
	get targetIds() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		return this.#_3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
	}
	/** Describes the indirect object, or target, of the activity.  The precise
	* meaning of the target is largely dependent on the type of action being
	* described but will often be the object of the English preposition "to".
	* For instance, in the activity "John added a movie to his wishlist",
	* the target of the activity is John's wishlist.  An activity can have more
	* than one target.
	*/
	async *getTargets(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		const vs = this.#_3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target;
		for (let i = 0; i < vs.length; i++) {
			let v = vs[i];
			if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target.has(i)) v = v.id;
			if (v instanceof URL) {
				const fetched = await this.#fetchTarget(v, options);
				if (fetched == null) continue;
				vs[i] = fetched;
				this.#_trust_3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target.add(i);
				this._cachedJsonLd = void 0;
				yield fetched;
				continue;
			}
			if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "target" in this._cachedJsonLd) {
				const prop = this._cachedJsonLd["target"];
				const obj = Array.isArray(prop) ? prop[i] : prop;
				if (obj != null && typeof obj === "object" && "@context" in obj) v = await this.#target_fromJsonLd(obj, options);
			}
			if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target.has(0)) {
				if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
				getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
					objectId: v.id.href,
					parentObjectId: this.id.href
				});
				continue;
			}
			yield v;
		}
	}
	async #fetchResult(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#result_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #result_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Object$1.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Object"].join(", "));
	}
	/**
	* Similar to
	* {@link Activity.getResult},
	* but returns its `@id` URL instead of the object itself.
	*/
	get resultId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_u4QGFbRFcYmPEKGbPv1hpBR9r5G_result.length < 1) return null;
		const v = this.#_u4QGFbRFcYmPEKGbPv1hpBR9r5G_result[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** Describes the result of the activity.  For instance, if a particular action
	* results in the creation of a new resource, the result property can be used
	* to describe that new resource.
	*/
	async getResult(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_u4QGFbRFcYmPEKGbPv1hpBR9r5G_result.length < 1) return null;
		let v = this.#_u4QGFbRFcYmPEKGbPv1hpBR9r5G_result[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_u4QGFbRFcYmPEKGbPv1hpBR9r5G_result.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchResult(v, options);
			if (fetched == null) return null;
			this.#_u4QGFbRFcYmPEKGbPv1hpBR9r5G_result[0] = fetched;
			this.#_trust_u4QGFbRFcYmPEKGbPv1hpBR9r5G_result.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "result" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["result"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#result_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_u4QGFbRFcYmPEKGbPv1hpBR9r5G_result.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	/**
	* Similar to
	* {@link Activity.getResults},
	* but returns their `@id`s instead of the objects themselves.
	*/
	get resultIds() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		return this.#_u4QGFbRFcYmPEKGbPv1hpBR9r5G_result.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
	}
	/** Describes the result of the activity.  For instance, if a particular action
	* results in the creation of a new resource, the result property can be used
	* to describe that new resource.
	*/
	async *getResults(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		const vs = this.#_u4QGFbRFcYmPEKGbPv1hpBR9r5G_result;
		for (let i = 0; i < vs.length; i++) {
			let v = vs[i];
			if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_u4QGFbRFcYmPEKGbPv1hpBR9r5G_result.has(i)) v = v.id;
			if (v instanceof URL) {
				const fetched = await this.#fetchResult(v, options);
				if (fetched == null) continue;
				vs[i] = fetched;
				this.#_trust_u4QGFbRFcYmPEKGbPv1hpBR9r5G_result.add(i);
				this._cachedJsonLd = void 0;
				yield fetched;
				continue;
			}
			if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "result" in this._cachedJsonLd) {
				const prop = this._cachedJsonLd["result"];
				const obj = Array.isArray(prop) ? prop[i] : prop;
				if (obj != null && typeof obj === "object" && "@context" in obj) v = await this.#result_fromJsonLd(obj, options);
			}
			if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_u4QGFbRFcYmPEKGbPv1hpBR9r5G_result.has(0)) {
				if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
				getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
					objectId: v.id.href,
					parentObjectId: this.id.href
				});
				continue;
			}
			yield v;
		}
	}
	async #fetchOrigin(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#origin_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #origin_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Object$1.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Object"].join(", "));
	}
	/**
	* Similar to
	* {@link Activity.getOrigin},
	* but returns its `@id` URL instead of the object itself.
	*/
	get originId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_25zu2s3VxVujgEKqrDycjE284XQR_origin.length < 1) return null;
		const v = this.#_25zu2s3VxVujgEKqrDycjE284XQR_origin[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** Describes an indirect object of the activity from which the activity is
	* directed.  The precise meaning of the origin is the object of the English
	* preposition "from". For instance, in the activity "John moved an item to
	* List B from List A", the origin of the activity is "List A".
	*/
	async getOrigin(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_25zu2s3VxVujgEKqrDycjE284XQR_origin.length < 1) return null;
		let v = this.#_25zu2s3VxVujgEKqrDycjE284XQR_origin[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_25zu2s3VxVujgEKqrDycjE284XQR_origin.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchOrigin(v, options);
			if (fetched == null) return null;
			this.#_25zu2s3VxVujgEKqrDycjE284XQR_origin[0] = fetched;
			this.#_trust_25zu2s3VxVujgEKqrDycjE284XQR_origin.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "origin" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["origin"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#origin_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_25zu2s3VxVujgEKqrDycjE284XQR_origin.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	/**
	* Similar to
	* {@link Activity.getOrigins},
	* but returns their `@id`s instead of the objects themselves.
	*/
	get originIds() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		return this.#_25zu2s3VxVujgEKqrDycjE284XQR_origin.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
	}
	/** Describes an indirect object of the activity from which the activity is
	* directed.  The precise meaning of the origin is the object of the English
	* preposition "from". For instance, in the activity "John moved an item to
	* List B from List A", the origin of the activity is "List A".
	*/
	async *getOrigins(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		const vs = this.#_25zu2s3VxVujgEKqrDycjE284XQR_origin;
		for (let i = 0; i < vs.length; i++) {
			let v = vs[i];
			if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_25zu2s3VxVujgEKqrDycjE284XQR_origin.has(i)) v = v.id;
			if (v instanceof URL) {
				const fetched = await this.#fetchOrigin(v, options);
				if (fetched == null) continue;
				vs[i] = fetched;
				this.#_trust_25zu2s3VxVujgEKqrDycjE284XQR_origin.add(i);
				this._cachedJsonLd = void 0;
				yield fetched;
				continue;
			}
			if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "origin" in this._cachedJsonLd) {
				const prop = this._cachedJsonLd["origin"];
				const obj = Array.isArray(prop) ? prop[i] : prop;
				if (obj != null && typeof obj === "object" && "@context" in obj) v = await this.#origin_fromJsonLd(obj, options);
			}
			if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_25zu2s3VxVujgEKqrDycjE284XQR_origin.has(0)) {
				if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
				getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
					objectId: v.id.href,
					parentObjectId: this.id.href
				});
				continue;
			}
			yield v;
		}
	}
	async #fetchInstrument(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#instrument_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #instrument_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Object$1.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Object"].join(", "));
	}
	/**
	* Similar to
	* {@link Activity.getInstrument},
	* but returns its `@id` URL instead of the object itself.
	*/
	get instrumentId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument.length < 1) return null;
		const v = this.#_3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** Identifies one or more objects used (or to be used) in the completion of
	* an {@link Activity}.
	*/
	async getInstrument(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument.length < 1) return null;
		let v = this.#_3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchInstrument(v, options);
			if (fetched == null) return null;
			this.#_3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument[0] = fetched;
			this.#_trust_3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "instrument" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["instrument"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#instrument_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	/**
	* Similar to
	* {@link Activity.getInstruments},
	* but returns their `@id`s instead of the objects themselves.
	*/
	get instrumentIds() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		return this.#_3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
	}
	/** Identifies one or more objects used (or to be used) in the completion of
	* an {@link Activity}.
	*/
	async *getInstruments(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		const vs = this.#_3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument;
		for (let i = 0; i < vs.length; i++) {
			let v = vs[i];
			if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument.has(i)) v = v.id;
			if (v instanceof URL) {
				const fetched = await this.#fetchInstrument(v, options);
				if (fetched == null) continue;
				vs[i] = fetched;
				this.#_trust_3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument.add(i);
				this._cachedJsonLd = void 0;
				yield fetched;
				continue;
			}
			if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "instrument" in this._cachedJsonLd) {
				const prop = this._cachedJsonLd["instrument"];
				const obj = Array.isArray(prop) ? prop[i] : prop;
				if (obj != null && typeof obj === "object" && "@context" in obj) v = await this.#instrument_fromJsonLd(obj, options);
			}
			if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument.has(0)) {
				if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
				getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
					objectId: v.id.href,
					parentObjectId: this.id.href
				});
				continue;
			}
			yield v;
		}
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		array = [];
		for (const v of this.#_2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor) {
			const element = v instanceof URL ? { "@id": v.href } : v instanceof Application ? await v.toJsonLd(options) : v instanceof Group ? await v.toJsonLd(options) : v instanceof Organization ? await v.toJsonLd(options) : v instanceof Person ? await v.toJsonLd(options) : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#actor"] = propValue;
		}
		array = [];
		for (const v of this.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#object"] = propValue;
		}
		array = [];
		for (const v of this.#_3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#target"] = propValue;
		}
		array = [];
		for (const v of this.#_u4QGFbRFcYmPEKGbPv1hpBR9r5G_result) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#result"] = propValue;
		}
		array = [];
		for (const v of this.#_25zu2s3VxVujgEKqrDycjE284XQR_origin) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#origin"] = propValue;
		}
		array = [];
		for (const v of this.#_3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#instrument"] = propValue;
		}
		values["@type"] = ["https://www.w3.org/ns/activitystreams#Activity"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? [
			"https://w3id.org/identity/v1",
			"https://www.w3.org/ns/activitystreams",
			"https://w3id.org/security/v1",
			"https://w3id.org/security/data-integrity/v1"
		];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {
			if ("proof" in compacted && compacted.proof != null) if (Array.isArray(compacted.proof)) for (const element of compacted.proof) element["@context"] = docContext;
			else compacted.proof["@context"] = docContext;
		}
		return compacted;
	}
	isCompactable() {
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__Activity__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__Activity__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (values["@type"].includes("http://litepub.social/ns#EmojiReact")) return await EmojiReact.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Accept")) return await Accept.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#TentativeAccept")) return await TentativeAccept.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Add")) return await Add.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Announce")) return await Announce.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Create")) return await Create.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Delete")) return await Delete.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Dislike")) return await Dislike.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Flag")) return await Flag.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Follow")) return await Follow.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Ignore")) return await Ignore.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Block")) return await Block.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#IntransitiveActivity")) return await IntransitiveActivity.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Arrive")) return await Arrive.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Question")) return await Question.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Travel")) return await Travel.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Join")) return await Join.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Leave")) return await Leave.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Like")) return await Like.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Listen")) return await Listen.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Move")) return await Move.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Offer")) return await Offer.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Invite")) return await Invite.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Read")) return await Read.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Reject")) return await Reject.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#TentativeReject")) return await TentativeReject.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Remove")) return await Remove.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Undo")) return await Undo.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Update")) return await Update.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#View")) return await View.fromJsonLd(json, options);
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Activity")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof Activity)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		const _2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor = [];
		const _trust_2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor = /* @__PURE__ */ new Set();
		let _2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor__array = values["https://www.w3.org/ns/activitystreams#actor"];
		for (const v of _2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor__array == null ? [] : _2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor__array.length === 1 && "@list" in _2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor__array[0] ? _2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor__array[0]["@list"] : _2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			const decoded = typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Application") ? await Application.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Group") ? await Group.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Organization") ? await Organization.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Person") ? await Person.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Service") ? await Service.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : void 0;
			if (typeof decoded === "undefined") continue;
			_2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor.push(decoded);
		}
		instance.#_2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor = _2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor;
		const _2MH19yxjn1wnHsNfa5n4JBhJzxyc_object = [];
		const _trust_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object = /* @__PURE__ */ new Set();
		let _2MH19yxjn1wnHsNfa5n4JBhJzxyc_object__array = values["https://www.w3.org/ns/activitystreams#object"];
		for (const v of _2MH19yxjn1wnHsNfa5n4JBhJzxyc_object__array == null ? [] : _2MH19yxjn1wnHsNfa5n4JBhJzxyc_object__array.length === 1 && "@list" in _2MH19yxjn1wnHsNfa5n4JBhJzxyc_object__array[0] ? _2MH19yxjn1wnHsNfa5n4JBhJzxyc_object__array[0]["@list"] : _2MH19yxjn1wnHsNfa5n4JBhJzxyc_object__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object.push(await Object$1.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object = _2MH19yxjn1wnHsNfa5n4JBhJzxyc_object;
		const _3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target = [];
		const _trust_3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target = /* @__PURE__ */ new Set();
		let _3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target__array = values["https://www.w3.org/ns/activitystreams#target"];
		for (const v of _3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target__array == null ? [] : _3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target__array.length === 1 && "@list" in _3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target__array[0] ? _3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target__array[0]["@list"] : _3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target.push(await Object$1.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target = _3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target;
		const _u4QGFbRFcYmPEKGbPv1hpBR9r5G_result = [];
		const _trust_u4QGFbRFcYmPEKGbPv1hpBR9r5G_result = /* @__PURE__ */ new Set();
		let _u4QGFbRFcYmPEKGbPv1hpBR9r5G_result__array = values["https://www.w3.org/ns/activitystreams#result"];
		for (const v of _u4QGFbRFcYmPEKGbPv1hpBR9r5G_result__array == null ? [] : _u4QGFbRFcYmPEKGbPv1hpBR9r5G_result__array.length === 1 && "@list" in _u4QGFbRFcYmPEKGbPv1hpBR9r5G_result__array[0] ? _u4QGFbRFcYmPEKGbPv1hpBR9r5G_result__array[0]["@list"] : _u4QGFbRFcYmPEKGbPv1hpBR9r5G_result__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_u4QGFbRFcYmPEKGbPv1hpBR9r5G_result.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_u4QGFbRFcYmPEKGbPv1hpBR9r5G_result.push(await Object$1.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_u4QGFbRFcYmPEKGbPv1hpBR9r5G_result = _u4QGFbRFcYmPEKGbPv1hpBR9r5G_result;
		const _25zu2s3VxVujgEKqrDycjE284XQR_origin = [];
		const _trust_25zu2s3VxVujgEKqrDycjE284XQR_origin = /* @__PURE__ */ new Set();
		let _25zu2s3VxVujgEKqrDycjE284XQR_origin__array = values["https://www.w3.org/ns/activitystreams#origin"];
		for (const v of _25zu2s3VxVujgEKqrDycjE284XQR_origin__array == null ? [] : _25zu2s3VxVujgEKqrDycjE284XQR_origin__array.length === 1 && "@list" in _25zu2s3VxVujgEKqrDycjE284XQR_origin__array[0] ? _25zu2s3VxVujgEKqrDycjE284XQR_origin__array[0]["@list"] : _25zu2s3VxVujgEKqrDycjE284XQR_origin__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_25zu2s3VxVujgEKqrDycjE284XQR_origin.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_25zu2s3VxVujgEKqrDycjE284XQR_origin.push(await Object$1.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_25zu2s3VxVujgEKqrDycjE284XQR_origin = _25zu2s3VxVujgEKqrDycjE284XQR_origin;
		const _3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument = [];
		const _trust_3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument = /* @__PURE__ */ new Set();
		let _3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument__array = values["https://www.w3.org/ns/activitystreams#instrument"];
		for (const v of _3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument__array == null ? [] : _3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument__array.length === 1 && "@list" in _3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument__array[0] ? _3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument__array[0]["@list"] : _3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument.push(await Object$1.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument = _3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument;
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		const _2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor = this.#_2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor.length == 1) proxy.actor = _2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor[0];
		if (_2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor.length > 1 || !("actor" in proxy) && _2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor.length > 0) proxy.actors = _2DjTTboo3CNHU2a2JQqUSE2dbv9D_actor;
		const _2MH19yxjn1wnHsNfa5n4JBhJzxyc_object = this.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object.length == 1) proxy.object = _2MH19yxjn1wnHsNfa5n4JBhJzxyc_object[0];
		if (_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object.length > 1 || !("object" in proxy) && _2MH19yxjn1wnHsNfa5n4JBhJzxyc_object.length > 0) proxy.objects = _2MH19yxjn1wnHsNfa5n4JBhJzxyc_object;
		const _3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target = this.#_3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target.length == 1) proxy.target = _3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target[0];
		if (_3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target.length > 1 || !("target" in proxy) && _3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target.length > 0) proxy.targets = _3JQCmF2Ww56Ag9EWRYoSZRDNCYtF_target;
		const _u4QGFbRFcYmPEKGbPv1hpBR9r5G_result = this.#_u4QGFbRFcYmPEKGbPv1hpBR9r5G_result.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_u4QGFbRFcYmPEKGbPv1hpBR9r5G_result.length == 1) proxy.result = _u4QGFbRFcYmPEKGbPv1hpBR9r5G_result[0];
		if (_u4QGFbRFcYmPEKGbPv1hpBR9r5G_result.length > 1 || !("result" in proxy) && _u4QGFbRFcYmPEKGbPv1hpBR9r5G_result.length > 0) proxy.results = _u4QGFbRFcYmPEKGbPv1hpBR9r5G_result;
		const _25zu2s3VxVujgEKqrDycjE284XQR_origin = this.#_25zu2s3VxVujgEKqrDycjE284XQR_origin.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_25zu2s3VxVujgEKqrDycjE284XQR_origin.length == 1) proxy.origin = _25zu2s3VxVujgEKqrDycjE284XQR_origin[0];
		if (_25zu2s3VxVujgEKqrDycjE284XQR_origin.length > 1 || !("origin" in proxy) && _25zu2s3VxVujgEKqrDycjE284XQR_origin.length > 0) proxy.origins = _25zu2s3VxVujgEKqrDycjE284XQR_origin;
		const _3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument = this.#_3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument.length == 1) proxy.instrument = _3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument[0];
		if (_3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument.length > 1 || !("instrument" in proxy) && _3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument.length > 0) proxy.instruments = _3c5t2x7DYRo2shwTxpkd4kYSS5WQ_instrument;
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "Activity " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "Activity " + inspect(proxy, options);
	}
};
/** Represents an emoji reaction.  See also [FEP-c0e0](https://w3id.org/fep/c0e0).
*/
var EmojiReact = class EmojiReact extends Activity {
	/**
	* The type URI of {@link EmojiReact}: `http://litepub.social/ns#EmojiReact`.
	*/
	static get typeId() {
		return new URL("http://litepub.social/ns#EmojiReact");
	}
	/**
	* Constructs a new instance of EmojiReact with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		return clone;
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		values["@type"] = ["http://litepub.social/ns#EmojiReact"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? [
			"https://w3id.org/identity/v1",
			"https://www.w3.org/ns/activitystreams",
			"https://w3id.org/security/data-integrity/v1",
			{
				"litepub": "http://litepub.social/ns#",
				"toot": "http://joinmastodon.org/ns#",
				"EmojiReact": "litepub:EmojiReact",
				"Emoji": "toot:Emoji"
			}
		];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {
			if ("proof" in compacted && compacted.proof != null) if (Array.isArray(compacted.proof)) for (const element of compacted.proof) element["@context"] = docContext;
			else compacted.proof["@context"] = docContext;
		}
		return compacted;
	}
	isCompactable() {
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__EmojiReact__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__EmojiReact__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (!values["@type"].includes("http://litepub.social/ns#EmojiReact")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof EmojiReact)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "EmojiReact " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "EmojiReact " + inspect(proxy, options);
	}
};
/** A pair of property name and value.
*/
var PropertyValue = class {
	#documentLoader;
	#contextLoader;
	#tracerProvider;
	#warning;
	#cachedJsonLd;
	id;
	get _documentLoader() {
		return this.#documentLoader;
	}
	get _contextLoader() {
		return this.#contextLoader;
	}
	get _tracerProvider() {
		return this.#tracerProvider;
	}
	get _warning() {
		return this.#warning;
	}
	get _cachedJsonLd() {
		return this.#cachedJsonLd;
	}
	set _cachedJsonLd(value) {
		this.#cachedJsonLd = value;
	}
	/**
	* The type URI of {@link PropertyValue}: `http://schema.org#PropertyValue`.
	*/
	static get typeId() {
		return new URL("http://schema.org#PropertyValue");
	}
	#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name = [];
	#_2cSy2magg4iZ7zLaG8U7DiJMoCkx_value = [];
	/**
	* Constructs a new instance of PropertyValue with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		this.#documentLoader = options.documentLoader;
		this.#contextLoader = options.contextLoader;
		this.#tracerProvider = options.tracerProvider;
		if ("$warning" in options) this.#warning = options.$warning;
		if (values.id == null || values.id instanceof URL) this.id = values.id ?? null;
		else throw new TypeError("The id must be a URL.");
		if ("name" in values && values.name != null) if (typeof values.name === "string" || values.name instanceof LanguageString) this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name = [values.name];
		else throw new TypeError("The name must be of type string | LanguageString.");
		if ("value" in values && values.value != null) if (typeof values.value === "string" || values.value instanceof LanguageString) this.#_2cSy2magg4iZ7zLaG8U7DiJMoCkx_value = [values.value];
		else throw new TypeError("The value must be of type string | LanguageString.");
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = new this.constructor({ id: values.id ?? this.id }, options);
		clone.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name = this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name;
		if ("name" in values && values.name != null) if (typeof values.name === "string" || values.name instanceof LanguageString) clone.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name = [values.name];
		else throw new TypeError("The name must be of type string | LanguageString.");
		clone.#_2cSy2magg4iZ7zLaG8U7DiJMoCkx_value = this.#_2cSy2magg4iZ7zLaG8U7DiJMoCkx_value;
		if ("value" in values && values.value != null) if (typeof values.value === "string" || values.value instanceof LanguageString) clone.#_2cSy2magg4iZ7zLaG8U7DiJMoCkx_value = [values.value];
		else throw new TypeError("The value must be of type string | LanguageString.");
		return clone;
	}
	/** The name of a property.
	*/
	get name() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name.length < 1) return null;
		return this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name[0];
	}
	/** The value of a property.
	*/
	get value() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2cSy2magg4iZ7zLaG8U7DiJMoCkx_value.length < 1) return null;
		return this.#_2cSy2magg4iZ7zLaG8U7DiJMoCkx_value[0];
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		if (options.format == null && this.isCompactable()) {
			const result = {};
			let compactItems;
			compactItems = [];
			for (const v of this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name) {
				const item = typeof v === "string" ? v : {
					"@value": v.toString(),
					"@language": v.language.compact()
				};
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["name"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_2cSy2magg4iZ7zLaG8U7DiJMoCkx_value) {
				const item = typeof v === "string" ? v : {
					"@value": v.toString(),
					"@language": v.language.compact()
				};
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["value"] = compactItems.length > 1 ? compactItems : compactItems[0];
			result["type"] = "PropertyValue";
			if (this.id != null) result["id"] = this.id.href;
			result["@context"] = ["https://www.w3.org/ns/activitystreams", {
				"schema": "http://schema.org#",
				"PropertyValue": "schema:PropertyValue",
				"value": "schema:value"
			}];
			return result;
		}
		let array;
		const values = {};
		array = [];
		for (const v of this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name) {
			const element = typeof v === "string" ? { "@value": v } : {
				"@value": v.toString(),
				"@language": v.language.compact()
			};
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#name"] = propValue;
		}
		array = [];
		for (const v of this.#_2cSy2magg4iZ7zLaG8U7DiJMoCkx_value) {
			const element = typeof v === "string" ? { "@value": v } : {
				"@value": v.toString(),
				"@language": v.language.compact()
			};
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["http://schema.org#value"] = propValue;
		}
		values["@type"] = ["http://schema.org#PropertyValue"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? ["https://www.w3.org/ns/activitystreams", {
			"schema": "http://schema.org#",
			"PropertyValue": "schema:PropertyValue",
			"value": "schema:value"
		}];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {}
		return compacted;
	}
	isCompactable() {
		if (this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name != null && this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name.length > 0) return false;
		if (this.#_2cSy2magg4iZ7zLaG8U7DiJMoCkx_value != null && this.#_2cSy2magg4iZ7zLaG8U7DiJMoCkx_value.length > 0) return false;
		return true;
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__PropertyValue__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__PropertyValue__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (!values["@type"].includes("http://schema.org#PropertyValue")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		const instance = new this({ id: "@id" in values ? new URL(values["@id"]) : void 0 }, options);
		const _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name = [];
		let _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name__array = values["https://www.w3.org/ns/activitystreams#name"];
		for (const v of _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name__array == null ? [] : _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name__array.length === 1 && "@list" in _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name__array[0] ? _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name__array[0]["@list"] : _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name__array) {
			if (v == null) continue;
			const decoded = typeof v === "object" && "@value" in v && typeof v["@value"] === "string" && !("@language" in v) ? v["@value"] : typeof v === "object" && "@language" in v && "@value" in v && typeof v["@language"] === "string" && typeof v["@value"] === "string" ? new LanguageString(v["@value"], v["@language"]) : void 0;
			if (typeof decoded === "undefined") continue;
			_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name.push(decoded);
		}
		instance.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name = _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name;
		const _2cSy2magg4iZ7zLaG8U7DiJMoCkx_value = [];
		let _2cSy2magg4iZ7zLaG8U7DiJMoCkx_value__array = values["http://schema.org#value"];
		for (const v of _2cSy2magg4iZ7zLaG8U7DiJMoCkx_value__array == null ? [] : _2cSy2magg4iZ7zLaG8U7DiJMoCkx_value__array.length === 1 && "@list" in _2cSy2magg4iZ7zLaG8U7DiJMoCkx_value__array[0] ? _2cSy2magg4iZ7zLaG8U7DiJMoCkx_value__array[0]["@list"] : _2cSy2magg4iZ7zLaG8U7DiJMoCkx_value__array) {
			if (v == null) continue;
			const decoded = typeof v === "object" && "@value" in v && typeof v["@value"] === "string" && !("@language" in v) ? v["@value"] : typeof v === "object" && "@language" in v && "@value" in v && typeof v["@language"] === "string" && typeof v["@value"] === "string" ? new LanguageString(v["@value"], v["@language"]) : void 0;
			if (typeof decoded === "undefined") continue;
			_2cSy2magg4iZ7zLaG8U7DiJMoCkx_value.push(decoded);
		}
		instance.#_2cSy2magg4iZ7zLaG8U7DiJMoCkx_value = _2cSy2magg4iZ7zLaG8U7DiJMoCkx_value;
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = {};
		if (this.id != null) proxy.id = {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(this.id.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(this.id.href, options)
		};
		const _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name = this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name.length == 1) proxy.name = _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name[0];
		const _2cSy2magg4iZ7zLaG8U7DiJMoCkx_value = this.#_2cSy2magg4iZ7zLaG8U7DiJMoCkx_value.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_2cSy2magg4iZ7zLaG8U7DiJMoCkx_value.length == 1) proxy.value = _2cSy2magg4iZ7zLaG8U7DiJMoCkx_value[0];
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "PropertyValue " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "PropertyValue " + inspect(proxy, options);
	}
};
/** Means of communicating or interacting with the DID subject or associated
* entities via one or more service endpoints. Examples include discovery
* services, agent services, social networking services, file storage services,
* and verifiable credential repository services.
*/
var DidService = class {
	#documentLoader;
	#contextLoader;
	#tracerProvider;
	#warning;
	#cachedJsonLd;
	id;
	get _documentLoader() {
		return this.#documentLoader;
	}
	get _contextLoader() {
		return this.#contextLoader;
	}
	get _tracerProvider() {
		return this.#tracerProvider;
	}
	get _warning() {
		return this.#warning;
	}
	get _cachedJsonLd() {
		return this.#cachedJsonLd;
	}
	set _cachedJsonLd(value) {
		this.#cachedJsonLd = value;
	}
	/**
	* The type URI of {@link DidService}: `https://www.w3.org/ns/did#Service`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/did#Service");
	}
	#_2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint = [];
	/**
	* Constructs a new instance of DidService with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		this.#documentLoader = options.documentLoader;
		this.#contextLoader = options.contextLoader;
		this.#tracerProvider = options.tracerProvider;
		if ("$warning" in options) this.#warning = options.$warning;
		if (values.id == null || values.id instanceof URL) this.id = values.id ?? null;
		else throw new TypeError("The id must be a URL.");
		if ("endpoint" in values && values.endpoint != null) if (values.endpoint instanceof URL) this.#_2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint = [values.endpoint];
		else throw new TypeError("The endpoint must be of type URL.");
		if ("endpoints" in values && values.endpoints != null) {
			if ("endpoint" in values && values.endpoint != null) throw new TypeError("Cannot initialize both endpoint and endpoints at the same time.");
			if (Array.isArray(values.endpoints) && values.endpoints.every((v) => v instanceof URL)) this.#_2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint = values.endpoints;
			else throw new TypeError("The endpoints must be an array of type URL.");
		}
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = new this.constructor({ id: values.id ?? this.id }, options);
		clone.#_2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint = this.#_2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint;
		if ("endpoint" in values && values.endpoint != null) if (values.endpoint instanceof URL) clone.#_2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint = [values.endpoint];
		else throw new TypeError("The endpoint must be of type URL.");
		if ("endpoints" in values && values.endpoints != null) {
			if ("endpoint" in values && values.endpoint != null) throw new TypeError("Cannot update both endpoint and endpoints at the same time.");
			if (Array.isArray(values.endpoints) && values.endpoints.every((v) => v instanceof URL)) clone.#_2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint = values.endpoints;
			else throw new TypeError("The endpoints must be an array of type URL.");
		}
		return clone;
	}
	/** A network address, such as an HTTP URL, at which services operate on behalf
	* of a DID subject.
	*/
	get endpoint() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint.length < 1) return null;
		return this.#_2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint[0];
	}
	/** A network address, such as an HTTP URL, at which services operate on behalf
	* of a DID subject.
	*/
	get endpoints() {
		return this.#_2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint;
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		let array;
		const values = {};
		array = [];
		for (const v of this.#_2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint) {
			const element = { "@id": v.href };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/did#serviceEndpoint"] = propValue;
		}
		values["@type"] = ["https://www.w3.org/ns/did#Service"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? "https://www.w3.org/ns/did/v1";
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {}
		return compacted;
	}
	isCompactable() {
		return true;
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__DidService__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__DidService__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (values["@type"].includes("https://w3id.org/fep/9091#Export")) return await Export.fromJsonLd(json, options);
			if (!values["@type"].includes("https://www.w3.org/ns/did#Service")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		const instance = new this({ id: "@id" in values ? new URL(values["@id"]) : void 0 }, options);
		const _2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint = [];
		let _2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint__array = values["https://www.w3.org/ns/did#serviceEndpoint"];
		for (const v of _2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint__array == null ? [] : _2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint__array.length === 1 && "@list" in _2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint__array[0] ? _2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint__array[0]["@list"] : _2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint__array) {
			if (v == null) continue;
			_2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint.push(v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].includes("/", 5) ? v["@id"].slice(5, v["@id"].indexOf("/", 5)) : v["@id"].slice(5)) + (v["@id"].includes("/", 5) ? v["@id"].slice(v["@id"].indexOf("/", 5)) : "")) : URL.canParse(v["@id"]) && (values["@id"] == null ? options.baseUrl : new URL(values["@id"])) ? new URL(v["@id"]) : new URL(v["@id"], values["@id"] == null ? options.baseUrl : new URL(values["@id"])));
		}
		instance.#_2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint = _2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint;
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = {};
		if (this.id != null) proxy.id = {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(this.id.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(this.id.href, options)
		};
		const _2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint = this.#_2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint.length == 1) proxy.endpoint = _2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint[0];
		if (_2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint.length > 1 || !("endpoint" in proxy) && _2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint.length > 0) proxy.endpoints = _2KM4fetG6FTJ1cphj76rzJ8Dyv7p_serviceEndpoint;
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "DidService " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "DidService " + inspect(proxy, options);
	}
};
/** "Export Actor" service.
*/
var Export = class Export extends DidService {
	/**
	* The type URI of {@link Export}: `https://w3id.org/fep/9091#Export`.
	*/
	static get typeId() {
		return new URL("https://w3id.org/fep/9091#Export");
	}
	/**
	* Constructs a new instance of Export with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		return clone;
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		values["@type"] = ["https://w3id.org/fep/9091#Export"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? "https://www.w3.org/ns/did/v1";
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {}
		return compacted;
	}
	isCompactable() {
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__Export__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__Export__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (!values["@type"].includes("https://w3id.org/fep/9091#Export")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof Export)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "Export " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "Export " + inspect(proxy, options);
	}
};
/** A proof that can be added to any activity or object, allowing recipients to
* verify the identity of the actor and the integrity of the data.
*/
var DataIntegrityProof = class {
	#documentLoader;
	#contextLoader;
	#tracerProvider;
	#warning;
	#cachedJsonLd;
	id;
	get _documentLoader() {
		return this.#documentLoader;
	}
	get _contextLoader() {
		return this.#contextLoader;
	}
	get _tracerProvider() {
		return this.#tracerProvider;
	}
	get _warning() {
		return this.#warning;
	}
	get _cachedJsonLd() {
		return this.#cachedJsonLd;
	}
	set _cachedJsonLd(value) {
		this.#cachedJsonLd = value;
	}
	/**
	* The type URI of {@link DataIntegrityProof}: `https://w3id.org/security#DataIntegrityProof`.
	*/
	static get typeId() {
		return new URL("https://w3id.org/security#DataIntegrityProof");
	}
	#_3RurJsa7tnptyqMFR5hDGcP9pMs5_cryptosuite = [];
	#_2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod = [];
	#_trust_2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod = /* @__PURE__ */ new Set();
	#_2AeEnPcAvVrPEuKbpmn9ZKNmWHKb_proofPurpose = [];
	#_3CjFK5vfKpX4HQuNh2b18TykoVLq_proofValue = [];
	#_3qzP3ukEZoUziK5FEiA1RhU4aqac = [];
	/**
	* Constructs a new instance of DataIntegrityProof with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		this.#documentLoader = options.documentLoader;
		this.#contextLoader = options.contextLoader;
		this.#tracerProvider = options.tracerProvider;
		if ("$warning" in options) this.#warning = options.$warning;
		if (values.id == null || values.id instanceof URL) this.id = values.id ?? null;
		else throw new TypeError("The id must be a URL.");
		if ("cryptosuite" in values && values.cryptosuite != null) if (values.cryptosuite == "eddsa-jcs-2022") this.#_3RurJsa7tnptyqMFR5hDGcP9pMs5_cryptosuite = [values.cryptosuite];
		else throw new TypeError("The cryptosuite must be of type \"eddsa-jcs-2022\".");
		if ("verificationMethod" in values && values.verificationMethod != null) if (values.verificationMethod instanceof Multikey || values.verificationMethod instanceof URL) {
			this.#_2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod = [values.verificationMethod];
			this.#_trust_2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod.add(0);
		} else throw new TypeError("The verificationMethod must be of type Multikey | URL.");
		if ("proofPurpose" in values && values.proofPurpose != null) if (values.proofPurpose === "assertionMethod" || values.proofPurpose === "authentication" || values.proofPurpose === "capabilityInvocation" || values.proofPurpose === "capabilityDelegation" || values.proofPurpose === "keyAgreement") this.#_2AeEnPcAvVrPEuKbpmn9ZKNmWHKb_proofPurpose = [values.proofPurpose];
		else throw new TypeError("The proofPurpose must be of type \"assertionMethod\" | \"authentication\" | \"capabilityInvocation\" | \"capabilityDelegation\" | \"keyAgreement\".");
		if ("proofValue" in values && values.proofValue != null) if (values.proofValue instanceof Uint8Array) this.#_3CjFK5vfKpX4HQuNh2b18TykoVLq_proofValue = [values.proofValue];
		else throw new TypeError("The proofValue must be of type Uint8Array.");
		if ("created" in values && values.created != null) if (values.created instanceof Temporal.Instant) this.#_3qzP3ukEZoUziK5FEiA1RhU4aqac = [values.created];
		else throw new TypeError("The created must be of type Temporal.Instant.");
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = new this.constructor({ id: values.id ?? this.id }, options);
		clone.#_3RurJsa7tnptyqMFR5hDGcP9pMs5_cryptosuite = this.#_3RurJsa7tnptyqMFR5hDGcP9pMs5_cryptosuite;
		if ("cryptosuite" in values && values.cryptosuite != null) if (values.cryptosuite == "eddsa-jcs-2022") clone.#_3RurJsa7tnptyqMFR5hDGcP9pMs5_cryptosuite = [values.cryptosuite];
		else throw new TypeError("The cryptosuite must be of type \"eddsa-jcs-2022\".");
		clone.#_2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod = this.#_2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod;
		clone.#_trust_2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod = new Set(this.#_trust_2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod);
		if ("verificationMethod" in values && values.verificationMethod != null) if (values.verificationMethod instanceof Multikey || values.verificationMethod instanceof URL) {
			clone.#_2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod = [values.verificationMethod];
			clone.#_trust_2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod = new Set([0]);
		} else throw new TypeError("The verificationMethod must be of type Multikey | URL.");
		clone.#_2AeEnPcAvVrPEuKbpmn9ZKNmWHKb_proofPurpose = this.#_2AeEnPcAvVrPEuKbpmn9ZKNmWHKb_proofPurpose;
		if ("proofPurpose" in values && values.proofPurpose != null) if (values.proofPurpose === "assertionMethod" || values.proofPurpose === "authentication" || values.proofPurpose === "capabilityInvocation" || values.proofPurpose === "capabilityDelegation" || values.proofPurpose === "keyAgreement") clone.#_2AeEnPcAvVrPEuKbpmn9ZKNmWHKb_proofPurpose = [values.proofPurpose];
		else throw new TypeError("The proofPurpose must be of type \"assertionMethod\" | \"authentication\" | \"capabilityInvocation\" | \"capabilityDelegation\" | \"keyAgreement\".");
		clone.#_3CjFK5vfKpX4HQuNh2b18TykoVLq_proofValue = this.#_3CjFK5vfKpX4HQuNh2b18TykoVLq_proofValue;
		if ("proofValue" in values && values.proofValue != null) if (values.proofValue instanceof Uint8Array) clone.#_3CjFK5vfKpX4HQuNh2b18TykoVLq_proofValue = [values.proofValue];
		else throw new TypeError("The proofValue must be of type Uint8Array.");
		clone.#_3qzP3ukEZoUziK5FEiA1RhU4aqac = this.#_3qzP3ukEZoUziK5FEiA1RhU4aqac;
		if ("created" in values && values.created != null) if (values.created instanceof Temporal.Instant) clone.#_3qzP3ukEZoUziK5FEiA1RhU4aqac = [values.created];
		else throw new TypeError("The created must be of type Temporal.Instant.");
		return clone;
	}
	/** The cryptographic suite used to create the proof.
	*/
	get cryptosuite() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3RurJsa7tnptyqMFR5hDGcP9pMs5_cryptosuite.length < 1) return null;
		return this.#_3RurJsa7tnptyqMFR5hDGcP9pMs5_cryptosuite[0];
	}
	async #fetchVerificationMethod(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#verificationMethod_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #verificationMethod_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Multikey.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://w3id.org/security#Multikey"].join(", "));
	}
	/**
	* Similar to
	* {@link DataIntegrityProof.getVerificationMethod},
	* but returns its `@id` URL instead of the object itself.
	*/
	get verificationMethodId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod.length < 1) return null;
		const v = this.#_2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** A key owned by an actor according to [FEP-521a: Representing actor's public
	* keys][1].
	*
	* [1]: https://w3id.org/fep/521a
	*/
	async getVerificationMethod(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod.length < 1) return null;
		let v = this.#_2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchVerificationMethod(v, options);
			if (fetched == null) return null;
			this.#_2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod[0] = fetched;
			this.#_trust_2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	/** The reason the proof was created.
	*
	* - `"assertionMethod"`
	* - `"authentication"`
	* - `"capabilityInvocation"`
	* - `"capabilityDelegation"`
	* - `"keyAgreement"`
	*/
	get proofPurpose() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2AeEnPcAvVrPEuKbpmn9ZKNmWHKb_proofPurpose.length < 1) return null;
		return this.#_2AeEnPcAvVrPEuKbpmn9ZKNmWHKb_proofPurpose[0];
	}
	/** The proof value.
	*/
	get proofValue() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3CjFK5vfKpX4HQuNh2b18TykoVLq_proofValue.length < 1) return null;
		return this.#_3CjFK5vfKpX4HQuNh2b18TykoVLq_proofValue[0];
	}
	/** The date and time the proof was created.
	*/
	get created() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3qzP3ukEZoUziK5FEiA1RhU4aqac.length < 1) return null;
		return this.#_3qzP3ukEZoUziK5FEiA1RhU4aqac[0];
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		let array;
		const values = {};
		array = [];
		for (const v of this.#_3RurJsa7tnptyqMFR5hDGcP9pMs5_cryptosuite) {
			const element = { "@value": v };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://w3id.org/security#cryptosuite"] = propValue;
		}
		array = [];
		for (const v of this.#_2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://w3id.org/security#verificationMethod"] = propValue;
		}
		array = [];
		for (const v of this.#_2AeEnPcAvVrPEuKbpmn9ZKNmWHKb_proofPurpose) {
			const element = { "@id": "https://w3id.org/security#" + v };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://w3id.org/security#proofPurpose"] = propValue;
		}
		array = [];
		for (const v of this.#_3CjFK5vfKpX4HQuNh2b18TykoVLq_proofValue) {
			const element = {
				"@type": "https://w3id.org/security#multibase",
				"@value": new TextDecoder().decode(encode("base58btc", v))
			};
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://w3id.org/security#proofValue"] = propValue;
		}
		array = [];
		for (const v of this.#_3qzP3ukEZoUziK5FEiA1RhU4aqac) {
			const element = {
				"@type": "http://www.w3.org/2001/XMLSchema#dateTime",
				"@value": v.toString()
			};
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["http://purl.org/dc/terms/created"] = propValue;
		}
		values["@type"] = ["https://w3id.org/security#DataIntegrityProof"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? "https://w3id.org/security/data-integrity/v1";
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {}
		return compacted;
	}
	isCompactable() {
		return true;
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__DataIntegrityProof__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__DataIntegrityProof__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (!values["@type"].includes("https://w3id.org/security#DataIntegrityProof")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		const instance = new this({ id: "@id" in values ? new URL(values["@id"]) : void 0 }, options);
		const _3RurJsa7tnptyqMFR5hDGcP9pMs5_cryptosuite = [];
		let _3RurJsa7tnptyqMFR5hDGcP9pMs5_cryptosuite__array = values["https://w3id.org/security#cryptosuite"];
		for (const v of _3RurJsa7tnptyqMFR5hDGcP9pMs5_cryptosuite__array == null ? [] : _3RurJsa7tnptyqMFR5hDGcP9pMs5_cryptosuite__array.length === 1 && "@list" in _3RurJsa7tnptyqMFR5hDGcP9pMs5_cryptosuite__array[0] ? _3RurJsa7tnptyqMFR5hDGcP9pMs5_cryptosuite__array[0]["@list"] : _3RurJsa7tnptyqMFR5hDGcP9pMs5_cryptosuite__array) {
			if (v == null) continue;
			_3RurJsa7tnptyqMFR5hDGcP9pMs5_cryptosuite.push(v["@value"]);
		}
		instance.#_3RurJsa7tnptyqMFR5hDGcP9pMs5_cryptosuite = _3RurJsa7tnptyqMFR5hDGcP9pMs5_cryptosuite;
		const _2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod = [];
		const _trust_2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod = /* @__PURE__ */ new Set();
		let _2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod__array = values["https://w3id.org/security#verificationMethod"];
		for (const v of _2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod__array == null ? [] : _2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod__array.length === 1 && "@list" in _2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod__array[0] ? _2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod__array[0]["@list"] : _2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod.push(await Multikey.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod = _2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod;
		const _2AeEnPcAvVrPEuKbpmn9ZKNmWHKb_proofPurpose = [];
		let _2AeEnPcAvVrPEuKbpmn9ZKNmWHKb_proofPurpose__array = values["https://w3id.org/security#proofPurpose"];
		for (const v of _2AeEnPcAvVrPEuKbpmn9ZKNmWHKb_proofPurpose__array == null ? [] : _2AeEnPcAvVrPEuKbpmn9ZKNmWHKb_proofPurpose__array.length === 1 && "@list" in _2AeEnPcAvVrPEuKbpmn9ZKNmWHKb_proofPurpose__array[0] ? _2AeEnPcAvVrPEuKbpmn9ZKNmWHKb_proofPurpose__array[0]["@list"] : _2AeEnPcAvVrPEuKbpmn9ZKNmWHKb_proofPurpose__array) {
			if (v == null) continue;
			_2AeEnPcAvVrPEuKbpmn9ZKNmWHKb_proofPurpose.push(v["@id"].substring(26));
		}
		instance.#_2AeEnPcAvVrPEuKbpmn9ZKNmWHKb_proofPurpose = _2AeEnPcAvVrPEuKbpmn9ZKNmWHKb_proofPurpose;
		const _3CjFK5vfKpX4HQuNh2b18TykoVLq_proofValue = [];
		let _3CjFK5vfKpX4HQuNh2b18TykoVLq_proofValue__array = values["https://w3id.org/security#proofValue"];
		for (const v of _3CjFK5vfKpX4HQuNh2b18TykoVLq_proofValue__array == null ? [] : _3CjFK5vfKpX4HQuNh2b18TykoVLq_proofValue__array.length === 1 && "@list" in _3CjFK5vfKpX4HQuNh2b18TykoVLq_proofValue__array[0] ? _3CjFK5vfKpX4HQuNh2b18TykoVLq_proofValue__array[0]["@list"] : _3CjFK5vfKpX4HQuNh2b18TykoVLq_proofValue__array) {
			if (v == null) continue;
			_3CjFK5vfKpX4HQuNh2b18TykoVLq_proofValue.push(decode(v["@value"]));
		}
		instance.#_3CjFK5vfKpX4HQuNh2b18TykoVLq_proofValue = _3CjFK5vfKpX4HQuNh2b18TykoVLq_proofValue;
		const _3qzP3ukEZoUziK5FEiA1RhU4aqac = [];
		let _3qzP3ukEZoUziK5FEiA1RhU4aqac__array = values["http://purl.org/dc/terms/created"];
		for (const v of _3qzP3ukEZoUziK5FEiA1RhU4aqac__array == null ? [] : _3qzP3ukEZoUziK5FEiA1RhU4aqac__array.length === 1 && "@list" in _3qzP3ukEZoUziK5FEiA1RhU4aqac__array[0] ? _3qzP3ukEZoUziK5FEiA1RhU4aqac__array[0]["@list"] : _3qzP3ukEZoUziK5FEiA1RhU4aqac__array) {
			if (v == null) continue;
			_3qzP3ukEZoUziK5FEiA1RhU4aqac.push(Temporal.Instant.from(v["@value"].substring(19).match(/[Z+-]/) ? v["@value"] : v["@value"] + "Z"));
		}
		instance.#_3qzP3ukEZoUziK5FEiA1RhU4aqac = _3qzP3ukEZoUziK5FEiA1RhU4aqac;
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = {};
		if (this.id != null) proxy.id = {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(this.id.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(this.id.href, options)
		};
		const _3RurJsa7tnptyqMFR5hDGcP9pMs5_cryptosuite = this.#_3RurJsa7tnptyqMFR5hDGcP9pMs5_cryptosuite.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3RurJsa7tnptyqMFR5hDGcP9pMs5_cryptosuite.length == 1) proxy.cryptosuite = _3RurJsa7tnptyqMFR5hDGcP9pMs5_cryptosuite[0];
		const _2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod = this.#_2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod.length == 1) proxy.verificationMethod = _2mHVKxqA7zncjveJrDEo3pWpMZqg_verificationMethod[0];
		const _2AeEnPcAvVrPEuKbpmn9ZKNmWHKb_proofPurpose = this.#_2AeEnPcAvVrPEuKbpmn9ZKNmWHKb_proofPurpose.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_2AeEnPcAvVrPEuKbpmn9ZKNmWHKb_proofPurpose.length == 1) proxy.proofPurpose = _2AeEnPcAvVrPEuKbpmn9ZKNmWHKb_proofPurpose[0];
		const _3CjFK5vfKpX4HQuNh2b18TykoVLq_proofValue = this.#_3CjFK5vfKpX4HQuNh2b18TykoVLq_proofValue.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3CjFK5vfKpX4HQuNh2b18TykoVLq_proofValue.length == 1) proxy.proofValue = _3CjFK5vfKpX4HQuNh2b18TykoVLq_proofValue[0];
		const _3qzP3ukEZoUziK5FEiA1RhU4aqac = this.#_3qzP3ukEZoUziK5FEiA1RhU4aqac.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3qzP3ukEZoUziK5FEiA1RhU4aqac.length == 1) proxy.created = _3qzP3ukEZoUziK5FEiA1RhU4aqac[0];
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "DataIntegrityProof " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "DataIntegrityProof " + inspect(proxy, options);
	}
};
/** A key owned by an actor.
*/
var CryptographicKey = class {
	#documentLoader;
	#contextLoader;
	#tracerProvider;
	#warning;
	#cachedJsonLd;
	id;
	get _documentLoader() {
		return this.#documentLoader;
	}
	get _contextLoader() {
		return this.#contextLoader;
	}
	get _tracerProvider() {
		return this.#tracerProvider;
	}
	get _warning() {
		return this.#warning;
	}
	get _cachedJsonLd() {
		return this.#cachedJsonLd;
	}
	set _cachedJsonLd(value) {
		this.#cachedJsonLd = value;
	}
	/**
	* The type URI of {@link CryptographicKey}: `https://w3id.org/security#Key`.
	*/
	static get typeId() {
		return new URL("https://w3id.org/security#Key");
	}
	#_5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner = [];
	#_trust_5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner = /* @__PURE__ */ new Set();
	#_2fE2QMDdg6KFGqa4NEC3TmjApSAD_publicKeyPem = [];
	/**
	* Constructs a new instance of CryptographicKey with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		this.#documentLoader = options.documentLoader;
		this.#contextLoader = options.contextLoader;
		this.#tracerProvider = options.tracerProvider;
		if ("$warning" in options) this.#warning = options.$warning;
		if (values.id == null || values.id instanceof URL) this.id = values.id ?? null;
		else throw new TypeError("The id must be a URL.");
		if ("owner" in values && values.owner != null) if (values.owner instanceof Application || values.owner instanceof Group || values.owner instanceof Organization || values.owner instanceof Person || values.owner instanceof Service || values.owner instanceof URL) {
			this.#_5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner = [values.owner];
			this.#_trust_5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner.add(0);
		} else throw new TypeError("The owner must be of type Application | Group | Organization | Person | Service | URL.");
		if ("publicKey" in values && values.publicKey != null) if (values.publicKey instanceof CryptoKey) this.#_2fE2QMDdg6KFGqa4NEC3TmjApSAD_publicKeyPem = [values.publicKey];
		else throw new TypeError("The publicKey must be of type CryptoKey.");
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = new this.constructor({ id: values.id ?? this.id }, options);
		clone.#_5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner = this.#_5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner;
		clone.#_trust_5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner = new Set(this.#_trust_5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner);
		if ("owner" in values && values.owner != null) if (values.owner instanceof Application || values.owner instanceof Group || values.owner instanceof Organization || values.owner instanceof Person || values.owner instanceof Service || values.owner instanceof URL) {
			clone.#_5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner = [values.owner];
			clone.#_trust_5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner = new Set([0]);
		} else throw new TypeError("The owner must be of type Application | Group | Organization | Person | Service | URL.");
		clone.#_2fE2QMDdg6KFGqa4NEC3TmjApSAD_publicKeyPem = this.#_2fE2QMDdg6KFGqa4NEC3TmjApSAD_publicKeyPem;
		if ("publicKey" in values && values.publicKey != null) if (values.publicKey instanceof CryptoKey) clone.#_2fE2QMDdg6KFGqa4NEC3TmjApSAD_publicKeyPem = [values.publicKey];
		else throw new TypeError("The publicKey must be of type CryptoKey.");
		return clone;
	}
	async #fetchOwner(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#owner_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #owner_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Application.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Group.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Organization.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Person.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Service.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + [
			"https://www.w3.org/ns/activitystreams#Application",
			"https://www.w3.org/ns/activitystreams#Group",
			"https://www.w3.org/ns/activitystreams#Organization",
			"https://www.w3.org/ns/activitystreams#Person",
			"https://www.w3.org/ns/activitystreams#Service"
		].join(", "));
	}
	/**
	* Similar to
	* {@link CryptographicKey.getOwner},
	* but returns its `@id` URL instead of the object itself.
	*/
	get ownerId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner.length < 1) return null;
		const v = this.#_5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** An actor who owns this key.
	*/
	async getOwner(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner.length < 1) return null;
		let v = this.#_5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchOwner(v, options);
			if (fetched == null) return null;
			this.#_5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner[0] = fetched;
			this.#_trust_5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "owner" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["owner"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#owner_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	/** A PEM-encoded public key.
	*/
	get publicKey() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2fE2QMDdg6KFGqa4NEC3TmjApSAD_publicKeyPem.length < 1) return null;
		return this.#_2fE2QMDdg6KFGqa4NEC3TmjApSAD_publicKeyPem[0];
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		if (options.format == null && this.isCompactable()) {
			const result = {};
			let compactItems;
			compactItems = [];
			for (const v of this.#_5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner) {
				const item = v instanceof URL ? v.href : v instanceof Application ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : v instanceof Group ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : v instanceof Organization ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : v instanceof Person ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["owner"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_2fE2QMDdg6KFGqa4NEC3TmjApSAD_publicKeyPem) {
				const item = await exportSpki(v);
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["publicKeyPem"] = compactItems.length > 1 ? compactItems : compactItems[0];
			result["type"] = "CryptographicKey";
			if (this.id != null) result["id"] = this.id.href;
			result["@context"] = "https://w3id.org/security/v1";
			return result;
		}
		let array;
		const values = {};
		array = [];
		for (const v of this.#_5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner) {
			const element = v instanceof URL ? { "@id": v.href } : v instanceof Application ? await v.toJsonLd(options) : v instanceof Group ? await v.toJsonLd(options) : v instanceof Organization ? await v.toJsonLd(options) : v instanceof Person ? await v.toJsonLd(options) : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://w3id.org/security#owner"] = propValue;
		}
		array = [];
		for (const v of this.#_2fE2QMDdg6KFGqa4NEC3TmjApSAD_publicKeyPem) {
			const element = { "@value": await exportSpki(v) };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://w3id.org/security#publicKeyPem"] = propValue;
		}
		values["@type"] = ["https://w3id.org/security#Key"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? "https://w3id.org/security/v1";
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {}
		return compacted;
	}
	isCompactable() {
		return true;
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__CryptographicKey__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__CryptographicKey__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (!values["@type"].includes("https://w3id.org/security#Key")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		const instance = new this({ id: "@id" in values ? new URL(values["@id"]) : void 0 }, options);
		const _5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner = [];
		const _trust_5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner = /* @__PURE__ */ new Set();
		let _5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner__array = values["https://w3id.org/security#owner"];
		for (const v of _5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner__array == null ? [] : _5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner__array.length === 1 && "@list" in _5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner__array[0] ? _5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner__array[0]["@list"] : _5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			const decoded = typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Application") ? await Application.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Group") ? await Group.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Organization") ? await Organization.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Person") ? await Person.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Service") ? await Service.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : void 0;
			if (typeof decoded === "undefined") continue;
			_5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner.push(decoded);
		}
		instance.#_5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner = _5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner;
		const _2fE2QMDdg6KFGqa4NEC3TmjApSAD_publicKeyPem = [];
		let _2fE2QMDdg6KFGqa4NEC3TmjApSAD_publicKeyPem__array = values["https://w3id.org/security#publicKeyPem"];
		for (const v of _2fE2QMDdg6KFGqa4NEC3TmjApSAD_publicKeyPem__array == null ? [] : _2fE2QMDdg6KFGqa4NEC3TmjApSAD_publicKeyPem__array.length === 1 && "@list" in _2fE2QMDdg6KFGqa4NEC3TmjApSAD_publicKeyPem__array[0] ? _2fE2QMDdg6KFGqa4NEC3TmjApSAD_publicKeyPem__array[0]["@list"] : _2fE2QMDdg6KFGqa4NEC3TmjApSAD_publicKeyPem__array) {
			if (v == null) continue;
			_2fE2QMDdg6KFGqa4NEC3TmjApSAD_publicKeyPem.push(await importPem(v["@value"]));
		}
		instance.#_2fE2QMDdg6KFGqa4NEC3TmjApSAD_publicKeyPem = _2fE2QMDdg6KFGqa4NEC3TmjApSAD_publicKeyPem;
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = {};
		if (this.id != null) proxy.id = {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(this.id.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(this.id.href, options)
		};
		const _5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner = this.#_5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner.length == 1) proxy.owner = _5UJq9NDh3ZHgswFwwdVxQvJxdx2_owner[0];
		const _2fE2QMDdg6KFGqa4NEC3TmjApSAD_publicKeyPem = this.#_2fE2QMDdg6KFGqa4NEC3TmjApSAD_publicKeyPem.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_2fE2QMDdg6KFGqa4NEC3TmjApSAD_publicKeyPem.length == 1) proxy.publicKey = _2fE2QMDdg6KFGqa4NEC3TmjApSAD_publicKeyPem[0];
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "CryptographicKey " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "CryptographicKey " + inspect(proxy, options);
	}
};
/** Represents a key owned by an actor according to [FEP-521a: Representing
* actor's public keys.][1]
*
* [1]: https://w3id.org/fep/521a
*/
var Multikey = class {
	#documentLoader;
	#contextLoader;
	#tracerProvider;
	#warning;
	#cachedJsonLd;
	id;
	get _documentLoader() {
		return this.#documentLoader;
	}
	get _contextLoader() {
		return this.#contextLoader;
	}
	get _tracerProvider() {
		return this.#tracerProvider;
	}
	get _warning() {
		return this.#warning;
	}
	get _cachedJsonLd() {
		return this.#cachedJsonLd;
	}
	set _cachedJsonLd(value) {
		this.#cachedJsonLd = value;
	}
	/**
	* The type URI of {@link Multikey}: `https://w3id.org/security#Multikey`.
	*/
	static get typeId() {
		return new URL("https://w3id.org/security#Multikey");
	}
	#_2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller = [];
	#_trust_2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller = /* @__PURE__ */ new Set();
	#_4XLHbsR2gLVWU3NpEqKt9wANzn4F_publicKeyMultibase = [];
	/**
	* Constructs a new instance of Multikey with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		this.#documentLoader = options.documentLoader;
		this.#contextLoader = options.contextLoader;
		this.#tracerProvider = options.tracerProvider;
		if ("$warning" in options) this.#warning = options.$warning;
		if (values.id == null || values.id instanceof URL) this.id = values.id ?? null;
		else throw new TypeError("The id must be a URL.");
		if ("controller" in values && values.controller != null) if (values.controller instanceof Application || values.controller instanceof Group || values.controller instanceof Organization || values.controller instanceof Person || values.controller instanceof Service || values.controller instanceof URL) {
			this.#_2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller = [values.controller];
			this.#_trust_2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller.add(0);
		} else throw new TypeError("The controller must be of type Application | Group | Organization | Person | Service | URL.");
		if ("publicKey" in values && values.publicKey != null) if (values.publicKey instanceof CryptoKey) this.#_4XLHbsR2gLVWU3NpEqKt9wANzn4F_publicKeyMultibase = [values.publicKey];
		else throw new TypeError("The publicKey must be of type CryptoKey.");
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = new this.constructor({ id: values.id ?? this.id }, options);
		clone.#_2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller = this.#_2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller;
		clone.#_trust_2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller = new Set(this.#_trust_2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller);
		if ("controller" in values && values.controller != null) if (values.controller instanceof Application || values.controller instanceof Group || values.controller instanceof Organization || values.controller instanceof Person || values.controller instanceof Service || values.controller instanceof URL) {
			clone.#_2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller = [values.controller];
			clone.#_trust_2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller = new Set([0]);
		} else throw new TypeError("The controller must be of type Application | Group | Organization | Person | Service | URL.");
		clone.#_4XLHbsR2gLVWU3NpEqKt9wANzn4F_publicKeyMultibase = this.#_4XLHbsR2gLVWU3NpEqKt9wANzn4F_publicKeyMultibase;
		if ("publicKey" in values && values.publicKey != null) if (values.publicKey instanceof CryptoKey) clone.#_4XLHbsR2gLVWU3NpEqKt9wANzn4F_publicKeyMultibase = [values.publicKey];
		else throw new TypeError("The publicKey must be of type CryptoKey.");
		return clone;
	}
	async #fetchController(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#controller_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #controller_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Application.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Group.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Organization.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Person.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Service.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + [
			"https://www.w3.org/ns/activitystreams#Application",
			"https://www.w3.org/ns/activitystreams#Group",
			"https://www.w3.org/ns/activitystreams#Organization",
			"https://www.w3.org/ns/activitystreams#Person",
			"https://www.w3.org/ns/activitystreams#Service"
		].join(", "));
	}
	/**
	* Similar to
	* {@link Multikey.getController},
	* but returns its `@id` URL instead of the object itself.
	*/
	get controllerId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller.length < 1) return null;
		const v = this.#_2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** An actor who owns this key.
	*/
	async getController(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller.length < 1) return null;
		let v = this.#_2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchController(v, options);
			if (fetched == null) return null;
			this.#_2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller[0] = fetched;
			this.#_trust_2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "controller" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["controller"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#controller_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	/** A [Multibase]-encoded value of a [Multicodec] prefix and the key.
	*
	* [Multibase]: https://www.w3.org/TR/vc-data-integrity/#multibase-0
	* [Multicodec]: https://github.com/multiformats/multicodec/
	*/
	get publicKey() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_4XLHbsR2gLVWU3NpEqKt9wANzn4F_publicKeyMultibase.length < 1) return null;
		return this.#_4XLHbsR2gLVWU3NpEqKt9wANzn4F_publicKeyMultibase[0];
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		if (options.format == null && this.isCompactable()) {
			const result = {};
			let compactItems;
			compactItems = [];
			for (const v of this.#_2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller) {
				const item = v instanceof URL ? v.href : v instanceof Application ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : v instanceof Group ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : v instanceof Organization ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : v instanceof Person ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["controller"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_4XLHbsR2gLVWU3NpEqKt9wANzn4F_publicKeyMultibase) {
				const item = await exportMultibaseKey(v);
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["publicKeyMultibase"] = compactItems.length > 1 ? compactItems : compactItems[0];
			result["type"] = "Multikey";
			if (this.id != null) result["id"] = this.id.href;
			result["@context"] = "https://w3id.org/security/multikey/v1";
			return result;
		}
		let array;
		const values = {};
		array = [];
		for (const v of this.#_2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller) {
			const element = v instanceof URL ? { "@id": v.href } : v instanceof Application ? await v.toJsonLd(options) : v instanceof Group ? await v.toJsonLd(options) : v instanceof Organization ? await v.toJsonLd(options) : v instanceof Person ? await v.toJsonLd(options) : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://w3id.org/security#controller"] = propValue;
		}
		array = [];
		for (const v of this.#_4XLHbsR2gLVWU3NpEqKt9wANzn4F_publicKeyMultibase) {
			const element = {
				"@type": "https://w3id.org/security#multibase",
				"@value": await exportMultibaseKey(v)
			};
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://w3id.org/security#publicKeyMultibase"] = propValue;
		}
		values["@type"] = ["https://w3id.org/security#Multikey"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? "https://w3id.org/security/multikey/v1";
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {}
		return compacted;
	}
	isCompactable() {
		return true;
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__Multikey__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__Multikey__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (!values["@type"].includes("https://w3id.org/security#Multikey")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		const instance = new this({ id: "@id" in values ? new URL(values["@id"]) : void 0 }, options);
		const _2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller = [];
		const _trust_2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller = /* @__PURE__ */ new Set();
		let _2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller__array = values["https://w3id.org/security#controller"];
		for (const v of _2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller__array == null ? [] : _2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller__array.length === 1 && "@list" in _2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller__array[0] ? _2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller__array[0]["@list"] : _2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			const decoded = typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Application") ? await Application.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Group") ? await Group.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Organization") ? await Organization.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Person") ? await Person.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Service") ? await Service.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : void 0;
			if (typeof decoded === "undefined") continue;
			_2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller.push(decoded);
		}
		instance.#_2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller = _2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller;
		const _4XLHbsR2gLVWU3NpEqKt9wANzn4F_publicKeyMultibase = [];
		let _4XLHbsR2gLVWU3NpEqKt9wANzn4F_publicKeyMultibase__array = values["https://w3id.org/security#publicKeyMultibase"];
		for (const v of _4XLHbsR2gLVWU3NpEqKt9wANzn4F_publicKeyMultibase__array == null ? [] : _4XLHbsR2gLVWU3NpEqKt9wANzn4F_publicKeyMultibase__array.length === 1 && "@list" in _4XLHbsR2gLVWU3NpEqKt9wANzn4F_publicKeyMultibase__array[0] ? _4XLHbsR2gLVWU3NpEqKt9wANzn4F_publicKeyMultibase__array[0]["@list"] : _4XLHbsR2gLVWU3NpEqKt9wANzn4F_publicKeyMultibase__array) {
			if (v == null) continue;
			_4XLHbsR2gLVWU3NpEqKt9wANzn4F_publicKeyMultibase.push(await importMultibaseKey(v["@value"]));
		}
		instance.#_4XLHbsR2gLVWU3NpEqKt9wANzn4F_publicKeyMultibase = _4XLHbsR2gLVWU3NpEqKt9wANzn4F_publicKeyMultibase;
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = {};
		if (this.id != null) proxy.id = {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(this.id.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(this.id.href, options)
		};
		const _2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller = this.#_2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller.length == 1) proxy.controller = _2yr3eUBTP6cNcyaxKzAXWjFsnGzN_controller[0];
		const _4XLHbsR2gLVWU3NpEqKt9wANzn4F_publicKeyMultibase = this.#_4XLHbsR2gLVWU3NpEqKt9wANzn4F_publicKeyMultibase.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_4XLHbsR2gLVWU3NpEqKt9wANzn4F_publicKeyMultibase.length == 1) proxy.publicKey = _4XLHbsR2gLVWU3NpEqKt9wANzn4F_publicKeyMultibase[0];
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "Multikey " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "Multikey " + inspect(proxy, options);
	}
};
/** Indicates that the `actor` accepts the `object`.  The `target` property can be
* used in certain circumstances to indicate the context into which the `object`
* has been accepted.
*/
var Accept = class Accept extends Activity {
	/**
	* The type URI of {@link Accept}: `https://www.w3.org/ns/activitystreams#Accept`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#Accept");
	}
	/**
	* Constructs a new instance of Accept with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		return clone;
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		values["@type"] = ["https://www.w3.org/ns/activitystreams#Accept"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? [
			"https://w3id.org/identity/v1",
			"https://www.w3.org/ns/activitystreams",
			"https://w3id.org/security/data-integrity/v1"
		];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {
			if ("proof" in compacted && compacted.proof != null) if (Array.isArray(compacted.proof)) for (const element of compacted.proof) element["@context"] = docContext;
			else compacted.proof["@context"] = docContext;
		}
		return compacted;
	}
	isCompactable() {
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__Accept__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__Accept__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#TentativeAccept")) return await TentativeAccept.fromJsonLd(json, options);
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Accept")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof Accept)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "Accept " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "Accept " + inspect(proxy, options);
	}
};
/** Indicates that the `actor` has added the `object` to the `target`.
* If the `target` property is not explicitly specified, the target would need
* to be determined implicitly by context.  The `origin` can be used to identify
* the context from which the `object` originated.
*/
var Add = class Add extends Activity {
	/**
	* The type URI of {@link Add}: `https://www.w3.org/ns/activitystreams#Add`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#Add");
	}
	/**
	* Constructs a new instance of Add with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		return clone;
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		values["@type"] = ["https://www.w3.org/ns/activitystreams#Add"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? [
			"https://w3id.org/identity/v1",
			"https://www.w3.org/ns/activitystreams",
			"https://w3id.org/security/data-integrity/v1"
		];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {
			if ("proof" in compacted && compacted.proof != null) if (Array.isArray(compacted.proof)) for (const element of compacted.proof) element["@context"] = docContext;
			else compacted.proof["@context"] = docContext;
		}
		return compacted;
	}
	isCompactable() {
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__Add__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__Add__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Add")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof Add)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "Add " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "Add " + inspect(proxy, options);
	}
};
/** Indicates that the `actor` is calling the `target`'s attention the `object`.
*
* The `origin` typically has no defined meaning.
*/
var Announce = class Announce extends Activity {
	/**
	* The type URI of {@link Announce}: `https://www.w3.org/ns/activitystreams#Announce`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#Announce");
	}
	/**
	* Constructs a new instance of Announce with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		return clone;
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		values["@type"] = ["https://www.w3.org/ns/activitystreams#Announce"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? [
			"https://w3id.org/identity/v1",
			"https://www.w3.org/ns/activitystreams",
			"https://w3id.org/security/data-integrity/v1",
			{
				"toot": "http://joinmastodon.org/ns#",
				"misskey": "https://misskey-hub.net/ns#",
				"fedibird": "http://fedibird.com/ns#",
				"sensitive": "as:sensitive",
				"votersCount": {
					"@id": "toot:votersCount",
					"@type": "http://www.w3.org/2001/XMLSchema#nonNegativeInteger"
				},
				"Emoji": "toot:Emoji",
				"Hashtag": "as:Hashtag",
				"quoteUrl": "as:quoteUrl",
				"_misskey_quote": "misskey:_misskey_quote",
				"quoteUri": "fedibird:quoteUri",
				"emojiReactions": {
					"@id": "fedibird:emojiReactions",
					"@type": "@id"
				}
			}
		];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {
			if ("proof" in compacted && compacted.proof != null) if (Array.isArray(compacted.proof)) for (const element of compacted.proof) element["@context"] = docContext;
			else compacted.proof["@context"] = docContext;
		}
		return compacted;
	}
	isCompactable() {
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__Announce__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__Announce__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Announce")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof Announce)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "Announce " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "Announce " + inspect(proxy, options);
	}
};
/** Describes a software application.
*/
var Application = class Application extends Object$1 {
	/**
	* The type URI of {@link Application}: `https://www.w3.org/ns/activitystreams#Application`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#Application");
	}
	#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = [];
	#_axq166E2eZADq34V4MYUc8KMZdC_publicKey = [];
	#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey = /* @__PURE__ */ new Set();
	#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = [];
	#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = /* @__PURE__ */ new Set();
	#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = [];
	#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = [];
	#_trust_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = /* @__PURE__ */ new Set();
	#_41QwhqJouoLg3h8dRPKat21brynC_outbox = [];
	#_trust_41QwhqJouoLg3h8dRPKat21brynC_outbox = /* @__PURE__ */ new Set();
	#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = [];
	#_trust_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = /* @__PURE__ */ new Set();
	#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = [];
	#_trust_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = /* @__PURE__ */ new Set();
	#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = [];
	#_trust_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = /* @__PURE__ */ new Set();
	#_4N1vBJzXDf8NbBumeECQMFvKetja_featured = [];
	#_trust_4N1vBJzXDf8NbBumeECQMFvKetja_featured = /* @__PURE__ */ new Set();
	#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = [];
	#_trust_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = /* @__PURE__ */ new Set();
	#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = [];
	#_trust_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = /* @__PURE__ */ new Set();
	#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = [];
	#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = [];
	#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = [];
	#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = [];
	#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = [];
	#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = [];
	#_trust_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = /* @__PURE__ */ new Set();
	#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = [];
	#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = /* @__PURE__ */ new Set();
	#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = [];
	#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = /* @__PURE__ */ new Set();
	#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = [];
	#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat = [];
	/**
	* Constructs a new instance of Application with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
		if ("preferredUsername" in values && values.preferredUsername != null) if (typeof values.preferredUsername === "string" || values.preferredUsername instanceof LanguageString) this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = [values.preferredUsername];
		else throw new TypeError("The preferredUsername must be of type string | LanguageString.");
		if ("preferredUsernames" in values && values.preferredUsernames != null) {
			if ("preferredUsername" in values && values.preferredUsername != null) throw new TypeError("Cannot initialize both preferredUsername and preferredUsernames at the same time.");
			if (Array.isArray(values.preferredUsernames) && values.preferredUsernames.every((v) => typeof v === "string" || v instanceof LanguageString)) this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = values.preferredUsernames;
			else throw new TypeError("The preferredUsernames must be an array of type string | LanguageString.");
		}
		if ("publicKey" in values && values.publicKey != null) if (values.publicKey instanceof CryptographicKey || values.publicKey instanceof URL) {
			this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey = [values.publicKey];
			this.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey.add(0);
		} else throw new TypeError("The publicKey must be of type CryptographicKey | URL.");
		if ("publicKeys" in values && values.publicKeys != null) {
			if ("publicKey" in values && values.publicKey != null) throw new TypeError("Cannot initialize both publicKey and publicKeys at the same time.");
			if (Array.isArray(values.publicKeys) && values.publicKeys.every((v) => v instanceof CryptographicKey || v instanceof URL)) {
				this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey = values.publicKeys;
				for (let i = 0; i < values.publicKeys.length; i++) this.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey.add(i);
			} else throw new TypeError("The publicKeys must be an array of type CryptographicKey | URL.");
		}
		if ("assertionMethod" in values && values.assertionMethod != null) if (values.assertionMethod instanceof Multikey || values.assertionMethod instanceof URL) {
			this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = [values.assertionMethod];
			this.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.add(0);
		} else throw new TypeError("The assertionMethod must be of type Multikey | URL.");
		if ("assertionMethods" in values && values.assertionMethods != null) {
			if ("assertionMethod" in values && values.assertionMethod != null) throw new TypeError("Cannot initialize both assertionMethod and assertionMethods at the same time.");
			if (Array.isArray(values.assertionMethods) && values.assertionMethods.every((v) => v instanceof Multikey || v instanceof URL)) {
				this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = values.assertionMethods;
				for (let i = 0; i < values.assertionMethods.length; i++) this.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.add(i);
			} else throw new TypeError("The assertionMethods must be an array of type Multikey | URL.");
		}
		if ("manuallyApprovesFollowers" in values && values.manuallyApprovesFollowers != null) if (typeof values.manuallyApprovesFollowers === "boolean") this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = [values.manuallyApprovesFollowers];
		else throw new TypeError("The manuallyApprovesFollowers must be of type boolean.");
		if ("inbox" in values && values.inbox != null) if (values.inbox instanceof OrderedCollection || values.inbox instanceof OrderedCollectionPage || values.inbox instanceof URL) {
			this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = [values.inbox];
			this.#_trust_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.add(0);
		} else throw new TypeError("The inbox must be of type OrderedCollection | OrderedCollectionPage | URL.");
		if ("outbox" in values && values.outbox != null) if (values.outbox instanceof OrderedCollection || values.outbox instanceof OrderedCollectionPage || values.outbox instanceof URL) {
			this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox = [values.outbox];
			this.#_trust_41QwhqJouoLg3h8dRPKat21brynC_outbox.add(0);
		} else throw new TypeError("The outbox must be of type OrderedCollection | OrderedCollectionPage | URL.");
		if ("following" in values && values.following != null) if (values.following instanceof Collection || values.following instanceof URL) {
			this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = [values.following];
			this.#_trust_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.add(0);
		} else throw new TypeError("The following must be of type Collection | URL.");
		if ("followers" in values && values.followers != null) if (values.followers instanceof Collection || values.followers instanceof URL) {
			this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = [values.followers];
			this.#_trust_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.add(0);
		} else throw new TypeError("The followers must be of type Collection | URL.");
		if ("liked" in values && values.liked != null) if (values.liked instanceof Collection || values.liked instanceof URL) {
			this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = [values.liked];
			this.#_trust_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.add(0);
		} else throw new TypeError("The liked must be of type Collection | URL.");
		if ("featured" in values && values.featured != null) if (values.featured instanceof Collection || values.featured instanceof URL) {
			this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured = [values.featured];
			this.#_trust_4N1vBJzXDf8NbBumeECQMFvKetja_featured.add(0);
		} else throw new TypeError("The featured must be of type Collection | URL.");
		if ("featuredTags" in values && values.featuredTags != null) if (values.featuredTags instanceof Collection || values.featuredTags instanceof URL) {
			this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = [values.featuredTags];
			this.#_trust_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.add(0);
		} else throw new TypeError("The featuredTags must be of type Collection | URL.");
		if ("streams" in values && values.streams != null) if (Array.isArray(values.streams) && values.streams.every((v) => v instanceof Collection || v instanceof URL)) {
			this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = values.streams;
			for (let i = 0; i < values.streams.length; i++) this.#_trust_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.add(i);
		} else throw new TypeError("The streams must be an array of type Collection | URL.");
		if ("endpoints" in values && values.endpoints != null) if (values.endpoints instanceof Endpoints) this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = [values.endpoints];
		else throw new TypeError("The endpoints must be of type Endpoints.");
		if ("discoverable" in values && values.discoverable != null) if (typeof values.discoverable === "boolean") this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = [values.discoverable];
		else throw new TypeError("The discoverable must be of type boolean.");
		if ("suspended" in values && values.suspended != null) if (typeof values.suspended === "boolean") this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = [values.suspended];
		else throw new TypeError("The suspended must be of type boolean.");
		if ("memorial" in values && values.memorial != null) if (typeof values.memorial === "boolean") this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = [values.memorial];
		else throw new TypeError("The memorial must be of type boolean.");
		if ("indexable" in values && values.indexable != null) if (typeof values.indexable === "boolean") this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = [values.indexable];
		else throw new TypeError("The indexable must be of type boolean.");
		if ("successor" in values && values.successor != null) if (values.successor instanceof Application || values.successor instanceof Group || values.successor instanceof Organization || values.successor instanceof Person || values.successor instanceof Service || values.successor instanceof URL) {
			this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = [values.successor];
			this.#_trust_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.add(0);
		} else throw new TypeError("The successor must be of type Application | Group | Organization | Person | Service | URL.");
		if ("alias" in values && values.alias != null) if (values.alias instanceof Application || values.alias instanceof Group || values.alias instanceof Organization || values.alias instanceof Person || values.alias instanceof Service || values.alias instanceof URL) {
			this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = [values.alias];
			this.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.add(0);
		} else throw new TypeError("The alias must be of type Application | Group | Organization | Person | Service | URL.");
		if ("aliases" in values && values.aliases != null) {
			if ("alias" in values && values.alias != null) throw new TypeError("Cannot initialize both alias and aliases at the same time.");
			if (Array.isArray(values.aliases) && values.aliases.every((v) => v instanceof Application || v instanceof Group || v instanceof Organization || v instanceof Person || v instanceof Service || v instanceof URL)) {
				this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = values.aliases;
				for (let i = 0; i < values.aliases.length; i++) this.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.add(i);
			} else throw new TypeError("The aliases must be an array of type Application | Group | Organization | Person | Service | URL.");
		}
		if ("service" in values && values.service != null) if (values.service instanceof DidService || values.service instanceof URL) {
			this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = [values.service];
			this.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.add(0);
		} else throw new TypeError("The service must be of type DidService | URL.");
		if ("services" in values && values.services != null) {
			if ("service" in values && values.service != null) throw new TypeError("Cannot initialize both service and services at the same time.");
			if (Array.isArray(values.services) && values.services.every((v) => v instanceof DidService || v instanceof URL)) {
				this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = values.services;
				for (let i = 0; i < values.services.length; i++) this.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.add(i);
			} else throw new TypeError("The services must be an array of type DidService | URL.");
		}
		if ("followedMessage" in values && values.followedMessage != null) if (typeof values.followedMessage === "string") this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = [values.followedMessage];
		else throw new TypeError("The followedMessage must be of type string.");
		if ("cat" in values && values.cat != null) if (typeof values.cat === "boolean") this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat = [values.cat];
		else throw new TypeError("The cat must be of type boolean.");
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		clone.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername;
		if ("preferredUsername" in values && values.preferredUsername != null) if (typeof values.preferredUsername === "string" || values.preferredUsername instanceof LanguageString) clone.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = [values.preferredUsername];
		else throw new TypeError("The preferredUsername must be of type string | LanguageString.");
		if ("preferredUsernames" in values && values.preferredUsernames != null) {
			if ("preferredUsername" in values && values.preferredUsername != null) throw new TypeError("Cannot update both preferredUsername and preferredUsernames at the same time.");
			if (Array.isArray(values.preferredUsernames) && values.preferredUsernames.every((v) => typeof v === "string" || v instanceof LanguageString)) clone.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = values.preferredUsernames;
			else throw new TypeError("The preferredUsernames must be an array of type string | LanguageString.");
		}
		clone.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey = this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey;
		clone.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey = new Set(this.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey);
		if ("publicKey" in values && values.publicKey != null) if (values.publicKey instanceof CryptographicKey || values.publicKey instanceof URL) {
			clone.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey = [values.publicKey];
			clone.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey = new Set([0]);
		} else throw new TypeError("The publicKey must be of type CryptographicKey | URL.");
		if ("publicKeys" in values && values.publicKeys != null) {
			if ("publicKey" in values && values.publicKey != null) throw new TypeError("Cannot update both publicKey and publicKeys at the same time.");
			if (Array.isArray(values.publicKeys) && values.publicKeys.every((v) => v instanceof CryptographicKey || v instanceof URL)) {
				clone.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey = values.publicKeys;
				clone.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey = /* @__PURE__ */ new Set();
				for (let i = 0; i < values.publicKeys.length; i++) clone.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey.add(i);
			} else throw new TypeError("The publicKeys must be an array of type CryptographicKey | URL.");
		}
		clone.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod;
		clone.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = new Set(this.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod);
		if ("assertionMethod" in values && values.assertionMethod != null) if (values.assertionMethod instanceof Multikey || values.assertionMethod instanceof URL) {
			clone.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = [values.assertionMethod];
			clone.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = new Set([0]);
		} else throw new TypeError("The assertionMethod must be of type Multikey | URL.");
		if ("assertionMethods" in values && values.assertionMethods != null) {
			if ("assertionMethod" in values && values.assertionMethod != null) throw new TypeError("Cannot update both assertionMethod and assertionMethods at the same time.");
			if (Array.isArray(values.assertionMethods) && values.assertionMethods.every((v) => v instanceof Multikey || v instanceof URL)) {
				clone.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = values.assertionMethods;
				clone.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = /* @__PURE__ */ new Set();
				for (let i = 0; i < values.assertionMethods.length; i++) clone.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.add(i);
			} else throw new TypeError("The assertionMethods must be an array of type Multikey | URL.");
		}
		clone.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers;
		if ("manuallyApprovesFollowers" in values && values.manuallyApprovesFollowers != null) if (typeof values.manuallyApprovesFollowers === "boolean") clone.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = [values.manuallyApprovesFollowers];
		else throw new TypeError("The manuallyApprovesFollowers must be of type boolean.");
		clone.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox;
		clone.#_trust_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = new Set(this.#_trust_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox);
		if ("inbox" in values && values.inbox != null) if (values.inbox instanceof OrderedCollection || values.inbox instanceof OrderedCollectionPage || values.inbox instanceof URL) {
			clone.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = [values.inbox];
			clone.#_trust_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = new Set([0]);
		} else throw new TypeError("The inbox must be of type OrderedCollection | OrderedCollectionPage | URL.");
		clone.#_41QwhqJouoLg3h8dRPKat21brynC_outbox = this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox;
		clone.#_trust_41QwhqJouoLg3h8dRPKat21brynC_outbox = new Set(this.#_trust_41QwhqJouoLg3h8dRPKat21brynC_outbox);
		if ("outbox" in values && values.outbox != null) if (values.outbox instanceof OrderedCollection || values.outbox instanceof OrderedCollectionPage || values.outbox instanceof URL) {
			clone.#_41QwhqJouoLg3h8dRPKat21brynC_outbox = [values.outbox];
			clone.#_trust_41QwhqJouoLg3h8dRPKat21brynC_outbox = new Set([0]);
		} else throw new TypeError("The outbox must be of type OrderedCollection | OrderedCollectionPage | URL.");
		clone.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following;
		clone.#_trust_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = new Set(this.#_trust_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following);
		if ("following" in values && values.following != null) if (values.following instanceof Collection || values.following instanceof URL) {
			clone.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = [values.following];
			clone.#_trust_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = new Set([0]);
		} else throw new TypeError("The following must be of type Collection | URL.");
		clone.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers;
		clone.#_trust_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = new Set(this.#_trust_BBCTgfphhsFzpVfKTykGSpBNwoA_followers);
		if ("followers" in values && values.followers != null) if (values.followers instanceof Collection || values.followers instanceof URL) {
			clone.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = [values.followers];
			clone.#_trust_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = new Set([0]);
		} else throw new TypeError("The followers must be of type Collection | URL.");
		clone.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked;
		clone.#_trust_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = new Set(this.#_trust_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked);
		if ("liked" in values && values.liked != null) if (values.liked instanceof Collection || values.liked instanceof URL) {
			clone.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = [values.liked];
			clone.#_trust_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = new Set([0]);
		} else throw new TypeError("The liked must be of type Collection | URL.");
		clone.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured = this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured;
		clone.#_trust_4N1vBJzXDf8NbBumeECQMFvKetja_featured = new Set(this.#_trust_4N1vBJzXDf8NbBumeECQMFvKetja_featured);
		if ("featured" in values && values.featured != null) if (values.featured instanceof Collection || values.featured instanceof URL) {
			clone.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured = [values.featured];
			clone.#_trust_4N1vBJzXDf8NbBumeECQMFvKetja_featured = new Set([0]);
		} else throw new TypeError("The featured must be of type Collection | URL.");
		clone.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags;
		clone.#_trust_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = new Set(this.#_trust_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags);
		if ("featuredTags" in values && values.featuredTags != null) if (values.featuredTags instanceof Collection || values.featuredTags instanceof URL) {
			clone.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = [values.featuredTags];
			clone.#_trust_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = new Set([0]);
		} else throw new TypeError("The featuredTags must be of type Collection | URL.");
		clone.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams;
		clone.#_trust_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = new Set(this.#_trust_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams);
		if ("streams" in values && values.streams != null) if (Array.isArray(values.streams) && values.streams.every((v) => v instanceof Collection || v instanceof URL)) {
			clone.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = values.streams;
			clone.#_trust_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = /* @__PURE__ */ new Set();
			for (let i = 0; i < values.streams.length; i++) clone.#_trust_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.add(i);
		} else throw new TypeError("The streams must be an array of type Collection | URL.");
		clone.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints;
		if ("endpoints" in values && values.endpoints != null) if (values.endpoints instanceof Endpoints) clone.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = [values.endpoints];
		else throw new TypeError("The endpoints must be of type Endpoints.");
		clone.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable;
		if ("discoverable" in values && values.discoverable != null) if (typeof values.discoverable === "boolean") clone.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = [values.discoverable];
		else throw new TypeError("The discoverable must be of type boolean.");
		clone.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended;
		if ("suspended" in values && values.suspended != null) if (typeof values.suspended === "boolean") clone.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = [values.suspended];
		else throw new TypeError("The suspended must be of type boolean.");
		clone.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial;
		if ("memorial" in values && values.memorial != null) if (typeof values.memorial === "boolean") clone.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = [values.memorial];
		else throw new TypeError("The memorial must be of type boolean.");
		clone.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable;
		if ("indexable" in values && values.indexable != null) if (typeof values.indexable === "boolean") clone.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = [values.indexable];
		else throw new TypeError("The indexable must be of type boolean.");
		clone.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo;
		clone.#_trust_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = new Set(this.#_trust_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo);
		if ("successor" in values && values.successor != null) if (values.successor instanceof Application || values.successor instanceof Group || values.successor instanceof Organization || values.successor instanceof Person || values.successor instanceof Service || values.successor instanceof URL) {
			clone.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = [values.successor];
			clone.#_trust_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = new Set([0]);
		} else throw new TypeError("The successor must be of type Application | Group | Organization | Person | Service | URL.");
		clone.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs;
		clone.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = new Set(this.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs);
		if ("alias" in values && values.alias != null) if (values.alias instanceof Application || values.alias instanceof Group || values.alias instanceof Organization || values.alias instanceof Person || values.alias instanceof Service || values.alias instanceof URL) {
			clone.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = [values.alias];
			clone.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = new Set([0]);
		} else throw new TypeError("The alias must be of type Application | Group | Organization | Person | Service | URL.");
		if ("aliases" in values && values.aliases != null) {
			if ("alias" in values && values.alias != null) throw new TypeError("Cannot update both alias and aliases at the same time.");
			if (Array.isArray(values.aliases) && values.aliases.every((v) => v instanceof Application || v instanceof Group || v instanceof Organization || v instanceof Person || v instanceof Service || v instanceof URL)) {
				clone.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = values.aliases;
				clone.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = /* @__PURE__ */ new Set();
				for (let i = 0; i < values.aliases.length; i++) clone.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.add(i);
			} else throw new TypeError("The aliases must be an array of type Application | Group | Organization | Person | Service | URL.");
		}
		clone.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service;
		clone.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = new Set(this.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service);
		if ("service" in values && values.service != null) if (values.service instanceof DidService || values.service instanceof URL) {
			clone.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = [values.service];
			clone.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = new Set([0]);
		} else throw new TypeError("The service must be of type DidService | URL.");
		if ("services" in values && values.services != null) {
			if ("service" in values && values.service != null) throw new TypeError("Cannot update both service and services at the same time.");
			if (Array.isArray(values.services) && values.services.every((v) => v instanceof DidService || v instanceof URL)) {
				clone.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = values.services;
				clone.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = /* @__PURE__ */ new Set();
				for (let i = 0; i < values.services.length; i++) clone.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.add(i);
			} else throw new TypeError("The services must be an array of type DidService | URL.");
		}
		clone.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage;
		if ("followedMessage" in values && values.followedMessage != null) if (typeof values.followedMessage === "string") clone.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = [values.followedMessage];
		else throw new TypeError("The followedMessage must be of type string.");
		clone.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat = this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat;
		if ("cat" in values && values.cat != null) if (typeof values.cat === "boolean") clone.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat = [values.cat];
		else throw new TypeError("The cat must be of type boolean.");
		return clone;
	}
	/** A short username which may be used to refer to the actor,
	* with no uniqueness guarantees.
	*/
	get preferredUsername() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.length < 1) return null;
		return this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername[0];
	}
	/** A short username which may be used to refer to the actor,
	* with no uniqueness guarantees.
	*/
	get preferredUsernames() {
		return this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername;
	}
	async #fetchPublicKey(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#publicKey_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #publicKey_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await CryptographicKey.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://w3id.org/security#Key"].join(", "));
	}
	/**
	* Similar to
	* {@link Application.getPublicKey},
	* but returns its `@id` URL instead of the object itself.
	*/
	get publicKeyId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey.length < 1) return null;
		const v = this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** A public part of the key pair owned by this actor.
	*/
	async getPublicKey(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey.length < 1) return null;
		let v = this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchPublicKey(v, options);
			if (fetched == null) return null;
			this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey[0] = fetched;
			this.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "publicKey" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["publicKey"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#publicKey_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	/**
	* Similar to
	* {@link Application.getPublicKeys},
	* but returns their `@id`s instead of the objects themselves.
	*/
	get publicKeyIds() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		return this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
	}
	/** A public part of the key pair owned by this actor.
	*/
	async *getPublicKeys(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		const vs = this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey;
		for (let i = 0; i < vs.length; i++) {
			let v = vs[i];
			if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey.has(i)) v = v.id;
			if (v instanceof URL) {
				const fetched = await this.#fetchPublicKey(v, options);
				if (fetched == null) continue;
				vs[i] = fetched;
				this.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey.add(i);
				this._cachedJsonLd = void 0;
				yield fetched;
				continue;
			}
			if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "publicKey" in this._cachedJsonLd) {
				const prop = this._cachedJsonLd["publicKey"];
				const obj = Array.isArray(prop) ? prop[i] : prop;
				if (obj != null && typeof obj === "object" && "@context" in obj) v = await this.#publicKey_fromJsonLd(obj, options);
			}
			if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey.has(0)) {
				if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
				getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
					objectId: v.id.href,
					parentObjectId: this.id.href
				});
				continue;
			}
			yield v;
		}
	}
	async #fetchAssertionMethod(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#assertionMethod_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #assertionMethod_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Multikey.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://w3id.org/security#Multikey"].join(", "));
	}
	/**
	* Similar to
	* {@link Application.getAssertionMethod},
	* but returns its `@id` URL instead of the object itself.
	*/
	get assertionMethodId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.length < 1) return null;
		const v = this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** Represents this actor's public keys.  It serves as equivalent to
	* the `publicKeys` property, but is used for [FEP-521a] compliance.
	*
	* [FEP-521a]: https://w3id.org/fep/521a
	*/
	async getAssertionMethod(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.length < 1) return null;
		let v = this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchAssertionMethod(v, options);
			if (fetched == null) return null;
			this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod[0] = fetched;
			this.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "assertionMethod" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["assertionMethod"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#assertionMethod_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	/**
	* Similar to
	* {@link Application.getAssertionMethods},
	* but returns their `@id`s instead of the objects themselves.
	*/
	get assertionMethodIds() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		return this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
	}
	/** Represents this actor's public keys.  It serves as equivalent to
	* the `publicKeys` property, but is used for [FEP-521a] compliance.
	*
	* [FEP-521a]: https://w3id.org/fep/521a
	*/
	async *getAssertionMethods(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		const vs = this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod;
		for (let i = 0; i < vs.length; i++) {
			let v = vs[i];
			if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.has(i)) v = v.id;
			if (v instanceof URL) {
				const fetched = await this.#fetchAssertionMethod(v, options);
				if (fetched == null) continue;
				vs[i] = fetched;
				this.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.add(i);
				this._cachedJsonLd = void 0;
				yield fetched;
				continue;
			}
			if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "assertionMethod" in this._cachedJsonLd) {
				const prop = this._cachedJsonLd["assertionMethod"];
				const obj = Array.isArray(prop) ? prop[i] : prop;
				if (obj != null && typeof obj === "object" && "@context" in obj) v = await this.#assertionMethod_fromJsonLd(obj, options);
			}
			if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.has(0)) {
				if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
				getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
					objectId: v.id.href,
					parentObjectId: this.id.href
				});
				continue;
			}
			yield v;
		}
	}
	/** When `true`, conveys that for this actor, follow requests are not usually
	* automatically approved, but instead are examined by a person who may accept
	* or reject the request, at some time in the future.  Setting of `false`
	* conveys no information and may be ignored.  This information is typically
	* used to affect display of accounts, such as showing an account as private or
	* locked.
	*/
	get manuallyApprovesFollowers() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers.length < 1) return null;
		return this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers[0];
	}
	async #fetchInbox(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#inbox_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #inbox_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await OrderedCollection.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await OrderedCollectionPage.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#OrderedCollection", "https://www.w3.org/ns/activitystreams#OrderedCollectionPage"].join(", "));
	}
	/**
	* Similar to
	* {@link Application.getInbox},
	* but returns its `@id` URL instead of the object itself.
	*/
	get inboxId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.length < 1) return null;
		const v = this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** The inbox stream contains all activities received by the actor.  The server
	* SHOULD filter content according to the requester's permission.  In general,
	* the owner of an inbox is likely to be able to access all of their inbox
	* contents.  Depending on access control, some other content may be public,
	* whereas other content may require authentication for non-owner users,
	* if they can access the inbox at all.
	*
	* The server MUST perform de-duplication of activities returned by the inbox.
	* Duplication can occur if an activity is addressed both to an actor's
	* followers, and a specific actor who also follows the recipient actor,
	* and the server has failed to de-duplicate the recipients list.
	* Such deduplication MUST be performed by comparing the `id` of the activities
	* and dropping any activities already seen.
	*/
	async getInbox(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.length < 1) return null;
		let v = this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchInbox(v, options);
			if (fetched == null) return null;
			this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox[0] = fetched;
			this.#_trust_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "inbox" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["inbox"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#inbox_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchOutbox(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#outbox_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #outbox_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await OrderedCollection.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await OrderedCollectionPage.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#OrderedCollection", "https://www.w3.org/ns/activitystreams#OrderedCollectionPage"].join(", "));
	}
	/**
	* Similar to
	* {@link Application.getOutbox},
	* but returns its `@id` URL instead of the object itself.
	*/
	get outboxId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox.length < 1) return null;
		const v = this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** The outbox stream contains activities the user has published,
	* subject to the ability of the requestor to retrieve the activity
	* (that is, the contents of the outbox are filtered by the permissions of
	* the person reading it).  If a user submits a request without
	* [Authorization](https://www.w3.org/TR/activitypub/#authorization)
	* the server should respond with all of the
	* [Public](https://www.w3.org/TR/activitypub/#public-addressing) posts.
	* This could potentially be all relevant objects published by the user,
	* though the number of available items is left to the discretion of those
	* implementing and deploying the server.
	*/
	async getOutbox(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox.length < 1) return null;
		let v = this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_41QwhqJouoLg3h8dRPKat21brynC_outbox.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchOutbox(v, options);
			if (fetched == null) return null;
			this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox[0] = fetched;
			this.#_trust_41QwhqJouoLg3h8dRPKat21brynC_outbox.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "outbox" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["outbox"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#outbox_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_41QwhqJouoLg3h8dRPKat21brynC_outbox.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchFollowing(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#following_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #following_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Collection.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
	}
	/**
	* Similar to
	* {@link Application.getFollowing},
	* but returns its `@id` URL instead of the object itself.
	*/
	get followingId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.length < 1) return null;
		const v = this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** This is a list of everybody that the actor has followed, added as a
	* [side effect](https://www.w3.org/TR/activitypub/#follow-activity-outbox).
	* The `following` collection MUST be either an {@link OrderedCollection}
	* or a {@link Collection} and MAY be filtered on privileges of
	* an authenticated user or as appropriate when no authentication is given.
	*/
	async getFollowing(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.length < 1) return null;
		let v = this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchFollowing(v, options);
			if (fetched == null) return null;
			this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following[0] = fetched;
			this.#_trust_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "following" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["following"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#following_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchFollowers(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#followers_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #followers_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Collection.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
	}
	/**
	* Similar to
	* {@link Application.getFollowers},
	* but returns its `@id` URL instead of the object itself.
	*/
	get followersId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.length < 1) return null;
		const v = this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** This is a list of everyone who has sent a {@link Follow} activity
	* for the actor, added as a
	* [side effect](https://www.w3.org/TR/activitypub/#follow-activity-outbox).
	* This is where one would find a list of all the actors that are following
	* the actor.  The `followers` collection MUST be either
	* an {@link OrderedCollection} or a {@link Collection} and MAY be filtered on
	* privileges of an authenticated user or as appropriate when no authentication
	* is given.
	*/
	async getFollowers(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.length < 1) return null;
		let v = this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchFollowers(v, options);
			if (fetched == null) return null;
			this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers[0] = fetched;
			this.#_trust_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "followers" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["followers"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#followers_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchLiked(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#liked_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #liked_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Collection.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
	}
	/**
	* Similar to
	* {@link Application.getLiked},
	* but returns its `@id` URL instead of the object itself.
	*/
	get likedId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.length < 1) return null;
		const v = this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** This is a list of every object from all of the actor's {@link Like}
	* activities, added as a
	* [side effect](https://www.w3.org/TR/activitypub/#like-activity-outbox).
	* The `liked` collection MUST be either an {@link OrderedCollection} or
	* a {@link Collection} and MAY be filtered on privileges of an authenticated
	* user or as appropriate when no authentication is given.
	*/
	async getLiked(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.length < 1) return null;
		let v = this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchLiked(v, options);
			if (fetched == null) return null;
			this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked[0] = fetched;
			this.#_trust_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "liked" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["liked"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#liked_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchFeatured(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#featured_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #featured_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Collection.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
	}
	/**
	* Similar to
	* {@link Application.getFeatured},
	* but returns its `@id` URL instead of the object itself.
	*/
	get featuredId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured.length < 1) return null;
		const v = this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** What is known in Mastodon as "pinned statuses", or statuses that are always
	* featured at the top of people's profiles, is implemented using an extra
	* property `featured` on the actor object that points to a {@link Collection}
	* of objects.
	*/
	async getFeatured(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured.length < 1) return null;
		let v = this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_4N1vBJzXDf8NbBumeECQMFvKetja_featured.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchFeatured(v, options);
			if (fetched == null) return null;
			this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured[0] = fetched;
			this.#_trust_4N1vBJzXDf8NbBumeECQMFvKetja_featured.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "featured" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["featured"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#featured_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_4N1vBJzXDf8NbBumeECQMFvKetja_featured.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchFeaturedTags(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#featuredTags_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #featuredTags_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Collection.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
	}
	/**
	* Similar to
	* {@link Application.getFeaturedTags},
	* but returns its `@id` URL instead of the object itself.
	*/
	get featuredTagsId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.length < 1) return null;
		const v = this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** What is known in Mastodon as "featured hashtags", hashtags that are featured
	* at people's profiles, is implemented using an extra property `featuredTags`
	* on the actor object that points to a {@link Collection} of {@link Hashtag}
	* objects specifically.
	*/
	async getFeaturedTags(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.length < 1) return null;
		let v = this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchFeaturedTags(v, options);
			if (fetched == null) return null;
			this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags[0] = fetched;
			this.#_trust_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "featuredTags" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["featuredTags"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#featuredTags_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchStream(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#stream_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #stream_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Collection.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
	}
	/**
	* Similar to
	* {@link Application.getStreams},
	* but returns their `@id`s instead of the objects themselves.
	*/
	get streamIds() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		return this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
	}
	/** A list of supplementary Collections which may be of interest.
	*/
	async *getStreams(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		const vs = this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams;
		for (let i = 0; i < vs.length; i++) {
			let v = vs[i];
			if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.has(i)) v = v.id;
			if (v instanceof URL) {
				const fetched = await this.#fetchStream(v, options);
				if (fetched == null) continue;
				vs[i] = fetched;
				this.#_trust_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.add(i);
				this._cachedJsonLd = void 0;
				yield fetched;
				continue;
			}
			if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "streams" in this._cachedJsonLd) {
				const prop = this._cachedJsonLd["streams"];
				const obj = Array.isArray(prop) ? prop[i] : prop;
				if (obj != null && typeof obj === "object" && "@context" in obj) v = await this.#stream_fromJsonLd(obj, options);
			}
			if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.has(0)) {
				if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
				getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
					objectId: v.id.href,
					parentObjectId: this.id.href
				});
				continue;
			}
			yield v;
		}
	}
	/** A JSON object which maps additional (typically server/domain-wide) endpoints
	* which may be useful either for this actor or someone referencing this actor.
	* This mapping may be nested inside the actor document as the value or may be
	* a link to a JSON-LD document with these properties.
	*/
	get endpoints() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints.length < 1) return null;
		return this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints[0];
	}
	/** Allows users to opt-in or opt-out of discoverability features like
	* the profile directory.  This flag may also be used as an indicator of
	* the user's preferences toward being included in external discovery services,
	* such as search engines or other indexing tools.
	*/
	get discoverable() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable.length < 1) return null;
		return this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable[0];
	}
	/** Reports whether a user was locally suspended, for better handling of
	* these accounts.
	*/
	get suspended() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended.length < 1) return null;
		return this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended[0];
	}
	/** Whether the actor is in-memorial state.
	*/
	get memorial() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial.length < 1) return null;
		return this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial[0];
	}
	/** Whether the actor allows to be indexed.
	*/
	get indexable() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable.length < 1) return null;
		return this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable[0];
	}
	async #fetchSuccessor(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#successor_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #successor_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Application.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Group.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Organization.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Person.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Service.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + [
			"https://www.w3.org/ns/activitystreams#Application",
			"https://www.w3.org/ns/activitystreams#Group",
			"https://www.w3.org/ns/activitystreams#Organization",
			"https://www.w3.org/ns/activitystreams#Person",
			"https://www.w3.org/ns/activitystreams#Service"
		].join(", "));
	}
	/**
	* Similar to
	* {@link Application.getSuccessor},
	* but returns its `@id` URL instead of the object itself.
	*/
	get successorId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.length < 1) return null;
		const v = this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** Signifies that an actor has been moved to a different ID. Used in Mastodon-style data portability with the {@link Move} activity; see [ActivityPub Data Portability/Move Action](https://swicg.github.io/activitypub-data-portability/#move-action) for more details.
	*/
	async getSuccessor(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.length < 1) return null;
		let v = this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchSuccessor(v, options);
			if (fetched == null) return null;
			this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo[0] = fetched;
			this.#_trust_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "movedTo" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["movedTo"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#successor_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchAlias(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#alias_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #alias_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Application.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Group.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Organization.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Person.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Service.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + [
			"https://www.w3.org/ns/activitystreams#Application",
			"https://www.w3.org/ns/activitystreams#Group",
			"https://www.w3.org/ns/activitystreams#Organization",
			"https://www.w3.org/ns/activitystreams#Person",
			"https://www.w3.org/ns/activitystreams#Service"
		].join(", "));
	}
	/**
	* Similar to
	* {@link Application.getAlias},
	* but returns its `@id` URL instead of the object itself.
	*/
	get aliasId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.length < 1) return null;
		const v = this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** The `aliases` (`alsoKnownAs`) property is used to specify alternative names
	* or aliases for an entity.  It can be used to provide additional identifiers
	* or labels for an entity, which can be useful in scenarios where an entity
	* may have multiple names or aliases.
	*/
	async getAlias(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.length < 1) return null;
		let v = this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchAlias(v, options);
			if (fetched == null) return null;
			this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs[0] = fetched;
			this.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "alsoKnownAs" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["alsoKnownAs"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#alias_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	/**
	* Similar to
	* {@link Application.getAliases},
	* but returns their `@id`s instead of the objects themselves.
	*/
	get aliasIds() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		return this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
	}
	/** The `aliases` (`alsoKnownAs`) property is used to specify alternative names
	* or aliases for an entity.  It can be used to provide additional identifiers
	* or labels for an entity, which can be useful in scenarios where an entity
	* may have multiple names or aliases.
	*/
	async *getAliases(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		const vs = this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs;
		for (let i = 0; i < vs.length; i++) {
			let v = vs[i];
			if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.has(i)) v = v.id;
			if (v instanceof URL) {
				const fetched = await this.#fetchAlias(v, options);
				if (fetched == null) continue;
				vs[i] = fetched;
				this.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.add(i);
				this._cachedJsonLd = void 0;
				yield fetched;
				continue;
			}
			if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "alsoKnownAs" in this._cachedJsonLd) {
				const prop = this._cachedJsonLd["alsoKnownAs"];
				const obj = Array.isArray(prop) ? prop[i] : prop;
				if (obj != null && typeof obj === "object" && "@context" in obj) v = await this.#alias_fromJsonLd(obj, options);
			}
			if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.has(0)) {
				if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
				getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
					objectId: v.id.href,
					parentObjectId: this.id.href
				});
				continue;
			}
			yield v;
		}
	}
	async #fetchService(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#service_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #service_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await DidService.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/did#Service"].join(", "));
	}
	/**
	* Similar to
	* {@link Application.getService},
	* but returns its `@id` URL instead of the object itself.
	*/
	get serviceId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length < 1) return null;
		const v = this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** Means of communicating or interacting with the DID subject or associated
	* entities via one or more service endpoints. Examples include discovery
	* services, agent services, social networking services, file storage services,
	* and verifiable credential repository services.
	*/
	async getService(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length < 1) return null;
		let v = this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchService(v, options);
			if (fetched == null) return null;
			this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service[0] = fetched;
			this.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "service" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["service"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#service_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	/**
	* Similar to
	* {@link Application.getServices},
	* but returns their `@id`s instead of the objects themselves.
	*/
	get serviceIds() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		return this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
	}
	/** Means of communicating or interacting with the DID subject or associated
	* entities via one or more service endpoints. Examples include discovery
	* services, agent services, social networking services, file storage services,
	* and verifiable credential repository services.
	*/
	async *getServices(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		const vs = this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service;
		for (let i = 0; i < vs.length; i++) {
			let v = vs[i];
			if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.has(i)) v = v.id;
			if (v instanceof URL) {
				const fetched = await this.#fetchService(v, options);
				if (fetched == null) continue;
				vs[i] = fetched;
				this.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.add(i);
				this._cachedJsonLd = void 0;
				yield fetched;
				continue;
			}
			if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "service" in this._cachedJsonLd) {
				const prop = this._cachedJsonLd["service"];
				const obj = Array.isArray(prop) ? prop[i] : prop;
				if (obj != null && typeof obj === "object" && "@context" in obj) v = await this.#service_fromJsonLd(obj, options);
			}
			if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.has(0)) {
				if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
				getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
					objectId: v.id.href,
					parentObjectId: this.id.href
				});
				continue;
			}
			yield v;
		}
	}
	/** This value is used for `Actor` type objects to show message on followed.
	*/
	get followedMessage() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage.length < 1) return null;
		return this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage[0];
	}
	/** Used on actors to indicate that they in some way identify as a cat,
	* expressed as a boolean value. If this property is set to `true`,
	* displaying the actor or their notes will have some special effects
	* attached in some clients.
	*/
	get cat() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat.length < 1) return null;
		return this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat[0];
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		if (options.format == null && this.isCompactable()) {
			const result = await super.toJsonLd({
				...options,
				format: void 0,
				context: void 0
			});
			let compactItems;
			compactItems = [];
			for (const v of this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername) {
				const item = typeof v === "string" ? v : {
					"@value": v.toString(),
					"@language": v.language.compact()
				};
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["preferredUsername"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["publicKey"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["assertionMethod"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers) {
				const item = v;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["manuallyApprovesFollowers"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox) {
				const item = v instanceof URL ? v.href : v instanceof OrderedCollection ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["inbox"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox) {
				const item = v instanceof URL ? v.href : v instanceof OrderedCollection ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["outbox"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["following"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["followers"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["liked"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["featured"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["featuredTags"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["streams"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints) {
				const item = await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["endpoints"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable) {
				const item = v;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["discoverable"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended) {
				const item = v;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["suspended"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial) {
				const item = v;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["memorial"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable) {
				const item = v;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["indexable"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo) {
				const item = v instanceof URL ? v.href : v instanceof Application ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : v instanceof Group ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : v instanceof Organization ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : v instanceof Person ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["movedTo"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs) {
				const item = v instanceof URL ? v.href : v instanceof Application ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : v instanceof Group ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : v instanceof Organization ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : v instanceof Person ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["alsoKnownAs"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["service"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage) {
				const item = v;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["_misskey_followedMessage"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat) {
				const item = v;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["isCat"] = compactItems.length > 1 ? compactItems : compactItems[0];
			result["type"] = "Application";
			if (this.id != null) result["id"] = this.id.href;
			result["@context"] = [
				"https://www.w3.org/ns/activitystreams",
				"https://w3id.org/security/v1",
				"https://w3id.org/security/data-integrity/v1",
				"https://www.w3.org/ns/did/v1",
				"https://w3id.org/security/multikey/v1",
				{
					"alsoKnownAs": {
						"@id": "as:alsoKnownAs",
						"@type": "@id"
					},
					"manuallyApprovesFollowers": "as:manuallyApprovesFollowers",
					"movedTo": {
						"@id": "as:movedTo",
						"@type": "@id"
					},
					"toot": "http://joinmastodon.org/ns#",
					"Emoji": "toot:Emoji",
					"featured": {
						"@id": "toot:featured",
						"@type": "@id"
					},
					"featuredTags": {
						"@id": "toot:featuredTags",
						"@type": "@id"
					},
					"discoverable": "toot:discoverable",
					"suspended": "toot:suspended",
					"memorial": "toot:memorial",
					"indexable": "toot:indexable",
					"schema": "http://schema.org#",
					"PropertyValue": "schema:PropertyValue",
					"value": "schema:value",
					"misskey": "https://misskey-hub.net/ns#",
					"_misskey_followedMessage": "misskey:_misskey_followedMessage",
					"isCat": "misskey:isCat"
				}
			];
			return result;
		}
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		array = [];
		for (const v of this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername) {
			const element = typeof v === "string" ? { "@value": v } : {
				"@value": v.toString(),
				"@language": v.language.compact()
			};
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#preferredUsername"] = propValue;
		}
		array = [];
		for (const v of this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://w3id.org/security#publicKey"] = propValue;
		}
		array = [];
		for (const v of this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://w3id.org/security#assertionMethod"] = propValue;
		}
		array = [];
		for (const v of this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers) {
			const element = { "@value": v };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#manuallyApprovesFollowers"] = propValue;
		}
		array = [];
		for (const v of this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox) {
			const element = v instanceof URL ? { "@id": v.href } : v instanceof OrderedCollection ? await v.toJsonLd(options) : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["http://www.w3.org/ns/ldp#inbox"] = propValue;
		}
		array = [];
		for (const v of this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox) {
			const element = v instanceof URL ? { "@id": v.href } : v instanceof OrderedCollection ? await v.toJsonLd(options) : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#outbox"] = propValue;
		}
		array = [];
		for (const v of this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#following"] = propValue;
		}
		array = [];
		for (const v of this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#followers"] = propValue;
		}
		array = [];
		for (const v of this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#liked"] = propValue;
		}
		array = [];
		for (const v of this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["http://joinmastodon.org/ns#featured"] = propValue;
		}
		array = [];
		for (const v of this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["http://joinmastodon.org/ns#featuredTags"] = propValue;
		}
		array = [];
		for (const v of this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#streams"] = propValue;
		}
		array = [];
		for (const v of this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints) {
			const element = await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#endpoints"] = propValue;
		}
		array = [];
		for (const v of this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable) {
			const element = { "@value": v };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["http://joinmastodon.org/ns#discoverable"] = propValue;
		}
		array = [];
		for (const v of this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended) {
			const element = { "@value": v };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["http://joinmastodon.org/ns#suspended"] = propValue;
		}
		array = [];
		for (const v of this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial) {
			const element = { "@value": v };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["http://joinmastodon.org/ns#memorial"] = propValue;
		}
		array = [];
		for (const v of this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable) {
			const element = { "@value": v };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["http://joinmastodon.org/ns#indexable"] = propValue;
		}
		array = [];
		for (const v of this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo) {
			const element = v instanceof URL ? { "@id": v.href } : v instanceof Application ? await v.toJsonLd(options) : v instanceof Group ? await v.toJsonLd(options) : v instanceof Organization ? await v.toJsonLd(options) : v instanceof Person ? await v.toJsonLd(options) : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#movedTo"] = propValue;
		}
		array = [];
		for (const v of this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs) {
			const element = v instanceof URL ? { "@id": v.href } : v instanceof Application ? await v.toJsonLd(options) : v instanceof Group ? await v.toJsonLd(options) : v instanceof Organization ? await v.toJsonLd(options) : v instanceof Person ? await v.toJsonLd(options) : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#alsoKnownAs"] = propValue;
		}
		array = [];
		for (const v of this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/did#service"] = propValue;
		}
		array = [];
		for (const v of this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage) {
			const element = { "@value": v };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://misskey-hub.net/ns#_misskey_followedMessage"] = propValue;
		}
		array = [];
		for (const v of this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat) {
			const element = { "@value": v };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://misskey-hub.net/ns#isCat"] = propValue;
		}
		values["@type"] = ["https://www.w3.org/ns/activitystreams#Application"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? [
			"https://www.w3.org/ns/activitystreams",
			"https://w3id.org/security/v1",
			"https://w3id.org/security/data-integrity/v1",
			"https://www.w3.org/ns/did/v1",
			"https://w3id.org/security/multikey/v1",
			{
				"alsoKnownAs": {
					"@id": "as:alsoKnownAs",
					"@type": "@id"
				},
				"manuallyApprovesFollowers": "as:manuallyApprovesFollowers",
				"movedTo": {
					"@id": "as:movedTo",
					"@type": "@id"
				},
				"toot": "http://joinmastodon.org/ns#",
				"Emoji": "toot:Emoji",
				"featured": {
					"@id": "toot:featured",
					"@type": "@id"
				},
				"featuredTags": {
					"@id": "toot:featuredTags",
					"@type": "@id"
				},
				"discoverable": "toot:discoverable",
				"suspended": "toot:suspended",
				"memorial": "toot:memorial",
				"indexable": "toot:indexable",
				"schema": "http://schema.org#",
				"PropertyValue": "schema:PropertyValue",
				"value": "schema:value",
				"misskey": "https://misskey-hub.net/ns#",
				"_misskey_followedMessage": "misskey:_misskey_followedMessage",
				"isCat": "misskey:isCat"
			}
		];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {
			if ("proof" in compacted && compacted.proof != null) if (Array.isArray(compacted.proof)) for (const element of compacted.proof) element["@context"] = docContext;
			else compacted.proof["@context"] = docContext;
		}
		return compacted;
	}
	isCompactable() {
		if (this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername != null && this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.length > 0) return false;
		if (this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service != null && this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length > 0) return false;
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__Application__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__Application__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Application")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof Application)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		const _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = [];
		let _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array = values["https://www.w3.org/ns/activitystreams#preferredUsername"];
		for (const v of _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array == null ? [] : _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array.length === 1 && "@list" in _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array[0] ? _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array[0]["@list"] : _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array) {
			if (v == null) continue;
			const decoded = typeof v === "object" && "@value" in v && typeof v["@value"] === "string" && !("@language" in v) ? v["@value"] : typeof v === "object" && "@language" in v && "@value" in v && typeof v["@language"] === "string" && typeof v["@value"] === "string" ? new LanguageString(v["@value"], v["@language"]) : void 0;
			if (typeof decoded === "undefined") continue;
			_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.push(decoded);
		}
		instance.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername;
		const _axq166E2eZADq34V4MYUc8KMZdC_publicKey = [];
		const _trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey = /* @__PURE__ */ new Set();
		let _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array = values["https://w3id.org/security#publicKey"];
		for (const v of _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array == null ? [] : _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array.length === 1 && "@list" in _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array[0] ? _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array[0]["@list"] : _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_axq166E2eZADq34V4MYUc8KMZdC_publicKey.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_axq166E2eZADq34V4MYUc8KMZdC_publicKey.push(await CryptographicKey.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey = _axq166E2eZADq34V4MYUc8KMZdC_publicKey;
		const _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = [];
		const _trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = /* @__PURE__ */ new Set();
		let _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array = values["https://w3id.org/security#assertionMethod"];
		for (const v of _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array == null ? [] : _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array.length === 1 && "@list" in _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array[0] ? _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array[0]["@list"] : _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.push(await Multikey.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod;
		const _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = [];
		let _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array = values["https://www.w3.org/ns/activitystreams#manuallyApprovesFollowers"];
		for (const v of _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array == null ? [] : _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array.length === 1 && "@list" in _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array[0] ? _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array[0]["@list"] : _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array) {
			if (v == null) continue;
			_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers.push(v["@value"]);
		}
		instance.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers;
		const _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = [];
		const _trust_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = /* @__PURE__ */ new Set();
		let _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array = values["http://www.w3.org/ns/ldp#inbox"];
		for (const v of _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array == null ? [] : _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array.length === 1 && "@list" in _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array[0] ? _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array[0]["@list"] : _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			const decoded = typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#OrderedCollection") ? await OrderedCollection.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#OrderedCollectionPage") ? await OrderedCollectionPage.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : void 0;
			if (typeof decoded === "undefined") continue;
			_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.push(decoded);
		}
		instance.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox;
		const _41QwhqJouoLg3h8dRPKat21brynC_outbox = [];
		const _trust_41QwhqJouoLg3h8dRPKat21brynC_outbox = /* @__PURE__ */ new Set();
		let _41QwhqJouoLg3h8dRPKat21brynC_outbox__array = values["https://www.w3.org/ns/activitystreams#outbox"];
		for (const v of _41QwhqJouoLg3h8dRPKat21brynC_outbox__array == null ? [] : _41QwhqJouoLg3h8dRPKat21brynC_outbox__array.length === 1 && "@list" in _41QwhqJouoLg3h8dRPKat21brynC_outbox__array[0] ? _41QwhqJouoLg3h8dRPKat21brynC_outbox__array[0]["@list"] : _41QwhqJouoLg3h8dRPKat21brynC_outbox__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_41QwhqJouoLg3h8dRPKat21brynC_outbox.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			const decoded = typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#OrderedCollection") ? await OrderedCollection.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#OrderedCollectionPage") ? await OrderedCollectionPage.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : void 0;
			if (typeof decoded === "undefined") continue;
			_41QwhqJouoLg3h8dRPKat21brynC_outbox.push(decoded);
		}
		instance.#_41QwhqJouoLg3h8dRPKat21brynC_outbox = _41QwhqJouoLg3h8dRPKat21brynC_outbox;
		const _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = [];
		const _trust_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = /* @__PURE__ */ new Set();
		let _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array = values["https://www.w3.org/ns/activitystreams#following"];
		for (const v of _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array == null ? [] : _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array.length === 1 && "@list" in _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array[0] ? _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array[0]["@list"] : _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.push(await Collection.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following;
		const _BBCTgfphhsFzpVfKTykGSpBNwoA_followers = [];
		const _trust_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = /* @__PURE__ */ new Set();
		let _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array = values["https://www.w3.org/ns/activitystreams#followers"];
		for (const v of _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array == null ? [] : _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array.length === 1 && "@list" in _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array[0] ? _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array[0]["@list"] : _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.push(await Collection.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = _BBCTgfphhsFzpVfKTykGSpBNwoA_followers;
		const _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = [];
		const _trust_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = /* @__PURE__ */ new Set();
		let _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array = values["https://www.w3.org/ns/activitystreams#liked"];
		for (const v of _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array == null ? [] : _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array.length === 1 && "@list" in _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array[0] ? _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array[0]["@list"] : _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.push(await Collection.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked;
		const _4N1vBJzXDf8NbBumeECQMFvKetja_featured = [];
		const _trust_4N1vBJzXDf8NbBumeECQMFvKetja_featured = /* @__PURE__ */ new Set();
		let _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array = values["http://joinmastodon.org/ns#featured"];
		for (const v of _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array == null ? [] : _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array.length === 1 && "@list" in _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array[0] ? _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array[0]["@list"] : _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_4N1vBJzXDf8NbBumeECQMFvKetja_featured.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_4N1vBJzXDf8NbBumeECQMFvKetja_featured.push(await Collection.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured = _4N1vBJzXDf8NbBumeECQMFvKetja_featured;
		const _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = [];
		const _trust_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = /* @__PURE__ */ new Set();
		let _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array = values["http://joinmastodon.org/ns#featuredTags"];
		for (const v of _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array == null ? [] : _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array.length === 1 && "@list" in _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array[0] ? _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array[0]["@list"] : _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.push(await Collection.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags;
		const _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = [];
		const _trust_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = /* @__PURE__ */ new Set();
		let _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array = values["https://www.w3.org/ns/activitystreams#streams"];
		for (const v of _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array == null ? [] : _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array.length === 1 && "@list" in _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array[0] ? _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array[0]["@list"] : _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.push(await Collection.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams;
		const _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = [];
		let _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array = values["https://www.w3.org/ns/activitystreams#endpoints"];
		for (const v of _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array == null ? [] : _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array.length === 1 && "@list" in _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array[0] ? _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array[0]["@list"] : _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array) {
			if (v == null) continue;
			_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints.push(await Endpoints.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints;
		const _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = [];
		let _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array = values["http://joinmastodon.org/ns#discoverable"];
		for (const v of _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array == null ? [] : _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array.length === 1 && "@list" in _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array[0] ? _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array[0]["@list"] : _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array) {
			if (v == null) continue;
			_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable.push(v["@value"]);
		}
		instance.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable;
		const _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = [];
		let _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array = values["http://joinmastodon.org/ns#suspended"];
		for (const v of _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array == null ? [] : _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array.length === 1 && "@list" in _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array[0] ? _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array[0]["@list"] : _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array) {
			if (v == null) continue;
			_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended.push(v["@value"]);
		}
		instance.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended;
		const _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = [];
		let _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array = values["http://joinmastodon.org/ns#memorial"];
		for (const v of _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array == null ? [] : _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array.length === 1 && "@list" in _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array[0] ? _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array[0]["@list"] : _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array) {
			if (v == null) continue;
			_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial.push(v["@value"]);
		}
		instance.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial;
		const _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = [];
		let _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array = values["http://joinmastodon.org/ns#indexable"];
		for (const v of _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array == null ? [] : _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array.length === 1 && "@list" in _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array[0] ? _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array[0]["@list"] : _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array) {
			if (v == null) continue;
			_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable.push(v["@value"]);
		}
		instance.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable;
		const _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = [];
		const _trust_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = /* @__PURE__ */ new Set();
		let _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array = values["https://www.w3.org/ns/activitystreams#movedTo"];
		for (const v of _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array == null ? [] : _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array.length === 1 && "@list" in _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array[0] ? _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array[0]["@list"] : _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			const decoded = typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Application") ? await Application.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Group") ? await Group.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Organization") ? await Organization.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Person") ? await Person.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Service") ? await Service.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : void 0;
			if (typeof decoded === "undefined") continue;
			_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.push(decoded);
		}
		instance.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo;
		const _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = [];
		const _trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = /* @__PURE__ */ new Set();
		let _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array = values["https://www.w3.org/ns/activitystreams#alsoKnownAs"];
		for (const v of _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array == null ? [] : _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array.length === 1 && "@list" in _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array[0] ? _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array[0]["@list"] : _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			const decoded = typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Application") ? await Application.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Group") ? await Group.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Organization") ? await Organization.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Person") ? await Person.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Service") ? await Service.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : void 0;
			if (typeof decoded === "undefined") continue;
			_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.push(decoded);
		}
		instance.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs;
		const _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = [];
		const _trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = /* @__PURE__ */ new Set();
		let _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array = values["https://www.w3.org/ns/did#service"];
		for (const v of _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array == null ? [] : _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array.length === 1 && "@list" in _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array[0] ? _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array[0]["@list"] : _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.push(await DidService.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service;
		const _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = [];
		let _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array = values["https://misskey-hub.net/ns#_misskey_followedMessage"];
		for (const v of _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array == null ? [] : _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array.length === 1 && "@list" in _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array[0] ? _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array[0]["@list"] : _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array) {
			if (v == null) continue;
			_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage.push(v["@value"]);
		}
		instance.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage;
		const _2xEU4QtkC53RAun67T81Egqt9vmL_isCat = [];
		let _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array = values["https://misskey-hub.net/ns#isCat"];
		for (const v of _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array == null ? [] : _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array.length === 1 && "@list" in _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array[0] ? _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array[0]["@list"] : _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array) {
			if (v == null) continue;
			_2xEU4QtkC53RAun67T81Egqt9vmL_isCat.push(v["@value"]);
		}
		instance.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat = _2xEU4QtkC53RAun67T81Egqt9vmL_isCat;
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		const _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.length == 1) proxy.preferredUsername = _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername[0];
		if (_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.length > 1 || !("preferredUsername" in proxy) && _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.length > 0) proxy.preferredUsernames = _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername;
		const _axq166E2eZADq34V4MYUc8KMZdC_publicKey = this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_axq166E2eZADq34V4MYUc8KMZdC_publicKey.length == 1) proxy.publicKey = _axq166E2eZADq34V4MYUc8KMZdC_publicKey[0];
		if (_axq166E2eZADq34V4MYUc8KMZdC_publicKey.length > 1 || !("publicKey" in proxy) && _axq166E2eZADq34V4MYUc8KMZdC_publicKey.length > 0) proxy.publicKeys = _axq166E2eZADq34V4MYUc8KMZdC_publicKey;
		const _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.length == 1) proxy.assertionMethod = _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod[0];
		if (_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.length > 1 || !("assertionMethod" in proxy) && _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.length > 0) proxy.assertionMethods = _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod;
		const _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers.length == 1) proxy.manuallyApprovesFollowers = _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers[0];
		const _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.length == 1) proxy.inbox = _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox[0];
		const _41QwhqJouoLg3h8dRPKat21brynC_outbox = this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_41QwhqJouoLg3h8dRPKat21brynC_outbox.length == 1) proxy.outbox = _41QwhqJouoLg3h8dRPKat21brynC_outbox[0];
		const _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.length == 1) proxy.following = _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following[0];
		const _BBCTgfphhsFzpVfKTykGSpBNwoA_followers = this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.length == 1) proxy.followers = _BBCTgfphhsFzpVfKTykGSpBNwoA_followers[0];
		const _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.length == 1) proxy.liked = _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked[0];
		const _4N1vBJzXDf8NbBumeECQMFvKetja_featured = this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_4N1vBJzXDf8NbBumeECQMFvKetja_featured.length == 1) proxy.featured = _4N1vBJzXDf8NbBumeECQMFvKetja_featured[0];
		const _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.length == 1) proxy.featuredTags = _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags[0];
		const _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.length > 1 || !("stream" in proxy) && _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.length > 0) proxy.streams = _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams;
		const _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints.length == 1) proxy.endpoints = _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints[0];
		const _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable.length == 1) proxy.discoverable = _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable[0];
		const _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended.length == 1) proxy.suspended = _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended[0];
		const _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial.length == 1) proxy.memorial = _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial[0];
		const _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable.length == 1) proxy.indexable = _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable[0];
		const _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.length == 1) proxy.successor = _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo[0];
		const _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.length == 1) proxy.alias = _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs[0];
		if (_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.length > 1 || !("alias" in proxy) && _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.length > 0) proxy.aliases = _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs;
		const _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length == 1) proxy.service = _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service[0];
		if (_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length > 1 || !("service" in proxy) && _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length > 0) proxy.services = _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service;
		const _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage.length == 1) proxy.followedMessage = _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage[0];
		const _2xEU4QtkC53RAun67T81Egqt9vmL_isCat = this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_2xEU4QtkC53RAun67T81Egqt9vmL_isCat.length == 1) proxy.cat = _2xEU4QtkC53RAun67T81Egqt9vmL_isCat[0];
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "Application " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "Application " + inspect(proxy, options);
	}
};
/** Instances of `IntransitiveActivity` are a subtype of {@link Activity}
* representing intransitive actions.  The `object` property is therefore
* inappropriate for these activities.
*/
var IntransitiveActivity = class IntransitiveActivity extends Activity {
	/**
	* The type URI of {@link IntransitiveActivity}: `https://www.w3.org/ns/activitystreams#IntransitiveActivity`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#IntransitiveActivity");
	}
	/**
	* Constructs a new instance of IntransitiveActivity with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		return clone;
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		values["@type"] = ["https://www.w3.org/ns/activitystreams#IntransitiveActivity"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? [
			"https://w3id.org/identity/v1",
			"https://www.w3.org/ns/activitystreams",
			"https://w3id.org/security/data-integrity/v1"
		];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {
			if ("proof" in compacted && compacted.proof != null) if (Array.isArray(compacted.proof)) for (const element of compacted.proof) element["@context"] = docContext;
			else compacted.proof["@context"] = docContext;
		}
		return compacted;
	}
	isCompactable() {
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__IntransitiveActivity__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__IntransitiveActivity__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Arrive")) return await Arrive.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Question")) return await Question.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Travel")) return await Travel.fromJsonLd(json, options);
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#IntransitiveActivity")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof IntransitiveActivity)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "IntransitiveActivity " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "IntransitiveActivity " + inspect(proxy, options);
	}
};
/** An `IntransitiveActivity` that indicates that the `actor` has arrived at the `location`.
* The `origin` can be used to identify the context from which the `actor` originated.
* The `target` typically has no defined meaning.
*/
var Arrive = class Arrive extends IntransitiveActivity {
	/**
	* The type URI of {@link Arrive}: `https://www.w3.org/ns/activitystreams#Arrive`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#Arrive");
	}
	/**
	* Constructs a new instance of Arrive with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		return clone;
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		values["@type"] = ["https://www.w3.org/ns/activitystreams#Arrive"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? [
			"https://w3id.org/identity/v1",
			"https://www.w3.org/ns/activitystreams",
			"https://w3id.org/security/data-integrity/v1"
		];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {
			if ("proof" in compacted && compacted.proof != null) if (Array.isArray(compacted.proof)) for (const element of compacted.proof) element["@context"] = docContext;
			else compacted.proof["@context"] = docContext;
		}
		return compacted;
	}
	isCompactable() {
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__Arrive__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__Arrive__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Arrive")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof Arrive)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "Arrive " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "Arrive " + inspect(proxy, options);
	}
};
/** Represents any kind of multi-paragraph written work.
*/
var Article = class Article extends Object$1 {
	/**
	* The type URI of {@link Article}: `https://www.w3.org/ns/activitystreams#Article`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#Article");
	}
	#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl = [];
	/**
	* Constructs a new instance of Article with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
		if ("quoteUrl" in values && values.quoteUrl != null) if (values.quoteUrl instanceof URL) this.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl = [values.quoteUrl];
		else throw new TypeError("The quoteUrl must be of type URL.");
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		clone.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl = this.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl;
		if ("quoteUrl" in values && values.quoteUrl != null) if (values.quoteUrl instanceof URL) clone.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl = [values.quoteUrl];
		else throw new TypeError("The quoteUrl must be of type URL.");
		return clone;
	}
	/** The URI of the ActivityStreams object that this object quotes.
	*
	* This property sets three JSON-LD properties at once under the hood:
	*
	* 1. https://www.w3.org/ns/activitystreams#quoteUrl
	* 2. https://misskey-hub.net/ns#_misskey_quote
	* 3. http://fedibird.com/ns#quoteUri
	*
	* When a JSON-LD object is parsed, this property is filled with one of
	* the values of those three properties in order.
	*/
	get quoteUrl() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl.length < 1) return null;
		return this.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl[0];
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		if (options.format == null && this.isCompactable()) {
			const result = await super.toJsonLd({
				...options,
				format: void 0,
				context: void 0
			});
			let compactItems;
			compactItems = [];
			for (const v of this.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl) {
				const item = v.href;
				compactItems.push(item);
			}
			if (compactItems.length > 0) {
				result["quoteUrl"] = compactItems.length > 1 ? compactItems : compactItems[0];
				result["_misskey_quote"] = compactItems.length > 1 ? compactItems : compactItems[0];
				result["quoteUri"] = compactItems.length > 1 ? compactItems : compactItems[0];
			}
			result["type"] = "Article";
			if (this.id != null) result["id"] = this.id.href;
			result["@context"] = [
				"https://www.w3.org/ns/activitystreams",
				"https://w3id.org/security/data-integrity/v1",
				{
					"toot": "http://joinmastodon.org/ns#",
					"misskey": "https://misskey-hub.net/ns#",
					"fedibird": "http://fedibird.com/ns#",
					"sensitive": "as:sensitive",
					"Emoji": "toot:Emoji",
					"Hashtag": "as:Hashtag",
					"quoteUrl": "as:quoteUrl",
					"_misskey_quote": "misskey:_misskey_quote",
					"quoteUri": "fedibird:quoteUri",
					"emojiReactions": {
						"@id": "fedibird:emojiReactions",
						"@type": "@id"
					}
				}
			];
			return result;
		}
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		array = [];
		for (const v of this.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl) {
			const element = { "@value": v.href };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#quoteUrl"] = propValue;
			values["https://misskey-hub.net/ns#_misskey_quote"] = propValue;
			values["http://fedibird.com/ns#quoteUri"] = propValue;
		}
		values["@type"] = ["https://www.w3.org/ns/activitystreams#Article"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? [
			"https://www.w3.org/ns/activitystreams",
			"https://w3id.org/security/data-integrity/v1",
			{
				"toot": "http://joinmastodon.org/ns#",
				"misskey": "https://misskey-hub.net/ns#",
				"fedibird": "http://fedibird.com/ns#",
				"sensitive": "as:sensitive",
				"Emoji": "toot:Emoji",
				"Hashtag": "as:Hashtag",
				"quoteUrl": "as:quoteUrl",
				"_misskey_quote": "misskey:_misskey_quote",
				"quoteUri": "fedibird:quoteUri",
				"emojiReactions": {
					"@id": "fedibird:emojiReactions",
					"@type": "@id"
				}
			}
		];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {
			if ("proof" in compacted && compacted.proof != null) if (Array.isArray(compacted.proof)) for (const element of compacted.proof) element["@context"] = docContext;
			else compacted.proof["@context"] = docContext;
		}
		return compacted;
	}
	isCompactable() {
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__Article__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__Article__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Article")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof Article)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		const _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl = [];
		let _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array = values["https://www.w3.org/ns/activitystreams#quoteUrl"];
		if (_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array == null || _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array.length < 1) _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array = values["https://misskey-hub.net/ns#_misskey_quote"];
		if (_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array == null || _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array.length < 1) _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array = values["http://fedibird.com/ns#quoteUri"];
		for (const v of _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array == null ? [] : _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array.length === 1 && "@list" in _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array[0] ? _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array[0]["@list"] : _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array) {
			if (v == null) continue;
			_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl.push(new URL(v["@value"]));
		}
		instance.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl = _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl;
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		const _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl = this.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl.length == 1) proxy.quoteUrl = _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl[0];
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "Article " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "Article " + inspect(proxy, options);
	}
};
/** Represents a document of any kind.
*/
var Document = class Document extends Object$1 {
	/**
	* The type URI of {@link Document}: `https://www.w3.org/ns/activitystreams#Document`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#Document");
	}
	#_2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width = [];
	#_2cGKFeFJMmiNpGZFEF75mCwFQsKb_height = [];
	/**
	* Constructs a new instance of Document with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
		if ("width" in values && values.width != null) if (typeof values.width === "number" && Number.isInteger(values.width) && values.width >= 0) this.#_2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width = [values.width];
		else throw new TypeError("The width must be of type number.");
		if ("height" in values && values.height != null) if (typeof values.height === "number" && Number.isInteger(values.height) && values.height >= 0) this.#_2cGKFeFJMmiNpGZFEF75mCwFQsKb_height = [values.height];
		else throw new TypeError("The height must be of type number.");
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		clone.#_2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width = this.#_2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width;
		if ("width" in values && values.width != null) if (typeof values.width === "number" && Number.isInteger(values.width) && values.width >= 0) clone.#_2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width = [values.width];
		else throw new TypeError("The width must be of type number.");
		clone.#_2cGKFeFJMmiNpGZFEF75mCwFQsKb_height = this.#_2cGKFeFJMmiNpGZFEF75mCwFQsKb_height;
		if ("height" in values && values.height != null) if (typeof values.height === "number" && Number.isInteger(values.height) && values.height >= 0) clone.#_2cGKFeFJMmiNpGZFEF75mCwFQsKb_height = [values.height];
		else throw new TypeError("The height must be of type number.");
		return clone;
	}
	/** Specifies a hint as to the rendering width in
	* device-independent pixels of the linked resource.
	*/
	get width() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width.length < 1) return null;
		return this.#_2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width[0];
	}
	/** Specifies a hint as to the rendering height in
	* device-independent pixels of the linked resource.
	*/
	get height() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2cGKFeFJMmiNpGZFEF75mCwFQsKb_height.length < 1) return null;
		return this.#_2cGKFeFJMmiNpGZFEF75mCwFQsKb_height[0];
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		if (options.format == null && this.isCompactable()) {
			const result = await super.toJsonLd({
				...options,
				format: void 0,
				context: void 0
			});
			let compactItems;
			compactItems = [];
			for (const v of this.#_2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width) {
				const item = v;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["width"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_2cGKFeFJMmiNpGZFEF75mCwFQsKb_height) {
				const item = v;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["height"] = compactItems.length > 1 ? compactItems : compactItems[0];
			result["type"] = "Document";
			if (this.id != null) result["id"] = this.id.href;
			result["@context"] = ["https://www.w3.org/ns/activitystreams", "https://w3id.org/security/data-integrity/v1"];
			return result;
		}
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		array = [];
		for (const v of this.#_2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width) {
			const element = {
				"@type": "http://www.w3.org/2001/XMLSchema#nonNegativeInteger",
				"@value": v
			};
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#width"] = propValue;
		}
		array = [];
		for (const v of this.#_2cGKFeFJMmiNpGZFEF75mCwFQsKb_height) {
			const element = {
				"@type": "http://www.w3.org/2001/XMLSchema#nonNegativeInteger",
				"@value": v
			};
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#height"] = propValue;
		}
		values["@type"] = ["https://www.w3.org/ns/activitystreams#Document"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? ["https://www.w3.org/ns/activitystreams", "https://w3id.org/security/data-integrity/v1"];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {
			if ("proof" in compacted && compacted.proof != null) if (Array.isArray(compacted.proof)) for (const element of compacted.proof) element["@context"] = docContext;
			else compacted.proof["@context"] = docContext;
		}
		return compacted;
	}
	isCompactable() {
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__Document__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__Document__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Audio")) return await Audio.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Image")) return await Image.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Page")) return await Page.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Video")) return await Video.fromJsonLd(json, options);
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Document")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof Document)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		const _2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width = [];
		let _2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width__array = values["https://www.w3.org/ns/activitystreams#width"];
		for (const v of _2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width__array == null ? [] : _2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width__array.length === 1 && "@list" in _2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width__array[0] ? _2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width__array[0]["@list"] : _2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width__array) {
			if (v == null) continue;
			_2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width.push(v["@value"]);
		}
		instance.#_2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width = _2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width;
		const _2cGKFeFJMmiNpGZFEF75mCwFQsKb_height = [];
		let _2cGKFeFJMmiNpGZFEF75mCwFQsKb_height__array = values["https://www.w3.org/ns/activitystreams#height"];
		for (const v of _2cGKFeFJMmiNpGZFEF75mCwFQsKb_height__array == null ? [] : _2cGKFeFJMmiNpGZFEF75mCwFQsKb_height__array.length === 1 && "@list" in _2cGKFeFJMmiNpGZFEF75mCwFQsKb_height__array[0] ? _2cGKFeFJMmiNpGZFEF75mCwFQsKb_height__array[0]["@list"] : _2cGKFeFJMmiNpGZFEF75mCwFQsKb_height__array) {
			if (v == null) continue;
			_2cGKFeFJMmiNpGZFEF75mCwFQsKb_height.push(v["@value"]);
		}
		instance.#_2cGKFeFJMmiNpGZFEF75mCwFQsKb_height = _2cGKFeFJMmiNpGZFEF75mCwFQsKb_height;
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		const _2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width = this.#_2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width.length == 1) proxy.width = _2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width[0];
		const _2cGKFeFJMmiNpGZFEF75mCwFQsKb_height = this.#_2cGKFeFJMmiNpGZFEF75mCwFQsKb_height.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_2cGKFeFJMmiNpGZFEF75mCwFQsKb_height.length == 1) proxy.height = _2cGKFeFJMmiNpGZFEF75mCwFQsKb_height[0];
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "Document " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "Document " + inspect(proxy, options);
	}
};
/** Represents an audio document of any kind.
*/
var Audio = class Audio extends Document {
	/**
	* The type URI of {@link Audio}: `https://www.w3.org/ns/activitystreams#Audio`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#Audio");
	}
	/**
	* Constructs a new instance of Audio with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		return clone;
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		if (options.format == null && this.isCompactable()) {
			const result = await super.toJsonLd({
				...options,
				format: void 0,
				context: void 0
			});
			let compactItems;
			result["type"] = "Audio";
			if (this.id != null) result["id"] = this.id.href;
			result["@context"] = ["https://www.w3.org/ns/activitystreams", "https://w3id.org/security/data-integrity/v1"];
			return result;
		}
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		values["@type"] = ["https://www.w3.org/ns/activitystreams#Audio"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? ["https://www.w3.org/ns/activitystreams", "https://w3id.org/security/data-integrity/v1"];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {
			if ("proof" in compacted && compacted.proof != null) if (Array.isArray(compacted.proof)) for (const element of compacted.proof) element["@context"] = docContext;
			else compacted.proof["@context"] = docContext;
		}
		return compacted;
	}
	isCompactable() {
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__Audio__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__Audio__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Audio")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof Audio)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "Audio " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "Audio " + inspect(proxy, options);
	}
};
/** Indicates that the `actor` is ignoring the `object`.  The `target` and
* `origin` typically have no defined meaning.
*/
var Ignore = class Ignore extends Activity {
	/**
	* The type URI of {@link Ignore}: `https://www.w3.org/ns/activitystreams#Ignore`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#Ignore");
	}
	/**
	* Constructs a new instance of Ignore with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		return clone;
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		values["@type"] = ["https://www.w3.org/ns/activitystreams#Ignore"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? [
			"https://w3id.org/identity/v1",
			"https://www.w3.org/ns/activitystreams",
			"https://w3id.org/security/data-integrity/v1"
		];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {
			if ("proof" in compacted && compacted.proof != null) if (Array.isArray(compacted.proof)) for (const element of compacted.proof) element["@context"] = docContext;
			else compacted.proof["@context"] = docContext;
		}
		return compacted;
	}
	isCompactable() {
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__Ignore__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__Ignore__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Block")) return await Block.fromJsonLd(json, options);
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Ignore")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof Ignore)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "Ignore " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "Ignore " + inspect(proxy, options);
	}
};
/** Indicates that the `actor` is blocking the `object`.  Blocking is a stronger
* form of {@link Ignore}.  The typical use is to support social systems that
* allow one user to block activities or content of other users.  The `target`
* and `origin` typically have no defined meaning.
*/
var Block = class Block extends Ignore {
	/**
	* The type URI of {@link Block}: `https://www.w3.org/ns/activitystreams#Block`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#Block");
	}
	/**
	* Constructs a new instance of Block with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		return clone;
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		values["@type"] = ["https://www.w3.org/ns/activitystreams#Block"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? [
			"https://w3id.org/identity/v1",
			"https://www.w3.org/ns/activitystreams",
			"https://w3id.org/security/data-integrity/v1"
		];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {
			if ("proof" in compacted && compacted.proof != null) if (Array.isArray(compacted.proof)) for (const element of compacted.proof) element["@context"] = docContext;
			else compacted.proof["@context"] = docContext;
		}
		return compacted;
	}
	isCompactable() {
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__Block__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__Block__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Block")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof Block)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "Block " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "Block " + inspect(proxy, options);
	}
};
/** A `Collection` is a subtype of {@link Object} that represents ordered or
* unordered sets of {@link Object} or {@link Link} instances.
*
* Refer to the Activity Streams 2.0 Core specification for a complete
* description of the Collection type.
*/
var Collection = class Collection extends Object$1 {
	/**
	* The type URI of {@link Collection}: `https://www.w3.org/ns/activitystreams#Collection`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#Collection");
	}
	#_XDbmNDuWHmrhqH712zqtecdbv1V_totalItems = [];
	#_3UyUdxnyn6cDn53QKrh4MBiearma_current = [];
	#_trust_3UyUdxnyn6cDn53QKrh4MBiearma_current = /* @__PURE__ */ new Set();
	#_J52RqweMe6hhv7RnLJMC8BExTE5_first = [];
	#_trust_J52RqweMe6hhv7RnLJMC8BExTE5_first = /* @__PURE__ */ new Set();
	#_gyJJnyEFnuNVi1HFZKfAn3Hfn26_last = [];
	#_trust_gyJJnyEFnuNVi1HFZKfAn3Hfn26_last = /* @__PURE__ */ new Set();
	#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items = [];
	#_trust_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items = /* @__PURE__ */ new Set();
	#_4TB9Qd9ddtcZEpMfzbHhzafE6jaJ_likesOf = [];
	#_trust_4TB9Qd9ddtcZEpMfzbHhzafE6jaJ_likesOf = /* @__PURE__ */ new Set();
	#_3manzgeKiPsugpztKGiaUUwJ3ito_sharesOf = [];
	#_trust_3manzgeKiPsugpztKGiaUUwJ3ito_sharesOf = /* @__PURE__ */ new Set();
	#_3T3oGm3twpcQUcrnMisXQtmDZ32X_repliesOf = [];
	#_trust_3T3oGm3twpcQUcrnMisXQtmDZ32X_repliesOf = /* @__PURE__ */ new Set();
	#_2bvRkAFZjMfVD8jiUWZJr5YokSeN_inboxOf = [];
	#_trust_2bvRkAFZjMfVD8jiUWZJr5YokSeN_inboxOf = /* @__PURE__ */ new Set();
	#_4AHzVZDxHjK6uEWa9UiKHGK34yYm_outboxOf = [];
	#_trust_4AHzVZDxHjK6uEWa9UiKHGK34yYm_outboxOf = /* @__PURE__ */ new Set();
	#_41aoZ5M6yRUHy3Zx8q6iuZQxtopb_followersOf = [];
	#_trust_41aoZ5M6yRUHy3Zx8q6iuZQxtopb_followersOf = /* @__PURE__ */ new Set();
	#_2nXT2Ah42UjEEQF5oJQ39CbKB1xj_followingOf = [];
	#_trust_2nXT2Ah42UjEEQF5oJQ39CbKB1xj_followingOf = /* @__PURE__ */ new Set();
	#_2bsySzmT3qEZcrnoe3tZ5xBjXSju_likedOf = [];
	#_trust_2bsySzmT3qEZcrnoe3tZ5xBjXSju_likedOf = /* @__PURE__ */ new Set();
	/**
	* Constructs a new instance of Collection with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
		if ("totalItems" in values && values.totalItems != null) if (typeof values.totalItems === "number" && Number.isInteger(values.totalItems) && values.totalItems >= 0) this.#_XDbmNDuWHmrhqH712zqtecdbv1V_totalItems = [values.totalItems];
		else throw new TypeError("The totalItems must be of type number.");
		if ("current" in values && values.current != null) if (values.current instanceof CollectionPage || values.current instanceof URL) {
			this.#_3UyUdxnyn6cDn53QKrh4MBiearma_current = [values.current];
			this.#_trust_3UyUdxnyn6cDn53QKrh4MBiearma_current.add(0);
		} else throw new TypeError("The current must be of type CollectionPage | URL.");
		if ("first" in values && values.first != null) if (values.first instanceof CollectionPage || values.first instanceof URL) {
			this.#_J52RqweMe6hhv7RnLJMC8BExTE5_first = [values.first];
			this.#_trust_J52RqweMe6hhv7RnLJMC8BExTE5_first.add(0);
		} else throw new TypeError("The first must be of type CollectionPage | URL.");
		if ("last" in values && values.last != null) if (values.last instanceof CollectionPage || values.last instanceof URL) {
			this.#_gyJJnyEFnuNVi1HFZKfAn3Hfn26_last = [values.last];
			this.#_trust_gyJJnyEFnuNVi1HFZKfAn3Hfn26_last.add(0);
		} else throw new TypeError("The last must be of type CollectionPage | URL.");
		if ("items" in values && values.items != null) if (Array.isArray(values.items) && values.items.every((v) => v instanceof Object$1 || v instanceof Link || v instanceof URL)) {
			this.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items = values.items;
			for (let i = 0; i < values.items.length; i++) this.#_trust_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items.add(i);
		} else throw new TypeError("The items must be an array of type Object | Link | URL.");
		if ("likesOf" in values && values.likesOf != null) if (values.likesOf instanceof Object$1 || values.likesOf instanceof URL) {
			this.#_4TB9Qd9ddtcZEpMfzbHhzafE6jaJ_likesOf = [values.likesOf];
			this.#_trust_4TB9Qd9ddtcZEpMfzbHhzafE6jaJ_likesOf.add(0);
		} else throw new TypeError("The likesOf must be of type Object | URL.");
		if ("sharesOf" in values && values.sharesOf != null) if (values.sharesOf instanceof Object$1 || values.sharesOf instanceof URL) {
			this.#_3manzgeKiPsugpztKGiaUUwJ3ito_sharesOf = [values.sharesOf];
			this.#_trust_3manzgeKiPsugpztKGiaUUwJ3ito_sharesOf.add(0);
		} else throw new TypeError("The sharesOf must be of type Object | URL.");
		if ("repliesOf" in values && values.repliesOf != null) if (values.repliesOf instanceof Object$1 || values.repliesOf instanceof URL) {
			this.#_3T3oGm3twpcQUcrnMisXQtmDZ32X_repliesOf = [values.repliesOf];
			this.#_trust_3T3oGm3twpcQUcrnMisXQtmDZ32X_repliesOf.add(0);
		} else throw new TypeError("The repliesOf must be of type Object | URL.");
		if ("inboxOf" in values && values.inboxOf != null) if (values.inboxOf instanceof Object$1 || values.inboxOf instanceof URL) {
			this.#_2bvRkAFZjMfVD8jiUWZJr5YokSeN_inboxOf = [values.inboxOf];
			this.#_trust_2bvRkAFZjMfVD8jiUWZJr5YokSeN_inboxOf.add(0);
		} else throw new TypeError("The inboxOf must be of type Object | URL.");
		if ("outboxOf" in values && values.outboxOf != null) if (values.outboxOf instanceof Object$1 || values.outboxOf instanceof URL) {
			this.#_4AHzVZDxHjK6uEWa9UiKHGK34yYm_outboxOf = [values.outboxOf];
			this.#_trust_4AHzVZDxHjK6uEWa9UiKHGK34yYm_outboxOf.add(0);
		} else throw new TypeError("The outboxOf must be of type Object | URL.");
		if ("followersOf" in values && values.followersOf != null) if (values.followersOf instanceof Object$1 || values.followersOf instanceof URL) {
			this.#_41aoZ5M6yRUHy3Zx8q6iuZQxtopb_followersOf = [values.followersOf];
			this.#_trust_41aoZ5M6yRUHy3Zx8q6iuZQxtopb_followersOf.add(0);
		} else throw new TypeError("The followersOf must be of type Object | URL.");
		if ("followingOf" in values && values.followingOf != null) if (values.followingOf instanceof Object$1 || values.followingOf instanceof URL) {
			this.#_2nXT2Ah42UjEEQF5oJQ39CbKB1xj_followingOf = [values.followingOf];
			this.#_trust_2nXT2Ah42UjEEQF5oJQ39CbKB1xj_followingOf.add(0);
		} else throw new TypeError("The followingOf must be of type Object | URL.");
		if ("likedOf" in values && values.likedOf != null) if (values.likedOf instanceof Object$1 || values.likedOf instanceof URL) {
			this.#_2bsySzmT3qEZcrnoe3tZ5xBjXSju_likedOf = [values.likedOf];
			this.#_trust_2bsySzmT3qEZcrnoe3tZ5xBjXSju_likedOf.add(0);
		} else throw new TypeError("The likedOf must be of type Object | URL.");
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		clone.#_XDbmNDuWHmrhqH712zqtecdbv1V_totalItems = this.#_XDbmNDuWHmrhqH712zqtecdbv1V_totalItems;
		if ("totalItems" in values && values.totalItems != null) if (typeof values.totalItems === "number" && Number.isInteger(values.totalItems) && values.totalItems >= 0) clone.#_XDbmNDuWHmrhqH712zqtecdbv1V_totalItems = [values.totalItems];
		else throw new TypeError("The totalItems must be of type number.");
		clone.#_3UyUdxnyn6cDn53QKrh4MBiearma_current = this.#_3UyUdxnyn6cDn53QKrh4MBiearma_current;
		clone.#_trust_3UyUdxnyn6cDn53QKrh4MBiearma_current = new Set(this.#_trust_3UyUdxnyn6cDn53QKrh4MBiearma_current);
		if ("current" in values && values.current != null) if (values.current instanceof CollectionPage || values.current instanceof URL) {
			clone.#_3UyUdxnyn6cDn53QKrh4MBiearma_current = [values.current];
			clone.#_trust_3UyUdxnyn6cDn53QKrh4MBiearma_current = new Set([0]);
		} else throw new TypeError("The current must be of type CollectionPage | URL.");
		clone.#_J52RqweMe6hhv7RnLJMC8BExTE5_first = this.#_J52RqweMe6hhv7RnLJMC8BExTE5_first;
		clone.#_trust_J52RqweMe6hhv7RnLJMC8BExTE5_first = new Set(this.#_trust_J52RqweMe6hhv7RnLJMC8BExTE5_first);
		if ("first" in values && values.first != null) if (values.first instanceof CollectionPage || values.first instanceof URL) {
			clone.#_J52RqweMe6hhv7RnLJMC8BExTE5_first = [values.first];
			clone.#_trust_J52RqweMe6hhv7RnLJMC8BExTE5_first = new Set([0]);
		} else throw new TypeError("The first must be of type CollectionPage | URL.");
		clone.#_gyJJnyEFnuNVi1HFZKfAn3Hfn26_last = this.#_gyJJnyEFnuNVi1HFZKfAn3Hfn26_last;
		clone.#_trust_gyJJnyEFnuNVi1HFZKfAn3Hfn26_last = new Set(this.#_trust_gyJJnyEFnuNVi1HFZKfAn3Hfn26_last);
		if ("last" in values && values.last != null) if (values.last instanceof CollectionPage || values.last instanceof URL) {
			clone.#_gyJJnyEFnuNVi1HFZKfAn3Hfn26_last = [values.last];
			clone.#_trust_gyJJnyEFnuNVi1HFZKfAn3Hfn26_last = new Set([0]);
		} else throw new TypeError("The last must be of type CollectionPage | URL.");
		clone.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items = this.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items;
		clone.#_trust_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items = new Set(this.#_trust_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items);
		if ("items" in values && values.items != null) if (Array.isArray(values.items) && values.items.every((v) => v instanceof Object$1 || v instanceof Link || v instanceof URL)) {
			clone.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items = values.items;
			clone.#_trust_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items = /* @__PURE__ */ new Set();
			for (let i = 0; i < values.items.length; i++) clone.#_trust_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items.add(i);
		} else throw new TypeError("The items must be an array of type Object | Link | URL.");
		clone.#_4TB9Qd9ddtcZEpMfzbHhzafE6jaJ_likesOf = this.#_4TB9Qd9ddtcZEpMfzbHhzafE6jaJ_likesOf;
		clone.#_trust_4TB9Qd9ddtcZEpMfzbHhzafE6jaJ_likesOf = new Set(this.#_trust_4TB9Qd9ddtcZEpMfzbHhzafE6jaJ_likesOf);
		if ("likesOf" in values && values.likesOf != null) if (values.likesOf instanceof Object$1 || values.likesOf instanceof URL) {
			clone.#_4TB9Qd9ddtcZEpMfzbHhzafE6jaJ_likesOf = [values.likesOf];
			clone.#_trust_4TB9Qd9ddtcZEpMfzbHhzafE6jaJ_likesOf = new Set([0]);
		} else throw new TypeError("The likesOf must be of type Object | URL.");
		clone.#_3manzgeKiPsugpztKGiaUUwJ3ito_sharesOf = this.#_3manzgeKiPsugpztKGiaUUwJ3ito_sharesOf;
		clone.#_trust_3manzgeKiPsugpztKGiaUUwJ3ito_sharesOf = new Set(this.#_trust_3manzgeKiPsugpztKGiaUUwJ3ito_sharesOf);
		if ("sharesOf" in values && values.sharesOf != null) if (values.sharesOf instanceof Object$1 || values.sharesOf instanceof URL) {
			clone.#_3manzgeKiPsugpztKGiaUUwJ3ito_sharesOf = [values.sharesOf];
			clone.#_trust_3manzgeKiPsugpztKGiaUUwJ3ito_sharesOf = new Set([0]);
		} else throw new TypeError("The sharesOf must be of type Object | URL.");
		clone.#_3T3oGm3twpcQUcrnMisXQtmDZ32X_repliesOf = this.#_3T3oGm3twpcQUcrnMisXQtmDZ32X_repliesOf;
		clone.#_trust_3T3oGm3twpcQUcrnMisXQtmDZ32X_repliesOf = new Set(this.#_trust_3T3oGm3twpcQUcrnMisXQtmDZ32X_repliesOf);
		if ("repliesOf" in values && values.repliesOf != null) if (values.repliesOf instanceof Object$1 || values.repliesOf instanceof URL) {
			clone.#_3T3oGm3twpcQUcrnMisXQtmDZ32X_repliesOf = [values.repliesOf];
			clone.#_trust_3T3oGm3twpcQUcrnMisXQtmDZ32X_repliesOf = new Set([0]);
		} else throw new TypeError("The repliesOf must be of type Object | URL.");
		clone.#_2bvRkAFZjMfVD8jiUWZJr5YokSeN_inboxOf = this.#_2bvRkAFZjMfVD8jiUWZJr5YokSeN_inboxOf;
		clone.#_trust_2bvRkAFZjMfVD8jiUWZJr5YokSeN_inboxOf = new Set(this.#_trust_2bvRkAFZjMfVD8jiUWZJr5YokSeN_inboxOf);
		if ("inboxOf" in values && values.inboxOf != null) if (values.inboxOf instanceof Object$1 || values.inboxOf instanceof URL) {
			clone.#_2bvRkAFZjMfVD8jiUWZJr5YokSeN_inboxOf = [values.inboxOf];
			clone.#_trust_2bvRkAFZjMfVD8jiUWZJr5YokSeN_inboxOf = new Set([0]);
		} else throw new TypeError("The inboxOf must be of type Object | URL.");
		clone.#_4AHzVZDxHjK6uEWa9UiKHGK34yYm_outboxOf = this.#_4AHzVZDxHjK6uEWa9UiKHGK34yYm_outboxOf;
		clone.#_trust_4AHzVZDxHjK6uEWa9UiKHGK34yYm_outboxOf = new Set(this.#_trust_4AHzVZDxHjK6uEWa9UiKHGK34yYm_outboxOf);
		if ("outboxOf" in values && values.outboxOf != null) if (values.outboxOf instanceof Object$1 || values.outboxOf instanceof URL) {
			clone.#_4AHzVZDxHjK6uEWa9UiKHGK34yYm_outboxOf = [values.outboxOf];
			clone.#_trust_4AHzVZDxHjK6uEWa9UiKHGK34yYm_outboxOf = new Set([0]);
		} else throw new TypeError("The outboxOf must be of type Object | URL.");
		clone.#_41aoZ5M6yRUHy3Zx8q6iuZQxtopb_followersOf = this.#_41aoZ5M6yRUHy3Zx8q6iuZQxtopb_followersOf;
		clone.#_trust_41aoZ5M6yRUHy3Zx8q6iuZQxtopb_followersOf = new Set(this.#_trust_41aoZ5M6yRUHy3Zx8q6iuZQxtopb_followersOf);
		if ("followersOf" in values && values.followersOf != null) if (values.followersOf instanceof Object$1 || values.followersOf instanceof URL) {
			clone.#_41aoZ5M6yRUHy3Zx8q6iuZQxtopb_followersOf = [values.followersOf];
			clone.#_trust_41aoZ5M6yRUHy3Zx8q6iuZQxtopb_followersOf = new Set([0]);
		} else throw new TypeError("The followersOf must be of type Object | URL.");
		clone.#_2nXT2Ah42UjEEQF5oJQ39CbKB1xj_followingOf = this.#_2nXT2Ah42UjEEQF5oJQ39CbKB1xj_followingOf;
		clone.#_trust_2nXT2Ah42UjEEQF5oJQ39CbKB1xj_followingOf = new Set(this.#_trust_2nXT2Ah42UjEEQF5oJQ39CbKB1xj_followingOf);
		if ("followingOf" in values && values.followingOf != null) if (values.followingOf instanceof Object$1 || values.followingOf instanceof URL) {
			clone.#_2nXT2Ah42UjEEQF5oJQ39CbKB1xj_followingOf = [values.followingOf];
			clone.#_trust_2nXT2Ah42UjEEQF5oJQ39CbKB1xj_followingOf = new Set([0]);
		} else throw new TypeError("The followingOf must be of type Object | URL.");
		clone.#_2bsySzmT3qEZcrnoe3tZ5xBjXSju_likedOf = this.#_2bsySzmT3qEZcrnoe3tZ5xBjXSju_likedOf;
		clone.#_trust_2bsySzmT3qEZcrnoe3tZ5xBjXSju_likedOf = new Set(this.#_trust_2bsySzmT3qEZcrnoe3tZ5xBjXSju_likedOf);
		if ("likedOf" in values && values.likedOf != null) if (values.likedOf instanceof Object$1 || values.likedOf instanceof URL) {
			clone.#_2bsySzmT3qEZcrnoe3tZ5xBjXSju_likedOf = [values.likedOf];
			clone.#_trust_2bsySzmT3qEZcrnoe3tZ5xBjXSju_likedOf = new Set([0]);
		} else throw new TypeError("The likedOf must be of type Object | URL.");
		return clone;
	}
	/** A non-negative integer specifying the total number of objects contained by
	* the logical view of the collection. This number might not reflect the actual
	* number of items serialized within the {@link Collection} object instance.
	*/
	get totalItems() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_XDbmNDuWHmrhqH712zqtecdbv1V_totalItems.length < 1) return null;
		return this.#_XDbmNDuWHmrhqH712zqtecdbv1V_totalItems[0];
	}
	async #fetchCurrent(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#current_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #current_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await CollectionPage.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#CollectionPage"].join(", "));
	}
	/**
	* Similar to
	* {@link Collection.getCurrent},
	* but returns its `@id` URL instead of the object itself.
	*/
	get currentId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3UyUdxnyn6cDn53QKrh4MBiearma_current.length < 1) return null;
		const v = this.#_3UyUdxnyn6cDn53QKrh4MBiearma_current[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** In a paged {@link Collection}, indicates the page that contains
	* the most recently updated member items.
	*/
	async getCurrent(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3UyUdxnyn6cDn53QKrh4MBiearma_current.length < 1) return null;
		let v = this.#_3UyUdxnyn6cDn53QKrh4MBiearma_current[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_3UyUdxnyn6cDn53QKrh4MBiearma_current.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchCurrent(v, options);
			if (fetched == null) return null;
			this.#_3UyUdxnyn6cDn53QKrh4MBiearma_current[0] = fetched;
			this.#_trust_3UyUdxnyn6cDn53QKrh4MBiearma_current.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "current" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["current"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#current_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_3UyUdxnyn6cDn53QKrh4MBiearma_current.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchFirst(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#first_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #first_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await CollectionPage.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#CollectionPage"].join(", "));
	}
	/**
	* Similar to
	* {@link Collection.getFirst},
	* but returns its `@id` URL instead of the object itself.
	*/
	get firstId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_J52RqweMe6hhv7RnLJMC8BExTE5_first.length < 1) return null;
		const v = this.#_J52RqweMe6hhv7RnLJMC8BExTE5_first[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** In a paged {@link Collection}, indicates the furthest preceding page of
	* items in the collection.
	*/
	async getFirst(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_J52RqweMe6hhv7RnLJMC8BExTE5_first.length < 1) return null;
		let v = this.#_J52RqweMe6hhv7RnLJMC8BExTE5_first[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_J52RqweMe6hhv7RnLJMC8BExTE5_first.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchFirst(v, options);
			if (fetched == null) return null;
			this.#_J52RqweMe6hhv7RnLJMC8BExTE5_first[0] = fetched;
			this.#_trust_J52RqweMe6hhv7RnLJMC8BExTE5_first.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "first" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["first"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#first_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_J52RqweMe6hhv7RnLJMC8BExTE5_first.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchLast(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#last_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #last_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await CollectionPage.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#CollectionPage"].join(", "));
	}
	/**
	* Similar to
	* {@link Collection.getLast},
	* but returns its `@id` URL instead of the object itself.
	*/
	get lastId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_gyJJnyEFnuNVi1HFZKfAn3Hfn26_last.length < 1) return null;
		const v = this.#_gyJJnyEFnuNVi1HFZKfAn3Hfn26_last[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** In a paged {@link Collection}, indicates the furthest proceeding page of
	* the collection.
	*/
	async getLast(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_gyJJnyEFnuNVi1HFZKfAn3Hfn26_last.length < 1) return null;
		let v = this.#_gyJJnyEFnuNVi1HFZKfAn3Hfn26_last[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_gyJJnyEFnuNVi1HFZKfAn3Hfn26_last.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchLast(v, options);
			if (fetched == null) return null;
			this.#_gyJJnyEFnuNVi1HFZKfAn3Hfn26_last[0] = fetched;
			this.#_trust_gyJJnyEFnuNVi1HFZKfAn3Hfn26_last.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "last" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["last"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#last_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_gyJJnyEFnuNVi1HFZKfAn3Hfn26_last.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchItem(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#item_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #item_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Object$1.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Link.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Object", "https://www.w3.org/ns/activitystreams#Link"].join(", "));
	}
	/**
	* Similar to
	* {@link Collection.getItems},
	* but returns their `@id`s instead of the objects themselves.
	*/
	get itemIds() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		return this.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
	}
	/** Identifies the items contained in a collection.  The items might be ordered
	* or unordered.
	*/
	async *getItems(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		const vs = this.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items;
		for (let i = 0; i < vs.length; i++) {
			let v = vs[i];
			if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items.has(i)) v = v.id;
			if (v instanceof URL) {
				const fetched = await this.#fetchItem(v, options);
				if (fetched == null) continue;
				vs[i] = fetched;
				this.#_trust_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items.add(i);
				this._cachedJsonLd = void 0;
				yield fetched;
				continue;
			}
			if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "items" in this._cachedJsonLd) {
				const prop = this._cachedJsonLd["items"];
				const obj = Array.isArray(prop) ? prop[i] : prop;
				if (obj != null && typeof obj === "object" && "@context" in obj) v = await this.#item_fromJsonLd(obj, options);
			}
			if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items.has(0)) {
				if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
				getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
					objectId: v.id.href,
					parentObjectId: this.id.href
				});
				continue;
			}
			yield v;
		}
	}
	async #fetchLikesOf(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#likesOf_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #likesOf_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Object$1.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Object"].join(", "));
	}
	/**
	* Similar to
	* {@link Collection.getLikesOf},
	* but returns its `@id` URL instead of the object itself.
	*/
	get likesOfId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_4TB9Qd9ddtcZEpMfzbHhzafE6jaJ_likesOf.length < 1) return null;
		const v = this.#_4TB9Qd9ddtcZEpMfzbHhzafE6jaJ_likesOf[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** Defines an object for which the collection is the value of the likes property.
	*/
	async getLikesOf(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_4TB9Qd9ddtcZEpMfzbHhzafE6jaJ_likesOf.length < 1) return null;
		let v = this.#_4TB9Qd9ddtcZEpMfzbHhzafE6jaJ_likesOf[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_4TB9Qd9ddtcZEpMfzbHhzafE6jaJ_likesOf.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchLikesOf(v, options);
			if (fetched == null) return null;
			this.#_4TB9Qd9ddtcZEpMfzbHhzafE6jaJ_likesOf[0] = fetched;
			this.#_trust_4TB9Qd9ddtcZEpMfzbHhzafE6jaJ_likesOf.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "likesOf" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["likesOf"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#likesOf_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_4TB9Qd9ddtcZEpMfzbHhzafE6jaJ_likesOf.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchSharesOf(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#sharesOf_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #sharesOf_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Object$1.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Object"].join(", "));
	}
	/**
	* Similar to
	* {@link Collection.getSharesOf},
	* but returns its `@id` URL instead of the object itself.
	*/
	get sharesOfId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3manzgeKiPsugpztKGiaUUwJ3ito_sharesOf.length < 1) return null;
		const v = this.#_3manzgeKiPsugpztKGiaUUwJ3ito_sharesOf[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** Defines an object for which the collection is the value of the shares property.
	*/
	async getSharesOf(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3manzgeKiPsugpztKGiaUUwJ3ito_sharesOf.length < 1) return null;
		let v = this.#_3manzgeKiPsugpztKGiaUUwJ3ito_sharesOf[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_3manzgeKiPsugpztKGiaUUwJ3ito_sharesOf.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchSharesOf(v, options);
			if (fetched == null) return null;
			this.#_3manzgeKiPsugpztKGiaUUwJ3ito_sharesOf[0] = fetched;
			this.#_trust_3manzgeKiPsugpztKGiaUUwJ3ito_sharesOf.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "sharesOf" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["sharesOf"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#sharesOf_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_3manzgeKiPsugpztKGiaUUwJ3ito_sharesOf.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchRepliesOf(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#repliesOf_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #repliesOf_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Object$1.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Object"].join(", "));
	}
	/**
	* Similar to
	* {@link Collection.getRepliesOf},
	* but returns its `@id` URL instead of the object itself.
	*/
	get repliesOfId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3T3oGm3twpcQUcrnMisXQtmDZ32X_repliesOf.length < 1) return null;
		const v = this.#_3T3oGm3twpcQUcrnMisXQtmDZ32X_repliesOf[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** Defines an object for which the collection is the value of the replies property.
	*/
	async getRepliesOf(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3T3oGm3twpcQUcrnMisXQtmDZ32X_repliesOf.length < 1) return null;
		let v = this.#_3T3oGm3twpcQUcrnMisXQtmDZ32X_repliesOf[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_3T3oGm3twpcQUcrnMisXQtmDZ32X_repliesOf.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchRepliesOf(v, options);
			if (fetched == null) return null;
			this.#_3T3oGm3twpcQUcrnMisXQtmDZ32X_repliesOf[0] = fetched;
			this.#_trust_3T3oGm3twpcQUcrnMisXQtmDZ32X_repliesOf.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "repliesOf" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["repliesOf"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#repliesOf_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_3T3oGm3twpcQUcrnMisXQtmDZ32X_repliesOf.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchInboxOf(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#inboxOf_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #inboxOf_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Object$1.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Object"].join(", "));
	}
	/**
	* Similar to
	* {@link Collection.getInboxOf},
	* but returns its `@id` URL instead of the object itself.
	*/
	get inboxOfId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2bvRkAFZjMfVD8jiUWZJr5YokSeN_inboxOf.length < 1) return null;
		const v = this.#_2bvRkAFZjMfVD8jiUWZJr5YokSeN_inboxOf[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** Defines an actor for which the collection is the value of the inbox property.
	*/
	async getInboxOf(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2bvRkAFZjMfVD8jiUWZJr5YokSeN_inboxOf.length < 1) return null;
		let v = this.#_2bvRkAFZjMfVD8jiUWZJr5YokSeN_inboxOf[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_2bvRkAFZjMfVD8jiUWZJr5YokSeN_inboxOf.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchInboxOf(v, options);
			if (fetched == null) return null;
			this.#_2bvRkAFZjMfVD8jiUWZJr5YokSeN_inboxOf[0] = fetched;
			this.#_trust_2bvRkAFZjMfVD8jiUWZJr5YokSeN_inboxOf.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "inboxOf" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["inboxOf"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#inboxOf_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_2bvRkAFZjMfVD8jiUWZJr5YokSeN_inboxOf.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchOutboxOf(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#outboxOf_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #outboxOf_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Object$1.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Object"].join(", "));
	}
	/**
	* Similar to
	* {@link Collection.getOutboxOf},
	* but returns its `@id` URL instead of the object itself.
	*/
	get outboxOfId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_4AHzVZDxHjK6uEWa9UiKHGK34yYm_outboxOf.length < 1) return null;
		const v = this.#_4AHzVZDxHjK6uEWa9UiKHGK34yYm_outboxOf[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** Defines an actor for which the collection is the value of the outbox property.
	*/
	async getOutboxOf(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_4AHzVZDxHjK6uEWa9UiKHGK34yYm_outboxOf.length < 1) return null;
		let v = this.#_4AHzVZDxHjK6uEWa9UiKHGK34yYm_outboxOf[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_4AHzVZDxHjK6uEWa9UiKHGK34yYm_outboxOf.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchOutboxOf(v, options);
			if (fetched == null) return null;
			this.#_4AHzVZDxHjK6uEWa9UiKHGK34yYm_outboxOf[0] = fetched;
			this.#_trust_4AHzVZDxHjK6uEWa9UiKHGK34yYm_outboxOf.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "outboxOf" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["outboxOf"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#outboxOf_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_4AHzVZDxHjK6uEWa9UiKHGK34yYm_outboxOf.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchFollowersOf(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#followersOf_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #followersOf_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Object$1.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Object"].join(", "));
	}
	/**
	* Similar to
	* {@link Collection.getFollowersOf},
	* but returns its `@id` URL instead of the object itself.
	*/
	get followersOfId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_41aoZ5M6yRUHy3Zx8q6iuZQxtopb_followersOf.length < 1) return null;
		const v = this.#_41aoZ5M6yRUHy3Zx8q6iuZQxtopb_followersOf[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** Defines an actor for which the collection is the value of the followers property.
	*/
	async getFollowersOf(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_41aoZ5M6yRUHy3Zx8q6iuZQxtopb_followersOf.length < 1) return null;
		let v = this.#_41aoZ5M6yRUHy3Zx8q6iuZQxtopb_followersOf[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_41aoZ5M6yRUHy3Zx8q6iuZQxtopb_followersOf.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchFollowersOf(v, options);
			if (fetched == null) return null;
			this.#_41aoZ5M6yRUHy3Zx8q6iuZQxtopb_followersOf[0] = fetched;
			this.#_trust_41aoZ5M6yRUHy3Zx8q6iuZQxtopb_followersOf.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "followersOf" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["followersOf"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#followersOf_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_41aoZ5M6yRUHy3Zx8q6iuZQxtopb_followersOf.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchFollowingOf(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#followingOf_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #followingOf_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Object$1.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Object"].join(", "));
	}
	/**
	* Similar to
	* {@link Collection.getFollowingOf},
	* but returns its `@id` URL instead of the object itself.
	*/
	get followingOfId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2nXT2Ah42UjEEQF5oJQ39CbKB1xj_followingOf.length < 1) return null;
		const v = this.#_2nXT2Ah42UjEEQF5oJQ39CbKB1xj_followingOf[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** Defines an actor for which the collection is the value of the following property.
	*/
	async getFollowingOf(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2nXT2Ah42UjEEQF5oJQ39CbKB1xj_followingOf.length < 1) return null;
		let v = this.#_2nXT2Ah42UjEEQF5oJQ39CbKB1xj_followingOf[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_2nXT2Ah42UjEEQF5oJQ39CbKB1xj_followingOf.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchFollowingOf(v, options);
			if (fetched == null) return null;
			this.#_2nXT2Ah42UjEEQF5oJQ39CbKB1xj_followingOf[0] = fetched;
			this.#_trust_2nXT2Ah42UjEEQF5oJQ39CbKB1xj_followingOf.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "followingOf" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["followingOf"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#followingOf_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_2nXT2Ah42UjEEQF5oJQ39CbKB1xj_followingOf.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchLikedOf(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#likedOf_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #likedOf_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Object$1.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Object"].join(", "));
	}
	/**
	* Similar to
	* {@link Collection.getLikedOf},
	* but returns its `@id` URL instead of the object itself.
	*/
	get likedOfId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2bsySzmT3qEZcrnoe3tZ5xBjXSju_likedOf.length < 1) return null;
		const v = this.#_2bsySzmT3qEZcrnoe3tZ5xBjXSju_likedOf[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** Defines an actor for which the collection is the value of the liked property.
	*/
	async getLikedOf(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2bsySzmT3qEZcrnoe3tZ5xBjXSju_likedOf.length < 1) return null;
		let v = this.#_2bsySzmT3qEZcrnoe3tZ5xBjXSju_likedOf[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_2bsySzmT3qEZcrnoe3tZ5xBjXSju_likedOf.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchLikedOf(v, options);
			if (fetched == null) return null;
			this.#_2bsySzmT3qEZcrnoe3tZ5xBjXSju_likedOf[0] = fetched;
			this.#_trust_2bsySzmT3qEZcrnoe3tZ5xBjXSju_likedOf.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "likedOf" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["likedOf"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#likedOf_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_2bsySzmT3qEZcrnoe3tZ5xBjXSju_likedOf.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		if (options.format == null && this.isCompactable()) {
			const result = await super.toJsonLd({
				...options,
				format: void 0,
				context: void 0
			});
			let compactItems;
			compactItems = [];
			for (const v of this.#_XDbmNDuWHmrhqH712zqtecdbv1V_totalItems) {
				const item = v;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["totalItems"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_3UyUdxnyn6cDn53QKrh4MBiearma_current) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["current"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_J52RqweMe6hhv7RnLJMC8BExTE5_first) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["first"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_gyJJnyEFnuNVi1HFZKfAn3Hfn26_last) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["last"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items) {
				const item = v instanceof URL ? v.href : v instanceof Object$1 ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["items"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_4TB9Qd9ddtcZEpMfzbHhzafE6jaJ_likesOf) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["likesOf"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_3manzgeKiPsugpztKGiaUUwJ3ito_sharesOf) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["sharesOf"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_3T3oGm3twpcQUcrnMisXQtmDZ32X_repliesOf) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["repliesOf"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_2bvRkAFZjMfVD8jiUWZJr5YokSeN_inboxOf) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["inboxOf"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_4AHzVZDxHjK6uEWa9UiKHGK34yYm_outboxOf) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["outboxOf"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_41aoZ5M6yRUHy3Zx8q6iuZQxtopb_followersOf) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["followersOf"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_2nXT2Ah42UjEEQF5oJQ39CbKB1xj_followingOf) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["followingOf"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_2bsySzmT3qEZcrnoe3tZ5xBjXSju_likedOf) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["likedOf"] = compactItems.length > 1 ? compactItems : compactItems[0];
			result["type"] = "Collection";
			if (this.id != null) result["id"] = this.id.href;
			result["@context"] = [
				"https://www.w3.org/ns/activitystreams",
				"https://w3id.org/security/data-integrity/v1",
				{
					"toot": "http://joinmastodon.org/ns#",
					"misskey": "https://misskey-hub.net/ns#",
					"fedibird": "http://fedibird.com/ns#",
					"ChatMessage": "http://litepub.social/ns#ChatMessage",
					"sensitive": "as:sensitive",
					"votersCount": "toot:votersCount",
					"Emoji": "toot:Emoji",
					"Hashtag": "as:Hashtag",
					"quoteUrl": "as:quoteUrl",
					"_misskey_quote": "misskey:_misskey_quote",
					"quoteUri": "fedibird:quoteUri",
					"emojiReactions": {
						"@id": "fedibird:emojiReactions",
						"@type": "@id"
					}
				}
			];
			return result;
		}
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		array = [];
		for (const v of this.#_XDbmNDuWHmrhqH712zqtecdbv1V_totalItems) {
			const element = {
				"@type": "http://www.w3.org/2001/XMLSchema#nonNegativeInteger",
				"@value": v
			};
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#totalItems"] = propValue;
		}
		array = [];
		for (const v of this.#_3UyUdxnyn6cDn53QKrh4MBiearma_current) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#current"] = propValue;
		}
		array = [];
		for (const v of this.#_J52RqweMe6hhv7RnLJMC8BExTE5_first) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#first"] = propValue;
		}
		array = [];
		for (const v of this.#_gyJJnyEFnuNVi1HFZKfAn3Hfn26_last) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#last"] = propValue;
		}
		array = [];
		for (const v of this.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items) {
			const element = v instanceof URL ? { "@id": v.href } : v instanceof Object$1 ? await v.toJsonLd(options) : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#items"] = propValue;
		}
		array = [];
		for (const v of this.#_4TB9Qd9ddtcZEpMfzbHhzafE6jaJ_likesOf) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://w3id.org/fep/5711#likesOf"] = propValue;
		}
		array = [];
		for (const v of this.#_3manzgeKiPsugpztKGiaUUwJ3ito_sharesOf) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://w3id.org/fep/5711#sharesOf"] = propValue;
		}
		array = [];
		for (const v of this.#_3T3oGm3twpcQUcrnMisXQtmDZ32X_repliesOf) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://w3id.org/fep/5711#repliesOf"] = propValue;
		}
		array = [];
		for (const v of this.#_2bvRkAFZjMfVD8jiUWZJr5YokSeN_inboxOf) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://w3id.org/fep/5711#inboxOf"] = propValue;
		}
		array = [];
		for (const v of this.#_4AHzVZDxHjK6uEWa9UiKHGK34yYm_outboxOf) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://w3id.org/fep/5711#outboxOf"] = propValue;
		}
		array = [];
		for (const v of this.#_41aoZ5M6yRUHy3Zx8q6iuZQxtopb_followersOf) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://w3id.org/fep/5711#followersOf"] = propValue;
		}
		array = [];
		for (const v of this.#_2nXT2Ah42UjEEQF5oJQ39CbKB1xj_followingOf) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://w3id.org/fep/5711#followingOf"] = propValue;
		}
		array = [];
		for (const v of this.#_2bsySzmT3qEZcrnoe3tZ5xBjXSju_likedOf) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://w3id.org/fep/5711#likedOf"] = propValue;
		}
		values["@type"] = ["https://www.w3.org/ns/activitystreams#Collection"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? [
			"https://www.w3.org/ns/activitystreams",
			"https://w3id.org/security/data-integrity/v1",
			{
				"toot": "http://joinmastodon.org/ns#",
				"misskey": "https://misskey-hub.net/ns#",
				"fedibird": "http://fedibird.com/ns#",
				"ChatMessage": "http://litepub.social/ns#ChatMessage",
				"sensitive": "as:sensitive",
				"votersCount": "toot:votersCount",
				"Emoji": "toot:Emoji",
				"Hashtag": "as:Hashtag",
				"quoteUrl": "as:quoteUrl",
				"_misskey_quote": "misskey:_misskey_quote",
				"quoteUri": "fedibird:quoteUri",
				"emojiReactions": {
					"@id": "fedibird:emojiReactions",
					"@type": "@id"
				}
			}
		];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {
			if ("proof" in compacted && compacted.proof != null) if (Array.isArray(compacted.proof)) for (const element of compacted.proof) element["@context"] = docContext;
			else compacted.proof["@context"] = docContext;
		}
		return compacted;
	}
	isCompactable() {
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__Collection__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__Collection__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#CollectionPage")) return await CollectionPage.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#OrderedCollectionPage")) return await OrderedCollectionPage.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#OrderedCollection")) return await OrderedCollection.fromJsonLd(json, options);
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Collection")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof Collection)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		const _XDbmNDuWHmrhqH712zqtecdbv1V_totalItems = [];
		let _XDbmNDuWHmrhqH712zqtecdbv1V_totalItems__array = values["https://www.w3.org/ns/activitystreams#totalItems"];
		for (const v of _XDbmNDuWHmrhqH712zqtecdbv1V_totalItems__array == null ? [] : _XDbmNDuWHmrhqH712zqtecdbv1V_totalItems__array.length === 1 && "@list" in _XDbmNDuWHmrhqH712zqtecdbv1V_totalItems__array[0] ? _XDbmNDuWHmrhqH712zqtecdbv1V_totalItems__array[0]["@list"] : _XDbmNDuWHmrhqH712zqtecdbv1V_totalItems__array) {
			if (v == null) continue;
			_XDbmNDuWHmrhqH712zqtecdbv1V_totalItems.push(v["@value"]);
		}
		instance.#_XDbmNDuWHmrhqH712zqtecdbv1V_totalItems = _XDbmNDuWHmrhqH712zqtecdbv1V_totalItems;
		const _3UyUdxnyn6cDn53QKrh4MBiearma_current = [];
		const _trust_3UyUdxnyn6cDn53QKrh4MBiearma_current = /* @__PURE__ */ new Set();
		let _3UyUdxnyn6cDn53QKrh4MBiearma_current__array = values["https://www.w3.org/ns/activitystreams#current"];
		for (const v of _3UyUdxnyn6cDn53QKrh4MBiearma_current__array == null ? [] : _3UyUdxnyn6cDn53QKrh4MBiearma_current__array.length === 1 && "@list" in _3UyUdxnyn6cDn53QKrh4MBiearma_current__array[0] ? _3UyUdxnyn6cDn53QKrh4MBiearma_current__array[0]["@list"] : _3UyUdxnyn6cDn53QKrh4MBiearma_current__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_3UyUdxnyn6cDn53QKrh4MBiearma_current.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_3UyUdxnyn6cDn53QKrh4MBiearma_current.push(await CollectionPage.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_3UyUdxnyn6cDn53QKrh4MBiearma_current = _3UyUdxnyn6cDn53QKrh4MBiearma_current;
		const _J52RqweMe6hhv7RnLJMC8BExTE5_first = [];
		const _trust_J52RqweMe6hhv7RnLJMC8BExTE5_first = /* @__PURE__ */ new Set();
		let _J52RqweMe6hhv7RnLJMC8BExTE5_first__array = values["https://www.w3.org/ns/activitystreams#first"];
		for (const v of _J52RqweMe6hhv7RnLJMC8BExTE5_first__array == null ? [] : _J52RqweMe6hhv7RnLJMC8BExTE5_first__array.length === 1 && "@list" in _J52RqweMe6hhv7RnLJMC8BExTE5_first__array[0] ? _J52RqweMe6hhv7RnLJMC8BExTE5_first__array[0]["@list"] : _J52RqweMe6hhv7RnLJMC8BExTE5_first__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_J52RqweMe6hhv7RnLJMC8BExTE5_first.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_J52RqweMe6hhv7RnLJMC8BExTE5_first.push(await CollectionPage.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_J52RqweMe6hhv7RnLJMC8BExTE5_first = _J52RqweMe6hhv7RnLJMC8BExTE5_first;
		const _gyJJnyEFnuNVi1HFZKfAn3Hfn26_last = [];
		const _trust_gyJJnyEFnuNVi1HFZKfAn3Hfn26_last = /* @__PURE__ */ new Set();
		let _gyJJnyEFnuNVi1HFZKfAn3Hfn26_last__array = values["https://www.w3.org/ns/activitystreams#last"];
		for (const v of _gyJJnyEFnuNVi1HFZKfAn3Hfn26_last__array == null ? [] : _gyJJnyEFnuNVi1HFZKfAn3Hfn26_last__array.length === 1 && "@list" in _gyJJnyEFnuNVi1HFZKfAn3Hfn26_last__array[0] ? _gyJJnyEFnuNVi1HFZKfAn3Hfn26_last__array[0]["@list"] : _gyJJnyEFnuNVi1HFZKfAn3Hfn26_last__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_gyJJnyEFnuNVi1HFZKfAn3Hfn26_last.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_gyJJnyEFnuNVi1HFZKfAn3Hfn26_last.push(await CollectionPage.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_gyJJnyEFnuNVi1HFZKfAn3Hfn26_last = _gyJJnyEFnuNVi1HFZKfAn3Hfn26_last;
		const _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items = [];
		const _trust_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items = /* @__PURE__ */ new Set();
		let _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items__array = values["https://www.w3.org/ns/activitystreams#items"];
		for (const v of _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items__array == null ? [] : _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items__array.length === 1 && "@list" in _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items__array[0] ? _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items__array[0]["@list"] : _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			const decoded = typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && [
				"https://www.w3.org/ns/activitystreams#Object",
				"http://joinmastodon.org/ns#Emoji",
				"http://litepub.social/ns#ChatMessage",
				"https://www.w3.org/ns/activitystreams#Activity",
				"http://litepub.social/ns#EmojiReact",
				"https://www.w3.org/ns/activitystreams#Accept",
				"https://www.w3.org/ns/activitystreams#TentativeAccept",
				"https://www.w3.org/ns/activitystreams#Add",
				"https://www.w3.org/ns/activitystreams#Announce",
				"https://www.w3.org/ns/activitystreams#Create",
				"https://www.w3.org/ns/activitystreams#Delete",
				"https://www.w3.org/ns/activitystreams#Dislike",
				"https://www.w3.org/ns/activitystreams#Flag",
				"https://www.w3.org/ns/activitystreams#Follow",
				"https://www.w3.org/ns/activitystreams#Ignore",
				"https://www.w3.org/ns/activitystreams#Block",
				"https://www.w3.org/ns/activitystreams#IntransitiveActivity",
				"https://www.w3.org/ns/activitystreams#Arrive",
				"https://www.w3.org/ns/activitystreams#Question",
				"https://www.w3.org/ns/activitystreams#Travel",
				"https://www.w3.org/ns/activitystreams#Join",
				"https://www.w3.org/ns/activitystreams#Leave",
				"https://www.w3.org/ns/activitystreams#Like",
				"https://www.w3.org/ns/activitystreams#Listen",
				"https://www.w3.org/ns/activitystreams#Move",
				"https://www.w3.org/ns/activitystreams#Offer",
				"https://www.w3.org/ns/activitystreams#Invite",
				"https://www.w3.org/ns/activitystreams#Read",
				"https://www.w3.org/ns/activitystreams#Reject",
				"https://www.w3.org/ns/activitystreams#TentativeReject",
				"https://www.w3.org/ns/activitystreams#Remove",
				"https://www.w3.org/ns/activitystreams#Undo",
				"https://www.w3.org/ns/activitystreams#Update",
				"https://www.w3.org/ns/activitystreams#View",
				"https://www.w3.org/ns/activitystreams#Application",
				"https://www.w3.org/ns/activitystreams#Article",
				"https://www.w3.org/ns/activitystreams#Collection",
				"https://www.w3.org/ns/activitystreams#CollectionPage",
				"https://www.w3.org/ns/activitystreams#OrderedCollectionPage",
				"https://www.w3.org/ns/activitystreams#OrderedCollection",
				"https://www.w3.org/ns/activitystreams#Document",
				"https://www.w3.org/ns/activitystreams#Audio",
				"https://www.w3.org/ns/activitystreams#Image",
				"https://www.w3.org/ns/activitystreams#Page",
				"https://www.w3.org/ns/activitystreams#Video",
				"https://www.w3.org/ns/activitystreams#Event",
				"https://www.w3.org/ns/activitystreams#Group",
				"https://www.w3.org/ns/activitystreams#Note",
				"https://www.w3.org/ns/activitystreams#Organization",
				"https://www.w3.org/ns/activitystreams#Person",
				"https://www.w3.org/ns/activitystreams#Place",
				"https://www.w3.org/ns/activitystreams#Profile",
				"https://www.w3.org/ns/activitystreams#Relationship",
				"https://www.w3.org/ns/activitystreams#Service",
				"https://www.w3.org/ns/activitystreams#Tombstone"
			].some((t) => v["@type"].includes(t)) ? await Object$1.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && [
				"https://www.w3.org/ns/activitystreams#Link",
				"https://www.w3.org/ns/activitystreams#Hashtag",
				"https://www.w3.org/ns/activitystreams#Mention"
			].some((t) => v["@type"].includes(t)) ? await Link.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : void 0;
			if (typeof decoded === "undefined") continue;
			_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items.push(decoded);
		}
		instance.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items = _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items;
		const _4TB9Qd9ddtcZEpMfzbHhzafE6jaJ_likesOf = [];
		const _trust_4TB9Qd9ddtcZEpMfzbHhzafE6jaJ_likesOf = /* @__PURE__ */ new Set();
		let _4TB9Qd9ddtcZEpMfzbHhzafE6jaJ_likesOf__array = values["https://w3id.org/fep/5711#likesOf"];
		for (const v of _4TB9Qd9ddtcZEpMfzbHhzafE6jaJ_likesOf__array == null ? [] : _4TB9Qd9ddtcZEpMfzbHhzafE6jaJ_likesOf__array.length === 1 && "@list" in _4TB9Qd9ddtcZEpMfzbHhzafE6jaJ_likesOf__array[0] ? _4TB9Qd9ddtcZEpMfzbHhzafE6jaJ_likesOf__array[0]["@list"] : _4TB9Qd9ddtcZEpMfzbHhzafE6jaJ_likesOf__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_4TB9Qd9ddtcZEpMfzbHhzafE6jaJ_likesOf.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_4TB9Qd9ddtcZEpMfzbHhzafE6jaJ_likesOf.push(await Object$1.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_4TB9Qd9ddtcZEpMfzbHhzafE6jaJ_likesOf = _4TB9Qd9ddtcZEpMfzbHhzafE6jaJ_likesOf;
		const _3manzgeKiPsugpztKGiaUUwJ3ito_sharesOf = [];
		const _trust_3manzgeKiPsugpztKGiaUUwJ3ito_sharesOf = /* @__PURE__ */ new Set();
		let _3manzgeKiPsugpztKGiaUUwJ3ito_sharesOf__array = values["https://w3id.org/fep/5711#sharesOf"];
		for (const v of _3manzgeKiPsugpztKGiaUUwJ3ito_sharesOf__array == null ? [] : _3manzgeKiPsugpztKGiaUUwJ3ito_sharesOf__array.length === 1 && "@list" in _3manzgeKiPsugpztKGiaUUwJ3ito_sharesOf__array[0] ? _3manzgeKiPsugpztKGiaUUwJ3ito_sharesOf__array[0]["@list"] : _3manzgeKiPsugpztKGiaUUwJ3ito_sharesOf__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_3manzgeKiPsugpztKGiaUUwJ3ito_sharesOf.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_3manzgeKiPsugpztKGiaUUwJ3ito_sharesOf.push(await Object$1.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_3manzgeKiPsugpztKGiaUUwJ3ito_sharesOf = _3manzgeKiPsugpztKGiaUUwJ3ito_sharesOf;
		const _3T3oGm3twpcQUcrnMisXQtmDZ32X_repliesOf = [];
		const _trust_3T3oGm3twpcQUcrnMisXQtmDZ32X_repliesOf = /* @__PURE__ */ new Set();
		let _3T3oGm3twpcQUcrnMisXQtmDZ32X_repliesOf__array = values["https://w3id.org/fep/5711#repliesOf"];
		for (const v of _3T3oGm3twpcQUcrnMisXQtmDZ32X_repliesOf__array == null ? [] : _3T3oGm3twpcQUcrnMisXQtmDZ32X_repliesOf__array.length === 1 && "@list" in _3T3oGm3twpcQUcrnMisXQtmDZ32X_repliesOf__array[0] ? _3T3oGm3twpcQUcrnMisXQtmDZ32X_repliesOf__array[0]["@list"] : _3T3oGm3twpcQUcrnMisXQtmDZ32X_repliesOf__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_3T3oGm3twpcQUcrnMisXQtmDZ32X_repliesOf.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_3T3oGm3twpcQUcrnMisXQtmDZ32X_repliesOf.push(await Object$1.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_3T3oGm3twpcQUcrnMisXQtmDZ32X_repliesOf = _3T3oGm3twpcQUcrnMisXQtmDZ32X_repliesOf;
		const _2bvRkAFZjMfVD8jiUWZJr5YokSeN_inboxOf = [];
		const _trust_2bvRkAFZjMfVD8jiUWZJr5YokSeN_inboxOf = /* @__PURE__ */ new Set();
		let _2bvRkAFZjMfVD8jiUWZJr5YokSeN_inboxOf__array = values["https://w3id.org/fep/5711#inboxOf"];
		for (const v of _2bvRkAFZjMfVD8jiUWZJr5YokSeN_inboxOf__array == null ? [] : _2bvRkAFZjMfVD8jiUWZJr5YokSeN_inboxOf__array.length === 1 && "@list" in _2bvRkAFZjMfVD8jiUWZJr5YokSeN_inboxOf__array[0] ? _2bvRkAFZjMfVD8jiUWZJr5YokSeN_inboxOf__array[0]["@list"] : _2bvRkAFZjMfVD8jiUWZJr5YokSeN_inboxOf__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_2bvRkAFZjMfVD8jiUWZJr5YokSeN_inboxOf.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_2bvRkAFZjMfVD8jiUWZJr5YokSeN_inboxOf.push(await Object$1.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_2bvRkAFZjMfVD8jiUWZJr5YokSeN_inboxOf = _2bvRkAFZjMfVD8jiUWZJr5YokSeN_inboxOf;
		const _4AHzVZDxHjK6uEWa9UiKHGK34yYm_outboxOf = [];
		const _trust_4AHzVZDxHjK6uEWa9UiKHGK34yYm_outboxOf = /* @__PURE__ */ new Set();
		let _4AHzVZDxHjK6uEWa9UiKHGK34yYm_outboxOf__array = values["https://w3id.org/fep/5711#outboxOf"];
		for (const v of _4AHzVZDxHjK6uEWa9UiKHGK34yYm_outboxOf__array == null ? [] : _4AHzVZDxHjK6uEWa9UiKHGK34yYm_outboxOf__array.length === 1 && "@list" in _4AHzVZDxHjK6uEWa9UiKHGK34yYm_outboxOf__array[0] ? _4AHzVZDxHjK6uEWa9UiKHGK34yYm_outboxOf__array[0]["@list"] : _4AHzVZDxHjK6uEWa9UiKHGK34yYm_outboxOf__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_4AHzVZDxHjK6uEWa9UiKHGK34yYm_outboxOf.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_4AHzVZDxHjK6uEWa9UiKHGK34yYm_outboxOf.push(await Object$1.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_4AHzVZDxHjK6uEWa9UiKHGK34yYm_outboxOf = _4AHzVZDxHjK6uEWa9UiKHGK34yYm_outboxOf;
		const _41aoZ5M6yRUHy3Zx8q6iuZQxtopb_followersOf = [];
		const _trust_41aoZ5M6yRUHy3Zx8q6iuZQxtopb_followersOf = /* @__PURE__ */ new Set();
		let _41aoZ5M6yRUHy3Zx8q6iuZQxtopb_followersOf__array = values["https://w3id.org/fep/5711#followersOf"];
		for (const v of _41aoZ5M6yRUHy3Zx8q6iuZQxtopb_followersOf__array == null ? [] : _41aoZ5M6yRUHy3Zx8q6iuZQxtopb_followersOf__array.length === 1 && "@list" in _41aoZ5M6yRUHy3Zx8q6iuZQxtopb_followersOf__array[0] ? _41aoZ5M6yRUHy3Zx8q6iuZQxtopb_followersOf__array[0]["@list"] : _41aoZ5M6yRUHy3Zx8q6iuZQxtopb_followersOf__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_41aoZ5M6yRUHy3Zx8q6iuZQxtopb_followersOf.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_41aoZ5M6yRUHy3Zx8q6iuZQxtopb_followersOf.push(await Object$1.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_41aoZ5M6yRUHy3Zx8q6iuZQxtopb_followersOf = _41aoZ5M6yRUHy3Zx8q6iuZQxtopb_followersOf;
		const _2nXT2Ah42UjEEQF5oJQ39CbKB1xj_followingOf = [];
		const _trust_2nXT2Ah42UjEEQF5oJQ39CbKB1xj_followingOf = /* @__PURE__ */ new Set();
		let _2nXT2Ah42UjEEQF5oJQ39CbKB1xj_followingOf__array = values["https://w3id.org/fep/5711#followingOf"];
		for (const v of _2nXT2Ah42UjEEQF5oJQ39CbKB1xj_followingOf__array == null ? [] : _2nXT2Ah42UjEEQF5oJQ39CbKB1xj_followingOf__array.length === 1 && "@list" in _2nXT2Ah42UjEEQF5oJQ39CbKB1xj_followingOf__array[0] ? _2nXT2Ah42UjEEQF5oJQ39CbKB1xj_followingOf__array[0]["@list"] : _2nXT2Ah42UjEEQF5oJQ39CbKB1xj_followingOf__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_2nXT2Ah42UjEEQF5oJQ39CbKB1xj_followingOf.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_2nXT2Ah42UjEEQF5oJQ39CbKB1xj_followingOf.push(await Object$1.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_2nXT2Ah42UjEEQF5oJQ39CbKB1xj_followingOf = _2nXT2Ah42UjEEQF5oJQ39CbKB1xj_followingOf;
		const _2bsySzmT3qEZcrnoe3tZ5xBjXSju_likedOf = [];
		const _trust_2bsySzmT3qEZcrnoe3tZ5xBjXSju_likedOf = /* @__PURE__ */ new Set();
		let _2bsySzmT3qEZcrnoe3tZ5xBjXSju_likedOf__array = values["https://w3id.org/fep/5711#likedOf"];
		for (const v of _2bsySzmT3qEZcrnoe3tZ5xBjXSju_likedOf__array == null ? [] : _2bsySzmT3qEZcrnoe3tZ5xBjXSju_likedOf__array.length === 1 && "@list" in _2bsySzmT3qEZcrnoe3tZ5xBjXSju_likedOf__array[0] ? _2bsySzmT3qEZcrnoe3tZ5xBjXSju_likedOf__array[0]["@list"] : _2bsySzmT3qEZcrnoe3tZ5xBjXSju_likedOf__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_2bsySzmT3qEZcrnoe3tZ5xBjXSju_likedOf.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_2bsySzmT3qEZcrnoe3tZ5xBjXSju_likedOf.push(await Object$1.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_2bsySzmT3qEZcrnoe3tZ5xBjXSju_likedOf = _2bsySzmT3qEZcrnoe3tZ5xBjXSju_likedOf;
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		const _XDbmNDuWHmrhqH712zqtecdbv1V_totalItems = this.#_XDbmNDuWHmrhqH712zqtecdbv1V_totalItems.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_XDbmNDuWHmrhqH712zqtecdbv1V_totalItems.length == 1) proxy.totalItems = _XDbmNDuWHmrhqH712zqtecdbv1V_totalItems[0];
		const _3UyUdxnyn6cDn53QKrh4MBiearma_current = this.#_3UyUdxnyn6cDn53QKrh4MBiearma_current.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3UyUdxnyn6cDn53QKrh4MBiearma_current.length == 1) proxy.current = _3UyUdxnyn6cDn53QKrh4MBiearma_current[0];
		const _J52RqweMe6hhv7RnLJMC8BExTE5_first = this.#_J52RqweMe6hhv7RnLJMC8BExTE5_first.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_J52RqweMe6hhv7RnLJMC8BExTE5_first.length == 1) proxy.first = _J52RqweMe6hhv7RnLJMC8BExTE5_first[0];
		const _gyJJnyEFnuNVi1HFZKfAn3Hfn26_last = this.#_gyJJnyEFnuNVi1HFZKfAn3Hfn26_last.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_gyJJnyEFnuNVi1HFZKfAn3Hfn26_last.length == 1) proxy.last = _gyJJnyEFnuNVi1HFZKfAn3Hfn26_last[0];
		const _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items = this.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items.length > 1 || !("item" in proxy) && _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items.length > 0) proxy.items = _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items;
		const _4TB9Qd9ddtcZEpMfzbHhzafE6jaJ_likesOf = this.#_4TB9Qd9ddtcZEpMfzbHhzafE6jaJ_likesOf.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_4TB9Qd9ddtcZEpMfzbHhzafE6jaJ_likesOf.length == 1) proxy.likesOf = _4TB9Qd9ddtcZEpMfzbHhzafE6jaJ_likesOf[0];
		const _3manzgeKiPsugpztKGiaUUwJ3ito_sharesOf = this.#_3manzgeKiPsugpztKGiaUUwJ3ito_sharesOf.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3manzgeKiPsugpztKGiaUUwJ3ito_sharesOf.length == 1) proxy.sharesOf = _3manzgeKiPsugpztKGiaUUwJ3ito_sharesOf[0];
		const _3T3oGm3twpcQUcrnMisXQtmDZ32X_repliesOf = this.#_3T3oGm3twpcQUcrnMisXQtmDZ32X_repliesOf.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3T3oGm3twpcQUcrnMisXQtmDZ32X_repliesOf.length == 1) proxy.repliesOf = _3T3oGm3twpcQUcrnMisXQtmDZ32X_repliesOf[0];
		const _2bvRkAFZjMfVD8jiUWZJr5YokSeN_inboxOf = this.#_2bvRkAFZjMfVD8jiUWZJr5YokSeN_inboxOf.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_2bvRkAFZjMfVD8jiUWZJr5YokSeN_inboxOf.length == 1) proxy.inboxOf = _2bvRkAFZjMfVD8jiUWZJr5YokSeN_inboxOf[0];
		const _4AHzVZDxHjK6uEWa9UiKHGK34yYm_outboxOf = this.#_4AHzVZDxHjK6uEWa9UiKHGK34yYm_outboxOf.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_4AHzVZDxHjK6uEWa9UiKHGK34yYm_outboxOf.length == 1) proxy.outboxOf = _4AHzVZDxHjK6uEWa9UiKHGK34yYm_outboxOf[0];
		const _41aoZ5M6yRUHy3Zx8q6iuZQxtopb_followersOf = this.#_41aoZ5M6yRUHy3Zx8q6iuZQxtopb_followersOf.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_41aoZ5M6yRUHy3Zx8q6iuZQxtopb_followersOf.length == 1) proxy.followersOf = _41aoZ5M6yRUHy3Zx8q6iuZQxtopb_followersOf[0];
		const _2nXT2Ah42UjEEQF5oJQ39CbKB1xj_followingOf = this.#_2nXT2Ah42UjEEQF5oJQ39CbKB1xj_followingOf.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_2nXT2Ah42UjEEQF5oJQ39CbKB1xj_followingOf.length == 1) proxy.followingOf = _2nXT2Ah42UjEEQF5oJQ39CbKB1xj_followingOf[0];
		const _2bsySzmT3qEZcrnoe3tZ5xBjXSju_likedOf = this.#_2bsySzmT3qEZcrnoe3tZ5xBjXSju_likedOf.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_2bsySzmT3qEZcrnoe3tZ5xBjXSju_likedOf.length == 1) proxy.likedOf = _2bsySzmT3qEZcrnoe3tZ5xBjXSju_likedOf[0];
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "Collection " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "Collection " + inspect(proxy, options);
	}
};
/** Used to represent distinct subsets of items from a `Collection`.
* Refer to the Activity Streams 2.0 Core for a complete description of
* the `CollectionPage` object.
*/
var CollectionPage = class CollectionPage extends Collection {
	/**
	* The type URI of {@link CollectionPage}: `https://www.w3.org/ns/activitystreams#CollectionPage`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#CollectionPage");
	}
	#_2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf = [];
	#_trust_2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf = /* @__PURE__ */ new Set();
	#_3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next = [];
	#_trust_3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next = /* @__PURE__ */ new Set();
	#_3b8yG8tDNzQFFEnWhCc13G8eHooA_prev = [];
	#_trust_3b8yG8tDNzQFFEnWhCc13G8eHooA_prev = /* @__PURE__ */ new Set();
	/**
	* Constructs a new instance of CollectionPage with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
		if ("partOf" in values && values.partOf != null) if (values.partOf instanceof Collection || values.partOf instanceof URL) {
			this.#_2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf = [values.partOf];
			this.#_trust_2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf.add(0);
		} else throw new TypeError("The partOf must be of type Collection | URL.");
		if ("next" in values && values.next != null) if (values.next instanceof CollectionPage || values.next instanceof URL) {
			this.#_3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next = [values.next];
			this.#_trust_3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next.add(0);
		} else throw new TypeError("The next must be of type CollectionPage | URL.");
		if ("prev" in values && values.prev != null) if (values.prev instanceof CollectionPage || values.prev instanceof URL) {
			this.#_3b8yG8tDNzQFFEnWhCc13G8eHooA_prev = [values.prev];
			this.#_trust_3b8yG8tDNzQFFEnWhCc13G8eHooA_prev.add(0);
		} else throw new TypeError("The prev must be of type CollectionPage | URL.");
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		clone.#_2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf = this.#_2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf;
		clone.#_trust_2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf = new Set(this.#_trust_2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf);
		if ("partOf" in values && values.partOf != null) if (values.partOf instanceof Collection || values.partOf instanceof URL) {
			clone.#_2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf = [values.partOf];
			clone.#_trust_2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf = new Set([0]);
		} else throw new TypeError("The partOf must be of type Collection | URL.");
		clone.#_3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next = this.#_3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next;
		clone.#_trust_3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next = new Set(this.#_trust_3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next);
		if ("next" in values && values.next != null) if (values.next instanceof CollectionPage || values.next instanceof URL) {
			clone.#_3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next = [values.next];
			clone.#_trust_3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next = new Set([0]);
		} else throw new TypeError("The next must be of type CollectionPage | URL.");
		clone.#_3b8yG8tDNzQFFEnWhCc13G8eHooA_prev = this.#_3b8yG8tDNzQFFEnWhCc13G8eHooA_prev;
		clone.#_trust_3b8yG8tDNzQFFEnWhCc13G8eHooA_prev = new Set(this.#_trust_3b8yG8tDNzQFFEnWhCc13G8eHooA_prev);
		if ("prev" in values && values.prev != null) if (values.prev instanceof CollectionPage || values.prev instanceof URL) {
			clone.#_3b8yG8tDNzQFFEnWhCc13G8eHooA_prev = [values.prev];
			clone.#_trust_3b8yG8tDNzQFFEnWhCc13G8eHooA_prev = new Set([0]);
		} else throw new TypeError("The prev must be of type CollectionPage | URL.");
		return clone;
	}
	async #fetchPartOf(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#partOf_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #partOf_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Collection.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
	}
	/**
	* Similar to
	* {@link CollectionPage.getPartOf},
	* but returns its `@id` URL instead of the object itself.
	*/
	get partOfId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf.length < 1) return null;
		const v = this.#_2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** Identifies the {@link Collection} to which a {@link CollectionPage} objects
	* items belong.
	*/
	async getPartOf(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf.length < 1) return null;
		let v = this.#_2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchPartOf(v, options);
			if (fetched == null) return null;
			this.#_2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf[0] = fetched;
			this.#_trust_2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "partOf" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["partOf"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#partOf_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchNext(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#next_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #next_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await CollectionPage.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#CollectionPage"].join(", "));
	}
	/**
	* Similar to
	* {@link CollectionPage.getNext},
	* but returns its `@id` URL instead of the object itself.
	*/
	get nextId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next.length < 1) return null;
		const v = this.#_3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** In a paged {@link Collection}, indicates the next page of items.
	*/
	async getNext(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next.length < 1) return null;
		let v = this.#_3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchNext(v, options);
			if (fetched == null) return null;
			this.#_3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next[0] = fetched;
			this.#_trust_3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "next" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["next"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#next_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchPrev(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#prev_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #prev_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await CollectionPage.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#CollectionPage"].join(", "));
	}
	/**
	* Similar to
	* {@link CollectionPage.getPrev},
	* but returns its `@id` URL instead of the object itself.
	*/
	get prevId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3b8yG8tDNzQFFEnWhCc13G8eHooA_prev.length < 1) return null;
		const v = this.#_3b8yG8tDNzQFFEnWhCc13G8eHooA_prev[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** In a paged {@link Collection}, identifies the previous page of items.
	*/
	async getPrev(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3b8yG8tDNzQFFEnWhCc13G8eHooA_prev.length < 1) return null;
		let v = this.#_3b8yG8tDNzQFFEnWhCc13G8eHooA_prev[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_3b8yG8tDNzQFFEnWhCc13G8eHooA_prev.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchPrev(v, options);
			if (fetched == null) return null;
			this.#_3b8yG8tDNzQFFEnWhCc13G8eHooA_prev[0] = fetched;
			this.#_trust_3b8yG8tDNzQFFEnWhCc13G8eHooA_prev.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "prev" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["prev"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#prev_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_3b8yG8tDNzQFFEnWhCc13G8eHooA_prev.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		if (options.format == null && this.isCompactable()) {
			const result = await super.toJsonLd({
				...options,
				format: void 0,
				context: void 0
			});
			let compactItems;
			compactItems = [];
			for (const v of this.#_2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["partOf"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["next"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_3b8yG8tDNzQFFEnWhCc13G8eHooA_prev) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["prev"] = compactItems.length > 1 ? compactItems : compactItems[0];
			result["type"] = "CollectionPage";
			if (this.id != null) result["id"] = this.id.href;
			result["@context"] = [
				"https://www.w3.org/ns/activitystreams",
				"https://w3id.org/security/data-integrity/v1",
				{
					"toot": "http://joinmastodon.org/ns#",
					"misskey": "https://misskey-hub.net/ns#",
					"fedibird": "http://fedibird.com/ns#",
					"ChatMessage": "http://litepub.social/ns#ChatMessage",
					"sensitive": "as:sensitive",
					"votersCount": "toot:votersCount",
					"Emoji": "toot:Emoji",
					"Hashtag": "as:Hashtag",
					"quoteUrl": "as:quoteUrl",
					"_misskey_quote": "misskey:_misskey_quote",
					"quoteUri": "fedibird:quoteUri",
					"emojiReactions": {
						"@id": "fedibird:emojiReactions",
						"@type": "@id"
					}
				}
			];
			return result;
		}
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		array = [];
		for (const v of this.#_2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#partOf"] = propValue;
		}
		array = [];
		for (const v of this.#_3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#next"] = propValue;
		}
		array = [];
		for (const v of this.#_3b8yG8tDNzQFFEnWhCc13G8eHooA_prev) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#prev"] = propValue;
		}
		values["@type"] = ["https://www.w3.org/ns/activitystreams#CollectionPage"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? [
			"https://www.w3.org/ns/activitystreams",
			"https://w3id.org/security/data-integrity/v1",
			{
				"toot": "http://joinmastodon.org/ns#",
				"misskey": "https://misskey-hub.net/ns#",
				"fedibird": "http://fedibird.com/ns#",
				"ChatMessage": "http://litepub.social/ns#ChatMessage",
				"sensitive": "as:sensitive",
				"votersCount": "toot:votersCount",
				"Emoji": "toot:Emoji",
				"Hashtag": "as:Hashtag",
				"quoteUrl": "as:quoteUrl",
				"_misskey_quote": "misskey:_misskey_quote",
				"quoteUri": "fedibird:quoteUri",
				"emojiReactions": {
					"@id": "fedibird:emojiReactions",
					"@type": "@id"
				}
			}
		];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {
			if ("proof" in compacted && compacted.proof != null) if (Array.isArray(compacted.proof)) for (const element of compacted.proof) element["@context"] = docContext;
			else compacted.proof["@context"] = docContext;
		}
		return compacted;
	}
	isCompactable() {
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__CollectionPage__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__CollectionPage__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#OrderedCollectionPage")) return await OrderedCollectionPage.fromJsonLd(json, options);
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#CollectionPage")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof CollectionPage)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		const _2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf = [];
		const _trust_2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf = /* @__PURE__ */ new Set();
		let _2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf__array = values["https://www.w3.org/ns/activitystreams#partOf"];
		for (const v of _2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf__array == null ? [] : _2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf__array.length === 1 && "@list" in _2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf__array[0] ? _2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf__array[0]["@list"] : _2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf.push(await Collection.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf = _2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf;
		const _3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next = [];
		const _trust_3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next = /* @__PURE__ */ new Set();
		let _3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next__array = values["https://www.w3.org/ns/activitystreams#next"];
		for (const v of _3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next__array == null ? [] : _3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next__array.length === 1 && "@list" in _3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next__array[0] ? _3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next__array[0]["@list"] : _3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next.push(await CollectionPage.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next = _3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next;
		const _3b8yG8tDNzQFFEnWhCc13G8eHooA_prev = [];
		const _trust_3b8yG8tDNzQFFEnWhCc13G8eHooA_prev = /* @__PURE__ */ new Set();
		let _3b8yG8tDNzQFFEnWhCc13G8eHooA_prev__array = values["https://www.w3.org/ns/activitystreams#prev"];
		for (const v of _3b8yG8tDNzQFFEnWhCc13G8eHooA_prev__array == null ? [] : _3b8yG8tDNzQFFEnWhCc13G8eHooA_prev__array.length === 1 && "@list" in _3b8yG8tDNzQFFEnWhCc13G8eHooA_prev__array[0] ? _3b8yG8tDNzQFFEnWhCc13G8eHooA_prev__array[0]["@list"] : _3b8yG8tDNzQFFEnWhCc13G8eHooA_prev__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_3b8yG8tDNzQFFEnWhCc13G8eHooA_prev.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_3b8yG8tDNzQFFEnWhCc13G8eHooA_prev.push(await CollectionPage.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_3b8yG8tDNzQFFEnWhCc13G8eHooA_prev = _3b8yG8tDNzQFFEnWhCc13G8eHooA_prev;
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		const _2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf = this.#_2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf.length == 1) proxy.partOf = _2kWgBhQKjEauxx8C6qF3ZQamK4Le_partOf[0];
		const _3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next = this.#_3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next.length == 1) proxy.next = _3BT4kQLcXhHx7TAWaNDKh8nFn9eY_next[0];
		const _3b8yG8tDNzQFFEnWhCc13G8eHooA_prev = this.#_3b8yG8tDNzQFFEnWhCc13G8eHooA_prev.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3b8yG8tDNzQFFEnWhCc13G8eHooA_prev.length == 1) proxy.prev = _3b8yG8tDNzQFFEnWhCc13G8eHooA_prev[0];
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "CollectionPage " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "CollectionPage " + inspect(proxy, options);
	}
};
/** Indicates that the `actor` has created the `object`.
*/
var Create = class Create extends Activity {
	/**
	* The type URI of {@link Create}: `https://www.w3.org/ns/activitystreams#Create`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#Create");
	}
	/**
	* Constructs a new instance of Create with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		return clone;
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		values["@type"] = ["https://www.w3.org/ns/activitystreams#Create"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? [
			"https://w3id.org/identity/v1",
			"https://www.w3.org/ns/activitystreams",
			"https://w3id.org/security/data-integrity/v1",
			{
				"toot": "http://joinmastodon.org/ns#",
				"misskey": "https://misskey-hub.net/ns#",
				"fedibird": "http://fedibird.com/ns#",
				"sensitive": "as:sensitive",
				"votersCount": {
					"@id": "toot:votersCount",
					"@type": "http://www.w3.org/2001/XMLSchema#nonNegativeInteger"
				},
				"Emoji": "toot:Emoji",
				"Hashtag": "as:Hashtag",
				"ChatMessage": "http://litepub.social/ns#ChatMessage",
				"quoteUrl": "as:quoteUrl",
				"_misskey_quote": "misskey:_misskey_quote",
				"quoteUri": "fedibird:quoteUri",
				"emojiReactions": {
					"@id": "fedibird:emojiReactions",
					"@type": "@id"
				}
			}
		];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {
			if ("proof" in compacted && compacted.proof != null) if (Array.isArray(compacted.proof)) for (const element of compacted.proof) element["@context"] = docContext;
			else compacted.proof["@context"] = docContext;
		}
		return compacted;
	}
	isCompactable() {
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__Create__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__Create__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Create")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof Create)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "Create " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "Create " + inspect(proxy, options);
	}
};
/** Indicates that the `actor` has deleted the `object`.  If specified,
* the `origin` indicates the context from which the `object` was deleted.
*/
var Delete = class Delete extends Activity {
	/**
	* The type URI of {@link Delete}: `https://www.w3.org/ns/activitystreams#Delete`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#Delete");
	}
	/**
	* Constructs a new instance of Delete with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		return clone;
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		values["@type"] = ["https://www.w3.org/ns/activitystreams#Delete"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? [
			"https://w3id.org/identity/v1",
			"https://www.w3.org/ns/activitystreams",
			"https://w3id.org/security/data-integrity/v1",
			{
				"toot": "http://joinmastodon.org/ns#",
				"misskey": "https://misskey-hub.net/ns#",
				"fedibird": "http://fedibird.com/ns#",
				"sensitive": "as:sensitive",
				"votersCount": {
					"@id": "toot:votersCount",
					"@type": "http://www.w3.org/2001/XMLSchema#nonNegativeInteger"
				},
				"Emoji": "toot:Emoji",
				"Hashtag": "as:Hashtag",
				"ChatMessage": "http://litepub.social/ns#ChatMessage",
				"quoteUrl": "as:quoteUrl",
				"_misskey_quote": "misskey:_misskey_quote",
				"quoteUri": "fedibird:quoteUri"
			}
		];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {
			if ("proof" in compacted && compacted.proof != null) if (Array.isArray(compacted.proof)) for (const element of compacted.proof) element["@context"] = docContext;
			else compacted.proof["@context"] = docContext;
		}
		return compacted;
	}
	isCompactable() {
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__Delete__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__Delete__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Delete")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof Delete)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "Delete " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "Delete " + inspect(proxy, options);
	}
};
/** Indicates that the `actor` dislikes the `object`.
*/
var Dislike = class Dislike extends Activity {
	/**
	* The type URI of {@link Dislike}: `https://www.w3.org/ns/activitystreams#Dislike`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#Dislike");
	}
	/**
	* Constructs a new instance of Dislike with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		return clone;
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		values["@type"] = ["https://www.w3.org/ns/activitystreams#Dislike"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? [
			"https://w3id.org/identity/v1",
			"https://www.w3.org/ns/activitystreams",
			"https://w3id.org/security/data-integrity/v1",
			{
				"toot": "http://joinmastodon.org/ns#",
				"Emoji": "toot:Emoji"
			}
		];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {
			if ("proof" in compacted && compacted.proof != null) if (Array.isArray(compacted.proof)) for (const element of compacted.proof) element["@context"] = docContext;
			else compacted.proof["@context"] = docContext;
		}
		return compacted;
	}
	isCompactable() {
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__Dislike__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__Dislike__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Dislike")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof Dislike)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "Dislike " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "Dislike " + inspect(proxy, options);
	}
};
/** Contents of {@link Actor}'s `endpoints`.
*/
var Endpoints = class {
	#documentLoader;
	#contextLoader;
	#tracerProvider;
	#warning;
	#cachedJsonLd;
	id;
	get _documentLoader() {
		return this.#documentLoader;
	}
	get _contextLoader() {
		return this.#contextLoader;
	}
	get _tracerProvider() {
		return this.#tracerProvider;
	}
	get _warning() {
		return this.#warning;
	}
	get _cachedJsonLd() {
		return this.#cachedJsonLd;
	}
	set _cachedJsonLd(value) {
		this.#cachedJsonLd = value;
	}
	/**
	* The type URI of {@link Endpoints}: `https://www.w3.org/ns/activitystreams#Endpoints`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#Endpoints");
	}
	#_2JCYDbSxEHCCLdBYed33cCETfGyR_proxyUrl = [];
	#_25S6UmgzDead8hxL5sQFezZTAusd_oauthAuthorizationEndpoint = [];
	#_iAMxqrSba7yBCRB1FZ5kEVdKEZ3_oauthTokenEndpoint = [];
	#_8Bx9qN8oU7Bpt2xi6khaxWp1gMr_provideClientKey = [];
	#_3dU7PMVQZJpsCpo2F4RQXxBXdPmS_signClientKey = [];
	#_3JprUSDLVqqX4dwHRi37qGZZCRCc_sharedInbox = [];
	/**
	* Constructs a new instance of Endpoints with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		this.#documentLoader = options.documentLoader;
		this.#contextLoader = options.contextLoader;
		this.#tracerProvider = options.tracerProvider;
		if ("$warning" in options) this.#warning = options.$warning;
		if (values.id == null || values.id instanceof URL) this.id = values.id ?? null;
		else throw new TypeError("The id must be a URL.");
		if ("proxyUrl" in values && values.proxyUrl != null) if (values.proxyUrl instanceof URL) this.#_2JCYDbSxEHCCLdBYed33cCETfGyR_proxyUrl = [values.proxyUrl];
		else throw new TypeError("The proxyUrl must be of type URL.");
		if ("oauthAuthorizationEndpoint" in values && values.oauthAuthorizationEndpoint != null) if (values.oauthAuthorizationEndpoint instanceof URL) this.#_25S6UmgzDead8hxL5sQFezZTAusd_oauthAuthorizationEndpoint = [values.oauthAuthorizationEndpoint];
		else throw new TypeError("The oauthAuthorizationEndpoint must be of type URL.");
		if ("oauthTokenEndpoint" in values && values.oauthTokenEndpoint != null) if (values.oauthTokenEndpoint instanceof URL) this.#_iAMxqrSba7yBCRB1FZ5kEVdKEZ3_oauthTokenEndpoint = [values.oauthTokenEndpoint];
		else throw new TypeError("The oauthTokenEndpoint must be of type URL.");
		if ("provideClientKey" in values && values.provideClientKey != null) if (values.provideClientKey instanceof URL) this.#_8Bx9qN8oU7Bpt2xi6khaxWp1gMr_provideClientKey = [values.provideClientKey];
		else throw new TypeError("The provideClientKey must be of type URL.");
		if ("signClientKey" in values && values.signClientKey != null) if (values.signClientKey instanceof URL) this.#_3dU7PMVQZJpsCpo2F4RQXxBXdPmS_signClientKey = [values.signClientKey];
		else throw new TypeError("The signClientKey must be of type URL.");
		if ("sharedInbox" in values && values.sharedInbox != null) if (values.sharedInbox instanceof URL) this.#_3JprUSDLVqqX4dwHRi37qGZZCRCc_sharedInbox = [values.sharedInbox];
		else throw new TypeError("The sharedInbox must be of type URL.");
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = new this.constructor({ id: values.id ?? this.id }, options);
		clone.#_2JCYDbSxEHCCLdBYed33cCETfGyR_proxyUrl = this.#_2JCYDbSxEHCCLdBYed33cCETfGyR_proxyUrl;
		if ("proxyUrl" in values && values.proxyUrl != null) if (values.proxyUrl instanceof URL) clone.#_2JCYDbSxEHCCLdBYed33cCETfGyR_proxyUrl = [values.proxyUrl];
		else throw new TypeError("The proxyUrl must be of type URL.");
		clone.#_25S6UmgzDead8hxL5sQFezZTAusd_oauthAuthorizationEndpoint = this.#_25S6UmgzDead8hxL5sQFezZTAusd_oauthAuthorizationEndpoint;
		if ("oauthAuthorizationEndpoint" in values && values.oauthAuthorizationEndpoint != null) if (values.oauthAuthorizationEndpoint instanceof URL) clone.#_25S6UmgzDead8hxL5sQFezZTAusd_oauthAuthorizationEndpoint = [values.oauthAuthorizationEndpoint];
		else throw new TypeError("The oauthAuthorizationEndpoint must be of type URL.");
		clone.#_iAMxqrSba7yBCRB1FZ5kEVdKEZ3_oauthTokenEndpoint = this.#_iAMxqrSba7yBCRB1FZ5kEVdKEZ3_oauthTokenEndpoint;
		if ("oauthTokenEndpoint" in values && values.oauthTokenEndpoint != null) if (values.oauthTokenEndpoint instanceof URL) clone.#_iAMxqrSba7yBCRB1FZ5kEVdKEZ3_oauthTokenEndpoint = [values.oauthTokenEndpoint];
		else throw new TypeError("The oauthTokenEndpoint must be of type URL.");
		clone.#_8Bx9qN8oU7Bpt2xi6khaxWp1gMr_provideClientKey = this.#_8Bx9qN8oU7Bpt2xi6khaxWp1gMr_provideClientKey;
		if ("provideClientKey" in values && values.provideClientKey != null) if (values.provideClientKey instanceof URL) clone.#_8Bx9qN8oU7Bpt2xi6khaxWp1gMr_provideClientKey = [values.provideClientKey];
		else throw new TypeError("The provideClientKey must be of type URL.");
		clone.#_3dU7PMVQZJpsCpo2F4RQXxBXdPmS_signClientKey = this.#_3dU7PMVQZJpsCpo2F4RQXxBXdPmS_signClientKey;
		if ("signClientKey" in values && values.signClientKey != null) if (values.signClientKey instanceof URL) clone.#_3dU7PMVQZJpsCpo2F4RQXxBXdPmS_signClientKey = [values.signClientKey];
		else throw new TypeError("The signClientKey must be of type URL.");
		clone.#_3JprUSDLVqqX4dwHRi37qGZZCRCc_sharedInbox = this.#_3JprUSDLVqqX4dwHRi37qGZZCRCc_sharedInbox;
		if ("sharedInbox" in values && values.sharedInbox != null) if (values.sharedInbox instanceof URL) clone.#_3JprUSDLVqqX4dwHRi37qGZZCRCc_sharedInbox = [values.sharedInbox];
		else throw new TypeError("The sharedInbox must be of type URL.");
		return clone;
	}
	/** Endpoint URI so this actor's clients may access remote ActivityStreams
	* objects which require authentication to access.  To use this endpoint,
	* the client posts an `x-www-form-urlencoded` `id` parameter with the value
	* being the `id` of the requested ActivityStreams object.
	*/
	get proxyUrl() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2JCYDbSxEHCCLdBYed33cCETfGyR_proxyUrl.length < 1) return null;
		return this.#_2JCYDbSxEHCCLdBYed33cCETfGyR_proxyUrl[0];
	}
	/** If OAuth 2.0 bearer tokens [RFC 6749] [RFC 6750] are being used for
	* authenticating [client to server
	* interactions](https://www.w3.org/TR/activitypub/#client-to-server-interactions),
	* this endpoint specifies a URI at which a browser-authenticated user may
	* obtain a new authorization grant.
	*/
	get oauthAuthorizationEndpoint() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_25S6UmgzDead8hxL5sQFezZTAusd_oauthAuthorizationEndpoint.length < 1) return null;
		return this.#_25S6UmgzDead8hxL5sQFezZTAusd_oauthAuthorizationEndpoint[0];
	}
	/** If OAuth 2.0 bearer tokens [RFC 6749] [RFC 6750] are being used for
	* authenticating [client to server
	* interactions](https://www.w3.org/TR/activitypub/#client-to-server-interactions),
	* this endpoint specifies a URI at which a client may acquire an access token.
	*/
	get oauthTokenEndpoint() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_iAMxqrSba7yBCRB1FZ5kEVdKEZ3_oauthTokenEndpoint.length < 1) return null;
		return this.#_iAMxqrSba7yBCRB1FZ5kEVdKEZ3_oauthTokenEndpoint[0];
	}
	/** If Linked Data Signatures and HTTP Signatures are being used for
	* authentication and authorization, this endpoint specifies a URI at which
	* browser-authenticated users may authorize a client's public key for [client
	* to server interactions](https://www.w3.org/TR/activitypub/#client-to-server-interactions).
	*/
	get provideClientKey() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_8Bx9qN8oU7Bpt2xi6khaxWp1gMr_provideClientKey.length < 1) return null;
		return this.#_8Bx9qN8oU7Bpt2xi6khaxWp1gMr_provideClientKey[0];
	}
	/** If Linked Data Signatures and HTTP Signatures are being used for
	* authentication and authorization, this endpoint specifies a URI at which
	* a client key may be signed by the actor's key for a time window to act on
	* behalf of the actor in interacting with foreign servers.
	*/
	get signClientKey() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3dU7PMVQZJpsCpo2F4RQXxBXdPmS_signClientKey.length < 1) return null;
		return this.#_3dU7PMVQZJpsCpo2F4RQXxBXdPmS_signClientKey[0];
	}
	/** An optional endpoint [used for wide delivery of publicly addressed
	* activities and activities sent to
	* followers](https://www.w3.org/TR/activitypub/#shared-inbox-delivery).
	* `sharedInbox` endpoints SHOULD also be publicly readable
	* {@link OrderedCollection} objects containing objects addressed to the
	* [Public](https://www.w3.org/TR/activitypub/#public-addressing) special
	* collection.  Reading from the `sharedInbox` endpoint MUST NOT present
	* objects which are not addressed to the `Public`` endpoint.
	*/
	get sharedInbox() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3JprUSDLVqqX4dwHRi37qGZZCRCc_sharedInbox.length < 1) return null;
		return this.#_3JprUSDLVqqX4dwHRi37qGZZCRCc_sharedInbox[0];
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		if (options.format == null && this.isCompactable()) {
			const result = {};
			let compactItems;
			compactItems = [];
			for (const v of this.#_2JCYDbSxEHCCLdBYed33cCETfGyR_proxyUrl) {
				const item = v.href;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["proxyUrl"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_25S6UmgzDead8hxL5sQFezZTAusd_oauthAuthorizationEndpoint) {
				const item = v.href;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["oauthAuthorizationEndpoint"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_iAMxqrSba7yBCRB1FZ5kEVdKEZ3_oauthTokenEndpoint) {
				const item = v.href;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["oauthTokenEndpoint"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_8Bx9qN8oU7Bpt2xi6khaxWp1gMr_provideClientKey) {
				const item = v.href;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["provideClientKey"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_3dU7PMVQZJpsCpo2F4RQXxBXdPmS_signClientKey) {
				const item = v.href;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["signClientKey"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_3JprUSDLVqqX4dwHRi37qGZZCRCc_sharedInbox) {
				const item = v.href;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["sharedInbox"] = compactItems.length > 1 ? compactItems : compactItems[0];
			result["type"] = "as:Endpoints";
			if (this.id != null) result["id"] = this.id.href;
			result["@context"] = "https://www.w3.org/ns/activitystreams";
			return result;
		}
		let array;
		const values = {};
		array = [];
		for (const v of this.#_2JCYDbSxEHCCLdBYed33cCETfGyR_proxyUrl) {
			const element = { "@id": v.href };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#proxyUrl"] = propValue;
		}
		array = [];
		for (const v of this.#_25S6UmgzDead8hxL5sQFezZTAusd_oauthAuthorizationEndpoint) {
			const element = { "@id": v.href };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#oauthAuthorizationEndpoint"] = propValue;
		}
		array = [];
		for (const v of this.#_iAMxqrSba7yBCRB1FZ5kEVdKEZ3_oauthTokenEndpoint) {
			const element = { "@id": v.href };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#oauthTokenEndpoint"] = propValue;
		}
		array = [];
		for (const v of this.#_8Bx9qN8oU7Bpt2xi6khaxWp1gMr_provideClientKey) {
			const element = { "@id": v.href };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#provideClientKey"] = propValue;
		}
		array = [];
		for (const v of this.#_3dU7PMVQZJpsCpo2F4RQXxBXdPmS_signClientKey) {
			const element = { "@id": v.href };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#signClientKey"] = propValue;
		}
		array = [];
		for (const v of this.#_3JprUSDLVqqX4dwHRi37qGZZCRCc_sharedInbox) {
			const element = { "@id": v.href };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#sharedInbox"] = propValue;
		}
		values["@type"] = ["https://www.w3.org/ns/activitystreams#Endpoints"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? "https://www.w3.org/ns/activitystreams";
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {}
		return compacted;
	}
	isCompactable() {
		return true;
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__Endpoints__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__Endpoints__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Endpoints")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		const instance = new this({ id: "@id" in values ? new URL(values["@id"]) : void 0 }, options);
		const _2JCYDbSxEHCCLdBYed33cCETfGyR_proxyUrl = [];
		let _2JCYDbSxEHCCLdBYed33cCETfGyR_proxyUrl__array = values["https://www.w3.org/ns/activitystreams#proxyUrl"];
		for (const v of _2JCYDbSxEHCCLdBYed33cCETfGyR_proxyUrl__array == null ? [] : _2JCYDbSxEHCCLdBYed33cCETfGyR_proxyUrl__array.length === 1 && "@list" in _2JCYDbSxEHCCLdBYed33cCETfGyR_proxyUrl__array[0] ? _2JCYDbSxEHCCLdBYed33cCETfGyR_proxyUrl__array[0]["@list"] : _2JCYDbSxEHCCLdBYed33cCETfGyR_proxyUrl__array) {
			if (v == null) continue;
			_2JCYDbSxEHCCLdBYed33cCETfGyR_proxyUrl.push(v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].includes("/", 5) ? v["@id"].slice(5, v["@id"].indexOf("/", 5)) : v["@id"].slice(5)) + (v["@id"].includes("/", 5) ? v["@id"].slice(v["@id"].indexOf("/", 5)) : "")) : URL.canParse(v["@id"]) && (values["@id"] == null ? options.baseUrl : new URL(values["@id"])) ? new URL(v["@id"]) : new URL(v["@id"], values["@id"] == null ? options.baseUrl : new URL(values["@id"])));
		}
		instance.#_2JCYDbSxEHCCLdBYed33cCETfGyR_proxyUrl = _2JCYDbSxEHCCLdBYed33cCETfGyR_proxyUrl;
		const _25S6UmgzDead8hxL5sQFezZTAusd_oauthAuthorizationEndpoint = [];
		let _25S6UmgzDead8hxL5sQFezZTAusd_oauthAuthorizationEndpoint__array = values["https://www.w3.org/ns/activitystreams#oauthAuthorizationEndpoint"];
		for (const v of _25S6UmgzDead8hxL5sQFezZTAusd_oauthAuthorizationEndpoint__array == null ? [] : _25S6UmgzDead8hxL5sQFezZTAusd_oauthAuthorizationEndpoint__array.length === 1 && "@list" in _25S6UmgzDead8hxL5sQFezZTAusd_oauthAuthorizationEndpoint__array[0] ? _25S6UmgzDead8hxL5sQFezZTAusd_oauthAuthorizationEndpoint__array[0]["@list"] : _25S6UmgzDead8hxL5sQFezZTAusd_oauthAuthorizationEndpoint__array) {
			if (v == null) continue;
			_25S6UmgzDead8hxL5sQFezZTAusd_oauthAuthorizationEndpoint.push(v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].includes("/", 5) ? v["@id"].slice(5, v["@id"].indexOf("/", 5)) : v["@id"].slice(5)) + (v["@id"].includes("/", 5) ? v["@id"].slice(v["@id"].indexOf("/", 5)) : "")) : URL.canParse(v["@id"]) && (values["@id"] == null ? options.baseUrl : new URL(values["@id"])) ? new URL(v["@id"]) : new URL(v["@id"], values["@id"] == null ? options.baseUrl : new URL(values["@id"])));
		}
		instance.#_25S6UmgzDead8hxL5sQFezZTAusd_oauthAuthorizationEndpoint = _25S6UmgzDead8hxL5sQFezZTAusd_oauthAuthorizationEndpoint;
		const _iAMxqrSba7yBCRB1FZ5kEVdKEZ3_oauthTokenEndpoint = [];
		let _iAMxqrSba7yBCRB1FZ5kEVdKEZ3_oauthTokenEndpoint__array = values["https://www.w3.org/ns/activitystreams#oauthTokenEndpoint"];
		for (const v of _iAMxqrSba7yBCRB1FZ5kEVdKEZ3_oauthTokenEndpoint__array == null ? [] : _iAMxqrSba7yBCRB1FZ5kEVdKEZ3_oauthTokenEndpoint__array.length === 1 && "@list" in _iAMxqrSba7yBCRB1FZ5kEVdKEZ3_oauthTokenEndpoint__array[0] ? _iAMxqrSba7yBCRB1FZ5kEVdKEZ3_oauthTokenEndpoint__array[0]["@list"] : _iAMxqrSba7yBCRB1FZ5kEVdKEZ3_oauthTokenEndpoint__array) {
			if (v == null) continue;
			_iAMxqrSba7yBCRB1FZ5kEVdKEZ3_oauthTokenEndpoint.push(v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].includes("/", 5) ? v["@id"].slice(5, v["@id"].indexOf("/", 5)) : v["@id"].slice(5)) + (v["@id"].includes("/", 5) ? v["@id"].slice(v["@id"].indexOf("/", 5)) : "")) : URL.canParse(v["@id"]) && (values["@id"] == null ? options.baseUrl : new URL(values["@id"])) ? new URL(v["@id"]) : new URL(v["@id"], values["@id"] == null ? options.baseUrl : new URL(values["@id"])));
		}
		instance.#_iAMxqrSba7yBCRB1FZ5kEVdKEZ3_oauthTokenEndpoint = _iAMxqrSba7yBCRB1FZ5kEVdKEZ3_oauthTokenEndpoint;
		const _8Bx9qN8oU7Bpt2xi6khaxWp1gMr_provideClientKey = [];
		let _8Bx9qN8oU7Bpt2xi6khaxWp1gMr_provideClientKey__array = values["https://www.w3.org/ns/activitystreams#provideClientKey"];
		for (const v of _8Bx9qN8oU7Bpt2xi6khaxWp1gMr_provideClientKey__array == null ? [] : _8Bx9qN8oU7Bpt2xi6khaxWp1gMr_provideClientKey__array.length === 1 && "@list" in _8Bx9qN8oU7Bpt2xi6khaxWp1gMr_provideClientKey__array[0] ? _8Bx9qN8oU7Bpt2xi6khaxWp1gMr_provideClientKey__array[0]["@list"] : _8Bx9qN8oU7Bpt2xi6khaxWp1gMr_provideClientKey__array) {
			if (v == null) continue;
			_8Bx9qN8oU7Bpt2xi6khaxWp1gMr_provideClientKey.push(v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].includes("/", 5) ? v["@id"].slice(5, v["@id"].indexOf("/", 5)) : v["@id"].slice(5)) + (v["@id"].includes("/", 5) ? v["@id"].slice(v["@id"].indexOf("/", 5)) : "")) : URL.canParse(v["@id"]) && (values["@id"] == null ? options.baseUrl : new URL(values["@id"])) ? new URL(v["@id"]) : new URL(v["@id"], values["@id"] == null ? options.baseUrl : new URL(values["@id"])));
		}
		instance.#_8Bx9qN8oU7Bpt2xi6khaxWp1gMr_provideClientKey = _8Bx9qN8oU7Bpt2xi6khaxWp1gMr_provideClientKey;
		const _3dU7PMVQZJpsCpo2F4RQXxBXdPmS_signClientKey = [];
		let _3dU7PMVQZJpsCpo2F4RQXxBXdPmS_signClientKey__array = values["https://www.w3.org/ns/activitystreams#signClientKey"];
		for (const v of _3dU7PMVQZJpsCpo2F4RQXxBXdPmS_signClientKey__array == null ? [] : _3dU7PMVQZJpsCpo2F4RQXxBXdPmS_signClientKey__array.length === 1 && "@list" in _3dU7PMVQZJpsCpo2F4RQXxBXdPmS_signClientKey__array[0] ? _3dU7PMVQZJpsCpo2F4RQXxBXdPmS_signClientKey__array[0]["@list"] : _3dU7PMVQZJpsCpo2F4RQXxBXdPmS_signClientKey__array) {
			if (v == null) continue;
			_3dU7PMVQZJpsCpo2F4RQXxBXdPmS_signClientKey.push(v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].includes("/", 5) ? v["@id"].slice(5, v["@id"].indexOf("/", 5)) : v["@id"].slice(5)) + (v["@id"].includes("/", 5) ? v["@id"].slice(v["@id"].indexOf("/", 5)) : "")) : URL.canParse(v["@id"]) && (values["@id"] == null ? options.baseUrl : new URL(values["@id"])) ? new URL(v["@id"]) : new URL(v["@id"], values["@id"] == null ? options.baseUrl : new URL(values["@id"])));
		}
		instance.#_3dU7PMVQZJpsCpo2F4RQXxBXdPmS_signClientKey = _3dU7PMVQZJpsCpo2F4RQXxBXdPmS_signClientKey;
		const _3JprUSDLVqqX4dwHRi37qGZZCRCc_sharedInbox = [];
		let _3JprUSDLVqqX4dwHRi37qGZZCRCc_sharedInbox__array = values["https://www.w3.org/ns/activitystreams#sharedInbox"];
		for (const v of _3JprUSDLVqqX4dwHRi37qGZZCRCc_sharedInbox__array == null ? [] : _3JprUSDLVqqX4dwHRi37qGZZCRCc_sharedInbox__array.length === 1 && "@list" in _3JprUSDLVqqX4dwHRi37qGZZCRCc_sharedInbox__array[0] ? _3JprUSDLVqqX4dwHRi37qGZZCRCc_sharedInbox__array[0]["@list"] : _3JprUSDLVqqX4dwHRi37qGZZCRCc_sharedInbox__array) {
			if (v == null) continue;
			_3JprUSDLVqqX4dwHRi37qGZZCRCc_sharedInbox.push(v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].includes("/", 5) ? v["@id"].slice(5, v["@id"].indexOf("/", 5)) : v["@id"].slice(5)) + (v["@id"].includes("/", 5) ? v["@id"].slice(v["@id"].indexOf("/", 5)) : "")) : URL.canParse(v["@id"]) && (values["@id"] == null ? options.baseUrl : new URL(values["@id"])) ? new URL(v["@id"]) : new URL(v["@id"], values["@id"] == null ? options.baseUrl : new URL(values["@id"])));
		}
		instance.#_3JprUSDLVqqX4dwHRi37qGZZCRCc_sharedInbox = _3JprUSDLVqqX4dwHRi37qGZZCRCc_sharedInbox;
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = {};
		if (this.id != null) proxy.id = {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(this.id.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(this.id.href, options)
		};
		const _2JCYDbSxEHCCLdBYed33cCETfGyR_proxyUrl = this.#_2JCYDbSxEHCCLdBYed33cCETfGyR_proxyUrl.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_2JCYDbSxEHCCLdBYed33cCETfGyR_proxyUrl.length == 1) proxy.proxyUrl = _2JCYDbSxEHCCLdBYed33cCETfGyR_proxyUrl[0];
		const _25S6UmgzDead8hxL5sQFezZTAusd_oauthAuthorizationEndpoint = this.#_25S6UmgzDead8hxL5sQFezZTAusd_oauthAuthorizationEndpoint.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_25S6UmgzDead8hxL5sQFezZTAusd_oauthAuthorizationEndpoint.length == 1) proxy.oauthAuthorizationEndpoint = _25S6UmgzDead8hxL5sQFezZTAusd_oauthAuthorizationEndpoint[0];
		const _iAMxqrSba7yBCRB1FZ5kEVdKEZ3_oauthTokenEndpoint = this.#_iAMxqrSba7yBCRB1FZ5kEVdKEZ3_oauthTokenEndpoint.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_iAMxqrSba7yBCRB1FZ5kEVdKEZ3_oauthTokenEndpoint.length == 1) proxy.oauthTokenEndpoint = _iAMxqrSba7yBCRB1FZ5kEVdKEZ3_oauthTokenEndpoint[0];
		const _8Bx9qN8oU7Bpt2xi6khaxWp1gMr_provideClientKey = this.#_8Bx9qN8oU7Bpt2xi6khaxWp1gMr_provideClientKey.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_8Bx9qN8oU7Bpt2xi6khaxWp1gMr_provideClientKey.length == 1) proxy.provideClientKey = _8Bx9qN8oU7Bpt2xi6khaxWp1gMr_provideClientKey[0];
		const _3dU7PMVQZJpsCpo2F4RQXxBXdPmS_signClientKey = this.#_3dU7PMVQZJpsCpo2F4RQXxBXdPmS_signClientKey.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3dU7PMVQZJpsCpo2F4RQXxBXdPmS_signClientKey.length == 1) proxy.signClientKey = _3dU7PMVQZJpsCpo2F4RQXxBXdPmS_signClientKey[0];
		const _3JprUSDLVqqX4dwHRi37qGZZCRCc_sharedInbox = this.#_3JprUSDLVqqX4dwHRi37qGZZCRCc_sharedInbox.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3JprUSDLVqqX4dwHRi37qGZZCRCc_sharedInbox.length == 1) proxy.sharedInbox = _3JprUSDLVqqX4dwHRi37qGZZCRCc_sharedInbox[0];
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "Endpoints " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "Endpoints " + inspect(proxy, options);
	}
};
/** Represents any kind of event.
*/
var Event = class Event extends Object$1 {
	/**
	* The type URI of {@link Event}: `https://www.w3.org/ns/activitystreams#Event`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#Event");
	}
	/**
	* Constructs a new instance of Event with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		return clone;
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		if (options.format == null && this.isCompactable()) {
			const result = await super.toJsonLd({
				...options,
				format: void 0,
				context: void 0
			});
			let compactItems;
			result["type"] = "Event";
			if (this.id != null) result["id"] = this.id.href;
			result["@context"] = ["https://www.w3.org/ns/activitystreams", "https://w3id.org/security/data-integrity/v1"];
			return result;
		}
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		values["@type"] = ["https://www.w3.org/ns/activitystreams#Event"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? ["https://www.w3.org/ns/activitystreams", "https://w3id.org/security/data-integrity/v1"];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {
			if ("proof" in compacted && compacted.proof != null) if (Array.isArray(compacted.proof)) for (const element of compacted.proof) element["@context"] = docContext;
			else compacted.proof["@context"] = docContext;
		}
		return compacted;
	}
	isCompactable() {
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__Event__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__Event__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Event")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof Event)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "Event " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "Event " + inspect(proxy, options);
	}
};
/** Indicates that the `actor` is "flagging" the `object`.  Flagging is defined
* in the sense common to many social platforms as reporting content as being
* inappropriate for any number of reasons.
*/
var Flag = class Flag extends Activity {
	/**
	* The type URI of {@link Flag}: `https://www.w3.org/ns/activitystreams#Flag`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#Flag");
	}
	/**
	* Constructs a new instance of Flag with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		return clone;
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		values["@type"] = ["https://www.w3.org/ns/activitystreams#Flag"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? [
			"https://w3id.org/identity/v1",
			"https://www.w3.org/ns/activitystreams",
			"https://w3id.org/security/data-integrity/v1"
		];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {
			if ("proof" in compacted && compacted.proof != null) if (Array.isArray(compacted.proof)) for (const element of compacted.proof) element["@context"] = docContext;
			else compacted.proof["@context"] = docContext;
		}
		return compacted;
	}
	isCompactable() {
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__Flag__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__Flag__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Flag")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof Flag)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "Flag " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "Flag " + inspect(proxy, options);
	}
};
/** Indicates that the `actor` is "following" the `object`.  Following is defined
* in the sense typically used within Social systems in which the actor is
* interested in any activity performed by or on the object.  The `target` and
* `origin` typically have no defined meaning.
*/
var Follow = class Follow extends Activity {
	/**
	* The type URI of {@link Follow}: `https://www.w3.org/ns/activitystreams#Follow`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#Follow");
	}
	/**
	* Constructs a new instance of Follow with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		return clone;
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		values["@type"] = ["https://www.w3.org/ns/activitystreams#Follow"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? [
			"https://w3id.org/identity/v1",
			"https://www.w3.org/ns/activitystreams",
			"https://w3id.org/security/v1",
			"https://w3id.org/security/data-integrity/v1",
			"https://www.w3.org/ns/did/v1",
			"https://w3id.org/security/multikey/v1"
		];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {
			if ("proof" in compacted && compacted.proof != null) if (Array.isArray(compacted.proof)) for (const element of compacted.proof) element["@context"] = docContext;
			else compacted.proof["@context"] = docContext;
		}
		return compacted;
	}
	isCompactable() {
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__Follow__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__Follow__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Follow")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof Follow)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "Follow " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "Follow " + inspect(proxy, options);
	}
};
/** Represents a formal or informal collective of Actors.
*/
var Group = class Group extends Object$1 {
	/**
	* The type URI of {@link Group}: `https://www.w3.org/ns/activitystreams#Group`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#Group");
	}
	#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = [];
	#_axq166E2eZADq34V4MYUc8KMZdC_publicKey = [];
	#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey = /* @__PURE__ */ new Set();
	#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = [];
	#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = /* @__PURE__ */ new Set();
	#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = [];
	#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = [];
	#_trust_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = /* @__PURE__ */ new Set();
	#_41QwhqJouoLg3h8dRPKat21brynC_outbox = [];
	#_trust_41QwhqJouoLg3h8dRPKat21brynC_outbox = /* @__PURE__ */ new Set();
	#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = [];
	#_trust_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = /* @__PURE__ */ new Set();
	#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = [];
	#_trust_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = /* @__PURE__ */ new Set();
	#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = [];
	#_trust_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = /* @__PURE__ */ new Set();
	#_4N1vBJzXDf8NbBumeECQMFvKetja_featured = [];
	#_trust_4N1vBJzXDf8NbBumeECQMFvKetja_featured = /* @__PURE__ */ new Set();
	#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = [];
	#_trust_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = /* @__PURE__ */ new Set();
	#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = [];
	#_trust_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = /* @__PURE__ */ new Set();
	#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = [];
	#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = [];
	#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = [];
	#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = [];
	#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = [];
	#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = [];
	#_trust_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = /* @__PURE__ */ new Set();
	#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = [];
	#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = /* @__PURE__ */ new Set();
	#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = [];
	#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = /* @__PURE__ */ new Set();
	#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = [];
	#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat = [];
	/**
	* Constructs a new instance of Group with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
		if ("preferredUsername" in values && values.preferredUsername != null) if (typeof values.preferredUsername === "string" || values.preferredUsername instanceof LanguageString) this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = [values.preferredUsername];
		else throw new TypeError("The preferredUsername must be of type string | LanguageString.");
		if ("preferredUsernames" in values && values.preferredUsernames != null) {
			if ("preferredUsername" in values && values.preferredUsername != null) throw new TypeError("Cannot initialize both preferredUsername and preferredUsernames at the same time.");
			if (Array.isArray(values.preferredUsernames) && values.preferredUsernames.every((v) => typeof v === "string" || v instanceof LanguageString)) this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = values.preferredUsernames;
			else throw new TypeError("The preferredUsernames must be an array of type string | LanguageString.");
		}
		if ("publicKey" in values && values.publicKey != null) if (values.publicKey instanceof CryptographicKey || values.publicKey instanceof URL) {
			this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey = [values.publicKey];
			this.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey.add(0);
		} else throw new TypeError("The publicKey must be of type CryptographicKey | URL.");
		if ("publicKeys" in values && values.publicKeys != null) {
			if ("publicKey" in values && values.publicKey != null) throw new TypeError("Cannot initialize both publicKey and publicKeys at the same time.");
			if (Array.isArray(values.publicKeys) && values.publicKeys.every((v) => v instanceof CryptographicKey || v instanceof URL)) {
				this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey = values.publicKeys;
				for (let i = 0; i < values.publicKeys.length; i++) this.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey.add(i);
			} else throw new TypeError("The publicKeys must be an array of type CryptographicKey | URL.");
		}
		if ("assertionMethod" in values && values.assertionMethod != null) if (values.assertionMethod instanceof Multikey || values.assertionMethod instanceof URL) {
			this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = [values.assertionMethod];
			this.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.add(0);
		} else throw new TypeError("The assertionMethod must be of type Multikey | URL.");
		if ("assertionMethods" in values && values.assertionMethods != null) {
			if ("assertionMethod" in values && values.assertionMethod != null) throw new TypeError("Cannot initialize both assertionMethod and assertionMethods at the same time.");
			if (Array.isArray(values.assertionMethods) && values.assertionMethods.every((v) => v instanceof Multikey || v instanceof URL)) {
				this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = values.assertionMethods;
				for (let i = 0; i < values.assertionMethods.length; i++) this.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.add(i);
			} else throw new TypeError("The assertionMethods must be an array of type Multikey | URL.");
		}
		if ("manuallyApprovesFollowers" in values && values.manuallyApprovesFollowers != null) if (typeof values.manuallyApprovesFollowers === "boolean") this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = [values.manuallyApprovesFollowers];
		else throw new TypeError("The manuallyApprovesFollowers must be of type boolean.");
		if ("inbox" in values && values.inbox != null) if (values.inbox instanceof OrderedCollection || values.inbox instanceof OrderedCollectionPage || values.inbox instanceof URL) {
			this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = [values.inbox];
			this.#_trust_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.add(0);
		} else throw new TypeError("The inbox must be of type OrderedCollection | OrderedCollectionPage | URL.");
		if ("outbox" in values && values.outbox != null) if (values.outbox instanceof OrderedCollection || values.outbox instanceof OrderedCollectionPage || values.outbox instanceof URL) {
			this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox = [values.outbox];
			this.#_trust_41QwhqJouoLg3h8dRPKat21brynC_outbox.add(0);
		} else throw new TypeError("The outbox must be of type OrderedCollection | OrderedCollectionPage | URL.");
		if ("following" in values && values.following != null) if (values.following instanceof Collection || values.following instanceof URL) {
			this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = [values.following];
			this.#_trust_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.add(0);
		} else throw new TypeError("The following must be of type Collection | URL.");
		if ("followers" in values && values.followers != null) if (values.followers instanceof Collection || values.followers instanceof URL) {
			this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = [values.followers];
			this.#_trust_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.add(0);
		} else throw new TypeError("The followers must be of type Collection | URL.");
		if ("liked" in values && values.liked != null) if (values.liked instanceof Collection || values.liked instanceof URL) {
			this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = [values.liked];
			this.#_trust_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.add(0);
		} else throw new TypeError("The liked must be of type Collection | URL.");
		if ("featured" in values && values.featured != null) if (values.featured instanceof Collection || values.featured instanceof URL) {
			this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured = [values.featured];
			this.#_trust_4N1vBJzXDf8NbBumeECQMFvKetja_featured.add(0);
		} else throw new TypeError("The featured must be of type Collection | URL.");
		if ("featuredTags" in values && values.featuredTags != null) if (values.featuredTags instanceof Collection || values.featuredTags instanceof URL) {
			this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = [values.featuredTags];
			this.#_trust_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.add(0);
		} else throw new TypeError("The featuredTags must be of type Collection | URL.");
		if ("streams" in values && values.streams != null) if (Array.isArray(values.streams) && values.streams.every((v) => v instanceof Collection || v instanceof URL)) {
			this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = values.streams;
			for (let i = 0; i < values.streams.length; i++) this.#_trust_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.add(i);
		} else throw new TypeError("The streams must be an array of type Collection | URL.");
		if ("endpoints" in values && values.endpoints != null) if (values.endpoints instanceof Endpoints) this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = [values.endpoints];
		else throw new TypeError("The endpoints must be of type Endpoints.");
		if ("discoverable" in values && values.discoverable != null) if (typeof values.discoverable === "boolean") this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = [values.discoverable];
		else throw new TypeError("The discoverable must be of type boolean.");
		if ("suspended" in values && values.suspended != null) if (typeof values.suspended === "boolean") this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = [values.suspended];
		else throw new TypeError("The suspended must be of type boolean.");
		if ("memorial" in values && values.memorial != null) if (typeof values.memorial === "boolean") this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = [values.memorial];
		else throw new TypeError("The memorial must be of type boolean.");
		if ("indexable" in values && values.indexable != null) if (typeof values.indexable === "boolean") this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = [values.indexable];
		else throw new TypeError("The indexable must be of type boolean.");
		if ("successor" in values && values.successor != null) if (values.successor instanceof Application || values.successor instanceof Group || values.successor instanceof Organization || values.successor instanceof Person || values.successor instanceof Service || values.successor instanceof URL) {
			this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = [values.successor];
			this.#_trust_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.add(0);
		} else throw new TypeError("The successor must be of type Application | Group | Organization | Person | Service | URL.");
		if ("alias" in values && values.alias != null) if (values.alias instanceof Application || values.alias instanceof Group || values.alias instanceof Organization || values.alias instanceof Person || values.alias instanceof Service || values.alias instanceof URL) {
			this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = [values.alias];
			this.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.add(0);
		} else throw new TypeError("The alias must be of type Application | Group | Organization | Person | Service | URL.");
		if ("aliases" in values && values.aliases != null) {
			if ("alias" in values && values.alias != null) throw new TypeError("Cannot initialize both alias and aliases at the same time.");
			if (Array.isArray(values.aliases) && values.aliases.every((v) => v instanceof Application || v instanceof Group || v instanceof Organization || v instanceof Person || v instanceof Service || v instanceof URL)) {
				this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = values.aliases;
				for (let i = 0; i < values.aliases.length; i++) this.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.add(i);
			} else throw new TypeError("The aliases must be an array of type Application | Group | Organization | Person | Service | URL.");
		}
		if ("service" in values && values.service != null) if (values.service instanceof DidService || values.service instanceof URL) {
			this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = [values.service];
			this.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.add(0);
		} else throw new TypeError("The service must be of type DidService | URL.");
		if ("services" in values && values.services != null) {
			if ("service" in values && values.service != null) throw new TypeError("Cannot initialize both service and services at the same time.");
			if (Array.isArray(values.services) && values.services.every((v) => v instanceof DidService || v instanceof URL)) {
				this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = values.services;
				for (let i = 0; i < values.services.length; i++) this.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.add(i);
			} else throw new TypeError("The services must be an array of type DidService | URL.");
		}
		if ("followedMessage" in values && values.followedMessage != null) if (typeof values.followedMessage === "string") this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = [values.followedMessage];
		else throw new TypeError("The followedMessage must be of type string.");
		if ("cat" in values && values.cat != null) if (typeof values.cat === "boolean") this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat = [values.cat];
		else throw new TypeError("The cat must be of type boolean.");
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		clone.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername;
		if ("preferredUsername" in values && values.preferredUsername != null) if (typeof values.preferredUsername === "string" || values.preferredUsername instanceof LanguageString) clone.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = [values.preferredUsername];
		else throw new TypeError("The preferredUsername must be of type string | LanguageString.");
		if ("preferredUsernames" in values && values.preferredUsernames != null) {
			if ("preferredUsername" in values && values.preferredUsername != null) throw new TypeError("Cannot update both preferredUsername and preferredUsernames at the same time.");
			if (Array.isArray(values.preferredUsernames) && values.preferredUsernames.every((v) => typeof v === "string" || v instanceof LanguageString)) clone.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = values.preferredUsernames;
			else throw new TypeError("The preferredUsernames must be an array of type string | LanguageString.");
		}
		clone.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey = this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey;
		clone.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey = new Set(this.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey);
		if ("publicKey" in values && values.publicKey != null) if (values.publicKey instanceof CryptographicKey || values.publicKey instanceof URL) {
			clone.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey = [values.publicKey];
			clone.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey = new Set([0]);
		} else throw new TypeError("The publicKey must be of type CryptographicKey | URL.");
		if ("publicKeys" in values && values.publicKeys != null) {
			if ("publicKey" in values && values.publicKey != null) throw new TypeError("Cannot update both publicKey and publicKeys at the same time.");
			if (Array.isArray(values.publicKeys) && values.publicKeys.every((v) => v instanceof CryptographicKey || v instanceof URL)) {
				clone.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey = values.publicKeys;
				clone.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey = /* @__PURE__ */ new Set();
				for (let i = 0; i < values.publicKeys.length; i++) clone.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey.add(i);
			} else throw new TypeError("The publicKeys must be an array of type CryptographicKey | URL.");
		}
		clone.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod;
		clone.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = new Set(this.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod);
		if ("assertionMethod" in values && values.assertionMethod != null) if (values.assertionMethod instanceof Multikey || values.assertionMethod instanceof URL) {
			clone.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = [values.assertionMethod];
			clone.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = new Set([0]);
		} else throw new TypeError("The assertionMethod must be of type Multikey | URL.");
		if ("assertionMethods" in values && values.assertionMethods != null) {
			if ("assertionMethod" in values && values.assertionMethod != null) throw new TypeError("Cannot update both assertionMethod and assertionMethods at the same time.");
			if (Array.isArray(values.assertionMethods) && values.assertionMethods.every((v) => v instanceof Multikey || v instanceof URL)) {
				clone.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = values.assertionMethods;
				clone.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = /* @__PURE__ */ new Set();
				for (let i = 0; i < values.assertionMethods.length; i++) clone.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.add(i);
			} else throw new TypeError("The assertionMethods must be an array of type Multikey | URL.");
		}
		clone.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers;
		if ("manuallyApprovesFollowers" in values && values.manuallyApprovesFollowers != null) if (typeof values.manuallyApprovesFollowers === "boolean") clone.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = [values.manuallyApprovesFollowers];
		else throw new TypeError("The manuallyApprovesFollowers must be of type boolean.");
		clone.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox;
		clone.#_trust_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = new Set(this.#_trust_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox);
		if ("inbox" in values && values.inbox != null) if (values.inbox instanceof OrderedCollection || values.inbox instanceof OrderedCollectionPage || values.inbox instanceof URL) {
			clone.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = [values.inbox];
			clone.#_trust_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = new Set([0]);
		} else throw new TypeError("The inbox must be of type OrderedCollection | OrderedCollectionPage | URL.");
		clone.#_41QwhqJouoLg3h8dRPKat21brynC_outbox = this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox;
		clone.#_trust_41QwhqJouoLg3h8dRPKat21brynC_outbox = new Set(this.#_trust_41QwhqJouoLg3h8dRPKat21brynC_outbox);
		if ("outbox" in values && values.outbox != null) if (values.outbox instanceof OrderedCollection || values.outbox instanceof OrderedCollectionPage || values.outbox instanceof URL) {
			clone.#_41QwhqJouoLg3h8dRPKat21brynC_outbox = [values.outbox];
			clone.#_trust_41QwhqJouoLg3h8dRPKat21brynC_outbox = new Set([0]);
		} else throw new TypeError("The outbox must be of type OrderedCollection | OrderedCollectionPage | URL.");
		clone.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following;
		clone.#_trust_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = new Set(this.#_trust_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following);
		if ("following" in values && values.following != null) if (values.following instanceof Collection || values.following instanceof URL) {
			clone.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = [values.following];
			clone.#_trust_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = new Set([0]);
		} else throw new TypeError("The following must be of type Collection | URL.");
		clone.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers;
		clone.#_trust_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = new Set(this.#_trust_BBCTgfphhsFzpVfKTykGSpBNwoA_followers);
		if ("followers" in values && values.followers != null) if (values.followers instanceof Collection || values.followers instanceof URL) {
			clone.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = [values.followers];
			clone.#_trust_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = new Set([0]);
		} else throw new TypeError("The followers must be of type Collection | URL.");
		clone.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked;
		clone.#_trust_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = new Set(this.#_trust_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked);
		if ("liked" in values && values.liked != null) if (values.liked instanceof Collection || values.liked instanceof URL) {
			clone.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = [values.liked];
			clone.#_trust_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = new Set([0]);
		} else throw new TypeError("The liked must be of type Collection | URL.");
		clone.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured = this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured;
		clone.#_trust_4N1vBJzXDf8NbBumeECQMFvKetja_featured = new Set(this.#_trust_4N1vBJzXDf8NbBumeECQMFvKetja_featured);
		if ("featured" in values && values.featured != null) if (values.featured instanceof Collection || values.featured instanceof URL) {
			clone.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured = [values.featured];
			clone.#_trust_4N1vBJzXDf8NbBumeECQMFvKetja_featured = new Set([0]);
		} else throw new TypeError("The featured must be of type Collection | URL.");
		clone.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags;
		clone.#_trust_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = new Set(this.#_trust_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags);
		if ("featuredTags" in values && values.featuredTags != null) if (values.featuredTags instanceof Collection || values.featuredTags instanceof URL) {
			clone.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = [values.featuredTags];
			clone.#_trust_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = new Set([0]);
		} else throw new TypeError("The featuredTags must be of type Collection | URL.");
		clone.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams;
		clone.#_trust_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = new Set(this.#_trust_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams);
		if ("streams" in values && values.streams != null) if (Array.isArray(values.streams) && values.streams.every((v) => v instanceof Collection || v instanceof URL)) {
			clone.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = values.streams;
			clone.#_trust_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = /* @__PURE__ */ new Set();
			for (let i = 0; i < values.streams.length; i++) clone.#_trust_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.add(i);
		} else throw new TypeError("The streams must be an array of type Collection | URL.");
		clone.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints;
		if ("endpoints" in values && values.endpoints != null) if (values.endpoints instanceof Endpoints) clone.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = [values.endpoints];
		else throw new TypeError("The endpoints must be of type Endpoints.");
		clone.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable;
		if ("discoverable" in values && values.discoverable != null) if (typeof values.discoverable === "boolean") clone.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = [values.discoverable];
		else throw new TypeError("The discoverable must be of type boolean.");
		clone.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended;
		if ("suspended" in values && values.suspended != null) if (typeof values.suspended === "boolean") clone.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = [values.suspended];
		else throw new TypeError("The suspended must be of type boolean.");
		clone.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial;
		if ("memorial" in values && values.memorial != null) if (typeof values.memorial === "boolean") clone.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = [values.memorial];
		else throw new TypeError("The memorial must be of type boolean.");
		clone.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable;
		if ("indexable" in values && values.indexable != null) if (typeof values.indexable === "boolean") clone.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = [values.indexable];
		else throw new TypeError("The indexable must be of type boolean.");
		clone.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo;
		clone.#_trust_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = new Set(this.#_trust_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo);
		if ("successor" in values && values.successor != null) if (values.successor instanceof Application || values.successor instanceof Group || values.successor instanceof Organization || values.successor instanceof Person || values.successor instanceof Service || values.successor instanceof URL) {
			clone.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = [values.successor];
			clone.#_trust_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = new Set([0]);
		} else throw new TypeError("The successor must be of type Application | Group | Organization | Person | Service | URL.");
		clone.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs;
		clone.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = new Set(this.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs);
		if ("alias" in values && values.alias != null) if (values.alias instanceof Application || values.alias instanceof Group || values.alias instanceof Organization || values.alias instanceof Person || values.alias instanceof Service || values.alias instanceof URL) {
			clone.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = [values.alias];
			clone.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = new Set([0]);
		} else throw new TypeError("The alias must be of type Application | Group | Organization | Person | Service | URL.");
		if ("aliases" in values && values.aliases != null) {
			if ("alias" in values && values.alias != null) throw new TypeError("Cannot update both alias and aliases at the same time.");
			if (Array.isArray(values.aliases) && values.aliases.every((v) => v instanceof Application || v instanceof Group || v instanceof Organization || v instanceof Person || v instanceof Service || v instanceof URL)) {
				clone.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = values.aliases;
				clone.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = /* @__PURE__ */ new Set();
				for (let i = 0; i < values.aliases.length; i++) clone.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.add(i);
			} else throw new TypeError("The aliases must be an array of type Application | Group | Organization | Person | Service | URL.");
		}
		clone.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service;
		clone.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = new Set(this.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service);
		if ("service" in values && values.service != null) if (values.service instanceof DidService || values.service instanceof URL) {
			clone.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = [values.service];
			clone.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = new Set([0]);
		} else throw new TypeError("The service must be of type DidService | URL.");
		if ("services" in values && values.services != null) {
			if ("service" in values && values.service != null) throw new TypeError("Cannot update both service and services at the same time.");
			if (Array.isArray(values.services) && values.services.every((v) => v instanceof DidService || v instanceof URL)) {
				clone.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = values.services;
				clone.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = /* @__PURE__ */ new Set();
				for (let i = 0; i < values.services.length; i++) clone.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.add(i);
			} else throw new TypeError("The services must be an array of type DidService | URL.");
		}
		clone.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage;
		if ("followedMessage" in values && values.followedMessage != null) if (typeof values.followedMessage === "string") clone.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = [values.followedMessage];
		else throw new TypeError("The followedMessage must be of type string.");
		clone.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat = this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat;
		if ("cat" in values && values.cat != null) if (typeof values.cat === "boolean") clone.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat = [values.cat];
		else throw new TypeError("The cat must be of type boolean.");
		return clone;
	}
	/** A short username which may be used to refer to the actor,
	* with no uniqueness guarantees.
	*/
	get preferredUsername() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.length < 1) return null;
		return this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername[0];
	}
	/** A short username which may be used to refer to the actor,
	* with no uniqueness guarantees.
	*/
	get preferredUsernames() {
		return this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername;
	}
	async #fetchPublicKey(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#publicKey_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #publicKey_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await CryptographicKey.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://w3id.org/security#Key"].join(", "));
	}
	/**
	* Similar to
	* {@link Group.getPublicKey},
	* but returns its `@id` URL instead of the object itself.
	*/
	get publicKeyId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey.length < 1) return null;
		const v = this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** A public part of the key pair owned by this actor.
	*/
	async getPublicKey(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey.length < 1) return null;
		let v = this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchPublicKey(v, options);
			if (fetched == null) return null;
			this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey[0] = fetched;
			this.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "publicKey" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["publicKey"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#publicKey_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	/**
	* Similar to
	* {@link Group.getPublicKeys},
	* but returns their `@id`s instead of the objects themselves.
	*/
	get publicKeyIds() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		return this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
	}
	/** A public part of the key pair owned by this actor.
	*/
	async *getPublicKeys(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		const vs = this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey;
		for (let i = 0; i < vs.length; i++) {
			let v = vs[i];
			if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey.has(i)) v = v.id;
			if (v instanceof URL) {
				const fetched = await this.#fetchPublicKey(v, options);
				if (fetched == null) continue;
				vs[i] = fetched;
				this.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey.add(i);
				this._cachedJsonLd = void 0;
				yield fetched;
				continue;
			}
			if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "publicKey" in this._cachedJsonLd) {
				const prop = this._cachedJsonLd["publicKey"];
				const obj = Array.isArray(prop) ? prop[i] : prop;
				if (obj != null && typeof obj === "object" && "@context" in obj) v = await this.#publicKey_fromJsonLd(obj, options);
			}
			if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey.has(0)) {
				if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
				getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
					objectId: v.id.href,
					parentObjectId: this.id.href
				});
				continue;
			}
			yield v;
		}
	}
	async #fetchAssertionMethod(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#assertionMethod_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #assertionMethod_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Multikey.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://w3id.org/security#Multikey"].join(", "));
	}
	/**
	* Similar to
	* {@link Group.getAssertionMethod},
	* but returns its `@id` URL instead of the object itself.
	*/
	get assertionMethodId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.length < 1) return null;
		const v = this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** Represents this actor's public keys.  It serves as equivalent to
	* the `publicKeys` property, but is used for [FEP-521a] compliance.
	*
	* [FEP-521a]: https://w3id.org/fep/521a
	*/
	async getAssertionMethod(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.length < 1) return null;
		let v = this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchAssertionMethod(v, options);
			if (fetched == null) return null;
			this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod[0] = fetched;
			this.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "assertionMethod" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["assertionMethod"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#assertionMethod_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	/**
	* Similar to
	* {@link Group.getAssertionMethods},
	* but returns their `@id`s instead of the objects themselves.
	*/
	get assertionMethodIds() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		return this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
	}
	/** Represents this actor's public keys.  It serves as equivalent to
	* the `publicKeys` property, but is used for [FEP-521a] compliance.
	*
	* [FEP-521a]: https://w3id.org/fep/521a
	*/
	async *getAssertionMethods(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		const vs = this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod;
		for (let i = 0; i < vs.length; i++) {
			let v = vs[i];
			if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.has(i)) v = v.id;
			if (v instanceof URL) {
				const fetched = await this.#fetchAssertionMethod(v, options);
				if (fetched == null) continue;
				vs[i] = fetched;
				this.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.add(i);
				this._cachedJsonLd = void 0;
				yield fetched;
				continue;
			}
			if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "assertionMethod" in this._cachedJsonLd) {
				const prop = this._cachedJsonLd["assertionMethod"];
				const obj = Array.isArray(prop) ? prop[i] : prop;
				if (obj != null && typeof obj === "object" && "@context" in obj) v = await this.#assertionMethod_fromJsonLd(obj, options);
			}
			if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.has(0)) {
				if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
				getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
					objectId: v.id.href,
					parentObjectId: this.id.href
				});
				continue;
			}
			yield v;
		}
	}
	/** When `true`, conveys that for this actor, follow requests are not usually
	* automatically approved, but instead are examined by a person who may accept
	* or reject the request, at some time in the future.  Setting of `false`
	* conveys no information and may be ignored.  This information is typically
	* used to affect display of accounts, such as showing an account as private or
	* locked.
	*/
	get manuallyApprovesFollowers() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers.length < 1) return null;
		return this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers[0];
	}
	async #fetchInbox(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#inbox_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #inbox_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await OrderedCollection.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await OrderedCollectionPage.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#OrderedCollection", "https://www.w3.org/ns/activitystreams#OrderedCollectionPage"].join(", "));
	}
	/**
	* Similar to
	* {@link Group.getInbox},
	* but returns its `@id` URL instead of the object itself.
	*/
	get inboxId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.length < 1) return null;
		const v = this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** The inbox stream contains all activities received by the actor.  The server
	* SHOULD filter content according to the requester's permission.  In general,
	* the owner of an inbox is likely to be able to access all of their inbox
	* contents.  Depending on access control, some other content may be public,
	* whereas other content may require authentication for non-owner users,
	* if they can access the inbox at all.
	*
	* The server MUST perform de-duplication of activities returned by the inbox.
	* Duplication can occur if an activity is addressed both to an actor's
	* followers, and a specific actor who also follows the recipient actor,
	* and the server has failed to de-duplicate the recipients list.
	* Such deduplication MUST be performed by comparing the `id` of the activities
	* and dropping any activities already seen.
	*/
	async getInbox(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.length < 1) return null;
		let v = this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchInbox(v, options);
			if (fetched == null) return null;
			this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox[0] = fetched;
			this.#_trust_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "inbox" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["inbox"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#inbox_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchOutbox(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#outbox_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #outbox_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await OrderedCollection.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await OrderedCollectionPage.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#OrderedCollection", "https://www.w3.org/ns/activitystreams#OrderedCollectionPage"].join(", "));
	}
	/**
	* Similar to
	* {@link Group.getOutbox},
	* but returns its `@id` URL instead of the object itself.
	*/
	get outboxId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox.length < 1) return null;
		const v = this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** The outbox stream contains activities the user has published,
	* subject to the ability of the requestor to retrieve the activity
	* (that is, the contents of the outbox are filtered by the permissions of
	* the person reading it).  If a user submits a request without
	* [Authorization](https://www.w3.org/TR/activitypub/#authorization)
	* the server should respond with all of the
	* [Public](https://www.w3.org/TR/activitypub/#public-addressing) posts.
	* This could potentially be all relevant objects published by the user,
	* though the number of available items is left to the discretion of those
	* implementing and deploying the server.
	*/
	async getOutbox(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox.length < 1) return null;
		let v = this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_41QwhqJouoLg3h8dRPKat21brynC_outbox.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchOutbox(v, options);
			if (fetched == null) return null;
			this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox[0] = fetched;
			this.#_trust_41QwhqJouoLg3h8dRPKat21brynC_outbox.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "outbox" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["outbox"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#outbox_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_41QwhqJouoLg3h8dRPKat21brynC_outbox.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchFollowing(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#following_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #following_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Collection.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
	}
	/**
	* Similar to
	* {@link Group.getFollowing},
	* but returns its `@id` URL instead of the object itself.
	*/
	get followingId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.length < 1) return null;
		const v = this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** This is a list of everybody that the actor has followed, added as a
	* [side effect](https://www.w3.org/TR/activitypub/#follow-activity-outbox).
	* The `following` collection MUST be either an {@link OrderedCollection}
	* or a {@link Collection} and MAY be filtered on privileges of
	* an authenticated user or as appropriate when no authentication is given.
	*/
	async getFollowing(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.length < 1) return null;
		let v = this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchFollowing(v, options);
			if (fetched == null) return null;
			this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following[0] = fetched;
			this.#_trust_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "following" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["following"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#following_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchFollowers(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#followers_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #followers_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Collection.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
	}
	/**
	* Similar to
	* {@link Group.getFollowers},
	* but returns its `@id` URL instead of the object itself.
	*/
	get followersId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.length < 1) return null;
		const v = this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** This is a list of everyone who has sent a {@link Follow} activity
	* for the actor, added as a
	* [side effect](https://www.w3.org/TR/activitypub/#follow-activity-outbox).
	* This is where one would find a list of all the actors that are following
	* the actor.  The `followers` collection MUST be either
	* an {@link OrderedCollection} or a {@link Collection} and MAY be filtered on
	* privileges of an authenticated user or as appropriate when no authentication
	* is given.
	*/
	async getFollowers(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.length < 1) return null;
		let v = this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchFollowers(v, options);
			if (fetched == null) return null;
			this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers[0] = fetched;
			this.#_trust_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "followers" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["followers"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#followers_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchLiked(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#liked_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #liked_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Collection.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
	}
	/**
	* Similar to
	* {@link Group.getLiked},
	* but returns its `@id` URL instead of the object itself.
	*/
	get likedId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.length < 1) return null;
		const v = this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** This is a list of every object from all of the actor's {@link Like}
	* activities, added as a
	* [side effect](https://www.w3.org/TR/activitypub/#like-activity-outbox).
	* The `liked` collection MUST be either an {@link OrderedCollection} or
	* a {@link Collection} and MAY be filtered on privileges of an authenticated
	* user or as appropriate when no authentication is given.
	*/
	async getLiked(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.length < 1) return null;
		let v = this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchLiked(v, options);
			if (fetched == null) return null;
			this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked[0] = fetched;
			this.#_trust_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "liked" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["liked"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#liked_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchFeatured(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#featured_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #featured_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Collection.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
	}
	/**
	* Similar to
	* {@link Group.getFeatured},
	* but returns its `@id` URL instead of the object itself.
	*/
	get featuredId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured.length < 1) return null;
		const v = this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** What is known in Mastodon as "pinned statuses", or statuses that are always
	* featured at the top of people's profiles, is implemented using an extra
	* property `featured` on the actor object that points to a {@link Collection}
	* of objects.
	*/
	async getFeatured(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured.length < 1) return null;
		let v = this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_4N1vBJzXDf8NbBumeECQMFvKetja_featured.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchFeatured(v, options);
			if (fetched == null) return null;
			this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured[0] = fetched;
			this.#_trust_4N1vBJzXDf8NbBumeECQMFvKetja_featured.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "featured" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["featured"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#featured_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_4N1vBJzXDf8NbBumeECQMFvKetja_featured.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchFeaturedTags(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#featuredTags_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #featuredTags_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Collection.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
	}
	/**
	* Similar to
	* {@link Group.getFeaturedTags},
	* but returns its `@id` URL instead of the object itself.
	*/
	get featuredTagsId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.length < 1) return null;
		const v = this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** What is known in Mastodon as "featured hashtags", hashtags that are featured
	* at people's profiles, is implemented using an extra property `featuredTags`
	* on the actor object that points to a {@link Collection} of {@link Hashtag}
	* objects specifically.
	*/
	async getFeaturedTags(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.length < 1) return null;
		let v = this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchFeaturedTags(v, options);
			if (fetched == null) return null;
			this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags[0] = fetched;
			this.#_trust_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "featuredTags" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["featuredTags"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#featuredTags_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchStream(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#stream_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #stream_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Collection.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
	}
	/**
	* Similar to
	* {@link Group.getStreams},
	* but returns their `@id`s instead of the objects themselves.
	*/
	get streamIds() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		return this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
	}
	/** A list of supplementary Collections which may be of interest.
	*/
	async *getStreams(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		const vs = this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams;
		for (let i = 0; i < vs.length; i++) {
			let v = vs[i];
			if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.has(i)) v = v.id;
			if (v instanceof URL) {
				const fetched = await this.#fetchStream(v, options);
				if (fetched == null) continue;
				vs[i] = fetched;
				this.#_trust_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.add(i);
				this._cachedJsonLd = void 0;
				yield fetched;
				continue;
			}
			if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "streams" in this._cachedJsonLd) {
				const prop = this._cachedJsonLd["streams"];
				const obj = Array.isArray(prop) ? prop[i] : prop;
				if (obj != null && typeof obj === "object" && "@context" in obj) v = await this.#stream_fromJsonLd(obj, options);
			}
			if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.has(0)) {
				if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
				getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
					objectId: v.id.href,
					parentObjectId: this.id.href
				});
				continue;
			}
			yield v;
		}
	}
	/** A JSON object which maps additional (typically server/domain-wide) endpoints
	* which may be useful either for this actor or someone referencing this actor.
	* This mapping may be nested inside the actor document as the value or may be
	* a link to a JSON-LD document with these properties.
	*/
	get endpoints() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints.length < 1) return null;
		return this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints[0];
	}
	/** Allows users to opt-in or opt-out of discoverability features like
	* the profile directory.  This flag may also be used as an indicator of
	* the user's preferences toward being included in external discovery services,
	* such as search engines or other indexing tools.
	*/
	get discoverable() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable.length < 1) return null;
		return this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable[0];
	}
	/** Reports whether a user was locally suspended, for better handling of
	* these accounts.
	*/
	get suspended() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended.length < 1) return null;
		return this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended[0];
	}
	/** Whether the actor is in-memorial state.
	*/
	get memorial() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial.length < 1) return null;
		return this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial[0];
	}
	/** Whether the actor allows to be indexed.
	*/
	get indexable() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable.length < 1) return null;
		return this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable[0];
	}
	async #fetchSuccessor(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#successor_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #successor_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Application.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Group.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Organization.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Person.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Service.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + [
			"https://www.w3.org/ns/activitystreams#Application",
			"https://www.w3.org/ns/activitystreams#Group",
			"https://www.w3.org/ns/activitystreams#Organization",
			"https://www.w3.org/ns/activitystreams#Person",
			"https://www.w3.org/ns/activitystreams#Service"
		].join(", "));
	}
	/**
	* Similar to
	* {@link Group.getSuccessor},
	* but returns its `@id` URL instead of the object itself.
	*/
	get successorId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.length < 1) return null;
		const v = this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** Signifies that an actor has been moved to a different ID. Used in Mastodon-style data portability with the {@link Move} activity; see [ActivityPub Data Portability/Move Action](https://swicg.github.io/activitypub-data-portability/#move-action) for more details.
	*/
	async getSuccessor(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.length < 1) return null;
		let v = this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchSuccessor(v, options);
			if (fetched == null) return null;
			this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo[0] = fetched;
			this.#_trust_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "movedTo" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["movedTo"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#successor_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchAlias(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#alias_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #alias_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Application.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Group.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Organization.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Person.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Service.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + [
			"https://www.w3.org/ns/activitystreams#Application",
			"https://www.w3.org/ns/activitystreams#Group",
			"https://www.w3.org/ns/activitystreams#Organization",
			"https://www.w3.org/ns/activitystreams#Person",
			"https://www.w3.org/ns/activitystreams#Service"
		].join(", "));
	}
	/**
	* Similar to
	* {@link Group.getAlias},
	* but returns its `@id` URL instead of the object itself.
	*/
	get aliasId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.length < 1) return null;
		const v = this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** The `aliases` (`alsoKnownAs`) property is used to specify alternative names
	* or aliases for an entity.  It can be used to provide additional identifiers
	* or labels for an entity, which can be useful in scenarios where an entity
	* may have multiple names or aliases.
	*/
	async getAlias(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.length < 1) return null;
		let v = this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchAlias(v, options);
			if (fetched == null) return null;
			this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs[0] = fetched;
			this.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "alsoKnownAs" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["alsoKnownAs"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#alias_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	/**
	* Similar to
	* {@link Group.getAliases},
	* but returns their `@id`s instead of the objects themselves.
	*/
	get aliasIds() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		return this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
	}
	/** The `aliases` (`alsoKnownAs`) property is used to specify alternative names
	* or aliases for an entity.  It can be used to provide additional identifiers
	* or labels for an entity, which can be useful in scenarios where an entity
	* may have multiple names or aliases.
	*/
	async *getAliases(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		const vs = this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs;
		for (let i = 0; i < vs.length; i++) {
			let v = vs[i];
			if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.has(i)) v = v.id;
			if (v instanceof URL) {
				const fetched = await this.#fetchAlias(v, options);
				if (fetched == null) continue;
				vs[i] = fetched;
				this.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.add(i);
				this._cachedJsonLd = void 0;
				yield fetched;
				continue;
			}
			if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "alsoKnownAs" in this._cachedJsonLd) {
				const prop = this._cachedJsonLd["alsoKnownAs"];
				const obj = Array.isArray(prop) ? prop[i] : prop;
				if (obj != null && typeof obj === "object" && "@context" in obj) v = await this.#alias_fromJsonLd(obj, options);
			}
			if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.has(0)) {
				if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
				getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
					objectId: v.id.href,
					parentObjectId: this.id.href
				});
				continue;
			}
			yield v;
		}
	}
	async #fetchService(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#service_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #service_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await DidService.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/did#Service"].join(", "));
	}
	/**
	* Similar to
	* {@link Group.getService},
	* but returns its `@id` URL instead of the object itself.
	*/
	get serviceId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length < 1) return null;
		const v = this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** Means of communicating or interacting with the DID subject or associated
	* entities via one or more service endpoints. Examples include discovery
	* services, agent services, social networking services, file storage services,
	* and verifiable credential repository services.
	*/
	async getService(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length < 1) return null;
		let v = this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchService(v, options);
			if (fetched == null) return null;
			this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service[0] = fetched;
			this.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "service" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["service"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#service_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	/**
	* Similar to
	* {@link Group.getServices},
	* but returns their `@id`s instead of the objects themselves.
	*/
	get serviceIds() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		return this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
	}
	/** Means of communicating or interacting with the DID subject or associated
	* entities via one or more service endpoints. Examples include discovery
	* services, agent services, social networking services, file storage services,
	* and verifiable credential repository services.
	*/
	async *getServices(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		const vs = this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service;
		for (let i = 0; i < vs.length; i++) {
			let v = vs[i];
			if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.has(i)) v = v.id;
			if (v instanceof URL) {
				const fetched = await this.#fetchService(v, options);
				if (fetched == null) continue;
				vs[i] = fetched;
				this.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.add(i);
				this._cachedJsonLd = void 0;
				yield fetched;
				continue;
			}
			if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "service" in this._cachedJsonLd) {
				const prop = this._cachedJsonLd["service"];
				const obj = Array.isArray(prop) ? prop[i] : prop;
				if (obj != null && typeof obj === "object" && "@context" in obj) v = await this.#service_fromJsonLd(obj, options);
			}
			if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.has(0)) {
				if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
				getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
					objectId: v.id.href,
					parentObjectId: this.id.href
				});
				continue;
			}
			yield v;
		}
	}
	/** This value is used for `Actor` type objects to show message on followed.
	*/
	get followedMessage() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage.length < 1) return null;
		return this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage[0];
	}
	/** Used on actors to indicate that they in some way identify as a cat,
	* expressed as a boolean value. If this property is set to `true`,
	* displaying the actor or their notes will have some special effects
	* attached in some clients.
	*/
	get cat() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat.length < 1) return null;
		return this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat[0];
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		if (options.format == null && this.isCompactable()) {
			const result = await super.toJsonLd({
				...options,
				format: void 0,
				context: void 0
			});
			let compactItems;
			compactItems = [];
			for (const v of this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername) {
				const item = typeof v === "string" ? v : {
					"@value": v.toString(),
					"@language": v.language.compact()
				};
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["preferredUsername"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["publicKey"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["assertionMethod"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers) {
				const item = v;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["manuallyApprovesFollowers"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox) {
				const item = v instanceof URL ? v.href : v instanceof OrderedCollection ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["inbox"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox) {
				const item = v instanceof URL ? v.href : v instanceof OrderedCollection ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["outbox"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["following"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["followers"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["liked"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["featured"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["featuredTags"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["streams"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints) {
				const item = await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["endpoints"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable) {
				const item = v;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["discoverable"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended) {
				const item = v;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["suspended"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial) {
				const item = v;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["memorial"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable) {
				const item = v;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["indexable"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo) {
				const item = v instanceof URL ? v.href : v instanceof Application ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : v instanceof Group ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : v instanceof Organization ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : v instanceof Person ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["movedTo"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs) {
				const item = v instanceof URL ? v.href : v instanceof Application ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : v instanceof Group ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : v instanceof Organization ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : v instanceof Person ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["alsoKnownAs"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["service"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage) {
				const item = v;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["_misskey_followedMessage"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat) {
				const item = v;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["isCat"] = compactItems.length > 1 ? compactItems : compactItems[0];
			result["type"] = "Group";
			if (this.id != null) result["id"] = this.id.href;
			result["@context"] = [
				"https://www.w3.org/ns/activitystreams",
				"https://w3id.org/security/v1",
				"https://w3id.org/security/data-integrity/v1",
				"https://www.w3.org/ns/did/v1",
				"https://w3id.org/security/multikey/v1",
				{
					"alsoKnownAs": {
						"@id": "as:alsoKnownAs",
						"@type": "@id"
					},
					"manuallyApprovesFollowers": "as:manuallyApprovesFollowers",
					"movedTo": {
						"@id": "as:movedTo",
						"@type": "@id"
					},
					"toot": "http://joinmastodon.org/ns#",
					"Emoji": "toot:Emoji",
					"featured": {
						"@id": "toot:featured",
						"@type": "@id"
					},
					"featuredTags": {
						"@id": "toot:featuredTags",
						"@type": "@id"
					},
					"discoverable": "toot:discoverable",
					"suspended": "toot:suspended",
					"memorial": "toot:memorial",
					"indexable": "toot:indexable",
					"schema": "http://schema.org#",
					"PropertyValue": "schema:PropertyValue",
					"value": "schema:value",
					"misskey": "https://misskey-hub.net/ns#",
					"_misskey_followedMessage": "misskey:_misskey_followedMessage",
					"isCat": "misskey:isCat"
				}
			];
			return result;
		}
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		array = [];
		for (const v of this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername) {
			const element = typeof v === "string" ? { "@value": v } : {
				"@value": v.toString(),
				"@language": v.language.compact()
			};
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#preferredUsername"] = propValue;
		}
		array = [];
		for (const v of this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://w3id.org/security#publicKey"] = propValue;
		}
		array = [];
		for (const v of this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://w3id.org/security#assertionMethod"] = propValue;
		}
		array = [];
		for (const v of this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers) {
			const element = { "@value": v };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#manuallyApprovesFollowers"] = propValue;
		}
		array = [];
		for (const v of this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox) {
			const element = v instanceof URL ? { "@id": v.href } : v instanceof OrderedCollection ? await v.toJsonLd(options) : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["http://www.w3.org/ns/ldp#inbox"] = propValue;
		}
		array = [];
		for (const v of this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox) {
			const element = v instanceof URL ? { "@id": v.href } : v instanceof OrderedCollection ? await v.toJsonLd(options) : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#outbox"] = propValue;
		}
		array = [];
		for (const v of this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#following"] = propValue;
		}
		array = [];
		for (const v of this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#followers"] = propValue;
		}
		array = [];
		for (const v of this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#liked"] = propValue;
		}
		array = [];
		for (const v of this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["http://joinmastodon.org/ns#featured"] = propValue;
		}
		array = [];
		for (const v of this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["http://joinmastodon.org/ns#featuredTags"] = propValue;
		}
		array = [];
		for (const v of this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#streams"] = propValue;
		}
		array = [];
		for (const v of this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints) {
			const element = await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#endpoints"] = propValue;
		}
		array = [];
		for (const v of this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable) {
			const element = { "@value": v };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["http://joinmastodon.org/ns#discoverable"] = propValue;
		}
		array = [];
		for (const v of this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended) {
			const element = { "@value": v };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["http://joinmastodon.org/ns#suspended"] = propValue;
		}
		array = [];
		for (const v of this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial) {
			const element = { "@value": v };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["http://joinmastodon.org/ns#memorial"] = propValue;
		}
		array = [];
		for (const v of this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable) {
			const element = { "@value": v };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["http://joinmastodon.org/ns#indexable"] = propValue;
		}
		array = [];
		for (const v of this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo) {
			const element = v instanceof URL ? { "@id": v.href } : v instanceof Application ? await v.toJsonLd(options) : v instanceof Group ? await v.toJsonLd(options) : v instanceof Organization ? await v.toJsonLd(options) : v instanceof Person ? await v.toJsonLd(options) : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#movedTo"] = propValue;
		}
		array = [];
		for (const v of this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs) {
			const element = v instanceof URL ? { "@id": v.href } : v instanceof Application ? await v.toJsonLd(options) : v instanceof Group ? await v.toJsonLd(options) : v instanceof Organization ? await v.toJsonLd(options) : v instanceof Person ? await v.toJsonLd(options) : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#alsoKnownAs"] = propValue;
		}
		array = [];
		for (const v of this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/did#service"] = propValue;
		}
		array = [];
		for (const v of this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage) {
			const element = { "@value": v };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://misskey-hub.net/ns#_misskey_followedMessage"] = propValue;
		}
		array = [];
		for (const v of this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat) {
			const element = { "@value": v };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://misskey-hub.net/ns#isCat"] = propValue;
		}
		values["@type"] = ["https://www.w3.org/ns/activitystreams#Group"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? [
			"https://www.w3.org/ns/activitystreams",
			"https://w3id.org/security/v1",
			"https://w3id.org/security/data-integrity/v1",
			"https://www.w3.org/ns/did/v1",
			"https://w3id.org/security/multikey/v1",
			{
				"alsoKnownAs": {
					"@id": "as:alsoKnownAs",
					"@type": "@id"
				},
				"manuallyApprovesFollowers": "as:manuallyApprovesFollowers",
				"movedTo": {
					"@id": "as:movedTo",
					"@type": "@id"
				},
				"toot": "http://joinmastodon.org/ns#",
				"Emoji": "toot:Emoji",
				"featured": {
					"@id": "toot:featured",
					"@type": "@id"
				},
				"featuredTags": {
					"@id": "toot:featuredTags",
					"@type": "@id"
				},
				"discoverable": "toot:discoverable",
				"suspended": "toot:suspended",
				"memorial": "toot:memorial",
				"indexable": "toot:indexable",
				"schema": "http://schema.org#",
				"PropertyValue": "schema:PropertyValue",
				"value": "schema:value",
				"misskey": "https://misskey-hub.net/ns#",
				"_misskey_followedMessage": "misskey:_misskey_followedMessage",
				"isCat": "misskey:isCat"
			}
		];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {
			if ("proof" in compacted && compacted.proof != null) if (Array.isArray(compacted.proof)) for (const element of compacted.proof) element["@context"] = docContext;
			else compacted.proof["@context"] = docContext;
		}
		return compacted;
	}
	isCompactable() {
		if (this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername != null && this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.length > 0) return false;
		if (this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service != null && this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length > 0) return false;
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__Group__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__Group__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Group")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof Group)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		const _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = [];
		let _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array = values["https://www.w3.org/ns/activitystreams#preferredUsername"];
		for (const v of _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array == null ? [] : _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array.length === 1 && "@list" in _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array[0] ? _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array[0]["@list"] : _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array) {
			if (v == null) continue;
			const decoded = typeof v === "object" && "@value" in v && typeof v["@value"] === "string" && !("@language" in v) ? v["@value"] : typeof v === "object" && "@language" in v && "@value" in v && typeof v["@language"] === "string" && typeof v["@value"] === "string" ? new LanguageString(v["@value"], v["@language"]) : void 0;
			if (typeof decoded === "undefined") continue;
			_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.push(decoded);
		}
		instance.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername;
		const _axq166E2eZADq34V4MYUc8KMZdC_publicKey = [];
		const _trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey = /* @__PURE__ */ new Set();
		let _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array = values["https://w3id.org/security#publicKey"];
		for (const v of _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array == null ? [] : _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array.length === 1 && "@list" in _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array[0] ? _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array[0]["@list"] : _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_axq166E2eZADq34V4MYUc8KMZdC_publicKey.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_axq166E2eZADq34V4MYUc8KMZdC_publicKey.push(await CryptographicKey.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey = _axq166E2eZADq34V4MYUc8KMZdC_publicKey;
		const _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = [];
		const _trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = /* @__PURE__ */ new Set();
		let _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array = values["https://w3id.org/security#assertionMethod"];
		for (const v of _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array == null ? [] : _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array.length === 1 && "@list" in _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array[0] ? _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array[0]["@list"] : _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.push(await Multikey.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod;
		const _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = [];
		let _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array = values["https://www.w3.org/ns/activitystreams#manuallyApprovesFollowers"];
		for (const v of _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array == null ? [] : _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array.length === 1 && "@list" in _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array[0] ? _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array[0]["@list"] : _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array) {
			if (v == null) continue;
			_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers.push(v["@value"]);
		}
		instance.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers;
		const _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = [];
		const _trust_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = /* @__PURE__ */ new Set();
		let _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array = values["http://www.w3.org/ns/ldp#inbox"];
		for (const v of _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array == null ? [] : _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array.length === 1 && "@list" in _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array[0] ? _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array[0]["@list"] : _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			const decoded = typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#OrderedCollection") ? await OrderedCollection.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#OrderedCollectionPage") ? await OrderedCollectionPage.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : void 0;
			if (typeof decoded === "undefined") continue;
			_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.push(decoded);
		}
		instance.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox;
		const _41QwhqJouoLg3h8dRPKat21brynC_outbox = [];
		const _trust_41QwhqJouoLg3h8dRPKat21brynC_outbox = /* @__PURE__ */ new Set();
		let _41QwhqJouoLg3h8dRPKat21brynC_outbox__array = values["https://www.w3.org/ns/activitystreams#outbox"];
		for (const v of _41QwhqJouoLg3h8dRPKat21brynC_outbox__array == null ? [] : _41QwhqJouoLg3h8dRPKat21brynC_outbox__array.length === 1 && "@list" in _41QwhqJouoLg3h8dRPKat21brynC_outbox__array[0] ? _41QwhqJouoLg3h8dRPKat21brynC_outbox__array[0]["@list"] : _41QwhqJouoLg3h8dRPKat21brynC_outbox__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_41QwhqJouoLg3h8dRPKat21brynC_outbox.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			const decoded = typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#OrderedCollection") ? await OrderedCollection.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#OrderedCollectionPage") ? await OrderedCollectionPage.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : void 0;
			if (typeof decoded === "undefined") continue;
			_41QwhqJouoLg3h8dRPKat21brynC_outbox.push(decoded);
		}
		instance.#_41QwhqJouoLg3h8dRPKat21brynC_outbox = _41QwhqJouoLg3h8dRPKat21brynC_outbox;
		const _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = [];
		const _trust_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = /* @__PURE__ */ new Set();
		let _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array = values["https://www.w3.org/ns/activitystreams#following"];
		for (const v of _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array == null ? [] : _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array.length === 1 && "@list" in _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array[0] ? _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array[0]["@list"] : _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.push(await Collection.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following;
		const _BBCTgfphhsFzpVfKTykGSpBNwoA_followers = [];
		const _trust_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = /* @__PURE__ */ new Set();
		let _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array = values["https://www.w3.org/ns/activitystreams#followers"];
		for (const v of _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array == null ? [] : _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array.length === 1 && "@list" in _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array[0] ? _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array[0]["@list"] : _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.push(await Collection.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = _BBCTgfphhsFzpVfKTykGSpBNwoA_followers;
		const _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = [];
		const _trust_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = /* @__PURE__ */ new Set();
		let _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array = values["https://www.w3.org/ns/activitystreams#liked"];
		for (const v of _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array == null ? [] : _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array.length === 1 && "@list" in _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array[0] ? _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array[0]["@list"] : _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.push(await Collection.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked;
		const _4N1vBJzXDf8NbBumeECQMFvKetja_featured = [];
		const _trust_4N1vBJzXDf8NbBumeECQMFvKetja_featured = /* @__PURE__ */ new Set();
		let _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array = values["http://joinmastodon.org/ns#featured"];
		for (const v of _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array == null ? [] : _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array.length === 1 && "@list" in _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array[0] ? _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array[0]["@list"] : _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_4N1vBJzXDf8NbBumeECQMFvKetja_featured.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_4N1vBJzXDf8NbBumeECQMFvKetja_featured.push(await Collection.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured = _4N1vBJzXDf8NbBumeECQMFvKetja_featured;
		const _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = [];
		const _trust_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = /* @__PURE__ */ new Set();
		let _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array = values["http://joinmastodon.org/ns#featuredTags"];
		for (const v of _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array == null ? [] : _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array.length === 1 && "@list" in _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array[0] ? _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array[0]["@list"] : _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.push(await Collection.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags;
		const _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = [];
		const _trust_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = /* @__PURE__ */ new Set();
		let _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array = values["https://www.w3.org/ns/activitystreams#streams"];
		for (const v of _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array == null ? [] : _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array.length === 1 && "@list" in _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array[0] ? _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array[0]["@list"] : _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.push(await Collection.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams;
		const _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = [];
		let _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array = values["https://www.w3.org/ns/activitystreams#endpoints"];
		for (const v of _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array == null ? [] : _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array.length === 1 && "@list" in _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array[0] ? _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array[0]["@list"] : _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array) {
			if (v == null) continue;
			_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints.push(await Endpoints.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints;
		const _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = [];
		let _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array = values["http://joinmastodon.org/ns#discoverable"];
		for (const v of _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array == null ? [] : _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array.length === 1 && "@list" in _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array[0] ? _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array[0]["@list"] : _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array) {
			if (v == null) continue;
			_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable.push(v["@value"]);
		}
		instance.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable;
		const _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = [];
		let _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array = values["http://joinmastodon.org/ns#suspended"];
		for (const v of _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array == null ? [] : _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array.length === 1 && "@list" in _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array[0] ? _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array[0]["@list"] : _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array) {
			if (v == null) continue;
			_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended.push(v["@value"]);
		}
		instance.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended;
		const _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = [];
		let _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array = values["http://joinmastodon.org/ns#memorial"];
		for (const v of _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array == null ? [] : _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array.length === 1 && "@list" in _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array[0] ? _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array[0]["@list"] : _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array) {
			if (v == null) continue;
			_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial.push(v["@value"]);
		}
		instance.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial;
		const _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = [];
		let _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array = values["http://joinmastodon.org/ns#indexable"];
		for (const v of _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array == null ? [] : _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array.length === 1 && "@list" in _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array[0] ? _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array[0]["@list"] : _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array) {
			if (v == null) continue;
			_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable.push(v["@value"]);
		}
		instance.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable;
		const _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = [];
		const _trust_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = /* @__PURE__ */ new Set();
		let _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array = values["https://www.w3.org/ns/activitystreams#movedTo"];
		for (const v of _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array == null ? [] : _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array.length === 1 && "@list" in _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array[0] ? _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array[0]["@list"] : _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			const decoded = typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Application") ? await Application.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Group") ? await Group.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Organization") ? await Organization.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Person") ? await Person.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Service") ? await Service.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : void 0;
			if (typeof decoded === "undefined") continue;
			_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.push(decoded);
		}
		instance.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo;
		const _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = [];
		const _trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = /* @__PURE__ */ new Set();
		let _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array = values["https://www.w3.org/ns/activitystreams#alsoKnownAs"];
		for (const v of _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array == null ? [] : _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array.length === 1 && "@list" in _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array[0] ? _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array[0]["@list"] : _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			const decoded = typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Application") ? await Application.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Group") ? await Group.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Organization") ? await Organization.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Person") ? await Person.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Service") ? await Service.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : void 0;
			if (typeof decoded === "undefined") continue;
			_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.push(decoded);
		}
		instance.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs;
		const _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = [];
		const _trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = /* @__PURE__ */ new Set();
		let _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array = values["https://www.w3.org/ns/did#service"];
		for (const v of _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array == null ? [] : _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array.length === 1 && "@list" in _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array[0] ? _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array[0]["@list"] : _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.push(await DidService.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service;
		const _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = [];
		let _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array = values["https://misskey-hub.net/ns#_misskey_followedMessage"];
		for (const v of _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array == null ? [] : _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array.length === 1 && "@list" in _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array[0] ? _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array[0]["@list"] : _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array) {
			if (v == null) continue;
			_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage.push(v["@value"]);
		}
		instance.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage;
		const _2xEU4QtkC53RAun67T81Egqt9vmL_isCat = [];
		let _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array = values["https://misskey-hub.net/ns#isCat"];
		for (const v of _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array == null ? [] : _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array.length === 1 && "@list" in _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array[0] ? _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array[0]["@list"] : _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array) {
			if (v == null) continue;
			_2xEU4QtkC53RAun67T81Egqt9vmL_isCat.push(v["@value"]);
		}
		instance.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat = _2xEU4QtkC53RAun67T81Egqt9vmL_isCat;
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		const _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.length == 1) proxy.preferredUsername = _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername[0];
		if (_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.length > 1 || !("preferredUsername" in proxy) && _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.length > 0) proxy.preferredUsernames = _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername;
		const _axq166E2eZADq34V4MYUc8KMZdC_publicKey = this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_axq166E2eZADq34V4MYUc8KMZdC_publicKey.length == 1) proxy.publicKey = _axq166E2eZADq34V4MYUc8KMZdC_publicKey[0];
		if (_axq166E2eZADq34V4MYUc8KMZdC_publicKey.length > 1 || !("publicKey" in proxy) && _axq166E2eZADq34V4MYUc8KMZdC_publicKey.length > 0) proxy.publicKeys = _axq166E2eZADq34V4MYUc8KMZdC_publicKey;
		const _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.length == 1) proxy.assertionMethod = _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod[0];
		if (_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.length > 1 || !("assertionMethod" in proxy) && _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.length > 0) proxy.assertionMethods = _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod;
		const _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers.length == 1) proxy.manuallyApprovesFollowers = _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers[0];
		const _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.length == 1) proxy.inbox = _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox[0];
		const _41QwhqJouoLg3h8dRPKat21brynC_outbox = this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_41QwhqJouoLg3h8dRPKat21brynC_outbox.length == 1) proxy.outbox = _41QwhqJouoLg3h8dRPKat21brynC_outbox[0];
		const _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.length == 1) proxy.following = _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following[0];
		const _BBCTgfphhsFzpVfKTykGSpBNwoA_followers = this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.length == 1) proxy.followers = _BBCTgfphhsFzpVfKTykGSpBNwoA_followers[0];
		const _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.length == 1) proxy.liked = _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked[0];
		const _4N1vBJzXDf8NbBumeECQMFvKetja_featured = this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_4N1vBJzXDf8NbBumeECQMFvKetja_featured.length == 1) proxy.featured = _4N1vBJzXDf8NbBumeECQMFvKetja_featured[0];
		const _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.length == 1) proxy.featuredTags = _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags[0];
		const _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.length > 1 || !("stream" in proxy) && _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.length > 0) proxy.streams = _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams;
		const _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints.length == 1) proxy.endpoints = _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints[0];
		const _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable.length == 1) proxy.discoverable = _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable[0];
		const _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended.length == 1) proxy.suspended = _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended[0];
		const _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial.length == 1) proxy.memorial = _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial[0];
		const _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable.length == 1) proxy.indexable = _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable[0];
		const _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.length == 1) proxy.successor = _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo[0];
		const _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.length == 1) proxy.alias = _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs[0];
		if (_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.length > 1 || !("alias" in proxy) && _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.length > 0) proxy.aliases = _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs;
		const _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length == 1) proxy.service = _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service[0];
		if (_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length > 1 || !("service" in proxy) && _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length > 0) proxy.services = _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service;
		const _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage.length == 1) proxy.followedMessage = _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage[0];
		const _2xEU4QtkC53RAun67T81Egqt9vmL_isCat = this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_2xEU4QtkC53RAun67T81Egqt9vmL_isCat.length == 1) proxy.cat = _2xEU4QtkC53RAun67T81Egqt9vmL_isCat[0];
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "Group " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "Group " + inspect(proxy, options);
	}
};
/** A Link is an indirect, qualified reference to a resource identified by a URL.
* The fundamental model for links is established by RFC 5988. Many of the
* properties defined by the Activity Vocabulary allow values that are either
* instances of {@link Object} or {@link Link}. When a {@link Link} is used,
* it establishes a qualified relation connecting the subject (the containing
* object) to the resource identified by the `href`. Properties of
* the {@link Link} are properties of the reference as opposed to properties of
* the resource.
*/
var Link = class Link {
	#documentLoader;
	#contextLoader;
	#tracerProvider;
	#warning;
	#cachedJsonLd;
	id;
	get _documentLoader() {
		return this.#documentLoader;
	}
	get _contextLoader() {
		return this.#contextLoader;
	}
	get _tracerProvider() {
		return this.#tracerProvider;
	}
	get _warning() {
		return this.#warning;
	}
	get _cachedJsonLd() {
		return this.#cachedJsonLd;
	}
	set _cachedJsonLd(value) {
		this.#cachedJsonLd = value;
	}
	/**
	* The type URI of {@link Link}: `https://www.w3.org/ns/activitystreams#Link`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#Link");
	}
	#_pVjLsybKQdmkjuU7MHjiVmNnuj7_href = [];
	#_2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel = [];
	#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType = [];
	#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name = [];
	#_f57HKWCp1YRBbTJE8PF12RbDJGf_hreflang = [];
	#_2cGKFeFJMmiNpGZFEF75mCwFQsKb_height = [];
	#_2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width = [];
	#_gCVTegXxWWCw6wWRxa1QF65zusg_preview = [];
	#_trust_gCVTegXxWWCw6wWRxa1QF65zusg_preview = /* @__PURE__ */ new Set();
	/**
	* Constructs a new instance of Link with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		this.#documentLoader = options.documentLoader;
		this.#contextLoader = options.contextLoader;
		this.#tracerProvider = options.tracerProvider;
		if ("$warning" in options) this.#warning = options.$warning;
		if (values.id == null || values.id instanceof URL) this.id = values.id ?? null;
		else throw new TypeError("The id must be a URL.");
		if ("href" in values && values.href != null) if (values.href instanceof URL) this.#_pVjLsybKQdmkjuU7MHjiVmNnuj7_href = [values.href];
		else throw new TypeError("The href must be of type URL.");
		if ("rel" in values && values.rel != null) if (typeof values.rel === "string") this.#_2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel = [values.rel];
		else throw new TypeError("The rel must be of type string.");
		if ("rels" in values && values.rels != null) {
			if ("rel" in values && values.rel != null) throw new TypeError("Cannot initialize both rel and rels at the same time.");
			if (Array.isArray(values.rels) && values.rels.every((v) => typeof v === "string")) this.#_2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel = values.rels;
			else throw new TypeError("The rels must be an array of type string.");
		}
		if ("mediaType" in values && values.mediaType != null) if (typeof values.mediaType === "string") this.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType = [values.mediaType];
		else throw new TypeError("The mediaType must be of type string.");
		if ("name" in values && values.name != null) if (typeof values.name === "string" || values.name instanceof LanguageString) this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name = [values.name];
		else throw new TypeError("The name must be of type string | LanguageString.");
		if ("names" in values && values.names != null) {
			if ("name" in values && values.name != null) throw new TypeError("Cannot initialize both name and names at the same time.");
			if (Array.isArray(values.names) && values.names.every((v) => typeof v === "string" || v instanceof LanguageString)) this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name = values.names;
			else throw new TypeError("The names must be an array of type string | LanguageString.");
		}
		if ("language" in values && values.language != null) if (values.language instanceof LanguageTag) this.#_f57HKWCp1YRBbTJE8PF12RbDJGf_hreflang = [values.language];
		else throw new TypeError("The language must be of type LanguageTag.");
		if ("height" in values && values.height != null) if (typeof values.height === "number" && Number.isInteger(values.height) && values.height >= 0) this.#_2cGKFeFJMmiNpGZFEF75mCwFQsKb_height = [values.height];
		else throw new TypeError("The height must be of type number.");
		if ("width" in values && values.width != null) if (typeof values.width === "number" && Number.isInteger(values.width) && values.width >= 0) this.#_2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width = [values.width];
		else throw new TypeError("The width must be of type number.");
		if ("previews" in values && values.previews != null) if (Array.isArray(values.previews) && values.previews.every((v) => v instanceof Link || v instanceof Object$1 || v instanceof URL)) {
			this.#_gCVTegXxWWCw6wWRxa1QF65zusg_preview = values.previews;
			for (let i = 0; i < values.previews.length; i++) this.#_trust_gCVTegXxWWCw6wWRxa1QF65zusg_preview.add(i);
		} else throw new TypeError("The previews must be an array of type Link | Object | URL.");
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = new this.constructor({ id: values.id ?? this.id }, options);
		clone.#_pVjLsybKQdmkjuU7MHjiVmNnuj7_href = this.#_pVjLsybKQdmkjuU7MHjiVmNnuj7_href;
		if ("href" in values && values.href != null) if (values.href instanceof URL) clone.#_pVjLsybKQdmkjuU7MHjiVmNnuj7_href = [values.href];
		else throw new TypeError("The href must be of type URL.");
		clone.#_2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel = this.#_2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel;
		if ("rel" in values && values.rel != null) if (typeof values.rel === "string") clone.#_2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel = [values.rel];
		else throw new TypeError("The rel must be of type string.");
		if ("rels" in values && values.rels != null) {
			if ("rel" in values && values.rel != null) throw new TypeError("Cannot update both rel and rels at the same time.");
			if (Array.isArray(values.rels) && values.rels.every((v) => typeof v === "string")) clone.#_2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel = values.rels;
			else throw new TypeError("The rels must be an array of type string.");
		}
		clone.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType = this.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType;
		if ("mediaType" in values && values.mediaType != null) if (typeof values.mediaType === "string") clone.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType = [values.mediaType];
		else throw new TypeError("The mediaType must be of type string.");
		clone.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name = this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name;
		if ("name" in values && values.name != null) if (typeof values.name === "string" || values.name instanceof LanguageString) clone.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name = [values.name];
		else throw new TypeError("The name must be of type string | LanguageString.");
		if ("names" in values && values.names != null) {
			if ("name" in values && values.name != null) throw new TypeError("Cannot update both name and names at the same time.");
			if (Array.isArray(values.names) && values.names.every((v) => typeof v === "string" || v instanceof LanguageString)) clone.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name = values.names;
			else throw new TypeError("The names must be an array of type string | LanguageString.");
		}
		clone.#_f57HKWCp1YRBbTJE8PF12RbDJGf_hreflang = this.#_f57HKWCp1YRBbTJE8PF12RbDJGf_hreflang;
		if ("language" in values && values.language != null) if (values.language instanceof LanguageTag) clone.#_f57HKWCp1YRBbTJE8PF12RbDJGf_hreflang = [values.language];
		else throw new TypeError("The language must be of type LanguageTag.");
		clone.#_2cGKFeFJMmiNpGZFEF75mCwFQsKb_height = this.#_2cGKFeFJMmiNpGZFEF75mCwFQsKb_height;
		if ("height" in values && values.height != null) if (typeof values.height === "number" && Number.isInteger(values.height) && values.height >= 0) clone.#_2cGKFeFJMmiNpGZFEF75mCwFQsKb_height = [values.height];
		else throw new TypeError("The height must be of type number.");
		clone.#_2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width = this.#_2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width;
		if ("width" in values && values.width != null) if (typeof values.width === "number" && Number.isInteger(values.width) && values.width >= 0) clone.#_2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width = [values.width];
		else throw new TypeError("The width must be of type number.");
		clone.#_gCVTegXxWWCw6wWRxa1QF65zusg_preview = this.#_gCVTegXxWWCw6wWRxa1QF65zusg_preview;
		clone.#_trust_gCVTegXxWWCw6wWRxa1QF65zusg_preview = new Set(this.#_trust_gCVTegXxWWCw6wWRxa1QF65zusg_preview);
		if ("previews" in values && values.previews != null) if (Array.isArray(values.previews) && values.previews.every((v) => v instanceof Link || v instanceof Object$1 || v instanceof URL)) {
			clone.#_gCVTegXxWWCw6wWRxa1QF65zusg_preview = values.previews;
			clone.#_trust_gCVTegXxWWCw6wWRxa1QF65zusg_preview = /* @__PURE__ */ new Set();
			for (let i = 0; i < values.previews.length; i++) clone.#_trust_gCVTegXxWWCw6wWRxa1QF65zusg_preview.add(i);
		} else throw new TypeError("The previews must be an array of type Link | Object | URL.");
		return clone;
	}
	/** The target resource pointed to by a {@link Link}.
	*/
	get href() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_pVjLsybKQdmkjuU7MHjiVmNnuj7_href.length < 1) return null;
		return this.#_pVjLsybKQdmkjuU7MHjiVmNnuj7_href[0];
	}
	/** A link relation associated with a {@link Link}. The value MUST conform to
	* both the HTML5 and RFC 5988 "link relation" definitions.
	*
	* In the HTML5, any string not containing the space (U+0020), tab (U+0009),
	* LF (U+000A), FF (U+000C), CR (U+000D) or comma (U+002C) characters can
	* be used as a valid link relation.
	*/
	get rel() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel.length < 1) return null;
		return this.#_2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel[0];
	}
	/** A link relation associated with a {@link Link}. The value MUST conform to
	* both the HTML5 and RFC 5988 "link relation" definitions.
	*
	* In the HTML5, any string not containing the space (U+0020), tab (U+0009),
	* LF (U+000A), FF (U+000C), CR (U+000D) or comma (U+002C) characters can
	* be used as a valid link relation.
	*/
	get rels() {
		return this.#_2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel;
	}
	/** When used on a {@link Link}, identifies the MIME media type of the
	* referenced resource.
	*/
	get mediaType() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType.length < 1) return null;
		return this.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType[0];
	}
	/** A simple, human-readable, plain-text name for the object. HTML markup MUST
	* NOT be included. The name MAY be expressed using multiple language-tagged
	* values.
	*/
	get name() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name.length < 1) return null;
		return this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name[0];
	}
	/** A simple, human-readable, plain-text name for the object. HTML markup MUST
	* NOT be included. The name MAY be expressed using multiple language-tagged
	* values.
	*/
	get names() {
		return this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name;
	}
	/** Hints as to the language used by the target resource.
	* Value MUST be a BCP 47 Language-Tag.
	*/
	get language() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_f57HKWCp1YRBbTJE8PF12RbDJGf_hreflang.length < 1) return null;
		return this.#_f57HKWCp1YRBbTJE8PF12RbDJGf_hreflang[0];
	}
	/** On a {@link Link}, specifies a hint as to the rendering height in
	* device-independent pixels of the linked resource.
	*/
	get height() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2cGKFeFJMmiNpGZFEF75mCwFQsKb_height.length < 1) return null;
		return this.#_2cGKFeFJMmiNpGZFEF75mCwFQsKb_height[0];
	}
	/** On a {@link Link}, specifies a hint as to the rendering width in
	* device-independent pixels of the linked resource.
	*/
	get width() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width.length < 1) return null;
		return this.#_2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width[0];
	}
	async #fetchPreview(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#preview_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #preview_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Link.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Object$1.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Link", "https://www.w3.org/ns/activitystreams#Object"].join(", "));
	}
	/**
	* Similar to
	* {@link Link.getPreviews},
	* but returns their `@id`s instead of the objects themselves.
	*/
	get previewIds() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		return this.#_gCVTegXxWWCw6wWRxa1QF65zusg_preview.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
	}
	/** Identifies an entity that provides a preview of this object.
	*/
	async *getPreviews(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		const vs = this.#_gCVTegXxWWCw6wWRxa1QF65zusg_preview;
		for (let i = 0; i < vs.length; i++) {
			let v = vs[i];
			if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_gCVTegXxWWCw6wWRxa1QF65zusg_preview.has(i)) v = v.id;
			if (v instanceof URL) {
				const fetched = await this.#fetchPreview(v, options);
				if (fetched == null) continue;
				vs[i] = fetched;
				this.#_trust_gCVTegXxWWCw6wWRxa1QF65zusg_preview.add(i);
				this._cachedJsonLd = void 0;
				yield fetched;
				continue;
			}
			if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "preview" in this._cachedJsonLd) {
				const prop = this._cachedJsonLd["preview"];
				const obj = Array.isArray(prop) ? prop[i] : prop;
				if (obj != null && typeof obj === "object" && "@context" in obj) v = await this.#preview_fromJsonLd(obj, options);
			}
			if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_gCVTegXxWWCw6wWRxa1QF65zusg_preview.has(0)) {
				if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
				getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
					objectId: v.id.href,
					parentObjectId: this.id.href
				});
				continue;
			}
			yield v;
		}
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		if (options.format == null && this.isCompactable()) {
			const result = {};
			let compactItems;
			compactItems = [];
			for (const v of this.#_pVjLsybKQdmkjuU7MHjiVmNnuj7_href) {
				const item = v.href;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["href"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel) {
				const item = v;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["rel"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType) {
				const item = v;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["mediaType"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name) {
				const item = typeof v === "string" ? v : {
					"@value": v.toString(),
					"@language": v.language.compact()
				};
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["name"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_f57HKWCp1YRBbTJE8PF12RbDJGf_hreflang) {
				const item = v.compact();
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["hreflang"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_2cGKFeFJMmiNpGZFEF75mCwFQsKb_height) {
				const item = v;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["height"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width) {
				const item = v;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["width"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_gCVTegXxWWCw6wWRxa1QF65zusg_preview) {
				const item = v instanceof URL ? v.href : v instanceof Link ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["preview"] = compactItems.length > 1 ? compactItems : compactItems[0];
			result["type"] = "Link";
			if (this.id != null) result["id"] = this.id.href;
			result["@context"] = "https://www.w3.org/ns/activitystreams";
			return result;
		}
		let array;
		const values = {};
		array = [];
		for (const v of this.#_pVjLsybKQdmkjuU7MHjiVmNnuj7_href) {
			const element = { "@id": v.href };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#href"] = propValue;
		}
		array = [];
		for (const v of this.#_2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel) {
			const element = { "@value": v };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#rel"] = propValue;
		}
		array = [];
		for (const v of this.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType) {
			const element = { "@value": v };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#mediaType"] = propValue;
		}
		array = [];
		for (const v of this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name) {
			const element = typeof v === "string" ? { "@value": v } : {
				"@value": v.toString(),
				"@language": v.language.compact()
			};
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#name"] = propValue;
		}
		array = [];
		for (const v of this.#_f57HKWCp1YRBbTJE8PF12RbDJGf_hreflang) {
			const element = { "@value": v.compact() };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#hreflang"] = propValue;
		}
		array = [];
		for (const v of this.#_2cGKFeFJMmiNpGZFEF75mCwFQsKb_height) {
			const element = {
				"@type": "http://www.w3.org/2001/XMLSchema#nonNegativeInteger",
				"@value": v
			};
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#height"] = propValue;
		}
		array = [];
		for (const v of this.#_2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width) {
			const element = {
				"@type": "http://www.w3.org/2001/XMLSchema#nonNegativeInteger",
				"@value": v
			};
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#width"] = propValue;
		}
		array = [];
		for (const v of this.#_gCVTegXxWWCw6wWRxa1QF65zusg_preview) {
			const element = v instanceof URL ? { "@id": v.href } : v instanceof Link ? await v.toJsonLd(options) : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#preview"] = propValue;
		}
		values["@type"] = ["https://www.w3.org/ns/activitystreams#Link"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? "https://www.w3.org/ns/activitystreams";
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {}
		return compacted;
	}
	isCompactable() {
		if (this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name != null && this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name.length > 0) return false;
		return true;
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__Link__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__Link__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Hashtag")) return await Hashtag.fromJsonLd(json, options);
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Mention")) return await Mention.fromJsonLd(json, options);
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Link")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		const instance = new this({ id: "@id" in values ? new URL(values["@id"]) : void 0 }, options);
		const _pVjLsybKQdmkjuU7MHjiVmNnuj7_href = [];
		let _pVjLsybKQdmkjuU7MHjiVmNnuj7_href__array = values["https://www.w3.org/ns/activitystreams#href"];
		for (const v of _pVjLsybKQdmkjuU7MHjiVmNnuj7_href__array == null ? [] : _pVjLsybKQdmkjuU7MHjiVmNnuj7_href__array.length === 1 && "@list" in _pVjLsybKQdmkjuU7MHjiVmNnuj7_href__array[0] ? _pVjLsybKQdmkjuU7MHjiVmNnuj7_href__array[0]["@list"] : _pVjLsybKQdmkjuU7MHjiVmNnuj7_href__array) {
			if (v == null) continue;
			_pVjLsybKQdmkjuU7MHjiVmNnuj7_href.push(v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].includes("/", 5) ? v["@id"].slice(5, v["@id"].indexOf("/", 5)) : v["@id"].slice(5)) + (v["@id"].includes("/", 5) ? v["@id"].slice(v["@id"].indexOf("/", 5)) : "")) : URL.canParse(v["@id"]) && (values["@id"] == null ? options.baseUrl : new URL(values["@id"])) ? new URL(v["@id"]) : new URL(v["@id"], values["@id"] == null ? options.baseUrl : new URL(values["@id"])));
		}
		instance.#_pVjLsybKQdmkjuU7MHjiVmNnuj7_href = _pVjLsybKQdmkjuU7MHjiVmNnuj7_href;
		const _2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel = [];
		let _2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel__array = values["https://www.w3.org/ns/activitystreams#rel"];
		for (const v of _2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel__array == null ? [] : _2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel__array.length === 1 && "@list" in _2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel__array[0] ? _2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel__array[0]["@list"] : _2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel__array) {
			if (v == null) continue;
			_2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel.push(v["@value"]);
		}
		instance.#_2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel = _2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel;
		const _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType = [];
		let _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType__array = values["https://www.w3.org/ns/activitystreams#mediaType"];
		for (const v of _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType__array == null ? [] : _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType__array.length === 1 && "@list" in _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType__array[0] ? _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType__array[0]["@list"] : _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType__array) {
			if (v == null) continue;
			_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType.push(v["@value"]);
		}
		instance.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType = _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType;
		const _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name = [];
		let _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name__array = values["https://www.w3.org/ns/activitystreams#name"];
		for (const v of _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name__array == null ? [] : _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name__array.length === 1 && "@list" in _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name__array[0] ? _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name__array[0]["@list"] : _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name__array) {
			if (v == null) continue;
			const decoded = typeof v === "object" && "@value" in v && typeof v["@value"] === "string" && !("@language" in v) ? v["@value"] : typeof v === "object" && "@language" in v && "@value" in v && typeof v["@language"] === "string" && typeof v["@value"] === "string" ? new LanguageString(v["@value"], v["@language"]) : void 0;
			if (typeof decoded === "undefined") continue;
			_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name.push(decoded);
		}
		instance.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name = _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name;
		const _f57HKWCp1YRBbTJE8PF12RbDJGf_hreflang = [];
		let _f57HKWCp1YRBbTJE8PF12RbDJGf_hreflang__array = values["https://www.w3.org/ns/activitystreams#hreflang"];
		for (const v of _f57HKWCp1YRBbTJE8PF12RbDJGf_hreflang__array == null ? [] : _f57HKWCp1YRBbTJE8PF12RbDJGf_hreflang__array.length === 1 && "@list" in _f57HKWCp1YRBbTJE8PF12RbDJGf_hreflang__array[0] ? _f57HKWCp1YRBbTJE8PF12RbDJGf_hreflang__array[0]["@list"] : _f57HKWCp1YRBbTJE8PF12RbDJGf_hreflang__array) {
			if (v == null) continue;
			_f57HKWCp1YRBbTJE8PF12RbDJGf_hreflang.push(parseLanguageTag(v["@value"]));
		}
		instance.#_f57HKWCp1YRBbTJE8PF12RbDJGf_hreflang = _f57HKWCp1YRBbTJE8PF12RbDJGf_hreflang;
		const _2cGKFeFJMmiNpGZFEF75mCwFQsKb_height = [];
		let _2cGKFeFJMmiNpGZFEF75mCwFQsKb_height__array = values["https://www.w3.org/ns/activitystreams#height"];
		for (const v of _2cGKFeFJMmiNpGZFEF75mCwFQsKb_height__array == null ? [] : _2cGKFeFJMmiNpGZFEF75mCwFQsKb_height__array.length === 1 && "@list" in _2cGKFeFJMmiNpGZFEF75mCwFQsKb_height__array[0] ? _2cGKFeFJMmiNpGZFEF75mCwFQsKb_height__array[0]["@list"] : _2cGKFeFJMmiNpGZFEF75mCwFQsKb_height__array) {
			if (v == null) continue;
			_2cGKFeFJMmiNpGZFEF75mCwFQsKb_height.push(v["@value"]);
		}
		instance.#_2cGKFeFJMmiNpGZFEF75mCwFQsKb_height = _2cGKFeFJMmiNpGZFEF75mCwFQsKb_height;
		const _2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width = [];
		let _2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width__array = values["https://www.w3.org/ns/activitystreams#width"];
		for (const v of _2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width__array == null ? [] : _2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width__array.length === 1 && "@list" in _2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width__array[0] ? _2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width__array[0]["@list"] : _2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width__array) {
			if (v == null) continue;
			_2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width.push(v["@value"]);
		}
		instance.#_2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width = _2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width;
		const _gCVTegXxWWCw6wWRxa1QF65zusg_preview = [];
		const _trust_gCVTegXxWWCw6wWRxa1QF65zusg_preview = /* @__PURE__ */ new Set();
		let _gCVTegXxWWCw6wWRxa1QF65zusg_preview__array = values["https://www.w3.org/ns/activitystreams#preview"];
		for (const v of _gCVTegXxWWCw6wWRxa1QF65zusg_preview__array == null ? [] : _gCVTegXxWWCw6wWRxa1QF65zusg_preview__array.length === 1 && "@list" in _gCVTegXxWWCw6wWRxa1QF65zusg_preview__array[0] ? _gCVTegXxWWCw6wWRxa1QF65zusg_preview__array[0]["@list"] : _gCVTegXxWWCw6wWRxa1QF65zusg_preview__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_gCVTegXxWWCw6wWRxa1QF65zusg_preview.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			const decoded = typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && [
				"https://www.w3.org/ns/activitystreams#Link",
				"https://www.w3.org/ns/activitystreams#Hashtag",
				"https://www.w3.org/ns/activitystreams#Mention"
			].some((t) => v["@type"].includes(t)) ? await Link.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && [
				"https://www.w3.org/ns/activitystreams#Object",
				"http://joinmastodon.org/ns#Emoji",
				"http://litepub.social/ns#ChatMessage",
				"https://www.w3.org/ns/activitystreams#Activity",
				"http://litepub.social/ns#EmojiReact",
				"https://www.w3.org/ns/activitystreams#Accept",
				"https://www.w3.org/ns/activitystreams#TentativeAccept",
				"https://www.w3.org/ns/activitystreams#Add",
				"https://www.w3.org/ns/activitystreams#Announce",
				"https://www.w3.org/ns/activitystreams#Create",
				"https://www.w3.org/ns/activitystreams#Delete",
				"https://www.w3.org/ns/activitystreams#Dislike",
				"https://www.w3.org/ns/activitystreams#Flag",
				"https://www.w3.org/ns/activitystreams#Follow",
				"https://www.w3.org/ns/activitystreams#Ignore",
				"https://www.w3.org/ns/activitystreams#Block",
				"https://www.w3.org/ns/activitystreams#IntransitiveActivity",
				"https://www.w3.org/ns/activitystreams#Arrive",
				"https://www.w3.org/ns/activitystreams#Question",
				"https://www.w3.org/ns/activitystreams#Travel",
				"https://www.w3.org/ns/activitystreams#Join",
				"https://www.w3.org/ns/activitystreams#Leave",
				"https://www.w3.org/ns/activitystreams#Like",
				"https://www.w3.org/ns/activitystreams#Listen",
				"https://www.w3.org/ns/activitystreams#Move",
				"https://www.w3.org/ns/activitystreams#Offer",
				"https://www.w3.org/ns/activitystreams#Invite",
				"https://www.w3.org/ns/activitystreams#Read",
				"https://www.w3.org/ns/activitystreams#Reject",
				"https://www.w3.org/ns/activitystreams#TentativeReject",
				"https://www.w3.org/ns/activitystreams#Remove",
				"https://www.w3.org/ns/activitystreams#Undo",
				"https://www.w3.org/ns/activitystreams#Update",
				"https://www.w3.org/ns/activitystreams#View",
				"https://www.w3.org/ns/activitystreams#Application",
				"https://www.w3.org/ns/activitystreams#Article",
				"https://www.w3.org/ns/activitystreams#Collection",
				"https://www.w3.org/ns/activitystreams#CollectionPage",
				"https://www.w3.org/ns/activitystreams#OrderedCollectionPage",
				"https://www.w3.org/ns/activitystreams#OrderedCollection",
				"https://www.w3.org/ns/activitystreams#Document",
				"https://www.w3.org/ns/activitystreams#Audio",
				"https://www.w3.org/ns/activitystreams#Image",
				"https://www.w3.org/ns/activitystreams#Page",
				"https://www.w3.org/ns/activitystreams#Video",
				"https://www.w3.org/ns/activitystreams#Event",
				"https://www.w3.org/ns/activitystreams#Group",
				"https://www.w3.org/ns/activitystreams#Note",
				"https://www.w3.org/ns/activitystreams#Organization",
				"https://www.w3.org/ns/activitystreams#Person",
				"https://www.w3.org/ns/activitystreams#Place",
				"https://www.w3.org/ns/activitystreams#Profile",
				"https://www.w3.org/ns/activitystreams#Relationship",
				"https://www.w3.org/ns/activitystreams#Service",
				"https://www.w3.org/ns/activitystreams#Tombstone"
			].some((t) => v["@type"].includes(t)) ? await Object$1.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : void 0;
			if (typeof decoded === "undefined") continue;
			_gCVTegXxWWCw6wWRxa1QF65zusg_preview.push(decoded);
		}
		instance.#_gCVTegXxWWCw6wWRxa1QF65zusg_preview = _gCVTegXxWWCw6wWRxa1QF65zusg_preview;
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = {};
		if (this.id != null) proxy.id = {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(this.id.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(this.id.href, options)
		};
		const _pVjLsybKQdmkjuU7MHjiVmNnuj7_href = this.#_pVjLsybKQdmkjuU7MHjiVmNnuj7_href.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_pVjLsybKQdmkjuU7MHjiVmNnuj7_href.length == 1) proxy.href = _pVjLsybKQdmkjuU7MHjiVmNnuj7_href[0];
		const _2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel = this.#_2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel.length == 1) proxy.rel = _2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel[0];
		if (_2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel.length > 1 || !("rel" in proxy) && _2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel.length > 0) proxy.rels = _2a1c5GkfkQsnyyLybF8UXBQfFuHZ_rel;
		const _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType = this.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType.length == 1) proxy.mediaType = _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType[0];
		const _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name = this.#_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name.length == 1) proxy.name = _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name[0];
		if (_4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name.length > 1 || !("name" in proxy) && _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name.length > 0) proxy.names = _4ZHbBuK7PrsvGgrjM8wgc6KMWjav_name;
		const _f57HKWCp1YRBbTJE8PF12RbDJGf_hreflang = this.#_f57HKWCp1YRBbTJE8PF12RbDJGf_hreflang.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_f57HKWCp1YRBbTJE8PF12RbDJGf_hreflang.length == 1) proxy.language = _f57HKWCp1YRBbTJE8PF12RbDJGf_hreflang[0];
		const _2cGKFeFJMmiNpGZFEF75mCwFQsKb_height = this.#_2cGKFeFJMmiNpGZFEF75mCwFQsKb_height.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_2cGKFeFJMmiNpGZFEF75mCwFQsKb_height.length == 1) proxy.height = _2cGKFeFJMmiNpGZFEF75mCwFQsKb_height[0];
		const _2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width = this.#_2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width.length == 1) proxy.width = _2e9AP7WdHBJYAgXG6GEyq7nSkNMe_width[0];
		const _gCVTegXxWWCw6wWRxa1QF65zusg_preview = this.#_gCVTegXxWWCw6wWRxa1QF65zusg_preview.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_gCVTegXxWWCw6wWRxa1QF65zusg_preview.length > 1 || !("preview" in proxy) && _gCVTegXxWWCw6wWRxa1QF65zusg_preview.length > 0) proxy.previews = _gCVTegXxWWCw6wWRxa1QF65zusg_preview;
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "Link " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "Link " + inspect(proxy, options);
	}
};
/** A specialized {@link Link} that represents an #hashtag.
*
* See also <https://swicg.github.io/miscellany/#Hashtag>.
*/
var Hashtag = class Hashtag extends Link {
	/**
	* The type URI of {@link Hashtag}: `https://www.w3.org/ns/activitystreams#Hashtag`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#Hashtag");
	}
	/**
	* Constructs a new instance of Hashtag with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		return clone;
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		if (options.format == null && this.isCompactable()) {
			const result = await super.toJsonLd({
				...options,
				format: void 0,
				context: void 0
			});
			let compactItems;
			result["type"] = "Hashtag";
			if (this.id != null) result["id"] = this.id.href;
			result["@context"] = ["https://www.w3.org/ns/activitystreams", { "Hashtag": "as:Hashtag" }];
			return result;
		}
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		values["@type"] = ["https://www.w3.org/ns/activitystreams#Hashtag"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? ["https://www.w3.org/ns/activitystreams", { "Hashtag": "as:Hashtag" }];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {}
		return compacted;
	}
	isCompactable() {
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__Hashtag__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__Hashtag__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Hashtag")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof Hashtag)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "Hashtag " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "Hashtag " + inspect(proxy, options);
	}
};
/** An image document of any kind.
*/
var Image = class Image extends Document {
	/**
	* The type URI of {@link Image}: `https://www.w3.org/ns/activitystreams#Image`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#Image");
	}
	/**
	* Constructs a new instance of Image with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		return clone;
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		if (options.format == null && this.isCompactable()) {
			const result = await super.toJsonLd({
				...options,
				format: void 0,
				context: void 0
			});
			let compactItems;
			result["type"] = "Image";
			if (this.id != null) result["id"] = this.id.href;
			result["@context"] = "https://www.w3.org/ns/activitystreams";
			return result;
		}
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		values["@type"] = ["https://www.w3.org/ns/activitystreams#Image"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? "https://www.w3.org/ns/activitystreams";
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {
			if ("proof" in compacted && compacted.proof != null) if (Array.isArray(compacted.proof)) for (const element of compacted.proof) element["@context"] = docContext;
			else compacted.proof["@context"] = docContext;
		}
		return compacted;
	}
	isCompactable() {
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__Image__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__Image__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Image")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof Image)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "Image " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "Image " + inspect(proxy, options);
	}
};
/** Indicates that the actor is offering the object.
* If specified, the target indicates the entity to which
* the object is being offered.
*/
var Offer = class Offer extends Activity {
	/**
	* The type URI of {@link Offer}: `https://www.w3.org/ns/activitystreams#Offer`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#Offer");
	}
	/**
	* Constructs a new instance of Offer with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		return clone;
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		values["@type"] = ["https://www.w3.org/ns/activitystreams#Offer"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? [
			"https://w3id.org/identity/v1",
			"https://www.w3.org/ns/activitystreams",
			"https://w3id.org/security/data-integrity/v1"
		];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {
			if ("proof" in compacted && compacted.proof != null) if (Array.isArray(compacted.proof)) for (const element of compacted.proof) element["@context"] = docContext;
			else compacted.proof["@context"] = docContext;
		}
		return compacted;
	}
	isCompactable() {
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__Offer__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__Offer__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#Invite")) return await Invite.fromJsonLd(json, options);
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Offer")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof Offer)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "Offer " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "Offer " + inspect(proxy, options);
	}
};
/** A specialization of `Offer` in which the `actor` is extending an invitation
* for the `object` to the `target`.
*/
var Invite = class Invite extends Offer {
	/**
	* The type URI of {@link Invite}: `https://www.w3.org/ns/activitystreams#Invite`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#Invite");
	}
	/**
	* Constructs a new instance of Invite with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		return clone;
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		values["@type"] = ["https://www.w3.org/ns/activitystreams#Invite"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? [
			"https://w3id.org/identity/v1",
			"https://www.w3.org/ns/activitystreams",
			"https://w3id.org/security/data-integrity/v1"
		];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {
			if ("proof" in compacted && compacted.proof != null) if (Array.isArray(compacted.proof)) for (const element of compacted.proof) element["@context"] = docContext;
			else compacted.proof["@context"] = docContext;
		}
		return compacted;
	}
	isCompactable() {
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__Invite__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__Invite__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Invite")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof Invite)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "Invite " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "Invite " + inspect(proxy, options);
	}
};
/** Indicates that the `actor` has joined the `object`.
* The `target` and `origin` typically have no defined meaning.
*/
var Join = class Join extends Activity {
	/**
	* The type URI of {@link Join}: `https://www.w3.org/ns/activitystreams#Join`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#Join");
	}
	/**
	* Constructs a new instance of Join with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		return clone;
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		values["@type"] = ["https://www.w3.org/ns/activitystreams#Join"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? [
			"https://w3id.org/identity/v1",
			"https://www.w3.org/ns/activitystreams",
			"https://w3id.org/security/data-integrity/v1"
		];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {
			if ("proof" in compacted && compacted.proof != null) if (Array.isArray(compacted.proof)) for (const element of compacted.proof) element["@context"] = docContext;
			else compacted.proof["@context"] = docContext;
		}
		return compacted;
	}
	isCompactable() {
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__Join__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__Join__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Join")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof Join)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "Join " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "Join " + inspect(proxy, options);
	}
};
/** Indicates that the `actor` has left the `object`.
* The `target` and `origin` typically have no meaning.
*/
var Leave = class Leave extends Activity {
	/**
	* The type URI of {@link Leave}: `https://www.w3.org/ns/activitystreams#Leave`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#Leave");
	}
	/**
	* Constructs a new instance of Leave with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		return clone;
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		values["@type"] = ["https://www.w3.org/ns/activitystreams#Leave"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? [
			"https://w3id.org/identity/v1",
			"https://www.w3.org/ns/activitystreams",
			"https://w3id.org/security/data-integrity/v1"
		];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {
			if ("proof" in compacted && compacted.proof != null) if (Array.isArray(compacted.proof)) for (const element of compacted.proof) element["@context"] = docContext;
			else compacted.proof["@context"] = docContext;
		}
		return compacted;
	}
	isCompactable() {
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__Leave__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__Leave__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Leave")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof Leave)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "Leave " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "Leave " + inspect(proxy, options);
	}
};
/** Indicates that the `actor` likes, recommends or endorses the `object`.
* The `target` and `origin` typically have no defined meaning.
*/
var Like = class Like extends Activity {
	/**
	* The type URI of {@link Like}: `https://www.w3.org/ns/activitystreams#Like`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#Like");
	}
	/**
	* Constructs a new instance of Like with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		return clone;
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		values["@type"] = ["https://www.w3.org/ns/activitystreams#Like"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? [
			"https://w3id.org/identity/v1",
			"https://www.w3.org/ns/activitystreams",
			"https://w3id.org/security/data-integrity/v1",
			{
				"toot": "http://joinmastodon.org/ns#",
				"Emoji": "toot:Emoji"
			}
		];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {
			if ("proof" in compacted && compacted.proof != null) if (Array.isArray(compacted.proof)) for (const element of compacted.proof) element["@context"] = docContext;
			else compacted.proof["@context"] = docContext;
		}
		return compacted;
	}
	isCompactable() {
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__Like__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__Like__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Like")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof Like)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "Like " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "Like " + inspect(proxy, options);
	}
};
/** Indicates that the `actor` has listened to the `object`.
*/
var Listen = class Listen extends Activity {
	/**
	* The type URI of {@link Listen}: `https://www.w3.org/ns/activitystreams#Listen`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#Listen");
	}
	/**
	* Constructs a new instance of Listen with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		return clone;
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		values["@type"] = ["https://www.w3.org/ns/activitystreams#Listen"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? [
			"https://w3id.org/identity/v1",
			"https://www.w3.org/ns/activitystreams",
			"https://w3id.org/security/data-integrity/v1"
		];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {
			if ("proof" in compacted && compacted.proof != null) if (Array.isArray(compacted.proof)) for (const element of compacted.proof) element["@context"] = docContext;
			else compacted.proof["@context"] = docContext;
		}
		return compacted;
	}
	isCompactable() {
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__Listen__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__Listen__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Listen")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof Listen)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "Listen " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "Listen " + inspect(proxy, options);
	}
};
/** A specialized {@link Link} that represents an @mention.
*/
var Mention = class Mention extends Link {
	/**
	* The type URI of {@link Mention}: `https://www.w3.org/ns/activitystreams#Mention`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#Mention");
	}
	/**
	* Constructs a new instance of Mention with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		return clone;
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		if (options.format == null && this.isCompactable()) {
			const result = await super.toJsonLd({
				...options,
				format: void 0,
				context: void 0
			});
			let compactItems;
			result["type"] = "Mention";
			if (this.id != null) result["id"] = this.id.href;
			result["@context"] = "https://www.w3.org/ns/activitystreams";
			return result;
		}
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		values["@type"] = ["https://www.w3.org/ns/activitystreams#Mention"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? "https://www.w3.org/ns/activitystreams";
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {}
		return compacted;
	}
	isCompactable() {
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__Mention__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__Mention__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Mention")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof Mention)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "Mention " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "Mention " + inspect(proxy, options);
	}
};
/** Indicates that the `actor` has moved `object` from `origin` to `target`.
* If the `origin` or `target` are not specified,
* either can be determined by context.
*/
var Move = class Move extends Activity {
	/**
	* The type URI of {@link Move}: `https://www.w3.org/ns/activitystreams#Move`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#Move");
	}
	/**
	* Constructs a new instance of Move with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		return clone;
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		values["@type"] = ["https://www.w3.org/ns/activitystreams#Move"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? [
			"https://w3id.org/identity/v1",
			"https://www.w3.org/ns/activitystreams",
			"https://w3id.org/security/data-integrity/v1"
		];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {
			if ("proof" in compacted && compacted.proof != null) if (Array.isArray(compacted.proof)) for (const element of compacted.proof) element["@context"] = docContext;
			else compacted.proof["@context"] = docContext;
		}
		return compacted;
	}
	isCompactable() {
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__Move__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__Move__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Move")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof Move)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "Move " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "Move " + inspect(proxy, options);
	}
};
/** Represents a short written work typically less than a single paragraph in
* length.
*/
var Note = class Note extends Object$1 {
	/**
	* The type URI of {@link Note}: `https://www.w3.org/ns/activitystreams#Note`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#Note");
	}
	#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl = [];
	/**
	* Constructs a new instance of Note with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
		if ("quoteUrl" in values && values.quoteUrl != null) if (values.quoteUrl instanceof URL) this.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl = [values.quoteUrl];
		else throw new TypeError("The quoteUrl must be of type URL.");
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		clone.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl = this.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl;
		if ("quoteUrl" in values && values.quoteUrl != null) if (values.quoteUrl instanceof URL) clone.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl = [values.quoteUrl];
		else throw new TypeError("The quoteUrl must be of type URL.");
		return clone;
	}
	/** The URI of the ActivityStreams object that this object quotes.
	*
	* This property sets three JSON-LD properties at once under the hood:
	*
	* 1. https://www.w3.org/ns/activitystreams#quoteUrl
	* 2. https://misskey-hub.net/ns#_misskey_quote
	* 3. http://fedibird.com/ns#quoteUri
	*
	* When a JSON-LD object is parsed, this property is filled with one of
	* the values of those three properties in order.
	*/
	get quoteUrl() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl.length < 1) return null;
		return this.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl[0];
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		if (options.format == null && this.isCompactable()) {
			const result = await super.toJsonLd({
				...options,
				format: void 0,
				context: void 0
			});
			let compactItems;
			compactItems = [];
			for (const v of this.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl) {
				const item = v.href;
				compactItems.push(item);
			}
			if (compactItems.length > 0) {
				result["quoteUrl"] = compactItems.length > 1 ? compactItems : compactItems[0];
				result["_misskey_quote"] = compactItems.length > 1 ? compactItems : compactItems[0];
				result["quoteUri"] = compactItems.length > 1 ? compactItems : compactItems[0];
			}
			result["type"] = "Note";
			if (this.id != null) result["id"] = this.id.href;
			result["@context"] = [
				"https://www.w3.org/ns/activitystreams",
				"https://w3id.org/security/data-integrity/v1",
				{
					"toot": "http://joinmastodon.org/ns#",
					"misskey": "https://misskey-hub.net/ns#",
					"fedibird": "http://fedibird.com/ns#",
					"sensitive": "as:sensitive",
					"Emoji": "toot:Emoji",
					"Hashtag": "as:Hashtag",
					"quoteUrl": "as:quoteUrl",
					"_misskey_quote": "misskey:_misskey_quote",
					"quoteUri": "fedibird:quoteUri",
					"emojiReactions": {
						"@id": "fedibird:emojiReactions",
						"@type": "@id"
					}
				}
			];
			return result;
		}
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		array = [];
		for (const v of this.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl) {
			const element = { "@value": v.href };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#quoteUrl"] = propValue;
			values["https://misskey-hub.net/ns#_misskey_quote"] = propValue;
			values["http://fedibird.com/ns#quoteUri"] = propValue;
		}
		values["@type"] = ["https://www.w3.org/ns/activitystreams#Note"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? [
			"https://www.w3.org/ns/activitystreams",
			"https://w3id.org/security/data-integrity/v1",
			{
				"toot": "http://joinmastodon.org/ns#",
				"misskey": "https://misskey-hub.net/ns#",
				"fedibird": "http://fedibird.com/ns#",
				"sensitive": "as:sensitive",
				"Emoji": "toot:Emoji",
				"Hashtag": "as:Hashtag",
				"quoteUrl": "as:quoteUrl",
				"_misskey_quote": "misskey:_misskey_quote",
				"quoteUri": "fedibird:quoteUri",
				"emojiReactions": {
					"@id": "fedibird:emojiReactions",
					"@type": "@id"
				}
			}
		];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {
			if ("proof" in compacted && compacted.proof != null) if (Array.isArray(compacted.proof)) for (const element of compacted.proof) element["@context"] = docContext;
			else compacted.proof["@context"] = docContext;
		}
		return compacted;
	}
	isCompactable() {
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__Note__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__Note__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Note")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof Note)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		const _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl = [];
		let _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array = values["https://www.w3.org/ns/activitystreams#quoteUrl"];
		if (_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array == null || _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array.length < 1) _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array = values["https://misskey-hub.net/ns#_misskey_quote"];
		if (_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array == null || _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array.length < 1) _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array = values["http://fedibird.com/ns#quoteUri"];
		for (const v of _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array == null ? [] : _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array.length === 1 && "@list" in _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array[0] ? _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array[0]["@list"] : _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array) {
			if (v == null) continue;
			_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl.push(new URL(v["@value"]));
		}
		instance.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl = _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl;
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		const _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl = this.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl.length == 1) proxy.quoteUrl = _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl[0];
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "Note " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "Note " + inspect(proxy, options);
	}
};
/** A subtype of {@link Collection} in which members of the logical collection
* are assumed to always be strictly ordered.
*/
var OrderedCollection = class OrderedCollection extends Collection {
	/**
	* The type URI of {@link OrderedCollection}: `https://www.w3.org/ns/activitystreams#OrderedCollection`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#OrderedCollection");
	}
	#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items = [];
	#_trust_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items = /* @__PURE__ */ new Set();
	/**
	* Constructs a new instance of OrderedCollection with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
		if ("items" in values && values.items != null) if (Array.isArray(values.items) && values.items.every((v) => v instanceof Object$1 || v instanceof Link || v instanceof URL)) {
			this.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items = values.items;
			for (let i = 0; i < values.items.length; i++) this.#_trust_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items.add(i);
		} else throw new TypeError("The items must be an array of type Object | Link | URL.");
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		clone.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items = this.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items;
		clone.#_trust_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items = new Set(this.#_trust_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items);
		if ("items" in values && values.items != null) if (Array.isArray(values.items) && values.items.every((v) => v instanceof Object$1 || v instanceof Link || v instanceof URL)) {
			clone.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items = values.items;
			clone.#_trust_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items = /* @__PURE__ */ new Set();
			for (let i = 0; i < values.items.length; i++) clone.#_trust_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items.add(i);
		} else throw new TypeError("The items must be an array of type Object | Link | URL.");
		return clone;
	}
	async #fetchItem(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#item_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #item_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Object$1.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Link.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Object", "https://www.w3.org/ns/activitystreams#Link"].join(", "));
	}
	/**
	* Similar to
	* {@link OrderedCollection.getItems},
	* but returns their `@id`s instead of the objects themselves.
	*/
	get itemIds() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		return this.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
	}
	/** Identifies the items contained in a collection.  The items might be ordered
	* or unordered.
	*/
	async *getItems(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		const vs = this.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items;
		for (let i = 0; i < vs.length; i++) {
			let v = vs[i];
			if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items.has(i)) v = v.id;
			if (v instanceof URL) {
				const fetched = await this.#fetchItem(v, options);
				if (fetched == null) continue;
				vs[i] = fetched;
				this.#_trust_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items.add(i);
				this._cachedJsonLd = void 0;
				yield fetched;
				continue;
			}
			if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "orderedItems" in this._cachedJsonLd) {
				const prop = this._cachedJsonLd["orderedItems"];
				const obj = Array.isArray(prop) ? prop[i] : prop;
				if (obj != null && typeof obj === "object" && "@context" in obj) v = await this.#item_fromJsonLd(obj, options);
			}
			if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items.has(0)) {
				if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
				getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
					objectId: v.id.href,
					parentObjectId: this.id.href
				});
				continue;
			}
			yield v;
		}
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		if (options.format == null && this.isCompactable()) {
			const result = await super.toJsonLd({
				...options,
				format: void 0,
				context: void 0
			});
			delete result["items"];
			let compactItems;
			compactItems = [];
			for (const v of this.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items) {
				const item = v instanceof URL ? v.href : v instanceof Object$1 ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["orderedItems"] = compactItems;
			result["type"] = "OrderedCollection";
			if (this.id != null) result["id"] = this.id.href;
			result["@context"] = [
				"https://www.w3.org/ns/activitystreams",
				"https://w3id.org/security/data-integrity/v1",
				{
					"toot": "http://joinmastodon.org/ns#",
					"misskey": "https://misskey-hub.net/ns#",
					"fedibird": "http://fedibird.com/ns#",
					"ChatMessage": "http://litepub.social/ns#ChatMessage",
					"sensitive": "as:sensitive",
					"votersCount": "toot:votersCount",
					"Emoji": "toot:Emoji",
					"Hashtag": "as:Hashtag",
					"quoteUrl": "as:quoteUrl",
					"_misskey_quote": "misskey:_misskey_quote",
					"quoteUri": "fedibird:quoteUri",
					"emojiReactions": {
						"@id": "fedibird:emojiReactions",
						"@type": "@id"
					}
				}
			];
			return result;
		}
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		array = [];
		for (const v of this.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items) {
			const element = v instanceof URL ? { "@id": v.href } : v instanceof Object$1 ? await v.toJsonLd(options) : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = { "@list": array };
			values["https://www.w3.org/ns/activitystreams#items"] = propValue;
		}
		values["@type"] = ["https://www.w3.org/ns/activitystreams#OrderedCollection"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? [
			"https://www.w3.org/ns/activitystreams",
			"https://w3id.org/security/data-integrity/v1",
			{
				"toot": "http://joinmastodon.org/ns#",
				"misskey": "https://misskey-hub.net/ns#",
				"fedibird": "http://fedibird.com/ns#",
				"ChatMessage": "http://litepub.social/ns#ChatMessage",
				"sensitive": "as:sensitive",
				"votersCount": "toot:votersCount",
				"Emoji": "toot:Emoji",
				"Hashtag": "as:Hashtag",
				"quoteUrl": "as:quoteUrl",
				"_misskey_quote": "misskey:_misskey_quote",
				"quoteUri": "fedibird:quoteUri",
				"emojiReactions": {
					"@id": "fedibird:emojiReactions",
					"@type": "@id"
				}
			}
		];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {
			if ("proof" in compacted && compacted.proof != null) if (Array.isArray(compacted.proof)) for (const element of compacted.proof) element["@context"] = docContext;
			else compacted.proof["@context"] = docContext;
		}
		return compacted;
	}
	isCompactable() {
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__OrderedCollection__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__OrderedCollection__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#OrderedCollection")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof OrderedCollection)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		const _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items = [];
		const _trust_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items = /* @__PURE__ */ new Set();
		let _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items__array = values["https://www.w3.org/ns/activitystreams#items"];
		for (const v of _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items__array == null ? [] : _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items__array.length === 1 && "@list" in _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items__array[0] ? _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items__array[0]["@list"] : _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			const decoded = typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && [
				"https://www.w3.org/ns/activitystreams#Object",
				"http://joinmastodon.org/ns#Emoji",
				"http://litepub.social/ns#ChatMessage",
				"https://www.w3.org/ns/activitystreams#Activity",
				"http://litepub.social/ns#EmojiReact",
				"https://www.w3.org/ns/activitystreams#Accept",
				"https://www.w3.org/ns/activitystreams#TentativeAccept",
				"https://www.w3.org/ns/activitystreams#Add",
				"https://www.w3.org/ns/activitystreams#Announce",
				"https://www.w3.org/ns/activitystreams#Create",
				"https://www.w3.org/ns/activitystreams#Delete",
				"https://www.w3.org/ns/activitystreams#Dislike",
				"https://www.w3.org/ns/activitystreams#Flag",
				"https://www.w3.org/ns/activitystreams#Follow",
				"https://www.w3.org/ns/activitystreams#Ignore",
				"https://www.w3.org/ns/activitystreams#Block",
				"https://www.w3.org/ns/activitystreams#IntransitiveActivity",
				"https://www.w3.org/ns/activitystreams#Arrive",
				"https://www.w3.org/ns/activitystreams#Question",
				"https://www.w3.org/ns/activitystreams#Travel",
				"https://www.w3.org/ns/activitystreams#Join",
				"https://www.w3.org/ns/activitystreams#Leave",
				"https://www.w3.org/ns/activitystreams#Like",
				"https://www.w3.org/ns/activitystreams#Listen",
				"https://www.w3.org/ns/activitystreams#Move",
				"https://www.w3.org/ns/activitystreams#Offer",
				"https://www.w3.org/ns/activitystreams#Invite",
				"https://www.w3.org/ns/activitystreams#Read",
				"https://www.w3.org/ns/activitystreams#Reject",
				"https://www.w3.org/ns/activitystreams#TentativeReject",
				"https://www.w3.org/ns/activitystreams#Remove",
				"https://www.w3.org/ns/activitystreams#Undo",
				"https://www.w3.org/ns/activitystreams#Update",
				"https://www.w3.org/ns/activitystreams#View",
				"https://www.w3.org/ns/activitystreams#Application",
				"https://www.w3.org/ns/activitystreams#Article",
				"https://www.w3.org/ns/activitystreams#Collection",
				"https://www.w3.org/ns/activitystreams#CollectionPage",
				"https://www.w3.org/ns/activitystreams#OrderedCollectionPage",
				"https://www.w3.org/ns/activitystreams#OrderedCollection",
				"https://www.w3.org/ns/activitystreams#Document",
				"https://www.w3.org/ns/activitystreams#Audio",
				"https://www.w3.org/ns/activitystreams#Image",
				"https://www.w3.org/ns/activitystreams#Page",
				"https://www.w3.org/ns/activitystreams#Video",
				"https://www.w3.org/ns/activitystreams#Event",
				"https://www.w3.org/ns/activitystreams#Group",
				"https://www.w3.org/ns/activitystreams#Note",
				"https://www.w3.org/ns/activitystreams#Organization",
				"https://www.w3.org/ns/activitystreams#Person",
				"https://www.w3.org/ns/activitystreams#Place",
				"https://www.w3.org/ns/activitystreams#Profile",
				"https://www.w3.org/ns/activitystreams#Relationship",
				"https://www.w3.org/ns/activitystreams#Service",
				"https://www.w3.org/ns/activitystreams#Tombstone"
			].some((t) => v["@type"].includes(t)) ? await Object$1.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && [
				"https://www.w3.org/ns/activitystreams#Link",
				"https://www.w3.org/ns/activitystreams#Hashtag",
				"https://www.w3.org/ns/activitystreams#Mention"
			].some((t) => v["@type"].includes(t)) ? await Link.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : void 0;
			if (typeof decoded === "undefined") continue;
			_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items.push(decoded);
		}
		instance.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items = _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items;
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		const _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items = this.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items.length > 1 || !("item" in proxy) && _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items.length > 0) proxy.items = _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items;
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "OrderedCollection " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "OrderedCollection " + inspect(proxy, options);
	}
};
/** Used to represent ordered subsets of items from an `OrderedCollection`.
* Refer to the Activity Streams 2.0 Core for a complete description of
* the `OrderedCollectionPage` object.
*/
var OrderedCollectionPage = class OrderedCollectionPage extends CollectionPage {
	/**
	* The type URI of {@link OrderedCollectionPage}: `https://www.w3.org/ns/activitystreams#OrderedCollectionPage`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#OrderedCollectionPage");
	}
	#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items = [];
	#_trust_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items = /* @__PURE__ */ new Set();
	#_2W4yinFwqmpneu2h4m1mZ3pcLADd_startIndex = [];
	/**
	* Constructs a new instance of OrderedCollectionPage with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
		if ("items" in values && values.items != null) if (Array.isArray(values.items) && values.items.every((v) => v instanceof Object$1 || v instanceof Link || v instanceof URL)) {
			this.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items = values.items;
			for (let i = 0; i < values.items.length; i++) this.#_trust_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items.add(i);
		} else throw new TypeError("The items must be an array of type Object | Link | URL.");
		if ("startIndex" in values && values.startIndex != null) if (typeof values.startIndex === "number" && Number.isInteger(values.startIndex) && values.startIndex >= 0) this.#_2W4yinFwqmpneu2h4m1mZ3pcLADd_startIndex = [values.startIndex];
		else throw new TypeError("The startIndex must be of type number.");
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		clone.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items = this.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items;
		clone.#_trust_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items = new Set(this.#_trust_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items);
		if ("items" in values && values.items != null) if (Array.isArray(values.items) && values.items.every((v) => v instanceof Object$1 || v instanceof Link || v instanceof URL)) {
			clone.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items = values.items;
			clone.#_trust_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items = /* @__PURE__ */ new Set();
			for (let i = 0; i < values.items.length; i++) clone.#_trust_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items.add(i);
		} else throw new TypeError("The items must be an array of type Object | Link | URL.");
		clone.#_2W4yinFwqmpneu2h4m1mZ3pcLADd_startIndex = this.#_2W4yinFwqmpneu2h4m1mZ3pcLADd_startIndex;
		if ("startIndex" in values && values.startIndex != null) if (typeof values.startIndex === "number" && Number.isInteger(values.startIndex) && values.startIndex >= 0) clone.#_2W4yinFwqmpneu2h4m1mZ3pcLADd_startIndex = [values.startIndex];
		else throw new TypeError("The startIndex must be of type number.");
		return clone;
	}
	async #fetchItem(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#item_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #item_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Object$1.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Link.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Object", "https://www.w3.org/ns/activitystreams#Link"].join(", "));
	}
	/**
	* Similar to
	* {@link OrderedCollectionPage.getItems},
	* but returns their `@id`s instead of the objects themselves.
	*/
	get itemIds() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		return this.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
	}
	/** Identifies the items contained in a collection.  The items might be ordered
	* or unordered.
	*/
	async *getItems(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		const vs = this.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items;
		for (let i = 0; i < vs.length; i++) {
			let v = vs[i];
			if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items.has(i)) v = v.id;
			if (v instanceof URL) {
				const fetched = await this.#fetchItem(v, options);
				if (fetched == null) continue;
				vs[i] = fetched;
				this.#_trust_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items.add(i);
				this._cachedJsonLd = void 0;
				yield fetched;
				continue;
			}
			if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "orderedItems" in this._cachedJsonLd) {
				const prop = this._cachedJsonLd["orderedItems"];
				const obj = Array.isArray(prop) ? prop[i] : prop;
				if (obj != null && typeof obj === "object" && "@context" in obj) v = await this.#item_fromJsonLd(obj, options);
			}
			if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items.has(0)) {
				if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
				getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
					objectId: v.id.href,
					parentObjectId: this.id.href
				});
				continue;
			}
			yield v;
		}
	}
	/** A non-negative integer value identifying the relative position within
	* the logical view of a strictly ordered collection.
	*/
	get startIndex() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2W4yinFwqmpneu2h4m1mZ3pcLADd_startIndex.length < 1) return null;
		return this.#_2W4yinFwqmpneu2h4m1mZ3pcLADd_startIndex[0];
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		if (options.format == null && this.isCompactable()) {
			const result = await super.toJsonLd({
				...options,
				format: void 0,
				context: void 0
			});
			delete result["items"];
			let compactItems;
			compactItems = [];
			for (const v of this.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items) {
				const item = v instanceof URL ? v.href : v instanceof Object$1 ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["orderedItems"] = compactItems;
			compactItems = [];
			for (const v of this.#_2W4yinFwqmpneu2h4m1mZ3pcLADd_startIndex) {
				const item = v;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["startIndex"] = compactItems.length > 1 ? compactItems : compactItems[0];
			result["type"] = "OrderedCollectionPage";
			if (this.id != null) result["id"] = this.id.href;
			result["@context"] = [
				"https://www.w3.org/ns/activitystreams",
				"https://w3id.org/security/data-integrity/v1",
				{
					"toot": "http://joinmastodon.org/ns#",
					"misskey": "https://misskey-hub.net/ns#",
					"fedibird": "http://fedibird.com/ns#",
					"ChatMessage": "http://litepub.social/ns#ChatMessage",
					"sensitive": "as:sensitive",
					"votersCount": "toot:votersCount",
					"Emoji": "toot:Emoji",
					"Hashtag": "as:Hashtag",
					"quoteUrl": "as:quoteUrl",
					"_misskey_quote": "misskey:_misskey_quote",
					"quoteUri": "fedibird:quoteUri",
					"emojiReactions": {
						"@id": "fedibird:emojiReactions",
						"@type": "@id"
					}
				}
			];
			return result;
		}
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		array = [];
		for (const v of this.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items) {
			const element = v instanceof URL ? { "@id": v.href } : v instanceof Object$1 ? await v.toJsonLd(options) : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = { "@list": array };
			values["https://www.w3.org/ns/activitystreams#items"] = propValue;
		}
		array = [];
		for (const v of this.#_2W4yinFwqmpneu2h4m1mZ3pcLADd_startIndex) {
			const element = {
				"@type": "http://www.w3.org/2001/XMLSchema#nonNegativeInteger",
				"@value": v
			};
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#startIndex"] = propValue;
		}
		values["@type"] = ["https://www.w3.org/ns/activitystreams#OrderedCollectionPage"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? [
			"https://www.w3.org/ns/activitystreams",
			"https://w3id.org/security/data-integrity/v1",
			{
				"toot": "http://joinmastodon.org/ns#",
				"misskey": "https://misskey-hub.net/ns#",
				"fedibird": "http://fedibird.com/ns#",
				"ChatMessage": "http://litepub.social/ns#ChatMessage",
				"sensitive": "as:sensitive",
				"votersCount": "toot:votersCount",
				"Emoji": "toot:Emoji",
				"Hashtag": "as:Hashtag",
				"quoteUrl": "as:quoteUrl",
				"_misskey_quote": "misskey:_misskey_quote",
				"quoteUri": "fedibird:quoteUri",
				"emojiReactions": {
					"@id": "fedibird:emojiReactions",
					"@type": "@id"
				}
			}
		];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {
			if ("proof" in compacted && compacted.proof != null) if (Array.isArray(compacted.proof)) for (const element of compacted.proof) element["@context"] = docContext;
			else compacted.proof["@context"] = docContext;
		}
		return compacted;
	}
	isCompactable() {
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__OrderedCollectionPage__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__OrderedCollectionPage__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#OrderedCollectionPage")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof OrderedCollectionPage)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		const _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items = [];
		const _trust_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items = /* @__PURE__ */ new Set();
		let _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items__array = values["https://www.w3.org/ns/activitystreams#items"];
		for (const v of _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items__array == null ? [] : _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items__array.length === 1 && "@list" in _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items__array[0] ? _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items__array[0]["@list"] : _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			const decoded = typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && [
				"https://www.w3.org/ns/activitystreams#Object",
				"http://joinmastodon.org/ns#Emoji",
				"http://litepub.social/ns#ChatMessage",
				"https://www.w3.org/ns/activitystreams#Activity",
				"http://litepub.social/ns#EmojiReact",
				"https://www.w3.org/ns/activitystreams#Accept",
				"https://www.w3.org/ns/activitystreams#TentativeAccept",
				"https://www.w3.org/ns/activitystreams#Add",
				"https://www.w3.org/ns/activitystreams#Announce",
				"https://www.w3.org/ns/activitystreams#Create",
				"https://www.w3.org/ns/activitystreams#Delete",
				"https://www.w3.org/ns/activitystreams#Dislike",
				"https://www.w3.org/ns/activitystreams#Flag",
				"https://www.w3.org/ns/activitystreams#Follow",
				"https://www.w3.org/ns/activitystreams#Ignore",
				"https://www.w3.org/ns/activitystreams#Block",
				"https://www.w3.org/ns/activitystreams#IntransitiveActivity",
				"https://www.w3.org/ns/activitystreams#Arrive",
				"https://www.w3.org/ns/activitystreams#Question",
				"https://www.w3.org/ns/activitystreams#Travel",
				"https://www.w3.org/ns/activitystreams#Join",
				"https://www.w3.org/ns/activitystreams#Leave",
				"https://www.w3.org/ns/activitystreams#Like",
				"https://www.w3.org/ns/activitystreams#Listen",
				"https://www.w3.org/ns/activitystreams#Move",
				"https://www.w3.org/ns/activitystreams#Offer",
				"https://www.w3.org/ns/activitystreams#Invite",
				"https://www.w3.org/ns/activitystreams#Read",
				"https://www.w3.org/ns/activitystreams#Reject",
				"https://www.w3.org/ns/activitystreams#TentativeReject",
				"https://www.w3.org/ns/activitystreams#Remove",
				"https://www.w3.org/ns/activitystreams#Undo",
				"https://www.w3.org/ns/activitystreams#Update",
				"https://www.w3.org/ns/activitystreams#View",
				"https://www.w3.org/ns/activitystreams#Application",
				"https://www.w3.org/ns/activitystreams#Article",
				"https://www.w3.org/ns/activitystreams#Collection",
				"https://www.w3.org/ns/activitystreams#CollectionPage",
				"https://www.w3.org/ns/activitystreams#OrderedCollectionPage",
				"https://www.w3.org/ns/activitystreams#OrderedCollection",
				"https://www.w3.org/ns/activitystreams#Document",
				"https://www.w3.org/ns/activitystreams#Audio",
				"https://www.w3.org/ns/activitystreams#Image",
				"https://www.w3.org/ns/activitystreams#Page",
				"https://www.w3.org/ns/activitystreams#Video",
				"https://www.w3.org/ns/activitystreams#Event",
				"https://www.w3.org/ns/activitystreams#Group",
				"https://www.w3.org/ns/activitystreams#Note",
				"https://www.w3.org/ns/activitystreams#Organization",
				"https://www.w3.org/ns/activitystreams#Person",
				"https://www.w3.org/ns/activitystreams#Place",
				"https://www.w3.org/ns/activitystreams#Profile",
				"https://www.w3.org/ns/activitystreams#Relationship",
				"https://www.w3.org/ns/activitystreams#Service",
				"https://www.w3.org/ns/activitystreams#Tombstone"
			].some((t) => v["@type"].includes(t)) ? await Object$1.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && [
				"https://www.w3.org/ns/activitystreams#Link",
				"https://www.w3.org/ns/activitystreams#Hashtag",
				"https://www.w3.org/ns/activitystreams#Mention"
			].some((t) => v["@type"].includes(t)) ? await Link.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : void 0;
			if (typeof decoded === "undefined") continue;
			_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items.push(decoded);
		}
		instance.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items = _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items;
		const _2W4yinFwqmpneu2h4m1mZ3pcLADd_startIndex = [];
		let _2W4yinFwqmpneu2h4m1mZ3pcLADd_startIndex__array = values["https://www.w3.org/ns/activitystreams#startIndex"];
		for (const v of _2W4yinFwqmpneu2h4m1mZ3pcLADd_startIndex__array == null ? [] : _2W4yinFwqmpneu2h4m1mZ3pcLADd_startIndex__array.length === 1 && "@list" in _2W4yinFwqmpneu2h4m1mZ3pcLADd_startIndex__array[0] ? _2W4yinFwqmpneu2h4m1mZ3pcLADd_startIndex__array[0]["@list"] : _2W4yinFwqmpneu2h4m1mZ3pcLADd_startIndex__array) {
			if (v == null) continue;
			_2W4yinFwqmpneu2h4m1mZ3pcLADd_startIndex.push(v["@value"]);
		}
		instance.#_2W4yinFwqmpneu2h4m1mZ3pcLADd_startIndex = _2W4yinFwqmpneu2h4m1mZ3pcLADd_startIndex;
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		const _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items = this.#_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items.length > 1 || !("item" in proxy) && _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items.length > 0) proxy.items = _2JPCKWTcfBmTCcW8Tv3TpRaLVaqg_items;
		const _2W4yinFwqmpneu2h4m1mZ3pcLADd_startIndex = this.#_2W4yinFwqmpneu2h4m1mZ3pcLADd_startIndex.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_2W4yinFwqmpneu2h4m1mZ3pcLADd_startIndex.length == 1) proxy.startIndex = _2W4yinFwqmpneu2h4m1mZ3pcLADd_startIndex[0];
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "OrderedCollectionPage " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "OrderedCollectionPage " + inspect(proxy, options);
	}
};
/** Represents an organization.
*/
var Organization = class Organization extends Object$1 {
	/**
	* The type URI of {@link Organization}: `https://www.w3.org/ns/activitystreams#Organization`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#Organization");
	}
	#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = [];
	#_axq166E2eZADq34V4MYUc8KMZdC_publicKey = [];
	#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey = /* @__PURE__ */ new Set();
	#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = [];
	#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = /* @__PURE__ */ new Set();
	#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = [];
	#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = [];
	#_trust_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = /* @__PURE__ */ new Set();
	#_41QwhqJouoLg3h8dRPKat21brynC_outbox = [];
	#_trust_41QwhqJouoLg3h8dRPKat21brynC_outbox = /* @__PURE__ */ new Set();
	#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = [];
	#_trust_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = /* @__PURE__ */ new Set();
	#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = [];
	#_trust_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = /* @__PURE__ */ new Set();
	#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = [];
	#_trust_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = /* @__PURE__ */ new Set();
	#_4N1vBJzXDf8NbBumeECQMFvKetja_featured = [];
	#_trust_4N1vBJzXDf8NbBumeECQMFvKetja_featured = /* @__PURE__ */ new Set();
	#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = [];
	#_trust_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = /* @__PURE__ */ new Set();
	#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = [];
	#_trust_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = /* @__PURE__ */ new Set();
	#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = [];
	#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = [];
	#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = [];
	#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = [];
	#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = [];
	#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = [];
	#_trust_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = /* @__PURE__ */ new Set();
	#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = [];
	#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = /* @__PURE__ */ new Set();
	#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = [];
	#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = /* @__PURE__ */ new Set();
	#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = [];
	#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat = [];
	/**
	* Constructs a new instance of Organization with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
		if ("preferredUsername" in values && values.preferredUsername != null) if (typeof values.preferredUsername === "string" || values.preferredUsername instanceof LanguageString) this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = [values.preferredUsername];
		else throw new TypeError("The preferredUsername must be of type string | LanguageString.");
		if ("preferredUsernames" in values && values.preferredUsernames != null) {
			if ("preferredUsername" in values && values.preferredUsername != null) throw new TypeError("Cannot initialize both preferredUsername and preferredUsernames at the same time.");
			if (Array.isArray(values.preferredUsernames) && values.preferredUsernames.every((v) => typeof v === "string" || v instanceof LanguageString)) this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = values.preferredUsernames;
			else throw new TypeError("The preferredUsernames must be an array of type string | LanguageString.");
		}
		if ("publicKey" in values && values.publicKey != null) if (values.publicKey instanceof CryptographicKey || values.publicKey instanceof URL) {
			this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey = [values.publicKey];
			this.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey.add(0);
		} else throw new TypeError("The publicKey must be of type CryptographicKey | URL.");
		if ("publicKeys" in values && values.publicKeys != null) {
			if ("publicKey" in values && values.publicKey != null) throw new TypeError("Cannot initialize both publicKey and publicKeys at the same time.");
			if (Array.isArray(values.publicKeys) && values.publicKeys.every((v) => v instanceof CryptographicKey || v instanceof URL)) {
				this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey = values.publicKeys;
				for (let i = 0; i < values.publicKeys.length; i++) this.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey.add(i);
			} else throw new TypeError("The publicKeys must be an array of type CryptographicKey | URL.");
		}
		if ("assertionMethod" in values && values.assertionMethod != null) if (values.assertionMethod instanceof Multikey || values.assertionMethod instanceof URL) {
			this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = [values.assertionMethod];
			this.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.add(0);
		} else throw new TypeError("The assertionMethod must be of type Multikey | URL.");
		if ("assertionMethods" in values && values.assertionMethods != null) {
			if ("assertionMethod" in values && values.assertionMethod != null) throw new TypeError("Cannot initialize both assertionMethod and assertionMethods at the same time.");
			if (Array.isArray(values.assertionMethods) && values.assertionMethods.every((v) => v instanceof Multikey || v instanceof URL)) {
				this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = values.assertionMethods;
				for (let i = 0; i < values.assertionMethods.length; i++) this.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.add(i);
			} else throw new TypeError("The assertionMethods must be an array of type Multikey | URL.");
		}
		if ("manuallyApprovesFollowers" in values && values.manuallyApprovesFollowers != null) if (typeof values.manuallyApprovesFollowers === "boolean") this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = [values.manuallyApprovesFollowers];
		else throw new TypeError("The manuallyApprovesFollowers must be of type boolean.");
		if ("inbox" in values && values.inbox != null) if (values.inbox instanceof OrderedCollection || values.inbox instanceof OrderedCollectionPage || values.inbox instanceof URL) {
			this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = [values.inbox];
			this.#_trust_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.add(0);
		} else throw new TypeError("The inbox must be of type OrderedCollection | OrderedCollectionPage | URL.");
		if ("outbox" in values && values.outbox != null) if (values.outbox instanceof OrderedCollection || values.outbox instanceof OrderedCollectionPage || values.outbox instanceof URL) {
			this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox = [values.outbox];
			this.#_trust_41QwhqJouoLg3h8dRPKat21brynC_outbox.add(0);
		} else throw new TypeError("The outbox must be of type OrderedCollection | OrderedCollectionPage | URL.");
		if ("following" in values && values.following != null) if (values.following instanceof Collection || values.following instanceof URL) {
			this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = [values.following];
			this.#_trust_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.add(0);
		} else throw new TypeError("The following must be of type Collection | URL.");
		if ("followers" in values && values.followers != null) if (values.followers instanceof Collection || values.followers instanceof URL) {
			this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = [values.followers];
			this.#_trust_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.add(0);
		} else throw new TypeError("The followers must be of type Collection | URL.");
		if ("liked" in values && values.liked != null) if (values.liked instanceof Collection || values.liked instanceof URL) {
			this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = [values.liked];
			this.#_trust_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.add(0);
		} else throw new TypeError("The liked must be of type Collection | URL.");
		if ("featured" in values && values.featured != null) if (values.featured instanceof Collection || values.featured instanceof URL) {
			this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured = [values.featured];
			this.#_trust_4N1vBJzXDf8NbBumeECQMFvKetja_featured.add(0);
		} else throw new TypeError("The featured must be of type Collection | URL.");
		if ("featuredTags" in values && values.featuredTags != null) if (values.featuredTags instanceof Collection || values.featuredTags instanceof URL) {
			this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = [values.featuredTags];
			this.#_trust_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.add(0);
		} else throw new TypeError("The featuredTags must be of type Collection | URL.");
		if ("streams" in values && values.streams != null) if (Array.isArray(values.streams) && values.streams.every((v) => v instanceof Collection || v instanceof URL)) {
			this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = values.streams;
			for (let i = 0; i < values.streams.length; i++) this.#_trust_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.add(i);
		} else throw new TypeError("The streams must be an array of type Collection | URL.");
		if ("endpoints" in values && values.endpoints != null) if (values.endpoints instanceof Endpoints) this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = [values.endpoints];
		else throw new TypeError("The endpoints must be of type Endpoints.");
		if ("discoverable" in values && values.discoverable != null) if (typeof values.discoverable === "boolean") this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = [values.discoverable];
		else throw new TypeError("The discoverable must be of type boolean.");
		if ("suspended" in values && values.suspended != null) if (typeof values.suspended === "boolean") this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = [values.suspended];
		else throw new TypeError("The suspended must be of type boolean.");
		if ("memorial" in values && values.memorial != null) if (typeof values.memorial === "boolean") this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = [values.memorial];
		else throw new TypeError("The memorial must be of type boolean.");
		if ("indexable" in values && values.indexable != null) if (typeof values.indexable === "boolean") this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = [values.indexable];
		else throw new TypeError("The indexable must be of type boolean.");
		if ("successor" in values && values.successor != null) if (values.successor instanceof Application || values.successor instanceof Group || values.successor instanceof Organization || values.successor instanceof Person || values.successor instanceof Service || values.successor instanceof URL) {
			this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = [values.successor];
			this.#_trust_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.add(0);
		} else throw new TypeError("The successor must be of type Application | Group | Organization | Person | Service | URL.");
		if ("alias" in values && values.alias != null) if (values.alias instanceof Application || values.alias instanceof Group || values.alias instanceof Organization || values.alias instanceof Person || values.alias instanceof Service || values.alias instanceof URL) {
			this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = [values.alias];
			this.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.add(0);
		} else throw new TypeError("The alias must be of type Application | Group | Organization | Person | Service | URL.");
		if ("aliases" in values && values.aliases != null) {
			if ("alias" in values && values.alias != null) throw new TypeError("Cannot initialize both alias and aliases at the same time.");
			if (Array.isArray(values.aliases) && values.aliases.every((v) => v instanceof Application || v instanceof Group || v instanceof Organization || v instanceof Person || v instanceof Service || v instanceof URL)) {
				this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = values.aliases;
				for (let i = 0; i < values.aliases.length; i++) this.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.add(i);
			} else throw new TypeError("The aliases must be an array of type Application | Group | Organization | Person | Service | URL.");
		}
		if ("service" in values && values.service != null) if (values.service instanceof DidService || values.service instanceof URL) {
			this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = [values.service];
			this.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.add(0);
		} else throw new TypeError("The service must be of type DidService | URL.");
		if ("services" in values && values.services != null) {
			if ("service" in values && values.service != null) throw new TypeError("Cannot initialize both service and services at the same time.");
			if (Array.isArray(values.services) && values.services.every((v) => v instanceof DidService || v instanceof URL)) {
				this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = values.services;
				for (let i = 0; i < values.services.length; i++) this.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.add(i);
			} else throw new TypeError("The services must be an array of type DidService | URL.");
		}
		if ("followedMessage" in values && values.followedMessage != null) if (typeof values.followedMessage === "string") this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = [values.followedMessage];
		else throw new TypeError("The followedMessage must be of type string.");
		if ("cat" in values && values.cat != null) if (typeof values.cat === "boolean") this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat = [values.cat];
		else throw new TypeError("The cat must be of type boolean.");
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		clone.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername;
		if ("preferredUsername" in values && values.preferredUsername != null) if (typeof values.preferredUsername === "string" || values.preferredUsername instanceof LanguageString) clone.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = [values.preferredUsername];
		else throw new TypeError("The preferredUsername must be of type string | LanguageString.");
		if ("preferredUsernames" in values && values.preferredUsernames != null) {
			if ("preferredUsername" in values && values.preferredUsername != null) throw new TypeError("Cannot update both preferredUsername and preferredUsernames at the same time.");
			if (Array.isArray(values.preferredUsernames) && values.preferredUsernames.every((v) => typeof v === "string" || v instanceof LanguageString)) clone.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = values.preferredUsernames;
			else throw new TypeError("The preferredUsernames must be an array of type string | LanguageString.");
		}
		clone.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey = this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey;
		clone.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey = new Set(this.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey);
		if ("publicKey" in values && values.publicKey != null) if (values.publicKey instanceof CryptographicKey || values.publicKey instanceof URL) {
			clone.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey = [values.publicKey];
			clone.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey = new Set([0]);
		} else throw new TypeError("The publicKey must be of type CryptographicKey | URL.");
		if ("publicKeys" in values && values.publicKeys != null) {
			if ("publicKey" in values && values.publicKey != null) throw new TypeError("Cannot update both publicKey and publicKeys at the same time.");
			if (Array.isArray(values.publicKeys) && values.publicKeys.every((v) => v instanceof CryptographicKey || v instanceof URL)) {
				clone.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey = values.publicKeys;
				clone.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey = /* @__PURE__ */ new Set();
				for (let i = 0; i < values.publicKeys.length; i++) clone.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey.add(i);
			} else throw new TypeError("The publicKeys must be an array of type CryptographicKey | URL.");
		}
		clone.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod;
		clone.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = new Set(this.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod);
		if ("assertionMethod" in values && values.assertionMethod != null) if (values.assertionMethod instanceof Multikey || values.assertionMethod instanceof URL) {
			clone.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = [values.assertionMethod];
			clone.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = new Set([0]);
		} else throw new TypeError("The assertionMethod must be of type Multikey | URL.");
		if ("assertionMethods" in values && values.assertionMethods != null) {
			if ("assertionMethod" in values && values.assertionMethod != null) throw new TypeError("Cannot update both assertionMethod and assertionMethods at the same time.");
			if (Array.isArray(values.assertionMethods) && values.assertionMethods.every((v) => v instanceof Multikey || v instanceof URL)) {
				clone.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = values.assertionMethods;
				clone.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = /* @__PURE__ */ new Set();
				for (let i = 0; i < values.assertionMethods.length; i++) clone.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.add(i);
			} else throw new TypeError("The assertionMethods must be an array of type Multikey | URL.");
		}
		clone.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers;
		if ("manuallyApprovesFollowers" in values && values.manuallyApprovesFollowers != null) if (typeof values.manuallyApprovesFollowers === "boolean") clone.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = [values.manuallyApprovesFollowers];
		else throw new TypeError("The manuallyApprovesFollowers must be of type boolean.");
		clone.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox;
		clone.#_trust_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = new Set(this.#_trust_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox);
		if ("inbox" in values && values.inbox != null) if (values.inbox instanceof OrderedCollection || values.inbox instanceof OrderedCollectionPage || values.inbox instanceof URL) {
			clone.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = [values.inbox];
			clone.#_trust_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = new Set([0]);
		} else throw new TypeError("The inbox must be of type OrderedCollection | OrderedCollectionPage | URL.");
		clone.#_41QwhqJouoLg3h8dRPKat21brynC_outbox = this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox;
		clone.#_trust_41QwhqJouoLg3h8dRPKat21brynC_outbox = new Set(this.#_trust_41QwhqJouoLg3h8dRPKat21brynC_outbox);
		if ("outbox" in values && values.outbox != null) if (values.outbox instanceof OrderedCollection || values.outbox instanceof OrderedCollectionPage || values.outbox instanceof URL) {
			clone.#_41QwhqJouoLg3h8dRPKat21brynC_outbox = [values.outbox];
			clone.#_trust_41QwhqJouoLg3h8dRPKat21brynC_outbox = new Set([0]);
		} else throw new TypeError("The outbox must be of type OrderedCollection | OrderedCollectionPage | URL.");
		clone.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following;
		clone.#_trust_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = new Set(this.#_trust_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following);
		if ("following" in values && values.following != null) if (values.following instanceof Collection || values.following instanceof URL) {
			clone.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = [values.following];
			clone.#_trust_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = new Set([0]);
		} else throw new TypeError("The following must be of type Collection | URL.");
		clone.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers;
		clone.#_trust_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = new Set(this.#_trust_BBCTgfphhsFzpVfKTykGSpBNwoA_followers);
		if ("followers" in values && values.followers != null) if (values.followers instanceof Collection || values.followers instanceof URL) {
			clone.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = [values.followers];
			clone.#_trust_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = new Set([0]);
		} else throw new TypeError("The followers must be of type Collection | URL.");
		clone.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked;
		clone.#_trust_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = new Set(this.#_trust_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked);
		if ("liked" in values && values.liked != null) if (values.liked instanceof Collection || values.liked instanceof URL) {
			clone.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = [values.liked];
			clone.#_trust_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = new Set([0]);
		} else throw new TypeError("The liked must be of type Collection | URL.");
		clone.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured = this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured;
		clone.#_trust_4N1vBJzXDf8NbBumeECQMFvKetja_featured = new Set(this.#_trust_4N1vBJzXDf8NbBumeECQMFvKetja_featured);
		if ("featured" in values && values.featured != null) if (values.featured instanceof Collection || values.featured instanceof URL) {
			clone.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured = [values.featured];
			clone.#_trust_4N1vBJzXDf8NbBumeECQMFvKetja_featured = new Set([0]);
		} else throw new TypeError("The featured must be of type Collection | URL.");
		clone.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags;
		clone.#_trust_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = new Set(this.#_trust_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags);
		if ("featuredTags" in values && values.featuredTags != null) if (values.featuredTags instanceof Collection || values.featuredTags instanceof URL) {
			clone.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = [values.featuredTags];
			clone.#_trust_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = new Set([0]);
		} else throw new TypeError("The featuredTags must be of type Collection | URL.");
		clone.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams;
		clone.#_trust_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = new Set(this.#_trust_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams);
		if ("streams" in values && values.streams != null) if (Array.isArray(values.streams) && values.streams.every((v) => v instanceof Collection || v instanceof URL)) {
			clone.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = values.streams;
			clone.#_trust_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = /* @__PURE__ */ new Set();
			for (let i = 0; i < values.streams.length; i++) clone.#_trust_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.add(i);
		} else throw new TypeError("The streams must be an array of type Collection | URL.");
		clone.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints;
		if ("endpoints" in values && values.endpoints != null) if (values.endpoints instanceof Endpoints) clone.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = [values.endpoints];
		else throw new TypeError("The endpoints must be of type Endpoints.");
		clone.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable;
		if ("discoverable" in values && values.discoverable != null) if (typeof values.discoverable === "boolean") clone.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = [values.discoverable];
		else throw new TypeError("The discoverable must be of type boolean.");
		clone.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended;
		if ("suspended" in values && values.suspended != null) if (typeof values.suspended === "boolean") clone.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = [values.suspended];
		else throw new TypeError("The suspended must be of type boolean.");
		clone.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial;
		if ("memorial" in values && values.memorial != null) if (typeof values.memorial === "boolean") clone.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = [values.memorial];
		else throw new TypeError("The memorial must be of type boolean.");
		clone.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable;
		if ("indexable" in values && values.indexable != null) if (typeof values.indexable === "boolean") clone.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = [values.indexable];
		else throw new TypeError("The indexable must be of type boolean.");
		clone.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo;
		clone.#_trust_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = new Set(this.#_trust_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo);
		if ("successor" in values && values.successor != null) if (values.successor instanceof Application || values.successor instanceof Group || values.successor instanceof Organization || values.successor instanceof Person || values.successor instanceof Service || values.successor instanceof URL) {
			clone.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = [values.successor];
			clone.#_trust_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = new Set([0]);
		} else throw new TypeError("The successor must be of type Application | Group | Organization | Person | Service | URL.");
		clone.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs;
		clone.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = new Set(this.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs);
		if ("alias" in values && values.alias != null) if (values.alias instanceof Application || values.alias instanceof Group || values.alias instanceof Organization || values.alias instanceof Person || values.alias instanceof Service || values.alias instanceof URL) {
			clone.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = [values.alias];
			clone.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = new Set([0]);
		} else throw new TypeError("The alias must be of type Application | Group | Organization | Person | Service | URL.");
		if ("aliases" in values && values.aliases != null) {
			if ("alias" in values && values.alias != null) throw new TypeError("Cannot update both alias and aliases at the same time.");
			if (Array.isArray(values.aliases) && values.aliases.every((v) => v instanceof Application || v instanceof Group || v instanceof Organization || v instanceof Person || v instanceof Service || v instanceof URL)) {
				clone.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = values.aliases;
				clone.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = /* @__PURE__ */ new Set();
				for (let i = 0; i < values.aliases.length; i++) clone.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.add(i);
			} else throw new TypeError("The aliases must be an array of type Application | Group | Organization | Person | Service | URL.");
		}
		clone.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service;
		clone.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = new Set(this.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service);
		if ("service" in values && values.service != null) if (values.service instanceof DidService || values.service instanceof URL) {
			clone.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = [values.service];
			clone.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = new Set([0]);
		} else throw new TypeError("The service must be of type DidService | URL.");
		if ("services" in values && values.services != null) {
			if ("service" in values && values.service != null) throw new TypeError("Cannot update both service and services at the same time.");
			if (Array.isArray(values.services) && values.services.every((v) => v instanceof DidService || v instanceof URL)) {
				clone.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = values.services;
				clone.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = /* @__PURE__ */ new Set();
				for (let i = 0; i < values.services.length; i++) clone.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.add(i);
			} else throw new TypeError("The services must be an array of type DidService | URL.");
		}
		clone.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage;
		if ("followedMessage" in values && values.followedMessage != null) if (typeof values.followedMessage === "string") clone.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = [values.followedMessage];
		else throw new TypeError("The followedMessage must be of type string.");
		clone.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat = this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat;
		if ("cat" in values && values.cat != null) if (typeof values.cat === "boolean") clone.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat = [values.cat];
		else throw new TypeError("The cat must be of type boolean.");
		return clone;
	}
	/** A short username which may be used to refer to the actor,
	* with no uniqueness guarantees.
	*/
	get preferredUsername() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.length < 1) return null;
		return this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername[0];
	}
	/** A short username which may be used to refer to the actor,
	* with no uniqueness guarantees.
	*/
	get preferredUsernames() {
		return this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername;
	}
	async #fetchPublicKey(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#publicKey_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #publicKey_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await CryptographicKey.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://w3id.org/security#Key"].join(", "));
	}
	/**
	* Similar to
	* {@link Organization.getPublicKey},
	* but returns its `@id` URL instead of the object itself.
	*/
	get publicKeyId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey.length < 1) return null;
		const v = this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** A public part of the key pair owned by this actor.
	*/
	async getPublicKey(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey.length < 1) return null;
		let v = this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchPublicKey(v, options);
			if (fetched == null) return null;
			this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey[0] = fetched;
			this.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "publicKey" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["publicKey"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#publicKey_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	/**
	* Similar to
	* {@link Organization.getPublicKeys},
	* but returns their `@id`s instead of the objects themselves.
	*/
	get publicKeyIds() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		return this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
	}
	/** A public part of the key pair owned by this actor.
	*/
	async *getPublicKeys(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		const vs = this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey;
		for (let i = 0; i < vs.length; i++) {
			let v = vs[i];
			if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey.has(i)) v = v.id;
			if (v instanceof URL) {
				const fetched = await this.#fetchPublicKey(v, options);
				if (fetched == null) continue;
				vs[i] = fetched;
				this.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey.add(i);
				this._cachedJsonLd = void 0;
				yield fetched;
				continue;
			}
			if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "publicKey" in this._cachedJsonLd) {
				const prop = this._cachedJsonLd["publicKey"];
				const obj = Array.isArray(prop) ? prop[i] : prop;
				if (obj != null && typeof obj === "object" && "@context" in obj) v = await this.#publicKey_fromJsonLd(obj, options);
			}
			if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey.has(0)) {
				if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
				getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
					objectId: v.id.href,
					parentObjectId: this.id.href
				});
				continue;
			}
			yield v;
		}
	}
	async #fetchAssertionMethod(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#assertionMethod_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #assertionMethod_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Multikey.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://w3id.org/security#Multikey"].join(", "));
	}
	/**
	* Similar to
	* {@link Organization.getAssertionMethod},
	* but returns its `@id` URL instead of the object itself.
	*/
	get assertionMethodId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.length < 1) return null;
		const v = this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** Represents this actor's public keys.  It serves as equivalent to
	* the `publicKeys` property, but is used for [FEP-521a] compliance.
	*
	* [FEP-521a]: https://w3id.org/fep/521a
	*/
	async getAssertionMethod(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.length < 1) return null;
		let v = this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchAssertionMethod(v, options);
			if (fetched == null) return null;
			this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod[0] = fetched;
			this.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "assertionMethod" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["assertionMethod"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#assertionMethod_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	/**
	* Similar to
	* {@link Organization.getAssertionMethods},
	* but returns their `@id`s instead of the objects themselves.
	*/
	get assertionMethodIds() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		return this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
	}
	/** Represents this actor's public keys.  It serves as equivalent to
	* the `publicKeys` property, but is used for [FEP-521a] compliance.
	*
	* [FEP-521a]: https://w3id.org/fep/521a
	*/
	async *getAssertionMethods(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		const vs = this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod;
		for (let i = 0; i < vs.length; i++) {
			let v = vs[i];
			if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.has(i)) v = v.id;
			if (v instanceof URL) {
				const fetched = await this.#fetchAssertionMethod(v, options);
				if (fetched == null) continue;
				vs[i] = fetched;
				this.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.add(i);
				this._cachedJsonLd = void 0;
				yield fetched;
				continue;
			}
			if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "assertionMethod" in this._cachedJsonLd) {
				const prop = this._cachedJsonLd["assertionMethod"];
				const obj = Array.isArray(prop) ? prop[i] : prop;
				if (obj != null && typeof obj === "object" && "@context" in obj) v = await this.#assertionMethod_fromJsonLd(obj, options);
			}
			if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.has(0)) {
				if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
				getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
					objectId: v.id.href,
					parentObjectId: this.id.href
				});
				continue;
			}
			yield v;
		}
	}
	/** When `true`, conveys that for this actor, follow requests are not usually
	* automatically approved, but instead are examined by a person who may accept
	* or reject the request, at some time in the future.  Setting of `false`
	* conveys no information and may be ignored.  This information is typically
	* used to affect display of accounts, such as showing an account as private or
	* locked.
	*/
	get manuallyApprovesFollowers() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers.length < 1) return null;
		return this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers[0];
	}
	async #fetchInbox(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#inbox_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #inbox_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await OrderedCollection.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await OrderedCollectionPage.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#OrderedCollection", "https://www.w3.org/ns/activitystreams#OrderedCollectionPage"].join(", "));
	}
	/**
	* Similar to
	* {@link Organization.getInbox},
	* but returns its `@id` URL instead of the object itself.
	*/
	get inboxId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.length < 1) return null;
		const v = this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** The inbox stream contains all activities received by the actor.  The server
	* SHOULD filter content according to the requester's permission.  In general,
	* the owner of an inbox is likely to be able to access all of their inbox
	* contents.  Depending on access control, some other content may be public,
	* whereas other content may require authentication for non-owner users,
	* if they can access the inbox at all.
	*
	* The server MUST perform de-duplication of activities returned by the inbox.
	* Duplication can occur if an activity is addressed both to an actor's
	* followers, and a specific actor who also follows the recipient actor,
	* and the server has failed to de-duplicate the recipients list.
	* Such deduplication MUST be performed by comparing the `id` of the activities
	* and dropping any activities already seen.
	*/
	async getInbox(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.length < 1) return null;
		let v = this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchInbox(v, options);
			if (fetched == null) return null;
			this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox[0] = fetched;
			this.#_trust_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "inbox" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["inbox"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#inbox_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchOutbox(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#outbox_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #outbox_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await OrderedCollection.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await OrderedCollectionPage.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#OrderedCollection", "https://www.w3.org/ns/activitystreams#OrderedCollectionPage"].join(", "));
	}
	/**
	* Similar to
	* {@link Organization.getOutbox},
	* but returns its `@id` URL instead of the object itself.
	*/
	get outboxId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox.length < 1) return null;
		const v = this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** The outbox stream contains activities the user has published,
	* subject to the ability of the requestor to retrieve the activity
	* (that is, the contents of the outbox are filtered by the permissions of
	* the person reading it).  If a user submits a request without
	* [Authorization](https://www.w3.org/TR/activitypub/#authorization)
	* the server should respond with all of the
	* [Public](https://www.w3.org/TR/activitypub/#public-addressing) posts.
	* This could potentially be all relevant objects published by the user,
	* though the number of available items is left to the discretion of those
	* implementing and deploying the server.
	*/
	async getOutbox(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox.length < 1) return null;
		let v = this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_41QwhqJouoLg3h8dRPKat21brynC_outbox.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchOutbox(v, options);
			if (fetched == null) return null;
			this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox[0] = fetched;
			this.#_trust_41QwhqJouoLg3h8dRPKat21brynC_outbox.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "outbox" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["outbox"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#outbox_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_41QwhqJouoLg3h8dRPKat21brynC_outbox.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchFollowing(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#following_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #following_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Collection.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
	}
	/**
	* Similar to
	* {@link Organization.getFollowing},
	* but returns its `@id` URL instead of the object itself.
	*/
	get followingId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.length < 1) return null;
		const v = this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** This is a list of everybody that the actor has followed, added as a
	* [side effect](https://www.w3.org/TR/activitypub/#follow-activity-outbox).
	* The `following` collection MUST be either an {@link OrderedCollection}
	* or a {@link Collection} and MAY be filtered on privileges of
	* an authenticated user or as appropriate when no authentication is given.
	*/
	async getFollowing(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.length < 1) return null;
		let v = this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchFollowing(v, options);
			if (fetched == null) return null;
			this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following[0] = fetched;
			this.#_trust_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "following" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["following"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#following_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchFollowers(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#followers_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #followers_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Collection.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
	}
	/**
	* Similar to
	* {@link Organization.getFollowers},
	* but returns its `@id` URL instead of the object itself.
	*/
	get followersId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.length < 1) return null;
		const v = this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** This is a list of everyone who has sent a {@link Follow} activity
	* for the actor, added as a
	* [side effect](https://www.w3.org/TR/activitypub/#follow-activity-outbox).
	* This is where one would find a list of all the actors that are following
	* the actor.  The `followers` collection MUST be either
	* an {@link OrderedCollection} or a {@link Collection} and MAY be filtered on
	* privileges of an authenticated user or as appropriate when no authentication
	* is given.
	*/
	async getFollowers(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.length < 1) return null;
		let v = this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchFollowers(v, options);
			if (fetched == null) return null;
			this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers[0] = fetched;
			this.#_trust_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "followers" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["followers"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#followers_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchLiked(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#liked_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #liked_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Collection.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
	}
	/**
	* Similar to
	* {@link Organization.getLiked},
	* but returns its `@id` URL instead of the object itself.
	*/
	get likedId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.length < 1) return null;
		const v = this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** This is a list of every object from all of the actor's {@link Like}
	* activities, added as a
	* [side effect](https://www.w3.org/TR/activitypub/#like-activity-outbox).
	* The `liked` collection MUST be either an {@link OrderedCollection} or
	* a {@link Collection} and MAY be filtered on privileges of an authenticated
	* user or as appropriate when no authentication is given.
	*/
	async getLiked(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.length < 1) return null;
		let v = this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchLiked(v, options);
			if (fetched == null) return null;
			this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked[0] = fetched;
			this.#_trust_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "liked" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["liked"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#liked_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchFeatured(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#featured_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #featured_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Collection.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
	}
	/**
	* Similar to
	* {@link Organization.getFeatured},
	* but returns its `@id` URL instead of the object itself.
	*/
	get featuredId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured.length < 1) return null;
		const v = this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** What is known in Mastodon as "pinned statuses", or statuses that are always
	* featured at the top of people's profiles, is implemented using an extra
	* property `featured` on the actor object that points to a {@link Collection}
	* of objects.
	*/
	async getFeatured(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured.length < 1) return null;
		let v = this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_4N1vBJzXDf8NbBumeECQMFvKetja_featured.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchFeatured(v, options);
			if (fetched == null) return null;
			this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured[0] = fetched;
			this.#_trust_4N1vBJzXDf8NbBumeECQMFvKetja_featured.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "featured" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["featured"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#featured_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_4N1vBJzXDf8NbBumeECQMFvKetja_featured.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchFeaturedTags(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#featuredTags_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #featuredTags_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Collection.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
	}
	/**
	* Similar to
	* {@link Organization.getFeaturedTags},
	* but returns its `@id` URL instead of the object itself.
	*/
	get featuredTagsId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.length < 1) return null;
		const v = this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** What is known in Mastodon as "featured hashtags", hashtags that are featured
	* at people's profiles, is implemented using an extra property `featuredTags`
	* on the actor object that points to a {@link Collection} of {@link Hashtag}
	* objects specifically.
	*/
	async getFeaturedTags(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.length < 1) return null;
		let v = this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchFeaturedTags(v, options);
			if (fetched == null) return null;
			this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags[0] = fetched;
			this.#_trust_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "featuredTags" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["featuredTags"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#featuredTags_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchStream(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#stream_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #stream_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Collection.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
	}
	/**
	* Similar to
	* {@link Organization.getStreams},
	* but returns their `@id`s instead of the objects themselves.
	*/
	get streamIds() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		return this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
	}
	/** A list of supplementary Collections which may be of interest.
	*/
	async *getStreams(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		const vs = this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams;
		for (let i = 0; i < vs.length; i++) {
			let v = vs[i];
			if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.has(i)) v = v.id;
			if (v instanceof URL) {
				const fetched = await this.#fetchStream(v, options);
				if (fetched == null) continue;
				vs[i] = fetched;
				this.#_trust_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.add(i);
				this._cachedJsonLd = void 0;
				yield fetched;
				continue;
			}
			if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "streams" in this._cachedJsonLd) {
				const prop = this._cachedJsonLd["streams"];
				const obj = Array.isArray(prop) ? prop[i] : prop;
				if (obj != null && typeof obj === "object" && "@context" in obj) v = await this.#stream_fromJsonLd(obj, options);
			}
			if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.has(0)) {
				if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
				getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
					objectId: v.id.href,
					parentObjectId: this.id.href
				});
				continue;
			}
			yield v;
		}
	}
	/** A JSON object which maps additional (typically server/domain-wide) endpoints
	* which may be useful either for this actor or someone referencing this actor.
	* This mapping may be nested inside the actor document as the value or may be
	* a link to a JSON-LD document with these properties.
	*/
	get endpoints() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints.length < 1) return null;
		return this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints[0];
	}
	/** Allows users to opt-in or opt-out of discoverability features like
	* the profile directory.  This flag may also be used as an indicator of
	* the user's preferences toward being included in external discovery services,
	* such as search engines or other indexing tools.
	*/
	get discoverable() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable.length < 1) return null;
		return this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable[0];
	}
	/** Reports whether a user was locally suspended, for better handling of
	* these accounts.
	*/
	get suspended() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended.length < 1) return null;
		return this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended[0];
	}
	/** Whether the actor is in-memorial state.
	*/
	get memorial() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial.length < 1) return null;
		return this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial[0];
	}
	/** Whether the actor allows to be indexed.
	*/
	get indexable() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable.length < 1) return null;
		return this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable[0];
	}
	async #fetchSuccessor(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#successor_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #successor_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Application.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Group.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Organization.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Person.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Service.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + [
			"https://www.w3.org/ns/activitystreams#Application",
			"https://www.w3.org/ns/activitystreams#Group",
			"https://www.w3.org/ns/activitystreams#Organization",
			"https://www.w3.org/ns/activitystreams#Person",
			"https://www.w3.org/ns/activitystreams#Service"
		].join(", "));
	}
	/**
	* Similar to
	* {@link Organization.getSuccessor},
	* but returns its `@id` URL instead of the object itself.
	*/
	get successorId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.length < 1) return null;
		const v = this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** Signifies that an actor has been moved to a different ID. Used in Mastodon-style data portability with the {@link Move} activity; see [ActivityPub Data Portability/Move Action](https://swicg.github.io/activitypub-data-portability/#move-action) for more details.
	*/
	async getSuccessor(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.length < 1) return null;
		let v = this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchSuccessor(v, options);
			if (fetched == null) return null;
			this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo[0] = fetched;
			this.#_trust_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "movedTo" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["movedTo"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#successor_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchAlias(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#alias_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #alias_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Application.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Group.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Organization.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Person.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Service.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + [
			"https://www.w3.org/ns/activitystreams#Application",
			"https://www.w3.org/ns/activitystreams#Group",
			"https://www.w3.org/ns/activitystreams#Organization",
			"https://www.w3.org/ns/activitystreams#Person",
			"https://www.w3.org/ns/activitystreams#Service"
		].join(", "));
	}
	/**
	* Similar to
	* {@link Organization.getAlias},
	* but returns its `@id` URL instead of the object itself.
	*/
	get aliasId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.length < 1) return null;
		const v = this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** The `aliases` (`alsoKnownAs`) property is used to specify alternative names
	* or aliases for an entity.  It can be used to provide additional identifiers
	* or labels for an entity, which can be useful in scenarios where an entity
	* may have multiple names or aliases.
	*/
	async getAlias(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.length < 1) return null;
		let v = this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchAlias(v, options);
			if (fetched == null) return null;
			this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs[0] = fetched;
			this.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "alsoKnownAs" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["alsoKnownAs"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#alias_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	/**
	* Similar to
	* {@link Organization.getAliases},
	* but returns their `@id`s instead of the objects themselves.
	*/
	get aliasIds() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		return this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
	}
	/** The `aliases` (`alsoKnownAs`) property is used to specify alternative names
	* or aliases for an entity.  It can be used to provide additional identifiers
	* or labels for an entity, which can be useful in scenarios where an entity
	* may have multiple names or aliases.
	*/
	async *getAliases(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		const vs = this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs;
		for (let i = 0; i < vs.length; i++) {
			let v = vs[i];
			if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.has(i)) v = v.id;
			if (v instanceof URL) {
				const fetched = await this.#fetchAlias(v, options);
				if (fetched == null) continue;
				vs[i] = fetched;
				this.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.add(i);
				this._cachedJsonLd = void 0;
				yield fetched;
				continue;
			}
			if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "alsoKnownAs" in this._cachedJsonLd) {
				const prop = this._cachedJsonLd["alsoKnownAs"];
				const obj = Array.isArray(prop) ? prop[i] : prop;
				if (obj != null && typeof obj === "object" && "@context" in obj) v = await this.#alias_fromJsonLd(obj, options);
			}
			if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.has(0)) {
				if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
				getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
					objectId: v.id.href,
					parentObjectId: this.id.href
				});
				continue;
			}
			yield v;
		}
	}
	async #fetchService(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#service_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #service_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await DidService.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/did#Service"].join(", "));
	}
	/**
	* Similar to
	* {@link Organization.getService},
	* but returns its `@id` URL instead of the object itself.
	*/
	get serviceId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length < 1) return null;
		const v = this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** Means of communicating or interacting with the DID subject or associated
	* entities via one or more service endpoints. Examples include discovery
	* services, agent services, social networking services, file storage services,
	* and verifiable credential repository services.
	*/
	async getService(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length < 1) return null;
		let v = this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchService(v, options);
			if (fetched == null) return null;
			this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service[0] = fetched;
			this.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "service" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["service"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#service_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	/**
	* Similar to
	* {@link Organization.getServices},
	* but returns their `@id`s instead of the objects themselves.
	*/
	get serviceIds() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		return this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
	}
	/** Means of communicating or interacting with the DID subject or associated
	* entities via one or more service endpoints. Examples include discovery
	* services, agent services, social networking services, file storage services,
	* and verifiable credential repository services.
	*/
	async *getServices(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		const vs = this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service;
		for (let i = 0; i < vs.length; i++) {
			let v = vs[i];
			if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.has(i)) v = v.id;
			if (v instanceof URL) {
				const fetched = await this.#fetchService(v, options);
				if (fetched == null) continue;
				vs[i] = fetched;
				this.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.add(i);
				this._cachedJsonLd = void 0;
				yield fetched;
				continue;
			}
			if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "service" in this._cachedJsonLd) {
				const prop = this._cachedJsonLd["service"];
				const obj = Array.isArray(prop) ? prop[i] : prop;
				if (obj != null && typeof obj === "object" && "@context" in obj) v = await this.#service_fromJsonLd(obj, options);
			}
			if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.has(0)) {
				if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
				getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
					objectId: v.id.href,
					parentObjectId: this.id.href
				});
				continue;
			}
			yield v;
		}
	}
	/** This value is used for `Actor` type objects to show message on followed.
	*/
	get followedMessage() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage.length < 1) return null;
		return this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage[0];
	}
	/** Used on actors to indicate that they in some way identify as a cat,
	* expressed as a boolean value. If this property is set to `true`,
	* displaying the actor or their notes will have some special effects
	* attached in some clients.
	*/
	get cat() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat.length < 1) return null;
		return this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat[0];
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		if (options.format == null && this.isCompactable()) {
			const result = await super.toJsonLd({
				...options,
				format: void 0,
				context: void 0
			});
			let compactItems;
			compactItems = [];
			for (const v of this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername) {
				const item = typeof v === "string" ? v : {
					"@value": v.toString(),
					"@language": v.language.compact()
				};
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["preferredUsername"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["publicKey"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["assertionMethod"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers) {
				const item = v;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["manuallyApprovesFollowers"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox) {
				const item = v instanceof URL ? v.href : v instanceof OrderedCollection ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["inbox"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox) {
				const item = v instanceof URL ? v.href : v instanceof OrderedCollection ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["outbox"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["following"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["followers"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["liked"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["featured"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["featuredTags"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["streams"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints) {
				const item = await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["endpoints"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable) {
				const item = v;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["discoverable"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended) {
				const item = v;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["suspended"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial) {
				const item = v;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["memorial"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable) {
				const item = v;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["indexable"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo) {
				const item = v instanceof URL ? v.href : v instanceof Application ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : v instanceof Group ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : v instanceof Organization ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : v instanceof Person ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["movedTo"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs) {
				const item = v instanceof URL ? v.href : v instanceof Application ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : v instanceof Group ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : v instanceof Organization ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : v instanceof Person ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["alsoKnownAs"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["service"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage) {
				const item = v;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["_misskey_followedMessage"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat) {
				const item = v;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["isCat"] = compactItems.length > 1 ? compactItems : compactItems[0];
			result["type"] = "Organization";
			if (this.id != null) result["id"] = this.id.href;
			result["@context"] = [
				"https://www.w3.org/ns/activitystreams",
				"https://w3id.org/security/v1",
				"https://w3id.org/security/data-integrity/v1",
				"https://www.w3.org/ns/did/v1",
				"https://w3id.org/security/multikey/v1",
				{
					"alsoKnownAs": {
						"@id": "as:alsoKnownAs",
						"@type": "@id"
					},
					"manuallyApprovesFollowers": "as:manuallyApprovesFollowers",
					"movedTo": {
						"@id": "as:movedTo",
						"@type": "@id"
					},
					"toot": "http://joinmastodon.org/ns#",
					"Emoji": "toot:Emoji",
					"featured": {
						"@id": "toot:featured",
						"@type": "@id"
					},
					"featuredTags": {
						"@id": "toot:featuredTags",
						"@type": "@id"
					},
					"discoverable": "toot:discoverable",
					"suspended": "toot:suspended",
					"memorial": "toot:memorial",
					"indexable": "toot:indexable",
					"schema": "http://schema.org#",
					"PropertyValue": "schema:PropertyValue",
					"value": "schema:value",
					"misskey": "https://misskey-hub.net/ns#",
					"_misskey_followedMessage": "misskey:_misskey_followedMessage",
					"isCat": "misskey:isCat"
				}
			];
			return result;
		}
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		array = [];
		for (const v of this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername) {
			const element = typeof v === "string" ? { "@value": v } : {
				"@value": v.toString(),
				"@language": v.language.compact()
			};
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#preferredUsername"] = propValue;
		}
		array = [];
		for (const v of this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://w3id.org/security#publicKey"] = propValue;
		}
		array = [];
		for (const v of this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://w3id.org/security#assertionMethod"] = propValue;
		}
		array = [];
		for (const v of this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers) {
			const element = { "@value": v };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#manuallyApprovesFollowers"] = propValue;
		}
		array = [];
		for (const v of this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox) {
			const element = v instanceof URL ? { "@id": v.href } : v instanceof OrderedCollection ? await v.toJsonLd(options) : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["http://www.w3.org/ns/ldp#inbox"] = propValue;
		}
		array = [];
		for (const v of this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox) {
			const element = v instanceof URL ? { "@id": v.href } : v instanceof OrderedCollection ? await v.toJsonLd(options) : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#outbox"] = propValue;
		}
		array = [];
		for (const v of this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#following"] = propValue;
		}
		array = [];
		for (const v of this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#followers"] = propValue;
		}
		array = [];
		for (const v of this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#liked"] = propValue;
		}
		array = [];
		for (const v of this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["http://joinmastodon.org/ns#featured"] = propValue;
		}
		array = [];
		for (const v of this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["http://joinmastodon.org/ns#featuredTags"] = propValue;
		}
		array = [];
		for (const v of this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#streams"] = propValue;
		}
		array = [];
		for (const v of this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints) {
			const element = await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#endpoints"] = propValue;
		}
		array = [];
		for (const v of this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable) {
			const element = { "@value": v };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["http://joinmastodon.org/ns#discoverable"] = propValue;
		}
		array = [];
		for (const v of this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended) {
			const element = { "@value": v };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["http://joinmastodon.org/ns#suspended"] = propValue;
		}
		array = [];
		for (const v of this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial) {
			const element = { "@value": v };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["http://joinmastodon.org/ns#memorial"] = propValue;
		}
		array = [];
		for (const v of this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable) {
			const element = { "@value": v };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["http://joinmastodon.org/ns#indexable"] = propValue;
		}
		array = [];
		for (const v of this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo) {
			const element = v instanceof URL ? { "@id": v.href } : v instanceof Application ? await v.toJsonLd(options) : v instanceof Group ? await v.toJsonLd(options) : v instanceof Organization ? await v.toJsonLd(options) : v instanceof Person ? await v.toJsonLd(options) : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#movedTo"] = propValue;
		}
		array = [];
		for (const v of this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs) {
			const element = v instanceof URL ? { "@id": v.href } : v instanceof Application ? await v.toJsonLd(options) : v instanceof Group ? await v.toJsonLd(options) : v instanceof Organization ? await v.toJsonLd(options) : v instanceof Person ? await v.toJsonLd(options) : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#alsoKnownAs"] = propValue;
		}
		array = [];
		for (const v of this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/did#service"] = propValue;
		}
		array = [];
		for (const v of this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage) {
			const element = { "@value": v };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://misskey-hub.net/ns#_misskey_followedMessage"] = propValue;
		}
		array = [];
		for (const v of this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat) {
			const element = { "@value": v };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://misskey-hub.net/ns#isCat"] = propValue;
		}
		values["@type"] = ["https://www.w3.org/ns/activitystreams#Organization"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? [
			"https://www.w3.org/ns/activitystreams",
			"https://w3id.org/security/v1",
			"https://w3id.org/security/data-integrity/v1",
			"https://www.w3.org/ns/did/v1",
			"https://w3id.org/security/multikey/v1",
			{
				"alsoKnownAs": {
					"@id": "as:alsoKnownAs",
					"@type": "@id"
				},
				"manuallyApprovesFollowers": "as:manuallyApprovesFollowers",
				"movedTo": {
					"@id": "as:movedTo",
					"@type": "@id"
				},
				"toot": "http://joinmastodon.org/ns#",
				"Emoji": "toot:Emoji",
				"featured": {
					"@id": "toot:featured",
					"@type": "@id"
				},
				"featuredTags": {
					"@id": "toot:featuredTags",
					"@type": "@id"
				},
				"discoverable": "toot:discoverable",
				"suspended": "toot:suspended",
				"memorial": "toot:memorial",
				"indexable": "toot:indexable",
				"schema": "http://schema.org#",
				"PropertyValue": "schema:PropertyValue",
				"value": "schema:value",
				"misskey": "https://misskey-hub.net/ns#",
				"_misskey_followedMessage": "misskey:_misskey_followedMessage",
				"isCat": "misskey:isCat"
			}
		];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {
			if ("proof" in compacted && compacted.proof != null) if (Array.isArray(compacted.proof)) for (const element of compacted.proof) element["@context"] = docContext;
			else compacted.proof["@context"] = docContext;
		}
		return compacted;
	}
	isCompactable() {
		if (this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername != null && this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.length > 0) return false;
		if (this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service != null && this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length > 0) return false;
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__Organization__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__Organization__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Organization")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof Organization)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		const _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = [];
		let _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array = values["https://www.w3.org/ns/activitystreams#preferredUsername"];
		for (const v of _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array == null ? [] : _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array.length === 1 && "@list" in _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array[0] ? _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array[0]["@list"] : _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array) {
			if (v == null) continue;
			const decoded = typeof v === "object" && "@value" in v && typeof v["@value"] === "string" && !("@language" in v) ? v["@value"] : typeof v === "object" && "@language" in v && "@value" in v && typeof v["@language"] === "string" && typeof v["@value"] === "string" ? new LanguageString(v["@value"], v["@language"]) : void 0;
			if (typeof decoded === "undefined") continue;
			_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.push(decoded);
		}
		instance.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername;
		const _axq166E2eZADq34V4MYUc8KMZdC_publicKey = [];
		const _trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey = /* @__PURE__ */ new Set();
		let _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array = values["https://w3id.org/security#publicKey"];
		for (const v of _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array == null ? [] : _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array.length === 1 && "@list" in _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array[0] ? _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array[0]["@list"] : _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_axq166E2eZADq34V4MYUc8KMZdC_publicKey.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_axq166E2eZADq34V4MYUc8KMZdC_publicKey.push(await CryptographicKey.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey = _axq166E2eZADq34V4MYUc8KMZdC_publicKey;
		const _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = [];
		const _trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = /* @__PURE__ */ new Set();
		let _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array = values["https://w3id.org/security#assertionMethod"];
		for (const v of _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array == null ? [] : _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array.length === 1 && "@list" in _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array[0] ? _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array[0]["@list"] : _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.push(await Multikey.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod;
		const _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = [];
		let _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array = values["https://www.w3.org/ns/activitystreams#manuallyApprovesFollowers"];
		for (const v of _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array == null ? [] : _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array.length === 1 && "@list" in _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array[0] ? _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array[0]["@list"] : _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array) {
			if (v == null) continue;
			_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers.push(v["@value"]);
		}
		instance.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers;
		const _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = [];
		const _trust_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = /* @__PURE__ */ new Set();
		let _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array = values["http://www.w3.org/ns/ldp#inbox"];
		for (const v of _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array == null ? [] : _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array.length === 1 && "@list" in _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array[0] ? _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array[0]["@list"] : _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			const decoded = typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#OrderedCollection") ? await OrderedCollection.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#OrderedCollectionPage") ? await OrderedCollectionPage.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : void 0;
			if (typeof decoded === "undefined") continue;
			_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.push(decoded);
		}
		instance.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox;
		const _41QwhqJouoLg3h8dRPKat21brynC_outbox = [];
		const _trust_41QwhqJouoLg3h8dRPKat21brynC_outbox = /* @__PURE__ */ new Set();
		let _41QwhqJouoLg3h8dRPKat21brynC_outbox__array = values["https://www.w3.org/ns/activitystreams#outbox"];
		for (const v of _41QwhqJouoLg3h8dRPKat21brynC_outbox__array == null ? [] : _41QwhqJouoLg3h8dRPKat21brynC_outbox__array.length === 1 && "@list" in _41QwhqJouoLg3h8dRPKat21brynC_outbox__array[0] ? _41QwhqJouoLg3h8dRPKat21brynC_outbox__array[0]["@list"] : _41QwhqJouoLg3h8dRPKat21brynC_outbox__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_41QwhqJouoLg3h8dRPKat21brynC_outbox.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			const decoded = typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#OrderedCollection") ? await OrderedCollection.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#OrderedCollectionPage") ? await OrderedCollectionPage.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : void 0;
			if (typeof decoded === "undefined") continue;
			_41QwhqJouoLg3h8dRPKat21brynC_outbox.push(decoded);
		}
		instance.#_41QwhqJouoLg3h8dRPKat21brynC_outbox = _41QwhqJouoLg3h8dRPKat21brynC_outbox;
		const _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = [];
		const _trust_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = /* @__PURE__ */ new Set();
		let _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array = values["https://www.w3.org/ns/activitystreams#following"];
		for (const v of _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array == null ? [] : _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array.length === 1 && "@list" in _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array[0] ? _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array[0]["@list"] : _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.push(await Collection.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following;
		const _BBCTgfphhsFzpVfKTykGSpBNwoA_followers = [];
		const _trust_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = /* @__PURE__ */ new Set();
		let _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array = values["https://www.w3.org/ns/activitystreams#followers"];
		for (const v of _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array == null ? [] : _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array.length === 1 && "@list" in _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array[0] ? _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array[0]["@list"] : _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.push(await Collection.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = _BBCTgfphhsFzpVfKTykGSpBNwoA_followers;
		const _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = [];
		const _trust_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = /* @__PURE__ */ new Set();
		let _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array = values["https://www.w3.org/ns/activitystreams#liked"];
		for (const v of _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array == null ? [] : _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array.length === 1 && "@list" in _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array[0] ? _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array[0]["@list"] : _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.push(await Collection.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked;
		const _4N1vBJzXDf8NbBumeECQMFvKetja_featured = [];
		const _trust_4N1vBJzXDf8NbBumeECQMFvKetja_featured = /* @__PURE__ */ new Set();
		let _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array = values["http://joinmastodon.org/ns#featured"];
		for (const v of _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array == null ? [] : _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array.length === 1 && "@list" in _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array[0] ? _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array[0]["@list"] : _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_4N1vBJzXDf8NbBumeECQMFvKetja_featured.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_4N1vBJzXDf8NbBumeECQMFvKetja_featured.push(await Collection.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured = _4N1vBJzXDf8NbBumeECQMFvKetja_featured;
		const _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = [];
		const _trust_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = /* @__PURE__ */ new Set();
		let _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array = values["http://joinmastodon.org/ns#featuredTags"];
		for (const v of _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array == null ? [] : _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array.length === 1 && "@list" in _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array[0] ? _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array[0]["@list"] : _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.push(await Collection.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags;
		const _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = [];
		const _trust_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = /* @__PURE__ */ new Set();
		let _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array = values["https://www.w3.org/ns/activitystreams#streams"];
		for (const v of _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array == null ? [] : _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array.length === 1 && "@list" in _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array[0] ? _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array[0]["@list"] : _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.push(await Collection.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams;
		const _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = [];
		let _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array = values["https://www.w3.org/ns/activitystreams#endpoints"];
		for (const v of _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array == null ? [] : _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array.length === 1 && "@list" in _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array[0] ? _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array[0]["@list"] : _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array) {
			if (v == null) continue;
			_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints.push(await Endpoints.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints;
		const _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = [];
		let _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array = values["http://joinmastodon.org/ns#discoverable"];
		for (const v of _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array == null ? [] : _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array.length === 1 && "@list" in _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array[0] ? _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array[0]["@list"] : _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array) {
			if (v == null) continue;
			_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable.push(v["@value"]);
		}
		instance.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable;
		const _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = [];
		let _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array = values["http://joinmastodon.org/ns#suspended"];
		for (const v of _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array == null ? [] : _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array.length === 1 && "@list" in _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array[0] ? _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array[0]["@list"] : _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array) {
			if (v == null) continue;
			_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended.push(v["@value"]);
		}
		instance.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended;
		const _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = [];
		let _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array = values["http://joinmastodon.org/ns#memorial"];
		for (const v of _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array == null ? [] : _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array.length === 1 && "@list" in _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array[0] ? _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array[0]["@list"] : _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array) {
			if (v == null) continue;
			_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial.push(v["@value"]);
		}
		instance.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial;
		const _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = [];
		let _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array = values["http://joinmastodon.org/ns#indexable"];
		for (const v of _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array == null ? [] : _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array.length === 1 && "@list" in _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array[0] ? _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array[0]["@list"] : _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array) {
			if (v == null) continue;
			_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable.push(v["@value"]);
		}
		instance.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable;
		const _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = [];
		const _trust_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = /* @__PURE__ */ new Set();
		let _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array = values["https://www.w3.org/ns/activitystreams#movedTo"];
		for (const v of _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array == null ? [] : _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array.length === 1 && "@list" in _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array[0] ? _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array[0]["@list"] : _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			const decoded = typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Application") ? await Application.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Group") ? await Group.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Organization") ? await Organization.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Person") ? await Person.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Service") ? await Service.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : void 0;
			if (typeof decoded === "undefined") continue;
			_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.push(decoded);
		}
		instance.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo;
		const _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = [];
		const _trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = /* @__PURE__ */ new Set();
		let _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array = values["https://www.w3.org/ns/activitystreams#alsoKnownAs"];
		for (const v of _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array == null ? [] : _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array.length === 1 && "@list" in _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array[0] ? _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array[0]["@list"] : _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			const decoded = typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Application") ? await Application.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Group") ? await Group.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Organization") ? await Organization.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Person") ? await Person.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Service") ? await Service.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : void 0;
			if (typeof decoded === "undefined") continue;
			_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.push(decoded);
		}
		instance.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs;
		const _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = [];
		const _trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = /* @__PURE__ */ new Set();
		let _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array = values["https://www.w3.org/ns/did#service"];
		for (const v of _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array == null ? [] : _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array.length === 1 && "@list" in _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array[0] ? _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array[0]["@list"] : _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.push(await DidService.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service;
		const _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = [];
		let _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array = values["https://misskey-hub.net/ns#_misskey_followedMessage"];
		for (const v of _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array == null ? [] : _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array.length === 1 && "@list" in _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array[0] ? _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array[0]["@list"] : _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array) {
			if (v == null) continue;
			_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage.push(v["@value"]);
		}
		instance.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage;
		const _2xEU4QtkC53RAun67T81Egqt9vmL_isCat = [];
		let _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array = values["https://misskey-hub.net/ns#isCat"];
		for (const v of _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array == null ? [] : _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array.length === 1 && "@list" in _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array[0] ? _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array[0]["@list"] : _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array) {
			if (v == null) continue;
			_2xEU4QtkC53RAun67T81Egqt9vmL_isCat.push(v["@value"]);
		}
		instance.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat = _2xEU4QtkC53RAun67T81Egqt9vmL_isCat;
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		const _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.length == 1) proxy.preferredUsername = _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername[0];
		if (_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.length > 1 || !("preferredUsername" in proxy) && _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.length > 0) proxy.preferredUsernames = _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername;
		const _axq166E2eZADq34V4MYUc8KMZdC_publicKey = this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_axq166E2eZADq34V4MYUc8KMZdC_publicKey.length == 1) proxy.publicKey = _axq166E2eZADq34V4MYUc8KMZdC_publicKey[0];
		if (_axq166E2eZADq34V4MYUc8KMZdC_publicKey.length > 1 || !("publicKey" in proxy) && _axq166E2eZADq34V4MYUc8KMZdC_publicKey.length > 0) proxy.publicKeys = _axq166E2eZADq34V4MYUc8KMZdC_publicKey;
		const _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.length == 1) proxy.assertionMethod = _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod[0];
		if (_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.length > 1 || !("assertionMethod" in proxy) && _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.length > 0) proxy.assertionMethods = _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod;
		const _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers.length == 1) proxy.manuallyApprovesFollowers = _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers[0];
		const _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.length == 1) proxy.inbox = _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox[0];
		const _41QwhqJouoLg3h8dRPKat21brynC_outbox = this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_41QwhqJouoLg3h8dRPKat21brynC_outbox.length == 1) proxy.outbox = _41QwhqJouoLg3h8dRPKat21brynC_outbox[0];
		const _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.length == 1) proxy.following = _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following[0];
		const _BBCTgfphhsFzpVfKTykGSpBNwoA_followers = this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.length == 1) proxy.followers = _BBCTgfphhsFzpVfKTykGSpBNwoA_followers[0];
		const _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.length == 1) proxy.liked = _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked[0];
		const _4N1vBJzXDf8NbBumeECQMFvKetja_featured = this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_4N1vBJzXDf8NbBumeECQMFvKetja_featured.length == 1) proxy.featured = _4N1vBJzXDf8NbBumeECQMFvKetja_featured[0];
		const _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.length == 1) proxy.featuredTags = _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags[0];
		const _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.length > 1 || !("stream" in proxy) && _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.length > 0) proxy.streams = _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams;
		const _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints.length == 1) proxy.endpoints = _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints[0];
		const _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable.length == 1) proxy.discoverable = _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable[0];
		const _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended.length == 1) proxy.suspended = _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended[0];
		const _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial.length == 1) proxy.memorial = _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial[0];
		const _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable.length == 1) proxy.indexable = _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable[0];
		const _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.length == 1) proxy.successor = _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo[0];
		const _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.length == 1) proxy.alias = _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs[0];
		if (_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.length > 1 || !("alias" in proxy) && _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.length > 0) proxy.aliases = _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs;
		const _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length == 1) proxy.service = _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service[0];
		if (_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length > 1 || !("service" in proxy) && _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length > 0) proxy.services = _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service;
		const _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage.length == 1) proxy.followedMessage = _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage[0];
		const _2xEU4QtkC53RAun67T81Egqt9vmL_isCat = this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_2xEU4QtkC53RAun67T81Egqt9vmL_isCat.length == 1) proxy.cat = _2xEU4QtkC53RAun67T81Egqt9vmL_isCat[0];
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "Organization " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "Organization " + inspect(proxy, options);
	}
};
/** Represents a Web Page.
*/
var Page = class Page extends Document {
	/**
	* The type URI of {@link Page}: `https://www.w3.org/ns/activitystreams#Page`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#Page");
	}
	/**
	* Constructs a new instance of Page with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		return clone;
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		if (options.format == null && this.isCompactable()) {
			const result = await super.toJsonLd({
				...options,
				format: void 0,
				context: void 0
			});
			let compactItems;
			result["type"] = "Page";
			if (this.id != null) result["id"] = this.id.href;
			result["@context"] = ["https://www.w3.org/ns/activitystreams", "https://w3id.org/security/data-integrity/v1"];
			return result;
		}
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		values["@type"] = ["https://www.w3.org/ns/activitystreams#Page"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? ["https://www.w3.org/ns/activitystreams", "https://w3id.org/security/data-integrity/v1"];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {
			if ("proof" in compacted && compacted.proof != null) if (Array.isArray(compacted.proof)) for (const element of compacted.proof) element["@context"] = docContext;
			else compacted.proof["@context"] = docContext;
		}
		return compacted;
	}
	isCompactable() {
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__Page__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__Page__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Page")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof Page)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "Page " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "Page " + inspect(proxy, options);
	}
};
/** Represents an individual person.
*/
var Person = class Person extends Object$1 {
	/**
	* The type URI of {@link Person}: `https://www.w3.org/ns/activitystreams#Person`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#Person");
	}
	#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = [];
	#_axq166E2eZADq34V4MYUc8KMZdC_publicKey = [];
	#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey = /* @__PURE__ */ new Set();
	#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = [];
	#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = /* @__PURE__ */ new Set();
	#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = [];
	#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = [];
	#_trust_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = /* @__PURE__ */ new Set();
	#_41QwhqJouoLg3h8dRPKat21brynC_outbox = [];
	#_trust_41QwhqJouoLg3h8dRPKat21brynC_outbox = /* @__PURE__ */ new Set();
	#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = [];
	#_trust_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = /* @__PURE__ */ new Set();
	#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = [];
	#_trust_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = /* @__PURE__ */ new Set();
	#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = [];
	#_trust_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = /* @__PURE__ */ new Set();
	#_4N1vBJzXDf8NbBumeECQMFvKetja_featured = [];
	#_trust_4N1vBJzXDf8NbBumeECQMFvKetja_featured = /* @__PURE__ */ new Set();
	#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = [];
	#_trust_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = /* @__PURE__ */ new Set();
	#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = [];
	#_trust_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = /* @__PURE__ */ new Set();
	#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = [];
	#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = [];
	#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = [];
	#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = [];
	#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = [];
	#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = [];
	#_trust_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = /* @__PURE__ */ new Set();
	#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = [];
	#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = /* @__PURE__ */ new Set();
	#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = [];
	#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = /* @__PURE__ */ new Set();
	#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = [];
	#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat = [];
	/**
	* Constructs a new instance of Person with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
		if ("preferredUsername" in values && values.preferredUsername != null) if (typeof values.preferredUsername === "string" || values.preferredUsername instanceof LanguageString) this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = [values.preferredUsername];
		else throw new TypeError("The preferredUsername must be of type string | LanguageString.");
		if ("preferredUsernames" in values && values.preferredUsernames != null) {
			if ("preferredUsername" in values && values.preferredUsername != null) throw new TypeError("Cannot initialize both preferredUsername and preferredUsernames at the same time.");
			if (Array.isArray(values.preferredUsernames) && values.preferredUsernames.every((v) => typeof v === "string" || v instanceof LanguageString)) this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = values.preferredUsernames;
			else throw new TypeError("The preferredUsernames must be an array of type string | LanguageString.");
		}
		if ("publicKey" in values && values.publicKey != null) if (values.publicKey instanceof CryptographicKey || values.publicKey instanceof URL) {
			this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey = [values.publicKey];
			this.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey.add(0);
		} else throw new TypeError("The publicKey must be of type CryptographicKey | URL.");
		if ("publicKeys" in values && values.publicKeys != null) {
			if ("publicKey" in values && values.publicKey != null) throw new TypeError("Cannot initialize both publicKey and publicKeys at the same time.");
			if (Array.isArray(values.publicKeys) && values.publicKeys.every((v) => v instanceof CryptographicKey || v instanceof URL)) {
				this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey = values.publicKeys;
				for (let i = 0; i < values.publicKeys.length; i++) this.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey.add(i);
			} else throw new TypeError("The publicKeys must be an array of type CryptographicKey | URL.");
		}
		if ("assertionMethod" in values && values.assertionMethod != null) if (values.assertionMethod instanceof Multikey || values.assertionMethod instanceof URL) {
			this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = [values.assertionMethod];
			this.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.add(0);
		} else throw new TypeError("The assertionMethod must be of type Multikey | URL.");
		if ("assertionMethods" in values && values.assertionMethods != null) {
			if ("assertionMethod" in values && values.assertionMethod != null) throw new TypeError("Cannot initialize both assertionMethod and assertionMethods at the same time.");
			if (Array.isArray(values.assertionMethods) && values.assertionMethods.every((v) => v instanceof Multikey || v instanceof URL)) {
				this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = values.assertionMethods;
				for (let i = 0; i < values.assertionMethods.length; i++) this.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.add(i);
			} else throw new TypeError("The assertionMethods must be an array of type Multikey | URL.");
		}
		if ("manuallyApprovesFollowers" in values && values.manuallyApprovesFollowers != null) if (typeof values.manuallyApprovesFollowers === "boolean") this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = [values.manuallyApprovesFollowers];
		else throw new TypeError("The manuallyApprovesFollowers must be of type boolean.");
		if ("inbox" in values && values.inbox != null) if (values.inbox instanceof OrderedCollection || values.inbox instanceof OrderedCollectionPage || values.inbox instanceof URL) {
			this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = [values.inbox];
			this.#_trust_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.add(0);
		} else throw new TypeError("The inbox must be of type OrderedCollection | OrderedCollectionPage | URL.");
		if ("outbox" in values && values.outbox != null) if (values.outbox instanceof OrderedCollection || values.outbox instanceof OrderedCollectionPage || values.outbox instanceof URL) {
			this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox = [values.outbox];
			this.#_trust_41QwhqJouoLg3h8dRPKat21brynC_outbox.add(0);
		} else throw new TypeError("The outbox must be of type OrderedCollection | OrderedCollectionPage | URL.");
		if ("following" in values && values.following != null) if (values.following instanceof Collection || values.following instanceof URL) {
			this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = [values.following];
			this.#_trust_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.add(0);
		} else throw new TypeError("The following must be of type Collection | URL.");
		if ("followers" in values && values.followers != null) if (values.followers instanceof Collection || values.followers instanceof URL) {
			this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = [values.followers];
			this.#_trust_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.add(0);
		} else throw new TypeError("The followers must be of type Collection | URL.");
		if ("liked" in values && values.liked != null) if (values.liked instanceof Collection || values.liked instanceof URL) {
			this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = [values.liked];
			this.#_trust_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.add(0);
		} else throw new TypeError("The liked must be of type Collection | URL.");
		if ("featured" in values && values.featured != null) if (values.featured instanceof Collection || values.featured instanceof URL) {
			this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured = [values.featured];
			this.#_trust_4N1vBJzXDf8NbBumeECQMFvKetja_featured.add(0);
		} else throw new TypeError("The featured must be of type Collection | URL.");
		if ("featuredTags" in values && values.featuredTags != null) if (values.featuredTags instanceof Collection || values.featuredTags instanceof URL) {
			this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = [values.featuredTags];
			this.#_trust_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.add(0);
		} else throw new TypeError("The featuredTags must be of type Collection | URL.");
		if ("streams" in values && values.streams != null) if (Array.isArray(values.streams) && values.streams.every((v) => v instanceof Collection || v instanceof URL)) {
			this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = values.streams;
			for (let i = 0; i < values.streams.length; i++) this.#_trust_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.add(i);
		} else throw new TypeError("The streams must be an array of type Collection | URL.");
		if ("endpoints" in values && values.endpoints != null) if (values.endpoints instanceof Endpoints) this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = [values.endpoints];
		else throw new TypeError("The endpoints must be of type Endpoints.");
		if ("discoverable" in values && values.discoverable != null) if (typeof values.discoverable === "boolean") this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = [values.discoverable];
		else throw new TypeError("The discoverable must be of type boolean.");
		if ("suspended" in values && values.suspended != null) if (typeof values.suspended === "boolean") this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = [values.suspended];
		else throw new TypeError("The suspended must be of type boolean.");
		if ("memorial" in values && values.memorial != null) if (typeof values.memorial === "boolean") this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = [values.memorial];
		else throw new TypeError("The memorial must be of type boolean.");
		if ("indexable" in values && values.indexable != null) if (typeof values.indexable === "boolean") this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = [values.indexable];
		else throw new TypeError("The indexable must be of type boolean.");
		if ("successor" in values && values.successor != null) if (values.successor instanceof Application || values.successor instanceof Group || values.successor instanceof Organization || values.successor instanceof Person || values.successor instanceof Service || values.successor instanceof URL) {
			this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = [values.successor];
			this.#_trust_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.add(0);
		} else throw new TypeError("The successor must be of type Application | Group | Organization | Person | Service | URL.");
		if ("alias" in values && values.alias != null) if (values.alias instanceof Application || values.alias instanceof Group || values.alias instanceof Organization || values.alias instanceof Person || values.alias instanceof Service || values.alias instanceof URL) {
			this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = [values.alias];
			this.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.add(0);
		} else throw new TypeError("The alias must be of type Application | Group | Organization | Person | Service | URL.");
		if ("aliases" in values && values.aliases != null) {
			if ("alias" in values && values.alias != null) throw new TypeError("Cannot initialize both alias and aliases at the same time.");
			if (Array.isArray(values.aliases) && values.aliases.every((v) => v instanceof Application || v instanceof Group || v instanceof Organization || v instanceof Person || v instanceof Service || v instanceof URL)) {
				this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = values.aliases;
				for (let i = 0; i < values.aliases.length; i++) this.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.add(i);
			} else throw new TypeError("The aliases must be an array of type Application | Group | Organization | Person | Service | URL.");
		}
		if ("service" in values && values.service != null) if (values.service instanceof DidService || values.service instanceof URL) {
			this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = [values.service];
			this.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.add(0);
		} else throw new TypeError("The service must be of type DidService | URL.");
		if ("services" in values && values.services != null) {
			if ("service" in values && values.service != null) throw new TypeError("Cannot initialize both service and services at the same time.");
			if (Array.isArray(values.services) && values.services.every((v) => v instanceof DidService || v instanceof URL)) {
				this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = values.services;
				for (let i = 0; i < values.services.length; i++) this.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.add(i);
			} else throw new TypeError("The services must be an array of type DidService | URL.");
		}
		if ("followedMessage" in values && values.followedMessage != null) if (typeof values.followedMessage === "string") this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = [values.followedMessage];
		else throw new TypeError("The followedMessage must be of type string.");
		if ("cat" in values && values.cat != null) if (typeof values.cat === "boolean") this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat = [values.cat];
		else throw new TypeError("The cat must be of type boolean.");
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		clone.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername;
		if ("preferredUsername" in values && values.preferredUsername != null) if (typeof values.preferredUsername === "string" || values.preferredUsername instanceof LanguageString) clone.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = [values.preferredUsername];
		else throw new TypeError("The preferredUsername must be of type string | LanguageString.");
		if ("preferredUsernames" in values && values.preferredUsernames != null) {
			if ("preferredUsername" in values && values.preferredUsername != null) throw new TypeError("Cannot update both preferredUsername and preferredUsernames at the same time.");
			if (Array.isArray(values.preferredUsernames) && values.preferredUsernames.every((v) => typeof v === "string" || v instanceof LanguageString)) clone.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = values.preferredUsernames;
			else throw new TypeError("The preferredUsernames must be an array of type string | LanguageString.");
		}
		clone.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey = this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey;
		clone.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey = new Set(this.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey);
		if ("publicKey" in values && values.publicKey != null) if (values.publicKey instanceof CryptographicKey || values.publicKey instanceof URL) {
			clone.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey = [values.publicKey];
			clone.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey = new Set([0]);
		} else throw new TypeError("The publicKey must be of type CryptographicKey | URL.");
		if ("publicKeys" in values && values.publicKeys != null) {
			if ("publicKey" in values && values.publicKey != null) throw new TypeError("Cannot update both publicKey and publicKeys at the same time.");
			if (Array.isArray(values.publicKeys) && values.publicKeys.every((v) => v instanceof CryptographicKey || v instanceof URL)) {
				clone.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey = values.publicKeys;
				clone.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey = /* @__PURE__ */ new Set();
				for (let i = 0; i < values.publicKeys.length; i++) clone.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey.add(i);
			} else throw new TypeError("The publicKeys must be an array of type CryptographicKey | URL.");
		}
		clone.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod;
		clone.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = new Set(this.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod);
		if ("assertionMethod" in values && values.assertionMethod != null) if (values.assertionMethod instanceof Multikey || values.assertionMethod instanceof URL) {
			clone.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = [values.assertionMethod];
			clone.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = new Set([0]);
		} else throw new TypeError("The assertionMethod must be of type Multikey | URL.");
		if ("assertionMethods" in values && values.assertionMethods != null) {
			if ("assertionMethod" in values && values.assertionMethod != null) throw new TypeError("Cannot update both assertionMethod and assertionMethods at the same time.");
			if (Array.isArray(values.assertionMethods) && values.assertionMethods.every((v) => v instanceof Multikey || v instanceof URL)) {
				clone.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = values.assertionMethods;
				clone.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = /* @__PURE__ */ new Set();
				for (let i = 0; i < values.assertionMethods.length; i++) clone.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.add(i);
			} else throw new TypeError("The assertionMethods must be an array of type Multikey | URL.");
		}
		clone.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers;
		if ("manuallyApprovesFollowers" in values && values.manuallyApprovesFollowers != null) if (typeof values.manuallyApprovesFollowers === "boolean") clone.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = [values.manuallyApprovesFollowers];
		else throw new TypeError("The manuallyApprovesFollowers must be of type boolean.");
		clone.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox;
		clone.#_trust_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = new Set(this.#_trust_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox);
		if ("inbox" in values && values.inbox != null) if (values.inbox instanceof OrderedCollection || values.inbox instanceof OrderedCollectionPage || values.inbox instanceof URL) {
			clone.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = [values.inbox];
			clone.#_trust_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = new Set([0]);
		} else throw new TypeError("The inbox must be of type OrderedCollection | OrderedCollectionPage | URL.");
		clone.#_41QwhqJouoLg3h8dRPKat21brynC_outbox = this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox;
		clone.#_trust_41QwhqJouoLg3h8dRPKat21brynC_outbox = new Set(this.#_trust_41QwhqJouoLg3h8dRPKat21brynC_outbox);
		if ("outbox" in values && values.outbox != null) if (values.outbox instanceof OrderedCollection || values.outbox instanceof OrderedCollectionPage || values.outbox instanceof URL) {
			clone.#_41QwhqJouoLg3h8dRPKat21brynC_outbox = [values.outbox];
			clone.#_trust_41QwhqJouoLg3h8dRPKat21brynC_outbox = new Set([0]);
		} else throw new TypeError("The outbox must be of type OrderedCollection | OrderedCollectionPage | URL.");
		clone.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following;
		clone.#_trust_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = new Set(this.#_trust_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following);
		if ("following" in values && values.following != null) if (values.following instanceof Collection || values.following instanceof URL) {
			clone.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = [values.following];
			clone.#_trust_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = new Set([0]);
		} else throw new TypeError("The following must be of type Collection | URL.");
		clone.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers;
		clone.#_trust_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = new Set(this.#_trust_BBCTgfphhsFzpVfKTykGSpBNwoA_followers);
		if ("followers" in values && values.followers != null) if (values.followers instanceof Collection || values.followers instanceof URL) {
			clone.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = [values.followers];
			clone.#_trust_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = new Set([0]);
		} else throw new TypeError("The followers must be of type Collection | URL.");
		clone.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked;
		clone.#_trust_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = new Set(this.#_trust_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked);
		if ("liked" in values && values.liked != null) if (values.liked instanceof Collection || values.liked instanceof URL) {
			clone.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = [values.liked];
			clone.#_trust_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = new Set([0]);
		} else throw new TypeError("The liked must be of type Collection | URL.");
		clone.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured = this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured;
		clone.#_trust_4N1vBJzXDf8NbBumeECQMFvKetja_featured = new Set(this.#_trust_4N1vBJzXDf8NbBumeECQMFvKetja_featured);
		if ("featured" in values && values.featured != null) if (values.featured instanceof Collection || values.featured instanceof URL) {
			clone.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured = [values.featured];
			clone.#_trust_4N1vBJzXDf8NbBumeECQMFvKetja_featured = new Set([0]);
		} else throw new TypeError("The featured must be of type Collection | URL.");
		clone.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags;
		clone.#_trust_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = new Set(this.#_trust_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags);
		if ("featuredTags" in values && values.featuredTags != null) if (values.featuredTags instanceof Collection || values.featuredTags instanceof URL) {
			clone.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = [values.featuredTags];
			clone.#_trust_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = new Set([0]);
		} else throw new TypeError("The featuredTags must be of type Collection | URL.");
		clone.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams;
		clone.#_trust_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = new Set(this.#_trust_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams);
		if ("streams" in values && values.streams != null) if (Array.isArray(values.streams) && values.streams.every((v) => v instanceof Collection || v instanceof URL)) {
			clone.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = values.streams;
			clone.#_trust_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = /* @__PURE__ */ new Set();
			for (let i = 0; i < values.streams.length; i++) clone.#_trust_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.add(i);
		} else throw new TypeError("The streams must be an array of type Collection | URL.");
		clone.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints;
		if ("endpoints" in values && values.endpoints != null) if (values.endpoints instanceof Endpoints) clone.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = [values.endpoints];
		else throw new TypeError("The endpoints must be of type Endpoints.");
		clone.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable;
		if ("discoverable" in values && values.discoverable != null) if (typeof values.discoverable === "boolean") clone.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = [values.discoverable];
		else throw new TypeError("The discoverable must be of type boolean.");
		clone.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended;
		if ("suspended" in values && values.suspended != null) if (typeof values.suspended === "boolean") clone.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = [values.suspended];
		else throw new TypeError("The suspended must be of type boolean.");
		clone.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial;
		if ("memorial" in values && values.memorial != null) if (typeof values.memorial === "boolean") clone.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = [values.memorial];
		else throw new TypeError("The memorial must be of type boolean.");
		clone.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable;
		if ("indexable" in values && values.indexable != null) if (typeof values.indexable === "boolean") clone.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = [values.indexable];
		else throw new TypeError("The indexable must be of type boolean.");
		clone.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo;
		clone.#_trust_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = new Set(this.#_trust_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo);
		if ("successor" in values && values.successor != null) if (values.successor instanceof Application || values.successor instanceof Group || values.successor instanceof Organization || values.successor instanceof Person || values.successor instanceof Service || values.successor instanceof URL) {
			clone.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = [values.successor];
			clone.#_trust_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = new Set([0]);
		} else throw new TypeError("The successor must be of type Application | Group | Organization | Person | Service | URL.");
		clone.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs;
		clone.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = new Set(this.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs);
		if ("alias" in values && values.alias != null) if (values.alias instanceof Application || values.alias instanceof Group || values.alias instanceof Organization || values.alias instanceof Person || values.alias instanceof Service || values.alias instanceof URL) {
			clone.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = [values.alias];
			clone.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = new Set([0]);
		} else throw new TypeError("The alias must be of type Application | Group | Organization | Person | Service | URL.");
		if ("aliases" in values && values.aliases != null) {
			if ("alias" in values && values.alias != null) throw new TypeError("Cannot update both alias and aliases at the same time.");
			if (Array.isArray(values.aliases) && values.aliases.every((v) => v instanceof Application || v instanceof Group || v instanceof Organization || v instanceof Person || v instanceof Service || v instanceof URL)) {
				clone.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = values.aliases;
				clone.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = /* @__PURE__ */ new Set();
				for (let i = 0; i < values.aliases.length; i++) clone.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.add(i);
			} else throw new TypeError("The aliases must be an array of type Application | Group | Organization | Person | Service | URL.");
		}
		clone.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service;
		clone.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = new Set(this.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service);
		if ("service" in values && values.service != null) if (values.service instanceof DidService || values.service instanceof URL) {
			clone.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = [values.service];
			clone.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = new Set([0]);
		} else throw new TypeError("The service must be of type DidService | URL.");
		if ("services" in values && values.services != null) {
			if ("service" in values && values.service != null) throw new TypeError("Cannot update both service and services at the same time.");
			if (Array.isArray(values.services) && values.services.every((v) => v instanceof DidService || v instanceof URL)) {
				clone.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = values.services;
				clone.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = /* @__PURE__ */ new Set();
				for (let i = 0; i < values.services.length; i++) clone.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.add(i);
			} else throw new TypeError("The services must be an array of type DidService | URL.");
		}
		clone.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage;
		if ("followedMessage" in values && values.followedMessage != null) if (typeof values.followedMessage === "string") clone.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = [values.followedMessage];
		else throw new TypeError("The followedMessage must be of type string.");
		clone.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat = this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat;
		if ("cat" in values && values.cat != null) if (typeof values.cat === "boolean") clone.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat = [values.cat];
		else throw new TypeError("The cat must be of type boolean.");
		return clone;
	}
	/** A short username which may be used to refer to the actor,
	* with no uniqueness guarantees.
	*/
	get preferredUsername() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.length < 1) return null;
		return this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername[0];
	}
	/** A short username which may be used to refer to the actor,
	* with no uniqueness guarantees.
	*/
	get preferredUsernames() {
		return this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername;
	}
	async #fetchPublicKey(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#publicKey_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #publicKey_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await CryptographicKey.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://w3id.org/security#Key"].join(", "));
	}
	/**
	* Similar to
	* {@link Person.getPublicKey},
	* but returns its `@id` URL instead of the object itself.
	*/
	get publicKeyId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey.length < 1) return null;
		const v = this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** A public part of the key pair owned by this actor.
	*/
	async getPublicKey(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey.length < 1) return null;
		let v = this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchPublicKey(v, options);
			if (fetched == null) return null;
			this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey[0] = fetched;
			this.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "publicKey" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["publicKey"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#publicKey_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	/**
	* Similar to
	* {@link Person.getPublicKeys},
	* but returns their `@id`s instead of the objects themselves.
	*/
	get publicKeyIds() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		return this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
	}
	/** A public part of the key pair owned by this actor.
	*/
	async *getPublicKeys(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		const vs = this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey;
		for (let i = 0; i < vs.length; i++) {
			let v = vs[i];
			if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey.has(i)) v = v.id;
			if (v instanceof URL) {
				const fetched = await this.#fetchPublicKey(v, options);
				if (fetched == null) continue;
				vs[i] = fetched;
				this.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey.add(i);
				this._cachedJsonLd = void 0;
				yield fetched;
				continue;
			}
			if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "publicKey" in this._cachedJsonLd) {
				const prop = this._cachedJsonLd["publicKey"];
				const obj = Array.isArray(prop) ? prop[i] : prop;
				if (obj != null && typeof obj === "object" && "@context" in obj) v = await this.#publicKey_fromJsonLd(obj, options);
			}
			if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey.has(0)) {
				if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
				getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
					objectId: v.id.href,
					parentObjectId: this.id.href
				});
				continue;
			}
			yield v;
		}
	}
	async #fetchAssertionMethod(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#assertionMethod_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #assertionMethod_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Multikey.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://w3id.org/security#Multikey"].join(", "));
	}
	/**
	* Similar to
	* {@link Person.getAssertionMethod},
	* but returns its `@id` URL instead of the object itself.
	*/
	get assertionMethodId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.length < 1) return null;
		const v = this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** Represents this actor's public keys.  It serves as equivalent to
	* the `publicKeys` property, but is used for [FEP-521a] compliance.
	*
	* [FEP-521a]: https://w3id.org/fep/521a
	*/
	async getAssertionMethod(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.length < 1) return null;
		let v = this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchAssertionMethod(v, options);
			if (fetched == null) return null;
			this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod[0] = fetched;
			this.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "assertionMethod" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["assertionMethod"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#assertionMethod_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	/**
	* Similar to
	* {@link Person.getAssertionMethods},
	* but returns their `@id`s instead of the objects themselves.
	*/
	get assertionMethodIds() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		return this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
	}
	/** Represents this actor's public keys.  It serves as equivalent to
	* the `publicKeys` property, but is used for [FEP-521a] compliance.
	*
	* [FEP-521a]: https://w3id.org/fep/521a
	*/
	async *getAssertionMethods(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		const vs = this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod;
		for (let i = 0; i < vs.length; i++) {
			let v = vs[i];
			if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.has(i)) v = v.id;
			if (v instanceof URL) {
				const fetched = await this.#fetchAssertionMethod(v, options);
				if (fetched == null) continue;
				vs[i] = fetched;
				this.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.add(i);
				this._cachedJsonLd = void 0;
				yield fetched;
				continue;
			}
			if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "assertionMethod" in this._cachedJsonLd) {
				const prop = this._cachedJsonLd["assertionMethod"];
				const obj = Array.isArray(prop) ? prop[i] : prop;
				if (obj != null && typeof obj === "object" && "@context" in obj) v = await this.#assertionMethod_fromJsonLd(obj, options);
			}
			if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.has(0)) {
				if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
				getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
					objectId: v.id.href,
					parentObjectId: this.id.href
				});
				continue;
			}
			yield v;
		}
	}
	/** When `true`, conveys that for this actor, follow requests are not usually
	* automatically approved, but instead are examined by a person who may accept
	* or reject the request, at some time in the future.  Setting of `false`
	* conveys no information and may be ignored.  This information is typically
	* used to affect display of accounts, such as showing an account as private or
	* locked.
	*/
	get manuallyApprovesFollowers() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers.length < 1) return null;
		return this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers[0];
	}
	async #fetchInbox(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#inbox_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #inbox_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await OrderedCollection.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await OrderedCollectionPage.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#OrderedCollection", "https://www.w3.org/ns/activitystreams#OrderedCollectionPage"].join(", "));
	}
	/**
	* Similar to
	* {@link Person.getInbox},
	* but returns its `@id` URL instead of the object itself.
	*/
	get inboxId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.length < 1) return null;
		const v = this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** The inbox stream contains all activities received by the actor.  The server
	* SHOULD filter content according to the requester's permission.  In general,
	* the owner of an inbox is likely to be able to access all of their inbox
	* contents.  Depending on access control, some other content may be public,
	* whereas other content may require authentication for non-owner users,
	* if they can access the inbox at all.
	*
	* The server MUST perform de-duplication of activities returned by the inbox.
	* Duplication can occur if an activity is addressed both to an actor's
	* followers, and a specific actor who also follows the recipient actor,
	* and the server has failed to de-duplicate the recipients list.
	* Such deduplication MUST be performed by comparing the `id` of the activities
	* and dropping any activities already seen.
	*/
	async getInbox(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.length < 1) return null;
		let v = this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchInbox(v, options);
			if (fetched == null) return null;
			this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox[0] = fetched;
			this.#_trust_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "inbox" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["inbox"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#inbox_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchOutbox(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#outbox_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #outbox_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await OrderedCollection.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await OrderedCollectionPage.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#OrderedCollection", "https://www.w3.org/ns/activitystreams#OrderedCollectionPage"].join(", "));
	}
	/**
	* Similar to
	* {@link Person.getOutbox},
	* but returns its `@id` URL instead of the object itself.
	*/
	get outboxId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox.length < 1) return null;
		const v = this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** The outbox stream contains activities the user has published,
	* subject to the ability of the requestor to retrieve the activity
	* (that is, the contents of the outbox are filtered by the permissions of
	* the person reading it).  If a user submits a request without
	* [Authorization](https://www.w3.org/TR/activitypub/#authorization)
	* the server should respond with all of the
	* [Public](https://www.w3.org/TR/activitypub/#public-addressing) posts.
	* This could potentially be all relevant objects published by the user,
	* though the number of available items is left to the discretion of those
	* implementing and deploying the server.
	*/
	async getOutbox(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox.length < 1) return null;
		let v = this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_41QwhqJouoLg3h8dRPKat21brynC_outbox.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchOutbox(v, options);
			if (fetched == null) return null;
			this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox[0] = fetched;
			this.#_trust_41QwhqJouoLg3h8dRPKat21brynC_outbox.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "outbox" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["outbox"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#outbox_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_41QwhqJouoLg3h8dRPKat21brynC_outbox.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchFollowing(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#following_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #following_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Collection.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
	}
	/**
	* Similar to
	* {@link Person.getFollowing},
	* but returns its `@id` URL instead of the object itself.
	*/
	get followingId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.length < 1) return null;
		const v = this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** This is a list of everybody that the actor has followed, added as a
	* [side effect](https://www.w3.org/TR/activitypub/#follow-activity-outbox).
	* The `following` collection MUST be either an {@link OrderedCollection}
	* or a {@link Collection} and MAY be filtered on privileges of
	* an authenticated user or as appropriate when no authentication is given.
	*/
	async getFollowing(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.length < 1) return null;
		let v = this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchFollowing(v, options);
			if (fetched == null) return null;
			this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following[0] = fetched;
			this.#_trust_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "following" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["following"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#following_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchFollowers(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#followers_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #followers_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Collection.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
	}
	/**
	* Similar to
	* {@link Person.getFollowers},
	* but returns its `@id` URL instead of the object itself.
	*/
	get followersId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.length < 1) return null;
		const v = this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** This is a list of everyone who has sent a {@link Follow} activity
	* for the actor, added as a
	* [side effect](https://www.w3.org/TR/activitypub/#follow-activity-outbox).
	* This is where one would find a list of all the actors that are following
	* the actor.  The `followers` collection MUST be either
	* an {@link OrderedCollection} or a {@link Collection} and MAY be filtered on
	* privileges of an authenticated user or as appropriate when no authentication
	* is given.
	*/
	async getFollowers(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.length < 1) return null;
		let v = this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchFollowers(v, options);
			if (fetched == null) return null;
			this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers[0] = fetched;
			this.#_trust_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "followers" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["followers"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#followers_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchLiked(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#liked_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #liked_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Collection.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
	}
	/**
	* Similar to
	* {@link Person.getLiked},
	* but returns its `@id` URL instead of the object itself.
	*/
	get likedId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.length < 1) return null;
		const v = this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** This is a list of every object from all of the actor's {@link Like}
	* activities, added as a
	* [side effect](https://www.w3.org/TR/activitypub/#like-activity-outbox).
	* The `liked` collection MUST be either an {@link OrderedCollection} or
	* a {@link Collection} and MAY be filtered on privileges of an authenticated
	* user or as appropriate when no authentication is given.
	*/
	async getLiked(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.length < 1) return null;
		let v = this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchLiked(v, options);
			if (fetched == null) return null;
			this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked[0] = fetched;
			this.#_trust_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "liked" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["liked"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#liked_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchFeatured(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#featured_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #featured_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Collection.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
	}
	/**
	* Similar to
	* {@link Person.getFeatured},
	* but returns its `@id` URL instead of the object itself.
	*/
	get featuredId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured.length < 1) return null;
		const v = this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** What is known in Mastodon as "pinned statuses", or statuses that are always
	* featured at the top of people's profiles, is implemented using an extra
	* property `featured` on the actor object that points to a {@link Collection}
	* of objects.
	*/
	async getFeatured(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured.length < 1) return null;
		let v = this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_4N1vBJzXDf8NbBumeECQMFvKetja_featured.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchFeatured(v, options);
			if (fetched == null) return null;
			this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured[0] = fetched;
			this.#_trust_4N1vBJzXDf8NbBumeECQMFvKetja_featured.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "featured" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["featured"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#featured_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_4N1vBJzXDf8NbBumeECQMFvKetja_featured.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchFeaturedTags(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#featuredTags_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #featuredTags_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Collection.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
	}
	/**
	* Similar to
	* {@link Person.getFeaturedTags},
	* but returns its `@id` URL instead of the object itself.
	*/
	get featuredTagsId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.length < 1) return null;
		const v = this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** What is known in Mastodon as "featured hashtags", hashtags that are featured
	* at people's profiles, is implemented using an extra property `featuredTags`
	* on the actor object that points to a {@link Collection} of {@link Hashtag}
	* objects specifically.
	*/
	async getFeaturedTags(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.length < 1) return null;
		let v = this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchFeaturedTags(v, options);
			if (fetched == null) return null;
			this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags[0] = fetched;
			this.#_trust_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "featuredTags" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["featuredTags"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#featuredTags_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchStream(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#stream_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #stream_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Collection.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
	}
	/**
	* Similar to
	* {@link Person.getStreams},
	* but returns their `@id`s instead of the objects themselves.
	*/
	get streamIds() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		return this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
	}
	/** A list of supplementary Collections which may be of interest.
	*/
	async *getStreams(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		const vs = this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams;
		for (let i = 0; i < vs.length; i++) {
			let v = vs[i];
			if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.has(i)) v = v.id;
			if (v instanceof URL) {
				const fetched = await this.#fetchStream(v, options);
				if (fetched == null) continue;
				vs[i] = fetched;
				this.#_trust_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.add(i);
				this._cachedJsonLd = void 0;
				yield fetched;
				continue;
			}
			if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "streams" in this._cachedJsonLd) {
				const prop = this._cachedJsonLd["streams"];
				const obj = Array.isArray(prop) ? prop[i] : prop;
				if (obj != null && typeof obj === "object" && "@context" in obj) v = await this.#stream_fromJsonLd(obj, options);
			}
			if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.has(0)) {
				if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
				getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
					objectId: v.id.href,
					parentObjectId: this.id.href
				});
				continue;
			}
			yield v;
		}
	}
	/** A JSON object which maps additional (typically server/domain-wide) endpoints
	* which may be useful either for this actor or someone referencing this actor.
	* This mapping may be nested inside the actor document as the value or may be
	* a link to a JSON-LD document with these properties.
	*/
	get endpoints() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints.length < 1) return null;
		return this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints[0];
	}
	/** Allows users to opt-in or opt-out of discoverability features like
	* the profile directory.  This flag may also be used as an indicator of
	* the user's preferences toward being included in external discovery services,
	* such as search engines or other indexing tools.
	*/
	get discoverable() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable.length < 1) return null;
		return this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable[0];
	}
	/** Reports whether a user was locally suspended, for better handling of
	* these accounts.
	*/
	get suspended() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended.length < 1) return null;
		return this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended[0];
	}
	/** Whether the actor is in-memorial state.
	*/
	get memorial() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial.length < 1) return null;
		return this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial[0];
	}
	/** Whether the actor allows to be indexed.
	*/
	get indexable() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable.length < 1) return null;
		return this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable[0];
	}
	async #fetchSuccessor(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#successor_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #successor_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Application.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Group.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Organization.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Person.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Service.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + [
			"https://www.w3.org/ns/activitystreams#Application",
			"https://www.w3.org/ns/activitystreams#Group",
			"https://www.w3.org/ns/activitystreams#Organization",
			"https://www.w3.org/ns/activitystreams#Person",
			"https://www.w3.org/ns/activitystreams#Service"
		].join(", "));
	}
	/**
	* Similar to
	* {@link Person.getSuccessor},
	* but returns its `@id` URL instead of the object itself.
	*/
	get successorId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.length < 1) return null;
		const v = this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** Signifies that an actor has been moved to a different ID. Used in Mastodon-style data portability with the {@link Move} activity; see [ActivityPub Data Portability/Move Action](https://swicg.github.io/activitypub-data-portability/#move-action) for more details.
	*/
	async getSuccessor(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.length < 1) return null;
		let v = this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchSuccessor(v, options);
			if (fetched == null) return null;
			this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo[0] = fetched;
			this.#_trust_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "movedTo" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["movedTo"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#successor_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchAlias(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#alias_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #alias_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Application.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Group.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Organization.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Person.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Service.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + [
			"https://www.w3.org/ns/activitystreams#Application",
			"https://www.w3.org/ns/activitystreams#Group",
			"https://www.w3.org/ns/activitystreams#Organization",
			"https://www.w3.org/ns/activitystreams#Person",
			"https://www.w3.org/ns/activitystreams#Service"
		].join(", "));
	}
	/**
	* Similar to
	* {@link Person.getAlias},
	* but returns its `@id` URL instead of the object itself.
	*/
	get aliasId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.length < 1) return null;
		const v = this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** The `aliases` (`alsoKnownAs`) property is used to specify alternative names
	* or aliases for an entity.  It can be used to provide additional identifiers
	* or labels for an entity, which can be useful in scenarios where an entity
	* may have multiple names or aliases.
	*/
	async getAlias(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.length < 1) return null;
		let v = this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchAlias(v, options);
			if (fetched == null) return null;
			this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs[0] = fetched;
			this.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "alsoKnownAs" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["alsoKnownAs"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#alias_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	/**
	* Similar to
	* {@link Person.getAliases},
	* but returns their `@id`s instead of the objects themselves.
	*/
	get aliasIds() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		return this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
	}
	/** The `aliases` (`alsoKnownAs`) property is used to specify alternative names
	* or aliases for an entity.  It can be used to provide additional identifiers
	* or labels for an entity, which can be useful in scenarios where an entity
	* may have multiple names or aliases.
	*/
	async *getAliases(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		const vs = this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs;
		for (let i = 0; i < vs.length; i++) {
			let v = vs[i];
			if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.has(i)) v = v.id;
			if (v instanceof URL) {
				const fetched = await this.#fetchAlias(v, options);
				if (fetched == null) continue;
				vs[i] = fetched;
				this.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.add(i);
				this._cachedJsonLd = void 0;
				yield fetched;
				continue;
			}
			if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "alsoKnownAs" in this._cachedJsonLd) {
				const prop = this._cachedJsonLd["alsoKnownAs"];
				const obj = Array.isArray(prop) ? prop[i] : prop;
				if (obj != null && typeof obj === "object" && "@context" in obj) v = await this.#alias_fromJsonLd(obj, options);
			}
			if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.has(0)) {
				if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
				getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
					objectId: v.id.href,
					parentObjectId: this.id.href
				});
				continue;
			}
			yield v;
		}
	}
	async #fetchService(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#service_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #service_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await DidService.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/did#Service"].join(", "));
	}
	/**
	* Similar to
	* {@link Person.getService},
	* but returns its `@id` URL instead of the object itself.
	*/
	get serviceId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length < 1) return null;
		const v = this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** Means of communicating or interacting with the DID subject or associated
	* entities via one or more service endpoints. Examples include discovery
	* services, agent services, social networking services, file storage services,
	* and verifiable credential repository services.
	*/
	async getService(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length < 1) return null;
		let v = this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchService(v, options);
			if (fetched == null) return null;
			this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service[0] = fetched;
			this.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "service" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["service"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#service_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	/**
	* Similar to
	* {@link Person.getServices},
	* but returns their `@id`s instead of the objects themselves.
	*/
	get serviceIds() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		return this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
	}
	/** Means of communicating or interacting with the DID subject or associated
	* entities via one or more service endpoints. Examples include discovery
	* services, agent services, social networking services, file storage services,
	* and verifiable credential repository services.
	*/
	async *getServices(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		const vs = this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service;
		for (let i = 0; i < vs.length; i++) {
			let v = vs[i];
			if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.has(i)) v = v.id;
			if (v instanceof URL) {
				const fetched = await this.#fetchService(v, options);
				if (fetched == null) continue;
				vs[i] = fetched;
				this.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.add(i);
				this._cachedJsonLd = void 0;
				yield fetched;
				continue;
			}
			if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "service" in this._cachedJsonLd) {
				const prop = this._cachedJsonLd["service"];
				const obj = Array.isArray(prop) ? prop[i] : prop;
				if (obj != null && typeof obj === "object" && "@context" in obj) v = await this.#service_fromJsonLd(obj, options);
			}
			if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.has(0)) {
				if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
				getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
					objectId: v.id.href,
					parentObjectId: this.id.href
				});
				continue;
			}
			yield v;
		}
	}
	/** This value is used for `Actor` type objects to show message on followed.
	*/
	get followedMessage() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage.length < 1) return null;
		return this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage[0];
	}
	/** Used on actors to indicate that they in some way identify as a cat,
	* expressed as a boolean value. If this property is set to `true`,
	* displaying the actor or their notes will have some special effects
	* attached in some clients.
	*/
	get cat() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat.length < 1) return null;
		return this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat[0];
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		if (options.format == null && this.isCompactable()) {
			const result = await super.toJsonLd({
				...options,
				format: void 0,
				context: void 0
			});
			let compactItems;
			compactItems = [];
			for (const v of this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername) {
				const item = typeof v === "string" ? v : {
					"@value": v.toString(),
					"@language": v.language.compact()
				};
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["preferredUsername"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["publicKey"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["assertionMethod"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers) {
				const item = v;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["manuallyApprovesFollowers"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox) {
				const item = v instanceof URL ? v.href : v instanceof OrderedCollection ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["inbox"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox) {
				const item = v instanceof URL ? v.href : v instanceof OrderedCollection ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["outbox"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["following"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["followers"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["liked"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["featured"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["featuredTags"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["streams"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints) {
				const item = await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["endpoints"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable) {
				const item = v;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["discoverable"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended) {
				const item = v;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["suspended"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial) {
				const item = v;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["memorial"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable) {
				const item = v;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["indexable"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo) {
				const item = v instanceof URL ? v.href : v instanceof Application ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : v instanceof Group ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : v instanceof Organization ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : v instanceof Person ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["movedTo"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs) {
				const item = v instanceof URL ? v.href : v instanceof Application ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : v instanceof Group ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : v instanceof Organization ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : v instanceof Person ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["alsoKnownAs"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["service"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage) {
				const item = v;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["_misskey_followedMessage"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat) {
				const item = v;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["isCat"] = compactItems.length > 1 ? compactItems : compactItems[0];
			result["type"] = "Person";
			if (this.id != null) result["id"] = this.id.href;
			result["@context"] = [
				"https://www.w3.org/ns/activitystreams",
				"https://w3id.org/security/v1",
				"https://w3id.org/security/data-integrity/v1",
				"https://www.w3.org/ns/did/v1",
				"https://w3id.org/security/multikey/v1",
				{
					"alsoKnownAs": {
						"@id": "as:alsoKnownAs",
						"@type": "@id"
					},
					"manuallyApprovesFollowers": "as:manuallyApprovesFollowers",
					"movedTo": {
						"@id": "as:movedTo",
						"@type": "@id"
					},
					"toot": "http://joinmastodon.org/ns#",
					"Emoji": "toot:Emoji",
					"featured": {
						"@id": "toot:featured",
						"@type": "@id"
					},
					"featuredTags": {
						"@id": "toot:featuredTags",
						"@type": "@id"
					},
					"discoverable": "toot:discoverable",
					"suspended": "toot:suspended",
					"memorial": "toot:memorial",
					"indexable": "toot:indexable",
					"schema": "http://schema.org#",
					"PropertyValue": "schema:PropertyValue",
					"value": "schema:value",
					"misskey": "https://misskey-hub.net/ns#",
					"_misskey_followedMessage": "misskey:_misskey_followedMessage",
					"isCat": "misskey:isCat"
				}
			];
			return result;
		}
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		array = [];
		for (const v of this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername) {
			const element = typeof v === "string" ? { "@value": v } : {
				"@value": v.toString(),
				"@language": v.language.compact()
			};
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#preferredUsername"] = propValue;
		}
		array = [];
		for (const v of this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://w3id.org/security#publicKey"] = propValue;
		}
		array = [];
		for (const v of this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://w3id.org/security#assertionMethod"] = propValue;
		}
		array = [];
		for (const v of this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers) {
			const element = { "@value": v };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#manuallyApprovesFollowers"] = propValue;
		}
		array = [];
		for (const v of this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox) {
			const element = v instanceof URL ? { "@id": v.href } : v instanceof OrderedCollection ? await v.toJsonLd(options) : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["http://www.w3.org/ns/ldp#inbox"] = propValue;
		}
		array = [];
		for (const v of this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox) {
			const element = v instanceof URL ? { "@id": v.href } : v instanceof OrderedCollection ? await v.toJsonLd(options) : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#outbox"] = propValue;
		}
		array = [];
		for (const v of this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#following"] = propValue;
		}
		array = [];
		for (const v of this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#followers"] = propValue;
		}
		array = [];
		for (const v of this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#liked"] = propValue;
		}
		array = [];
		for (const v of this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["http://joinmastodon.org/ns#featured"] = propValue;
		}
		array = [];
		for (const v of this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["http://joinmastodon.org/ns#featuredTags"] = propValue;
		}
		array = [];
		for (const v of this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#streams"] = propValue;
		}
		array = [];
		for (const v of this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints) {
			const element = await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#endpoints"] = propValue;
		}
		array = [];
		for (const v of this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable) {
			const element = { "@value": v };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["http://joinmastodon.org/ns#discoverable"] = propValue;
		}
		array = [];
		for (const v of this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended) {
			const element = { "@value": v };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["http://joinmastodon.org/ns#suspended"] = propValue;
		}
		array = [];
		for (const v of this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial) {
			const element = { "@value": v };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["http://joinmastodon.org/ns#memorial"] = propValue;
		}
		array = [];
		for (const v of this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable) {
			const element = { "@value": v };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["http://joinmastodon.org/ns#indexable"] = propValue;
		}
		array = [];
		for (const v of this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo) {
			const element = v instanceof URL ? { "@id": v.href } : v instanceof Application ? await v.toJsonLd(options) : v instanceof Group ? await v.toJsonLd(options) : v instanceof Organization ? await v.toJsonLd(options) : v instanceof Person ? await v.toJsonLd(options) : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#movedTo"] = propValue;
		}
		array = [];
		for (const v of this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs) {
			const element = v instanceof URL ? { "@id": v.href } : v instanceof Application ? await v.toJsonLd(options) : v instanceof Group ? await v.toJsonLd(options) : v instanceof Organization ? await v.toJsonLd(options) : v instanceof Person ? await v.toJsonLd(options) : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#alsoKnownAs"] = propValue;
		}
		array = [];
		for (const v of this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/did#service"] = propValue;
		}
		array = [];
		for (const v of this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage) {
			const element = { "@value": v };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://misskey-hub.net/ns#_misskey_followedMessage"] = propValue;
		}
		array = [];
		for (const v of this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat) {
			const element = { "@value": v };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://misskey-hub.net/ns#isCat"] = propValue;
		}
		values["@type"] = ["https://www.w3.org/ns/activitystreams#Person"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? [
			"https://www.w3.org/ns/activitystreams",
			"https://w3id.org/security/v1",
			"https://w3id.org/security/data-integrity/v1",
			"https://www.w3.org/ns/did/v1",
			"https://w3id.org/security/multikey/v1",
			{
				"alsoKnownAs": {
					"@id": "as:alsoKnownAs",
					"@type": "@id"
				},
				"manuallyApprovesFollowers": "as:manuallyApprovesFollowers",
				"movedTo": {
					"@id": "as:movedTo",
					"@type": "@id"
				},
				"toot": "http://joinmastodon.org/ns#",
				"Emoji": "toot:Emoji",
				"featured": {
					"@id": "toot:featured",
					"@type": "@id"
				},
				"featuredTags": {
					"@id": "toot:featuredTags",
					"@type": "@id"
				},
				"discoverable": "toot:discoverable",
				"suspended": "toot:suspended",
				"memorial": "toot:memorial",
				"indexable": "toot:indexable",
				"schema": "http://schema.org#",
				"PropertyValue": "schema:PropertyValue",
				"value": "schema:value",
				"misskey": "https://misskey-hub.net/ns#",
				"_misskey_followedMessage": "misskey:_misskey_followedMessage",
				"isCat": "misskey:isCat"
			}
		];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {
			if ("proof" in compacted && compacted.proof != null) if (Array.isArray(compacted.proof)) for (const element of compacted.proof) element["@context"] = docContext;
			else compacted.proof["@context"] = docContext;
		}
		return compacted;
	}
	isCompactable() {
		if (this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername != null && this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.length > 0) return false;
		if (this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service != null && this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length > 0) return false;
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__Person__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__Person__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Person")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof Person)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		const _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = [];
		let _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array = values["https://www.w3.org/ns/activitystreams#preferredUsername"];
		for (const v of _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array == null ? [] : _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array.length === 1 && "@list" in _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array[0] ? _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array[0]["@list"] : _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array) {
			if (v == null) continue;
			const decoded = typeof v === "object" && "@value" in v && typeof v["@value"] === "string" && !("@language" in v) ? v["@value"] : typeof v === "object" && "@language" in v && "@value" in v && typeof v["@language"] === "string" && typeof v["@value"] === "string" ? new LanguageString(v["@value"], v["@language"]) : void 0;
			if (typeof decoded === "undefined") continue;
			_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.push(decoded);
		}
		instance.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername;
		const _axq166E2eZADq34V4MYUc8KMZdC_publicKey = [];
		const _trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey = /* @__PURE__ */ new Set();
		let _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array = values["https://w3id.org/security#publicKey"];
		for (const v of _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array == null ? [] : _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array.length === 1 && "@list" in _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array[0] ? _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array[0]["@list"] : _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_axq166E2eZADq34V4MYUc8KMZdC_publicKey.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_axq166E2eZADq34V4MYUc8KMZdC_publicKey.push(await CryptographicKey.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey = _axq166E2eZADq34V4MYUc8KMZdC_publicKey;
		const _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = [];
		const _trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = /* @__PURE__ */ new Set();
		let _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array = values["https://w3id.org/security#assertionMethod"];
		for (const v of _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array == null ? [] : _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array.length === 1 && "@list" in _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array[0] ? _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array[0]["@list"] : _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.push(await Multikey.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod;
		const _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = [];
		let _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array = values["https://www.w3.org/ns/activitystreams#manuallyApprovesFollowers"];
		for (const v of _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array == null ? [] : _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array.length === 1 && "@list" in _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array[0] ? _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array[0]["@list"] : _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array) {
			if (v == null) continue;
			_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers.push(v["@value"]);
		}
		instance.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers;
		const _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = [];
		const _trust_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = /* @__PURE__ */ new Set();
		let _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array = values["http://www.w3.org/ns/ldp#inbox"];
		for (const v of _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array == null ? [] : _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array.length === 1 && "@list" in _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array[0] ? _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array[0]["@list"] : _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			const decoded = typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#OrderedCollection") ? await OrderedCollection.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#OrderedCollectionPage") ? await OrderedCollectionPage.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : void 0;
			if (typeof decoded === "undefined") continue;
			_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.push(decoded);
		}
		instance.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox;
		const _41QwhqJouoLg3h8dRPKat21brynC_outbox = [];
		const _trust_41QwhqJouoLg3h8dRPKat21brynC_outbox = /* @__PURE__ */ new Set();
		let _41QwhqJouoLg3h8dRPKat21brynC_outbox__array = values["https://www.w3.org/ns/activitystreams#outbox"];
		for (const v of _41QwhqJouoLg3h8dRPKat21brynC_outbox__array == null ? [] : _41QwhqJouoLg3h8dRPKat21brynC_outbox__array.length === 1 && "@list" in _41QwhqJouoLg3h8dRPKat21brynC_outbox__array[0] ? _41QwhqJouoLg3h8dRPKat21brynC_outbox__array[0]["@list"] : _41QwhqJouoLg3h8dRPKat21brynC_outbox__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_41QwhqJouoLg3h8dRPKat21brynC_outbox.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			const decoded = typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#OrderedCollection") ? await OrderedCollection.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#OrderedCollectionPage") ? await OrderedCollectionPage.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : void 0;
			if (typeof decoded === "undefined") continue;
			_41QwhqJouoLg3h8dRPKat21brynC_outbox.push(decoded);
		}
		instance.#_41QwhqJouoLg3h8dRPKat21brynC_outbox = _41QwhqJouoLg3h8dRPKat21brynC_outbox;
		const _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = [];
		const _trust_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = /* @__PURE__ */ new Set();
		let _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array = values["https://www.w3.org/ns/activitystreams#following"];
		for (const v of _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array == null ? [] : _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array.length === 1 && "@list" in _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array[0] ? _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array[0]["@list"] : _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.push(await Collection.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following;
		const _BBCTgfphhsFzpVfKTykGSpBNwoA_followers = [];
		const _trust_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = /* @__PURE__ */ new Set();
		let _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array = values["https://www.w3.org/ns/activitystreams#followers"];
		for (const v of _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array == null ? [] : _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array.length === 1 && "@list" in _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array[0] ? _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array[0]["@list"] : _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.push(await Collection.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = _BBCTgfphhsFzpVfKTykGSpBNwoA_followers;
		const _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = [];
		const _trust_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = /* @__PURE__ */ new Set();
		let _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array = values["https://www.w3.org/ns/activitystreams#liked"];
		for (const v of _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array == null ? [] : _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array.length === 1 && "@list" in _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array[0] ? _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array[0]["@list"] : _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.push(await Collection.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked;
		const _4N1vBJzXDf8NbBumeECQMFvKetja_featured = [];
		const _trust_4N1vBJzXDf8NbBumeECQMFvKetja_featured = /* @__PURE__ */ new Set();
		let _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array = values["http://joinmastodon.org/ns#featured"];
		for (const v of _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array == null ? [] : _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array.length === 1 && "@list" in _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array[0] ? _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array[0]["@list"] : _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_4N1vBJzXDf8NbBumeECQMFvKetja_featured.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_4N1vBJzXDf8NbBumeECQMFvKetja_featured.push(await Collection.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured = _4N1vBJzXDf8NbBumeECQMFvKetja_featured;
		const _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = [];
		const _trust_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = /* @__PURE__ */ new Set();
		let _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array = values["http://joinmastodon.org/ns#featuredTags"];
		for (const v of _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array == null ? [] : _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array.length === 1 && "@list" in _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array[0] ? _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array[0]["@list"] : _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.push(await Collection.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags;
		const _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = [];
		const _trust_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = /* @__PURE__ */ new Set();
		let _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array = values["https://www.w3.org/ns/activitystreams#streams"];
		for (const v of _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array == null ? [] : _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array.length === 1 && "@list" in _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array[0] ? _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array[0]["@list"] : _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.push(await Collection.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams;
		const _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = [];
		let _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array = values["https://www.w3.org/ns/activitystreams#endpoints"];
		for (const v of _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array == null ? [] : _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array.length === 1 && "@list" in _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array[0] ? _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array[0]["@list"] : _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array) {
			if (v == null) continue;
			_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints.push(await Endpoints.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints;
		const _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = [];
		let _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array = values["http://joinmastodon.org/ns#discoverable"];
		for (const v of _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array == null ? [] : _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array.length === 1 && "@list" in _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array[0] ? _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array[0]["@list"] : _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array) {
			if (v == null) continue;
			_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable.push(v["@value"]);
		}
		instance.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable;
		const _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = [];
		let _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array = values["http://joinmastodon.org/ns#suspended"];
		for (const v of _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array == null ? [] : _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array.length === 1 && "@list" in _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array[0] ? _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array[0]["@list"] : _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array) {
			if (v == null) continue;
			_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended.push(v["@value"]);
		}
		instance.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended;
		const _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = [];
		let _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array = values["http://joinmastodon.org/ns#memorial"];
		for (const v of _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array == null ? [] : _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array.length === 1 && "@list" in _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array[0] ? _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array[0]["@list"] : _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array) {
			if (v == null) continue;
			_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial.push(v["@value"]);
		}
		instance.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial;
		const _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = [];
		let _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array = values["http://joinmastodon.org/ns#indexable"];
		for (const v of _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array == null ? [] : _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array.length === 1 && "@list" in _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array[0] ? _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array[0]["@list"] : _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array) {
			if (v == null) continue;
			_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable.push(v["@value"]);
		}
		instance.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable;
		const _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = [];
		const _trust_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = /* @__PURE__ */ new Set();
		let _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array = values["https://www.w3.org/ns/activitystreams#movedTo"];
		for (const v of _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array == null ? [] : _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array.length === 1 && "@list" in _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array[0] ? _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array[0]["@list"] : _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			const decoded = typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Application") ? await Application.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Group") ? await Group.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Organization") ? await Organization.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Person") ? await Person.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Service") ? await Service.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : void 0;
			if (typeof decoded === "undefined") continue;
			_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.push(decoded);
		}
		instance.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo;
		const _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = [];
		const _trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = /* @__PURE__ */ new Set();
		let _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array = values["https://www.w3.org/ns/activitystreams#alsoKnownAs"];
		for (const v of _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array == null ? [] : _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array.length === 1 && "@list" in _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array[0] ? _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array[0]["@list"] : _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			const decoded = typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Application") ? await Application.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Group") ? await Group.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Organization") ? await Organization.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Person") ? await Person.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Service") ? await Service.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : void 0;
			if (typeof decoded === "undefined") continue;
			_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.push(decoded);
		}
		instance.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs;
		const _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = [];
		const _trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = /* @__PURE__ */ new Set();
		let _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array = values["https://www.w3.org/ns/did#service"];
		for (const v of _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array == null ? [] : _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array.length === 1 && "@list" in _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array[0] ? _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array[0]["@list"] : _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.push(await DidService.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service;
		const _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = [];
		let _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array = values["https://misskey-hub.net/ns#_misskey_followedMessage"];
		for (const v of _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array == null ? [] : _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array.length === 1 && "@list" in _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array[0] ? _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array[0]["@list"] : _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array) {
			if (v == null) continue;
			_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage.push(v["@value"]);
		}
		instance.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage;
		const _2xEU4QtkC53RAun67T81Egqt9vmL_isCat = [];
		let _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array = values["https://misskey-hub.net/ns#isCat"];
		for (const v of _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array == null ? [] : _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array.length === 1 && "@list" in _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array[0] ? _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array[0]["@list"] : _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array) {
			if (v == null) continue;
			_2xEU4QtkC53RAun67T81Egqt9vmL_isCat.push(v["@value"]);
		}
		instance.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat = _2xEU4QtkC53RAun67T81Egqt9vmL_isCat;
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		const _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.length == 1) proxy.preferredUsername = _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername[0];
		if (_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.length > 1 || !("preferredUsername" in proxy) && _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.length > 0) proxy.preferredUsernames = _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername;
		const _axq166E2eZADq34V4MYUc8KMZdC_publicKey = this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_axq166E2eZADq34V4MYUc8KMZdC_publicKey.length == 1) proxy.publicKey = _axq166E2eZADq34V4MYUc8KMZdC_publicKey[0];
		if (_axq166E2eZADq34V4MYUc8KMZdC_publicKey.length > 1 || !("publicKey" in proxy) && _axq166E2eZADq34V4MYUc8KMZdC_publicKey.length > 0) proxy.publicKeys = _axq166E2eZADq34V4MYUc8KMZdC_publicKey;
		const _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.length == 1) proxy.assertionMethod = _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod[0];
		if (_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.length > 1 || !("assertionMethod" in proxy) && _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.length > 0) proxy.assertionMethods = _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod;
		const _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers.length == 1) proxy.manuallyApprovesFollowers = _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers[0];
		const _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.length == 1) proxy.inbox = _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox[0];
		const _41QwhqJouoLg3h8dRPKat21brynC_outbox = this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_41QwhqJouoLg3h8dRPKat21brynC_outbox.length == 1) proxy.outbox = _41QwhqJouoLg3h8dRPKat21brynC_outbox[0];
		const _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.length == 1) proxy.following = _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following[0];
		const _BBCTgfphhsFzpVfKTykGSpBNwoA_followers = this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.length == 1) proxy.followers = _BBCTgfphhsFzpVfKTykGSpBNwoA_followers[0];
		const _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.length == 1) proxy.liked = _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked[0];
		const _4N1vBJzXDf8NbBumeECQMFvKetja_featured = this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_4N1vBJzXDf8NbBumeECQMFvKetja_featured.length == 1) proxy.featured = _4N1vBJzXDf8NbBumeECQMFvKetja_featured[0];
		const _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.length == 1) proxy.featuredTags = _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags[0];
		const _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.length > 1 || !("stream" in proxy) && _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.length > 0) proxy.streams = _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams;
		const _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints.length == 1) proxy.endpoints = _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints[0];
		const _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable.length == 1) proxy.discoverable = _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable[0];
		const _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended.length == 1) proxy.suspended = _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended[0];
		const _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial.length == 1) proxy.memorial = _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial[0];
		const _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable.length == 1) proxy.indexable = _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable[0];
		const _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.length == 1) proxy.successor = _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo[0];
		const _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.length == 1) proxy.alias = _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs[0];
		if (_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.length > 1 || !("alias" in proxy) && _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.length > 0) proxy.aliases = _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs;
		const _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length == 1) proxy.service = _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service[0];
		if (_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length > 1 || !("service" in proxy) && _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length > 0) proxy.services = _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service;
		const _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage.length == 1) proxy.followedMessage = _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage[0];
		const _2xEU4QtkC53RAun67T81Egqt9vmL_isCat = this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_2xEU4QtkC53RAun67T81Egqt9vmL_isCat.length == 1) proxy.cat = _2xEU4QtkC53RAun67T81Egqt9vmL_isCat[0];
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "Person " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "Person " + inspect(proxy, options);
	}
};
/** Represents a logical or physical location.  See [5.3 Representing
* Places](https://www.w3.org/TR/activitystreams-vocabulary/#places)
* for additional information.
*/
var Place = class Place extends Object$1 {
	/**
	* The type URI of {@link Place}: `https://www.w3.org/ns/activitystreams#Place`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#Place");
	}
	#_3UCsHnBHvDAXJnBuzw3zw1VVs3Ne_accuracy = [];
	#_3Q6KDcFQUJRRaBux1BL2yp5QWiBi_altitude = [];
	#_3g85RoKRnaNjP7DFyLSvsWDg7HGM_latitude = [];
	#_B2GEYdS9yBAF3ho1pm1rcRg7cSf_longitude = [];
	#_3ga86BKHUtRkGx5PHBjRiUXXzwnw_radius = [];
	#_oKrwxU4V8wiKhMW1QEYQibcJh8c_units = [];
	/**
	* Constructs a new instance of Place with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
		if ("accuracy" in values && values.accuracy != null) if (typeof values.accuracy === "number" && !Number.isNaN(values.accuracy)) this.#_3UCsHnBHvDAXJnBuzw3zw1VVs3Ne_accuracy = [values.accuracy];
		else throw new TypeError("The accuracy must be of type number.");
		if ("altitude" in values && values.altitude != null) if (typeof values.altitude === "number" && !Number.isNaN(values.altitude)) this.#_3Q6KDcFQUJRRaBux1BL2yp5QWiBi_altitude = [values.altitude];
		else throw new TypeError("The altitude must be of type number.");
		if ("latitude" in values && values.latitude != null) if (typeof values.latitude === "number" && !Number.isNaN(values.latitude)) this.#_3g85RoKRnaNjP7DFyLSvsWDg7HGM_latitude = [values.latitude];
		else throw new TypeError("The latitude must be of type number.");
		if ("longitude" in values && values.longitude != null) if (typeof values.longitude === "number" && !Number.isNaN(values.longitude)) this.#_B2GEYdS9yBAF3ho1pm1rcRg7cSf_longitude = [values.longitude];
		else throw new TypeError("The longitude must be of type number.");
		if ("radius" in values && values.radius != null) if (typeof values.radius === "number" && !Number.isNaN(values.radius)) this.#_3ga86BKHUtRkGx5PHBjRiUXXzwnw_radius = [values.radius];
		else throw new TypeError("The radius must be of type number.");
		if ("units" in values && values.units != null) if (values.units == "cm" || values.units == "feet" || values.units == "inches" || values.units == "km" || values.units == "m" || values.units == "miles" || values.units instanceof URL) this.#_oKrwxU4V8wiKhMW1QEYQibcJh8c_units = [values.units];
		else throw new TypeError("The units must be of type \"cm\" | \"feet\" | \"inches\" | \"km\" | \"m\" | \"miles\" | URL.");
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		clone.#_3UCsHnBHvDAXJnBuzw3zw1VVs3Ne_accuracy = this.#_3UCsHnBHvDAXJnBuzw3zw1VVs3Ne_accuracy;
		if ("accuracy" in values && values.accuracy != null) if (typeof values.accuracy === "number" && !Number.isNaN(values.accuracy)) clone.#_3UCsHnBHvDAXJnBuzw3zw1VVs3Ne_accuracy = [values.accuracy];
		else throw new TypeError("The accuracy must be of type number.");
		clone.#_3Q6KDcFQUJRRaBux1BL2yp5QWiBi_altitude = this.#_3Q6KDcFQUJRRaBux1BL2yp5QWiBi_altitude;
		if ("altitude" in values && values.altitude != null) if (typeof values.altitude === "number" && !Number.isNaN(values.altitude)) clone.#_3Q6KDcFQUJRRaBux1BL2yp5QWiBi_altitude = [values.altitude];
		else throw new TypeError("The altitude must be of type number.");
		clone.#_3g85RoKRnaNjP7DFyLSvsWDg7HGM_latitude = this.#_3g85RoKRnaNjP7DFyLSvsWDg7HGM_latitude;
		if ("latitude" in values && values.latitude != null) if (typeof values.latitude === "number" && !Number.isNaN(values.latitude)) clone.#_3g85RoKRnaNjP7DFyLSvsWDg7HGM_latitude = [values.latitude];
		else throw new TypeError("The latitude must be of type number.");
		clone.#_B2GEYdS9yBAF3ho1pm1rcRg7cSf_longitude = this.#_B2GEYdS9yBAF3ho1pm1rcRg7cSf_longitude;
		if ("longitude" in values && values.longitude != null) if (typeof values.longitude === "number" && !Number.isNaN(values.longitude)) clone.#_B2GEYdS9yBAF3ho1pm1rcRg7cSf_longitude = [values.longitude];
		else throw new TypeError("The longitude must be of type number.");
		clone.#_3ga86BKHUtRkGx5PHBjRiUXXzwnw_radius = this.#_3ga86BKHUtRkGx5PHBjRiUXXzwnw_radius;
		if ("radius" in values && values.radius != null) if (typeof values.radius === "number" && !Number.isNaN(values.radius)) clone.#_3ga86BKHUtRkGx5PHBjRiUXXzwnw_radius = [values.radius];
		else throw new TypeError("The radius must be of type number.");
		clone.#_oKrwxU4V8wiKhMW1QEYQibcJh8c_units = this.#_oKrwxU4V8wiKhMW1QEYQibcJh8c_units;
		if ("units" in values && values.units != null) if (values.units == "cm" || values.units == "feet" || values.units == "inches" || values.units == "km" || values.units == "m" || values.units == "miles" || values.units instanceof URL) clone.#_oKrwxU4V8wiKhMW1QEYQibcJh8c_units = [values.units];
		else throw new TypeError("The units must be of type \"cm\" | \"feet\" | \"inches\" | \"km\" | \"m\" | \"miles\" | URL.");
		return clone;
	}
	/** Indicates the accuracy of position coordinates on a {@link Place} objects.
	* Expressed in properties of percentage. e.g. "94.0" means "94.0% accurate".
	*/
	get accuracy() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3UCsHnBHvDAXJnBuzw3zw1VVs3Ne_accuracy.length < 1) return null;
		return this.#_3UCsHnBHvDAXJnBuzw3zw1VVs3Ne_accuracy[0];
	}
	/** Indicates the altitude of a place.  The measurement units is indicated
	* using the {@link Place.units} property.  If {@link Place.units} is not
	* specified, the default is assumed to be "`m`" indicating meters.
	*/
	get altitude() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3Q6KDcFQUJRRaBux1BL2yp5QWiBi_altitude.length < 1) return null;
		return this.#_3Q6KDcFQUJRRaBux1BL2yp5QWiBi_altitude[0];
	}
	/** The latitude of a place.
	*/
	get latitude() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3g85RoKRnaNjP7DFyLSvsWDg7HGM_latitude.length < 1) return null;
		return this.#_3g85RoKRnaNjP7DFyLSvsWDg7HGM_latitude[0];
	}
	/** The longitude of a place.
	*/
	get longitude() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_B2GEYdS9yBAF3ho1pm1rcRg7cSf_longitude.length < 1) return null;
		return this.#_B2GEYdS9yBAF3ho1pm1rcRg7cSf_longitude[0];
	}
	/** The radius from the given latitude and longitude for a {@link Place}.
	* The units is expressed by the {@link Place.units} property.
	* If {@link Place.units} is not specified, the default is assumed to be
	* "`m`" indicating "meters".
	*/
	get radius() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3ga86BKHUtRkGx5PHBjRiUXXzwnw_radius.length < 1) return null;
		return this.#_3ga86BKHUtRkGx5PHBjRiUXXzwnw_radius[0];
	}
	/** Specifies the measurement units for the {@link Place.radius} and
	* {@link Place.altitude} properties on a {@link Place} object.
	* If not specified, the default is assumed to be "`m`" for "meters".
	*/
	get units() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_oKrwxU4V8wiKhMW1QEYQibcJh8c_units.length < 1) return null;
		return this.#_oKrwxU4V8wiKhMW1QEYQibcJh8c_units[0];
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		if (options.format == null && this.isCompactable()) {
			const result = await super.toJsonLd({
				...options,
				format: void 0,
				context: void 0
			});
			let compactItems;
			compactItems = [];
			for (const v of this.#_3UCsHnBHvDAXJnBuzw3zw1VVs3Ne_accuracy) {
				const item = v;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["accuracy"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_3Q6KDcFQUJRRaBux1BL2yp5QWiBi_altitude) {
				const item = v;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["altitude"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_3g85RoKRnaNjP7DFyLSvsWDg7HGM_latitude) {
				const item = v;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["latitude"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_B2GEYdS9yBAF3ho1pm1rcRg7cSf_longitude) {
				const item = v;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["longitude"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_3ga86BKHUtRkGx5PHBjRiUXXzwnw_radius) {
				const item = v;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["radius"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_oKrwxU4V8wiKhMW1QEYQibcJh8c_units) {
				const item = v == "cm" || v == "feet" || v == "inches" || v == "km" || v == "m" || v == "miles" ? v : v.href;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["units"] = compactItems.length > 1 ? compactItems : compactItems[0];
			result["type"] = "Place";
			if (this.id != null) result["id"] = this.id.href;
			result["@context"] = ["https://www.w3.org/ns/activitystreams", "https://w3id.org/security/data-integrity/v1"];
			return result;
		}
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		array = [];
		for (const v of this.#_3UCsHnBHvDAXJnBuzw3zw1VVs3Ne_accuracy) {
			const element = {
				"@type": "http://www.w3.org/2001/XMLSchema#float",
				"@value": v
			};
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#accuracy"] = propValue;
		}
		array = [];
		for (const v of this.#_3Q6KDcFQUJRRaBux1BL2yp5QWiBi_altitude) {
			const element = {
				"@type": "http://www.w3.org/2001/XMLSchema#float",
				"@value": v
			};
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#altitude"] = propValue;
		}
		array = [];
		for (const v of this.#_3g85RoKRnaNjP7DFyLSvsWDg7HGM_latitude) {
			const element = {
				"@type": "http://www.w3.org/2001/XMLSchema#float",
				"@value": v
			};
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#latitude"] = propValue;
		}
		array = [];
		for (const v of this.#_B2GEYdS9yBAF3ho1pm1rcRg7cSf_longitude) {
			const element = {
				"@type": "http://www.w3.org/2001/XMLSchema#float",
				"@value": v
			};
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#longitude"] = propValue;
		}
		array = [];
		for (const v of this.#_3ga86BKHUtRkGx5PHBjRiUXXzwnw_radius) {
			const element = {
				"@type": "http://www.w3.org/2001/XMLSchema#float",
				"@value": v
			};
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#radius"] = propValue;
		}
		array = [];
		for (const v of this.#_oKrwxU4V8wiKhMW1QEYQibcJh8c_units) {
			const element = v == "cm" || v == "feet" || v == "inches" || v == "km" || v == "m" || v == "miles" ? { "@value": v } : { "@id": v.href };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#units"] = propValue;
		}
		values["@type"] = ["https://www.w3.org/ns/activitystreams#Place"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? ["https://www.w3.org/ns/activitystreams", "https://w3id.org/security/data-integrity/v1"];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {
			if ("proof" in compacted && compacted.proof != null) if (Array.isArray(compacted.proof)) for (const element of compacted.proof) element["@context"] = docContext;
			else compacted.proof["@context"] = docContext;
		}
		return compacted;
	}
	isCompactable() {
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__Place__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__Place__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Place")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof Place)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		const _3UCsHnBHvDAXJnBuzw3zw1VVs3Ne_accuracy = [];
		let _3UCsHnBHvDAXJnBuzw3zw1VVs3Ne_accuracy__array = values["https://www.w3.org/ns/activitystreams#accuracy"];
		for (const v of _3UCsHnBHvDAXJnBuzw3zw1VVs3Ne_accuracy__array == null ? [] : _3UCsHnBHvDAXJnBuzw3zw1VVs3Ne_accuracy__array.length === 1 && "@list" in _3UCsHnBHvDAXJnBuzw3zw1VVs3Ne_accuracy__array[0] ? _3UCsHnBHvDAXJnBuzw3zw1VVs3Ne_accuracy__array[0]["@list"] : _3UCsHnBHvDAXJnBuzw3zw1VVs3Ne_accuracy__array) {
			if (v == null) continue;
			_3UCsHnBHvDAXJnBuzw3zw1VVs3Ne_accuracy.push(v["@value"]);
		}
		instance.#_3UCsHnBHvDAXJnBuzw3zw1VVs3Ne_accuracy = _3UCsHnBHvDAXJnBuzw3zw1VVs3Ne_accuracy;
		const _3Q6KDcFQUJRRaBux1BL2yp5QWiBi_altitude = [];
		let _3Q6KDcFQUJRRaBux1BL2yp5QWiBi_altitude__array = values["https://www.w3.org/ns/activitystreams#altitude"];
		for (const v of _3Q6KDcFQUJRRaBux1BL2yp5QWiBi_altitude__array == null ? [] : _3Q6KDcFQUJRRaBux1BL2yp5QWiBi_altitude__array.length === 1 && "@list" in _3Q6KDcFQUJRRaBux1BL2yp5QWiBi_altitude__array[0] ? _3Q6KDcFQUJRRaBux1BL2yp5QWiBi_altitude__array[0]["@list"] : _3Q6KDcFQUJRRaBux1BL2yp5QWiBi_altitude__array) {
			if (v == null) continue;
			_3Q6KDcFQUJRRaBux1BL2yp5QWiBi_altitude.push(v["@value"]);
		}
		instance.#_3Q6KDcFQUJRRaBux1BL2yp5QWiBi_altitude = _3Q6KDcFQUJRRaBux1BL2yp5QWiBi_altitude;
		const _3g85RoKRnaNjP7DFyLSvsWDg7HGM_latitude = [];
		let _3g85RoKRnaNjP7DFyLSvsWDg7HGM_latitude__array = values["https://www.w3.org/ns/activitystreams#latitude"];
		for (const v of _3g85RoKRnaNjP7DFyLSvsWDg7HGM_latitude__array == null ? [] : _3g85RoKRnaNjP7DFyLSvsWDg7HGM_latitude__array.length === 1 && "@list" in _3g85RoKRnaNjP7DFyLSvsWDg7HGM_latitude__array[0] ? _3g85RoKRnaNjP7DFyLSvsWDg7HGM_latitude__array[0]["@list"] : _3g85RoKRnaNjP7DFyLSvsWDg7HGM_latitude__array) {
			if (v == null) continue;
			_3g85RoKRnaNjP7DFyLSvsWDg7HGM_latitude.push(v["@value"]);
		}
		instance.#_3g85RoKRnaNjP7DFyLSvsWDg7HGM_latitude = _3g85RoKRnaNjP7DFyLSvsWDg7HGM_latitude;
		const _B2GEYdS9yBAF3ho1pm1rcRg7cSf_longitude = [];
		let _B2GEYdS9yBAF3ho1pm1rcRg7cSf_longitude__array = values["https://www.w3.org/ns/activitystreams#longitude"];
		for (const v of _B2GEYdS9yBAF3ho1pm1rcRg7cSf_longitude__array == null ? [] : _B2GEYdS9yBAF3ho1pm1rcRg7cSf_longitude__array.length === 1 && "@list" in _B2GEYdS9yBAF3ho1pm1rcRg7cSf_longitude__array[0] ? _B2GEYdS9yBAF3ho1pm1rcRg7cSf_longitude__array[0]["@list"] : _B2GEYdS9yBAF3ho1pm1rcRg7cSf_longitude__array) {
			if (v == null) continue;
			_B2GEYdS9yBAF3ho1pm1rcRg7cSf_longitude.push(v["@value"]);
		}
		instance.#_B2GEYdS9yBAF3ho1pm1rcRg7cSf_longitude = _B2GEYdS9yBAF3ho1pm1rcRg7cSf_longitude;
		const _3ga86BKHUtRkGx5PHBjRiUXXzwnw_radius = [];
		let _3ga86BKHUtRkGx5PHBjRiUXXzwnw_radius__array = values["https://www.w3.org/ns/activitystreams#radius"];
		for (const v of _3ga86BKHUtRkGx5PHBjRiUXXzwnw_radius__array == null ? [] : _3ga86BKHUtRkGx5PHBjRiUXXzwnw_radius__array.length === 1 && "@list" in _3ga86BKHUtRkGx5PHBjRiUXXzwnw_radius__array[0] ? _3ga86BKHUtRkGx5PHBjRiUXXzwnw_radius__array[0]["@list"] : _3ga86BKHUtRkGx5PHBjRiUXXzwnw_radius__array) {
			if (v == null) continue;
			_3ga86BKHUtRkGx5PHBjRiUXXzwnw_radius.push(v["@value"]);
		}
		instance.#_3ga86BKHUtRkGx5PHBjRiUXXzwnw_radius = _3ga86BKHUtRkGx5PHBjRiUXXzwnw_radius;
		const _oKrwxU4V8wiKhMW1QEYQibcJh8c_units = [];
		let _oKrwxU4V8wiKhMW1QEYQibcJh8c_units__array = values["https://www.w3.org/ns/activitystreams#units"];
		for (const v of _oKrwxU4V8wiKhMW1QEYQibcJh8c_units__array == null ? [] : _oKrwxU4V8wiKhMW1QEYQibcJh8c_units__array.length === 1 && "@list" in _oKrwxU4V8wiKhMW1QEYQibcJh8c_units__array[0] ? _oKrwxU4V8wiKhMW1QEYQibcJh8c_units__array[0]["@list"] : _oKrwxU4V8wiKhMW1QEYQibcJh8c_units__array) {
			if (v == null) continue;
			const decoded = typeof v === "object" && "@value" in v && (v["@value"] == "cm" || v["@value"] == "feet" || v["@value"] == "inches" || v["@value"] == "km" || v["@value"] == "m" || v["@value"] == "miles") ? v["@value"] : typeof v === "object" && "@id" in v && typeof v["@id"] === "string" && v["@id"] !== "" ? v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].includes("/", 5) ? v["@id"].slice(5, v["@id"].indexOf("/", 5)) : v["@id"].slice(5)) + (v["@id"].includes("/", 5) ? v["@id"].slice(v["@id"].indexOf("/", 5)) : "")) : URL.canParse(v["@id"]) && (values["@id"] == null ? options.baseUrl : new URL(values["@id"])) ? new URL(v["@id"]) : new URL(v["@id"], values["@id"] == null ? options.baseUrl : new URL(values["@id"])) : void 0;
			if (typeof decoded === "undefined") continue;
			_oKrwxU4V8wiKhMW1QEYQibcJh8c_units.push(decoded);
		}
		instance.#_oKrwxU4V8wiKhMW1QEYQibcJh8c_units = _oKrwxU4V8wiKhMW1QEYQibcJh8c_units;
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		const _3UCsHnBHvDAXJnBuzw3zw1VVs3Ne_accuracy = this.#_3UCsHnBHvDAXJnBuzw3zw1VVs3Ne_accuracy.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3UCsHnBHvDAXJnBuzw3zw1VVs3Ne_accuracy.length == 1) proxy.accuracy = _3UCsHnBHvDAXJnBuzw3zw1VVs3Ne_accuracy[0];
		const _3Q6KDcFQUJRRaBux1BL2yp5QWiBi_altitude = this.#_3Q6KDcFQUJRRaBux1BL2yp5QWiBi_altitude.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3Q6KDcFQUJRRaBux1BL2yp5QWiBi_altitude.length == 1) proxy.altitude = _3Q6KDcFQUJRRaBux1BL2yp5QWiBi_altitude[0];
		const _3g85RoKRnaNjP7DFyLSvsWDg7HGM_latitude = this.#_3g85RoKRnaNjP7DFyLSvsWDg7HGM_latitude.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3g85RoKRnaNjP7DFyLSvsWDg7HGM_latitude.length == 1) proxy.latitude = _3g85RoKRnaNjP7DFyLSvsWDg7HGM_latitude[0];
		const _B2GEYdS9yBAF3ho1pm1rcRg7cSf_longitude = this.#_B2GEYdS9yBAF3ho1pm1rcRg7cSf_longitude.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_B2GEYdS9yBAF3ho1pm1rcRg7cSf_longitude.length == 1) proxy.longitude = _B2GEYdS9yBAF3ho1pm1rcRg7cSf_longitude[0];
		const _3ga86BKHUtRkGx5PHBjRiUXXzwnw_radius = this.#_3ga86BKHUtRkGx5PHBjRiUXXzwnw_radius.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3ga86BKHUtRkGx5PHBjRiUXXzwnw_radius.length == 1) proxy.radius = _3ga86BKHUtRkGx5PHBjRiUXXzwnw_radius[0];
		const _oKrwxU4V8wiKhMW1QEYQibcJh8c_units = this.#_oKrwxU4V8wiKhMW1QEYQibcJh8c_units.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_oKrwxU4V8wiKhMW1QEYQibcJh8c_units.length == 1) proxy.units = _oKrwxU4V8wiKhMW1QEYQibcJh8c_units[0];
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "Place " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "Place " + inspect(proxy, options);
	}
};
/** A {@link Profile} is a content object that describes another {@link Object},
* typically used to describe [Actor
* Type](https://www.w3.org/TR/activitystreams-vocabulary/#actor-types) objects.
* The {@link Profile.describes} property is used to reference the object being
* described by the profile.
*/
var Profile = class Profile extends Object$1 {
	/**
	* The type URI of {@link Profile}: `https://www.w3.org/ns/activitystreams#Profile`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#Profile");
	}
	#_3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes = [];
	#_trust_3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes = /* @__PURE__ */ new Set();
	/**
	* Constructs a new instance of Profile with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
		if ("describes" in values && values.describes != null) if (values.describes instanceof Object$1 || values.describes instanceof URL) {
			this.#_3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes = [values.describes];
			this.#_trust_3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes.add(0);
		} else throw new TypeError("The describes must be of type Object | URL.");
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		clone.#_3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes = this.#_3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes;
		clone.#_trust_3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes = new Set(this.#_trust_3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes);
		if ("describes" in values && values.describes != null) if (values.describes instanceof Object$1 || values.describes instanceof URL) {
			clone.#_3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes = [values.describes];
			clone.#_trust_3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes = new Set([0]);
		} else throw new TypeError("The describes must be of type Object | URL.");
		return clone;
	}
	async #fetchDescribes(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#describes_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #describes_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Object$1.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Object"].join(", "));
	}
	/**
	* Similar to
	* {@link Profile.getDescribes},
	* but returns its `@id` URL instead of the object itself.
	*/
	get describesId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes.length < 1) return null;
		const v = this.#_3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** On a {@link Profile} object, the {@link Profile.describes} property
	* identifies the object described by the {@link Profile}.
	*/
	async getDescribes(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes.length < 1) return null;
		let v = this.#_3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchDescribes(v, options);
			if (fetched == null) return null;
			this.#_3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes[0] = fetched;
			this.#_trust_3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "describes" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["describes"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#describes_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		if (options.format == null && this.isCompactable()) {
			const result = await super.toJsonLd({
				...options,
				format: void 0,
				context: void 0
			});
			let compactItems;
			compactItems = [];
			for (const v of this.#_3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["describes"] = compactItems.length > 1 ? compactItems : compactItems[0];
			result["type"] = "Profile";
			if (this.id != null) result["id"] = this.id.href;
			result["@context"] = ["https://www.w3.org/ns/activitystreams", "https://w3id.org/security/data-integrity/v1"];
			return result;
		}
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		array = [];
		for (const v of this.#_3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#describes"] = propValue;
		}
		values["@type"] = ["https://www.w3.org/ns/activitystreams#Profile"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? ["https://www.w3.org/ns/activitystreams", "https://w3id.org/security/data-integrity/v1"];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {
			if ("proof" in compacted && compacted.proof != null) if (Array.isArray(compacted.proof)) for (const element of compacted.proof) element["@context"] = docContext;
			else compacted.proof["@context"] = docContext;
		}
		return compacted;
	}
	isCompactable() {
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__Profile__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__Profile__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Profile")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof Profile)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		const _3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes = [];
		const _trust_3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes = /* @__PURE__ */ new Set();
		let _3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes__array = values["https://www.w3.org/ns/activitystreams#describes"];
		for (const v of _3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes__array == null ? [] : _3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes__array.length === 1 && "@list" in _3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes__array[0] ? _3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes__array[0]["@list"] : _3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes.push(await Object$1.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes = _3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes;
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		const _3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes = this.#_3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes.length == 1) proxy.describes = _3CLQ1PLSXrhSQbTGGHuxNyaEFKM1_describes[0];
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "Profile " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "Profile " + inspect(proxy, options);
	}
};
/** Represents a question being asked.  Question objects are an extension of
* {@link IntransitiveActivity}.  That is, the Question object is an Activity,
* but the direct object is the question itself and therefore it would not
* contain an `object` property.
*
* Either of the `inclusiveOptions` and `exclusiveOptions` properties *may* be
* used to express possible answers, but a Question object *must not* have both
* properties.
*/
var Question = class Question extends IntransitiveActivity {
	/**
	* The type URI of {@link Question}: `https://www.w3.org/ns/activitystreams#Question`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#Question");
	}
	#_2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf = [];
	#_trust_2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf = /* @__PURE__ */ new Set();
	#_2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf = [];
	#_trust_2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf = /* @__PURE__ */ new Set();
	#_3KronwL8DiiKBRcJFKQPiEHm8xb6_closed = [];
	#_3H4RdST7dxfmghccvE3rKD3KgcxG_votersCount = [];
	#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl = [];
	/**
	* Constructs a new instance of Question with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
		if ("exclusiveOptions" in values && values.exclusiveOptions != null) if (Array.isArray(values.exclusiveOptions) && values.exclusiveOptions.every((v) => v instanceof Object$1 || v instanceof URL)) {
			this.#_2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf = values.exclusiveOptions;
			for (let i = 0; i < values.exclusiveOptions.length; i++) this.#_trust_2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf.add(i);
		} else throw new TypeError("The exclusiveOptions must be an array of type Object | URL.");
		if ("inclusiveOptions" in values && values.inclusiveOptions != null) if (Array.isArray(values.inclusiveOptions) && values.inclusiveOptions.every((v) => v instanceof Object$1 || v instanceof URL)) {
			this.#_2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf = values.inclusiveOptions;
			for (let i = 0; i < values.inclusiveOptions.length; i++) this.#_trust_2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf.add(i);
		} else throw new TypeError("The inclusiveOptions must be an array of type Object | URL.");
		if ("closed" in values && values.closed != null) if (values.closed instanceof Temporal.Instant || typeof values.closed === "boolean") this.#_3KronwL8DiiKBRcJFKQPiEHm8xb6_closed = [values.closed];
		else throw new TypeError("The closed must be of type Temporal.Instant | boolean.");
		if ("voters" in values && values.voters != null) if (typeof values.voters === "number" && Number.isInteger(values.voters) && values.voters >= 0) this.#_3H4RdST7dxfmghccvE3rKD3KgcxG_votersCount = [values.voters];
		else throw new TypeError("The voters must be of type number.");
		if ("quoteUrl" in values && values.quoteUrl != null) if (values.quoteUrl instanceof URL) this.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl = [values.quoteUrl];
		else throw new TypeError("The quoteUrl must be of type URL.");
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		clone.#_2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf = this.#_2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf;
		clone.#_trust_2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf = new Set(this.#_trust_2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf);
		if ("exclusiveOptions" in values && values.exclusiveOptions != null) if (Array.isArray(values.exclusiveOptions) && values.exclusiveOptions.every((v) => v instanceof Object$1 || v instanceof URL)) {
			clone.#_2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf = values.exclusiveOptions;
			clone.#_trust_2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf = /* @__PURE__ */ new Set();
			for (let i = 0; i < values.exclusiveOptions.length; i++) clone.#_trust_2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf.add(i);
		} else throw new TypeError("The exclusiveOptions must be an array of type Object | URL.");
		clone.#_2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf = this.#_2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf;
		clone.#_trust_2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf = new Set(this.#_trust_2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf);
		if ("inclusiveOptions" in values && values.inclusiveOptions != null) if (Array.isArray(values.inclusiveOptions) && values.inclusiveOptions.every((v) => v instanceof Object$1 || v instanceof URL)) {
			clone.#_2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf = values.inclusiveOptions;
			clone.#_trust_2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf = /* @__PURE__ */ new Set();
			for (let i = 0; i < values.inclusiveOptions.length; i++) clone.#_trust_2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf.add(i);
		} else throw new TypeError("The inclusiveOptions must be an array of type Object | URL.");
		clone.#_3KronwL8DiiKBRcJFKQPiEHm8xb6_closed = this.#_3KronwL8DiiKBRcJFKQPiEHm8xb6_closed;
		if ("closed" in values && values.closed != null) if (values.closed instanceof Temporal.Instant || typeof values.closed === "boolean") clone.#_3KronwL8DiiKBRcJFKQPiEHm8xb6_closed = [values.closed];
		else throw new TypeError("The closed must be of type Temporal.Instant | boolean.");
		clone.#_3H4RdST7dxfmghccvE3rKD3KgcxG_votersCount = this.#_3H4RdST7dxfmghccvE3rKD3KgcxG_votersCount;
		if ("voters" in values && values.voters != null) if (typeof values.voters === "number" && Number.isInteger(values.voters) && values.voters >= 0) clone.#_3H4RdST7dxfmghccvE3rKD3KgcxG_votersCount = [values.voters];
		else throw new TypeError("The voters must be of type number.");
		clone.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl = this.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl;
		if ("quoteUrl" in values && values.quoteUrl != null) if (values.quoteUrl instanceof URL) clone.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl = [values.quoteUrl];
		else throw new TypeError("The quoteUrl must be of type URL.");
		return clone;
	}
	async #fetchExclusiveOption(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#exclusiveOption_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #exclusiveOption_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Object$1.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Object"].join(", "));
	}
	/**
	* Similar to
	* {@link Question.getExclusiveOptions},
	* but returns their `@id`s instead of the objects themselves.
	*/
	get exclusiveOptionIds() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		return this.#_2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
	}
	/** Identifies an exclusive option for a Question.  Use of `exclusiveOptions`
	* implies that the Question can have only a single answer.  To indicate that
	* a Question can have multiple answers, use `inclusiveOptions`.
	*/
	async *getExclusiveOptions(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		const vs = this.#_2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf;
		for (let i = 0; i < vs.length; i++) {
			let v = vs[i];
			if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf.has(i)) v = v.id;
			if (v instanceof URL) {
				const fetched = await this.#fetchExclusiveOption(v, options);
				if (fetched == null) continue;
				vs[i] = fetched;
				this.#_trust_2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf.add(i);
				this._cachedJsonLd = void 0;
				yield fetched;
				continue;
			}
			if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "oneOf" in this._cachedJsonLd) {
				const prop = this._cachedJsonLd["oneOf"];
				const obj = Array.isArray(prop) ? prop[i] : prop;
				if (obj != null && typeof obj === "object" && "@context" in obj) v = await this.#exclusiveOption_fromJsonLd(obj, options);
			}
			if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf.has(0)) {
				if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
				getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
					objectId: v.id.href,
					parentObjectId: this.id.href
				});
				continue;
			}
			yield v;
		}
	}
	async #fetchInclusiveOption(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#inclusiveOption_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #inclusiveOption_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Object$1.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Object"].join(", "));
	}
	/**
	* Similar to
	* {@link Question.getInclusiveOptions},
	* but returns their `@id`s instead of the objects themselves.
	*/
	get inclusiveOptionIds() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		return this.#_2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
	}
	/** Identifies an inclusive option for a Question.  Use of `inclusiveOptions`
	* implies that the Question can have multiple answers.  To indicate that
	* a Question can have only one answer, use `exclusiveOptions`.
	*/
	async *getInclusiveOptions(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		const vs = this.#_2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf;
		for (let i = 0; i < vs.length; i++) {
			let v = vs[i];
			if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf.has(i)) v = v.id;
			if (v instanceof URL) {
				const fetched = await this.#fetchInclusiveOption(v, options);
				if (fetched == null) continue;
				vs[i] = fetched;
				this.#_trust_2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf.add(i);
				this._cachedJsonLd = void 0;
				yield fetched;
				continue;
			}
			if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "anyOf" in this._cachedJsonLd) {
				const prop = this._cachedJsonLd["anyOf"];
				const obj = Array.isArray(prop) ? prop[i] : prop;
				if (obj != null && typeof obj === "object" && "@context" in obj) v = await this.#inclusiveOption_fromJsonLd(obj, options);
			}
			if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf.has(0)) {
				if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
				getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
					objectId: v.id.href,
					parentObjectId: this.id.href
				});
				continue;
			}
			yield v;
		}
	}
	/** Indicates that a question has been closed, and answers are no longer
	* accepted.
	*/
	get closed() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3KronwL8DiiKBRcJFKQPiEHm8xb6_closed.length < 1) return null;
		return this.#_3KronwL8DiiKBRcJFKQPiEHm8xb6_closed[0];
	}
	/** How many people have voted in the poll.  Distinct from how many votes have
	* been cast (in the case of multiple-choice polls).
	*/
	get voters() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3H4RdST7dxfmghccvE3rKD3KgcxG_votersCount.length < 1) return null;
		return this.#_3H4RdST7dxfmghccvE3rKD3KgcxG_votersCount[0];
	}
	/** The URI of the ActivityStreams object that this object quotes.
	*
	* This property sets three JSON-LD properties at once under the hood:
	*
	* 1. https://www.w3.org/ns/activitystreams#quoteUrl
	* 2. https://misskey-hub.net/ns#_misskey_quote
	* 3. http://fedibird.com/ns#quoteUri
	*
	* When a JSON-LD object is parsed, this property is filled with one of
	* the values of those three properties in order.
	*/
	get quoteUrl() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl.length < 1) return null;
		return this.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl[0];
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		array = [];
		for (const v of this.#_2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#oneOf"] = propValue;
		}
		array = [];
		for (const v of this.#_2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#anyOf"] = propValue;
		}
		array = [];
		for (const v of this.#_3KronwL8DiiKBRcJFKQPiEHm8xb6_closed) {
			const element = v instanceof Temporal.Instant ? {
				"@type": "http://www.w3.org/2001/XMLSchema#dateTime",
				"@value": v.toString()
			} : { "@value": v };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#closed"] = propValue;
		}
		array = [];
		for (const v of this.#_3H4RdST7dxfmghccvE3rKD3KgcxG_votersCount) {
			const element = {
				"@type": "http://www.w3.org/2001/XMLSchema#nonNegativeInteger",
				"@value": v
			};
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["http://joinmastodon.org/ns#votersCount"] = propValue;
		}
		array = [];
		for (const v of this.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl) {
			const element = { "@value": v.href };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#quoteUrl"] = propValue;
			values["https://misskey-hub.net/ns#_misskey_quote"] = propValue;
			values["http://fedibird.com/ns#quoteUri"] = propValue;
		}
		values["@type"] = ["https://www.w3.org/ns/activitystreams#Question"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? [
			"https://w3id.org/identity/v1",
			"https://www.w3.org/ns/activitystreams",
			"https://w3id.org/security/data-integrity/v1",
			{
				"toot": "http://joinmastodon.org/ns#",
				"misskey": "https://misskey-hub.net/ns#",
				"fedibird": "http://fedibird.com/ns#",
				"sensitive": "as:sensitive",
				"votersCount": {
					"@id": "toot:votersCount",
					"@type": "http://www.w3.org/2001/XMLSchema#nonNegativeInteger"
				},
				"Emoji": "toot:Emoji",
				"Hashtag": "as:Hashtag",
				"quoteUrl": "as:quoteUrl",
				"_misskey_quote": "misskey:_misskey_quote",
				"quoteUri": "fedibird:quoteUri",
				"emojiReactions": {
					"@id": "fedibird:emojiReactions",
					"@type": "@id"
				}
			}
		];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {
			if ("proof" in compacted && compacted.proof != null) if (Array.isArray(compacted.proof)) for (const element of compacted.proof) element["@context"] = docContext;
			else compacted.proof["@context"] = docContext;
		}
		return compacted;
	}
	isCompactable() {
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__Question__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__Question__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Question")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof Question)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		const _2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf = [];
		const _trust_2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf = /* @__PURE__ */ new Set();
		let _2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf__array = values["https://www.w3.org/ns/activitystreams#oneOf"];
		for (const v of _2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf__array == null ? [] : _2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf__array.length === 1 && "@list" in _2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf__array[0] ? _2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf__array[0]["@list"] : _2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf.push(await Object$1.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf = _2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf;
		const _2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf = [];
		const _trust_2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf = /* @__PURE__ */ new Set();
		let _2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf__array = values["https://www.w3.org/ns/activitystreams#anyOf"];
		for (const v of _2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf__array == null ? [] : _2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf__array.length === 1 && "@list" in _2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf__array[0] ? _2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf__array[0]["@list"] : _2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf.push(await Object$1.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf = _2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf;
		const _3KronwL8DiiKBRcJFKQPiEHm8xb6_closed = [];
		let _3KronwL8DiiKBRcJFKQPiEHm8xb6_closed__array = values["https://www.w3.org/ns/activitystreams#closed"];
		for (const v of _3KronwL8DiiKBRcJFKQPiEHm8xb6_closed__array == null ? [] : _3KronwL8DiiKBRcJFKQPiEHm8xb6_closed__array.length === 1 && "@list" in _3KronwL8DiiKBRcJFKQPiEHm8xb6_closed__array[0] ? _3KronwL8DiiKBRcJFKQPiEHm8xb6_closed__array[0]["@list"] : _3KronwL8DiiKBRcJFKQPiEHm8xb6_closed__array) {
			if (v == null) continue;
			const decoded = typeof v === "object" && "@type" in v && "@value" in v && typeof v["@value"] === "string" && v["@type"] === "http://www.w3.org/2001/XMLSchema#dateTime" && new Date(v["@value"]).toString() !== "Invalid Date" ? Temporal.Instant.from(v["@value"].substring(19).match(/[Z+-]/) ? v["@value"] : v["@value"] + "Z") : typeof v === "object" && "@value" in v && typeof v["@value"] === "boolean" ? v["@value"] : void 0;
			if (typeof decoded === "undefined") continue;
			_3KronwL8DiiKBRcJFKQPiEHm8xb6_closed.push(decoded);
		}
		instance.#_3KronwL8DiiKBRcJFKQPiEHm8xb6_closed = _3KronwL8DiiKBRcJFKQPiEHm8xb6_closed;
		const _3H4RdST7dxfmghccvE3rKD3KgcxG_votersCount = [];
		let _3H4RdST7dxfmghccvE3rKD3KgcxG_votersCount__array = values["http://joinmastodon.org/ns#votersCount"];
		for (const v of _3H4RdST7dxfmghccvE3rKD3KgcxG_votersCount__array == null ? [] : _3H4RdST7dxfmghccvE3rKD3KgcxG_votersCount__array.length === 1 && "@list" in _3H4RdST7dxfmghccvE3rKD3KgcxG_votersCount__array[0] ? _3H4RdST7dxfmghccvE3rKD3KgcxG_votersCount__array[0]["@list"] : _3H4RdST7dxfmghccvE3rKD3KgcxG_votersCount__array) {
			if (v == null) continue;
			_3H4RdST7dxfmghccvE3rKD3KgcxG_votersCount.push(v["@value"]);
		}
		instance.#_3H4RdST7dxfmghccvE3rKD3KgcxG_votersCount = _3H4RdST7dxfmghccvE3rKD3KgcxG_votersCount;
		const _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl = [];
		let _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array = values["https://www.w3.org/ns/activitystreams#quoteUrl"];
		if (_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array == null || _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array.length < 1) _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array = values["https://misskey-hub.net/ns#_misskey_quote"];
		if (_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array == null || _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array.length < 1) _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array = values["http://fedibird.com/ns#quoteUri"];
		for (const v of _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array == null ? [] : _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array.length === 1 && "@list" in _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array[0] ? _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array[0]["@list"] : _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl__array) {
			if (v == null) continue;
			_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl.push(new URL(v["@value"]));
		}
		instance.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl = _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl;
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		const _2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf = this.#_2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf.length > 1 || !("exclusiveOption" in proxy) && _2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf.length > 0) proxy.exclusiveOptions = _2N5scKaVEcdYHFmfKYYacAwUhUgQ_oneOf;
		const _2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf = this.#_2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf.length > 1 || !("inclusiveOption" in proxy) && _2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf.length > 0) proxy.inclusiveOptions = _2mV6isMTPRKbWdLCjcpiEysq5dAY_anyOf;
		const _3KronwL8DiiKBRcJFKQPiEHm8xb6_closed = this.#_3KronwL8DiiKBRcJFKQPiEHm8xb6_closed.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3KronwL8DiiKBRcJFKQPiEHm8xb6_closed.length == 1) proxy.closed = _3KronwL8DiiKBRcJFKQPiEHm8xb6_closed[0];
		const _3H4RdST7dxfmghccvE3rKD3KgcxG_votersCount = this.#_3H4RdST7dxfmghccvE3rKD3KgcxG_votersCount.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3H4RdST7dxfmghccvE3rKD3KgcxG_votersCount.length == 1) proxy.voters = _3H4RdST7dxfmghccvE3rKD3KgcxG_votersCount[0];
		const _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl = this.#_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl.length == 1) proxy.quoteUrl = _K1zrMQkQjmciFAmGdGLfaDbG925_quoteUrl[0];
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "Question " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "Question " + inspect(proxy, options);
	}
};
/** Indicates that the `actor` has read the `object`.
*/
var Read = class Read extends Activity {
	/**
	* The type URI of {@link Read}: `https://www.w3.org/ns/activitystreams#Read`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#Read");
	}
	/**
	* Constructs a new instance of Read with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		return clone;
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		values["@type"] = ["https://www.w3.org/ns/activitystreams#Read"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? [
			"https://w3id.org/identity/v1",
			"https://www.w3.org/ns/activitystreams",
			"https://w3id.org/security/data-integrity/v1"
		];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {
			if ("proof" in compacted && compacted.proof != null) if (Array.isArray(compacted.proof)) for (const element of compacted.proof) element["@context"] = docContext;
			else compacted.proof["@context"] = docContext;
		}
		return compacted;
	}
	isCompactable() {
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__Read__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__Read__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Read")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof Read)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "Read " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "Read " + inspect(proxy, options);
	}
};
/** Indicates that the `actor` is rejecting the `object`.  The `target` and
* `origin` typically have no defined meaning.
*/
var Reject = class Reject extends Activity {
	/**
	* The type URI of {@link Reject}: `https://www.w3.org/ns/activitystreams#Reject`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#Reject");
	}
	/**
	* Constructs a new instance of Reject with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		return clone;
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		values["@type"] = ["https://www.w3.org/ns/activitystreams#Reject"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? [
			"https://w3id.org/identity/v1",
			"https://www.w3.org/ns/activitystreams",
			"https://w3id.org/security/data-integrity/v1"
		];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {
			if ("proof" in compacted && compacted.proof != null) if (Array.isArray(compacted.proof)) for (const element of compacted.proof) element["@context"] = docContext;
			else compacted.proof["@context"] = docContext;
		}
		return compacted;
	}
	isCompactable() {
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__Reject__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__Reject__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (values["@type"].includes("https://www.w3.org/ns/activitystreams#TentativeReject")) return await TentativeReject.fromJsonLd(json, options);
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Reject")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof Reject)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "Reject " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "Reject " + inspect(proxy, options);
	}
};
/** Describes a relationship between two individuals.
* The {@link Relationship.subject} and {@link Relationship.object} properties
* are used to identify the connected individuals.
*
* See [5.2 Representing Relationships Between
* Entities](https://www.w3.org/TR/activitystreams-vocabulary/#connections)
* for additional information.
*/
var Relationship = class Relationship extends Object$1 {
	/**
	* The type URI of {@link Relationship}: `https://www.w3.org/ns/activitystreams#Relationship`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#Relationship");
	}
	#_2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject = [];
	#_trust_2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject = /* @__PURE__ */ new Set();
	#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object = [];
	#_trust_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object = /* @__PURE__ */ new Set();
	#_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship = [];
	#_trust_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship = /* @__PURE__ */ new Set();
	/**
	* Constructs a new instance of Relationship with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
		if ("subject" in values && values.subject != null) if (values.subject instanceof Object$1 || values.subject instanceof URL) {
			this.#_2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject = [values.subject];
			this.#_trust_2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject.add(0);
		} else throw new TypeError("The subject must be of type Object | URL.");
		if ("object" in values && values.object != null) if (values.object instanceof Object$1 || values.object instanceof URL) {
			this.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object = [values.object];
			this.#_trust_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object.add(0);
		} else throw new TypeError("The object must be of type Object | URL.");
		if ("objects" in values && values.objects != null) {
			if ("object" in values && values.object != null) throw new TypeError("Cannot initialize both object and objects at the same time.");
			if (Array.isArray(values.objects) && values.objects.every((v) => v instanceof Object$1 || v instanceof URL)) {
				this.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object = values.objects;
				for (let i = 0; i < values.objects.length; i++) this.#_trust_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object.add(i);
			} else throw new TypeError("The objects must be an array of type Object | URL.");
		}
		if ("relationship" in values && values.relationship != null) if (values.relationship instanceof Object$1 || values.relationship instanceof URL) {
			this.#_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship = [values.relationship];
			this.#_trust_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship.add(0);
		} else throw new TypeError("The relationship must be of type Object | URL.");
		if ("relationships" in values && values.relationships != null) {
			if ("relationship" in values && values.relationship != null) throw new TypeError("Cannot initialize both relationship and relationships at the same time.");
			if (Array.isArray(values.relationships) && values.relationships.every((v) => v instanceof Object$1 || v instanceof URL)) {
				this.#_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship = values.relationships;
				for (let i = 0; i < values.relationships.length; i++) this.#_trust_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship.add(i);
			} else throw new TypeError("The relationships must be an array of type Object | URL.");
		}
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		clone.#_2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject = this.#_2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject;
		clone.#_trust_2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject = new Set(this.#_trust_2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject);
		if ("subject" in values && values.subject != null) if (values.subject instanceof Object$1 || values.subject instanceof URL) {
			clone.#_2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject = [values.subject];
			clone.#_trust_2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject = new Set([0]);
		} else throw new TypeError("The subject must be of type Object | URL.");
		clone.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object = this.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object;
		clone.#_trust_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object = new Set(this.#_trust_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object);
		if ("object" in values && values.object != null) if (values.object instanceof Object$1 || values.object instanceof URL) {
			clone.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object = [values.object];
			clone.#_trust_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object = new Set([0]);
		} else throw new TypeError("The object must be of type Object | URL.");
		if ("objects" in values && values.objects != null) {
			if ("object" in values && values.object != null) throw new TypeError("Cannot update both object and objects at the same time.");
			if (Array.isArray(values.objects) && values.objects.every((v) => v instanceof Object$1 || v instanceof URL)) {
				clone.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object = values.objects;
				clone.#_trust_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object = /* @__PURE__ */ new Set();
				for (let i = 0; i < values.objects.length; i++) clone.#_trust_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object.add(i);
			} else throw new TypeError("The objects must be an array of type Object | URL.");
		}
		clone.#_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship = this.#_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship;
		clone.#_trust_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship = new Set(this.#_trust_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship);
		if ("relationship" in values && values.relationship != null) if (values.relationship instanceof Object$1 || values.relationship instanceof URL) {
			clone.#_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship = [values.relationship];
			clone.#_trust_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship = new Set([0]);
		} else throw new TypeError("The relationship must be of type Object | URL.");
		if ("relationships" in values && values.relationships != null) {
			if ("relationship" in values && values.relationship != null) throw new TypeError("Cannot update both relationship and relationships at the same time.");
			if (Array.isArray(values.relationships) && values.relationships.every((v) => v instanceof Object$1 || v instanceof URL)) {
				clone.#_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship = values.relationships;
				clone.#_trust_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship = /* @__PURE__ */ new Set();
				for (let i = 0; i < values.relationships.length; i++) clone.#_trust_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship.add(i);
			} else throw new TypeError("The relationships must be an array of type Object | URL.");
		}
		return clone;
	}
	async #fetchSubject(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#subject_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #subject_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Object$1.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Object"].join(", "));
	}
	/**
	* Similar to
	* {@link Relationship.getSubject},
	* but returns its `@id` URL instead of the object itself.
	*/
	get subjectId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject.length < 1) return null;
		const v = this.#_2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** On a {@link Relationship} object, the {@link Relationship.subject} property
	* identifies one of the connected individuals.  For instance,
	* for a {@link Relationship} object describing "John is related to Sally",
	* the {@link Relationship.subject} property would refer to John.
	*/
	async getSubject(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject.length < 1) return null;
		let v = this.#_2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchSubject(v, options);
			if (fetched == null) return null;
			this.#_2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject[0] = fetched;
			this.#_trust_2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "subject" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["subject"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#subject_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchObject(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#object_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #object_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Object$1.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Object"].join(", "));
	}
	/**
	* Similar to
	* {@link Relationship.getObject},
	* but returns its `@id` URL instead of the object itself.
	*/
	get objectId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object.length < 1) return null;
		const v = this.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** Describes the entity to which the {@link Relationship.subject} is related.
	*/
	async getObject(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object.length < 1) return null;
		let v = this.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchObject(v, options);
			if (fetched == null) return null;
			this.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object[0] = fetched;
			this.#_trust_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "object" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["object"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#object_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	/**
	* Similar to
	* {@link Relationship.getObjects},
	* but returns their `@id`s instead of the objects themselves.
	*/
	get objectIds() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		return this.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
	}
	/** Describes the entity to which the {@link Relationship.subject} is related.
	*/
	async *getObjects(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		const vs = this.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object;
		for (let i = 0; i < vs.length; i++) {
			let v = vs[i];
			if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object.has(i)) v = v.id;
			if (v instanceof URL) {
				const fetched = await this.#fetchObject(v, options);
				if (fetched == null) continue;
				vs[i] = fetched;
				this.#_trust_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object.add(i);
				this._cachedJsonLd = void 0;
				yield fetched;
				continue;
			}
			if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "object" in this._cachedJsonLd) {
				const prop = this._cachedJsonLd["object"];
				const obj = Array.isArray(prop) ? prop[i] : prop;
				if (obj != null && typeof obj === "object" && "@context" in obj) v = await this.#object_fromJsonLd(obj, options);
			}
			if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object.has(0)) {
				if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
				getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
					objectId: v.id.href,
					parentObjectId: this.id.href
				});
				continue;
			}
			yield v;
		}
	}
	async #fetchRelationship(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#relationship_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #relationship_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Object$1.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Object"].join(", "));
	}
	/**
	* Similar to
	* {@link Relationship.getRelationship},
	* but returns its `@id` URL instead of the object itself.
	*/
	get relationshipId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship.length < 1) return null;
		const v = this.#_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** On a {@link Relationship} object, the {@link Relationship.relationship}
	* property identifies the kind of relationship that exists between
	* {@link Relationship.subject} and {@link Relationship.object}.
	*/
	async getRelationship(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship.length < 1) return null;
		let v = this.#_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchRelationship(v, options);
			if (fetched == null) return null;
			this.#_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship[0] = fetched;
			this.#_trust_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "relationship" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["relationship"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#relationship_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	/**
	* Similar to
	* {@link Relationship.getRelationships},
	* but returns their `@id`s instead of the objects themselves.
	*/
	get relationshipIds() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		return this.#_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
	}
	/** On a {@link Relationship} object, the {@link Relationship.relationship}
	* property identifies the kind of relationship that exists between
	* {@link Relationship.subject} and {@link Relationship.object}.
	*/
	async *getRelationships(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		const vs = this.#_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship;
		for (let i = 0; i < vs.length; i++) {
			let v = vs[i];
			if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship.has(i)) v = v.id;
			if (v instanceof URL) {
				const fetched = await this.#fetchRelationship(v, options);
				if (fetched == null) continue;
				vs[i] = fetched;
				this.#_trust_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship.add(i);
				this._cachedJsonLd = void 0;
				yield fetched;
				continue;
			}
			if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "relationship" in this._cachedJsonLd) {
				const prop = this._cachedJsonLd["relationship"];
				const obj = Array.isArray(prop) ? prop[i] : prop;
				if (obj != null && typeof obj === "object" && "@context" in obj) v = await this.#relationship_fromJsonLd(obj, options);
			}
			if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship.has(0)) {
				if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
				getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
					objectId: v.id.href,
					parentObjectId: this.id.href
				});
				continue;
			}
			yield v;
		}
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		if (options.format == null && this.isCompactable()) {
			const result = await super.toJsonLd({
				...options,
				format: void 0,
				context: void 0
			});
			let compactItems;
			compactItems = [];
			for (const v of this.#_2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["subject"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["object"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["relationship"] = compactItems.length > 1 ? compactItems : compactItems[0];
			result["type"] = "Relationship";
			if (this.id != null) result["id"] = this.id.href;
			result["@context"] = ["https://www.w3.org/ns/activitystreams", "https://w3id.org/security/data-integrity/v1"];
			return result;
		}
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		array = [];
		for (const v of this.#_2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#subject"] = propValue;
		}
		array = [];
		for (const v of this.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#object"] = propValue;
		}
		array = [];
		for (const v of this.#_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#relationship"] = propValue;
		}
		values["@type"] = ["https://www.w3.org/ns/activitystreams#Relationship"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? ["https://www.w3.org/ns/activitystreams", "https://w3id.org/security/data-integrity/v1"];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {
			if ("proof" in compacted && compacted.proof != null) if (Array.isArray(compacted.proof)) for (const element of compacted.proof) element["@context"] = docContext;
			else compacted.proof["@context"] = docContext;
		}
		return compacted;
	}
	isCompactable() {
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__Relationship__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__Relationship__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Relationship")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof Relationship)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		const _2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject = [];
		const _trust_2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject = /* @__PURE__ */ new Set();
		let _2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject__array = values["https://www.w3.org/ns/activitystreams#subject"];
		for (const v of _2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject__array == null ? [] : _2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject__array.length === 1 && "@list" in _2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject__array[0] ? _2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject__array[0]["@list"] : _2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject.push(await Object$1.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject = _2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject;
		const _2MH19yxjn1wnHsNfa5n4JBhJzxyc_object = [];
		const _trust_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object = /* @__PURE__ */ new Set();
		let _2MH19yxjn1wnHsNfa5n4JBhJzxyc_object__array = values["https://www.w3.org/ns/activitystreams#object"];
		for (const v of _2MH19yxjn1wnHsNfa5n4JBhJzxyc_object__array == null ? [] : _2MH19yxjn1wnHsNfa5n4JBhJzxyc_object__array.length === 1 && "@list" in _2MH19yxjn1wnHsNfa5n4JBhJzxyc_object__array[0] ? _2MH19yxjn1wnHsNfa5n4JBhJzxyc_object__array[0]["@list"] : _2MH19yxjn1wnHsNfa5n4JBhJzxyc_object__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object.push(await Object$1.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object = _2MH19yxjn1wnHsNfa5n4JBhJzxyc_object;
		const _4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship = [];
		const _trust_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship = /* @__PURE__ */ new Set();
		let _4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship__array = values["https://www.w3.org/ns/activitystreams#relationship"];
		for (const v of _4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship__array == null ? [] : _4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship__array.length === 1 && "@list" in _4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship__array[0] ? _4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship__array[0]["@list"] : _4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship.push(await Object$1.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship = _4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship;
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		const _2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject = this.#_2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject.length == 1) proxy.subject = _2Zqdmi46ZnDQsECS6mzwhrv3rUKq_subject[0];
		const _2MH19yxjn1wnHsNfa5n4JBhJzxyc_object = this.#_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object.length == 1) proxy.object = _2MH19yxjn1wnHsNfa5n4JBhJzxyc_object[0];
		if (_2MH19yxjn1wnHsNfa5n4JBhJzxyc_object.length > 1 || !("object" in proxy) && _2MH19yxjn1wnHsNfa5n4JBhJzxyc_object.length > 0) proxy.objects = _2MH19yxjn1wnHsNfa5n4JBhJzxyc_object;
		const _4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship = this.#_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship.length == 1) proxy.relationship = _4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship[0];
		if (_4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship.length > 1 || !("relationship" in proxy) && _4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship.length > 0) proxy.relationships = _4Lzz89F9qipAQSGkWyX9DGWiUojG_relationship;
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "Relationship " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "Relationship " + inspect(proxy, options);
	}
};
/** Indicates that the `actor` is removing the `object`.  If specified,
* the `origin` indicates the context from which the `object` is being removed.
*/
var Remove = class Remove extends Activity {
	/**
	* The type URI of {@link Remove}: `https://www.w3.org/ns/activitystreams#Remove`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#Remove");
	}
	/**
	* Constructs a new instance of Remove with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		return clone;
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		values["@type"] = ["https://www.w3.org/ns/activitystreams#Remove"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? [
			"https://w3id.org/identity/v1",
			"https://www.w3.org/ns/activitystreams",
			"https://w3id.org/security/data-integrity/v1"
		];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {
			if ("proof" in compacted && compacted.proof != null) if (Array.isArray(compacted.proof)) for (const element of compacted.proof) element["@context"] = docContext;
			else compacted.proof["@context"] = docContext;
		}
		return compacted;
	}
	isCompactable() {
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__Remove__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__Remove__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Remove")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof Remove)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "Remove " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "Remove " + inspect(proxy, options);
	}
};
/** Represents a service of any kind.
*/
var Service = class Service extends Object$1 {
	/**
	* The type URI of {@link Service}: `https://www.w3.org/ns/activitystreams#Service`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#Service");
	}
	#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = [];
	#_axq166E2eZADq34V4MYUc8KMZdC_publicKey = [];
	#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey = /* @__PURE__ */ new Set();
	#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = [];
	#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = /* @__PURE__ */ new Set();
	#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = [];
	#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = [];
	#_trust_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = /* @__PURE__ */ new Set();
	#_41QwhqJouoLg3h8dRPKat21brynC_outbox = [];
	#_trust_41QwhqJouoLg3h8dRPKat21brynC_outbox = /* @__PURE__ */ new Set();
	#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = [];
	#_trust_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = /* @__PURE__ */ new Set();
	#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = [];
	#_trust_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = /* @__PURE__ */ new Set();
	#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = [];
	#_trust_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = /* @__PURE__ */ new Set();
	#_4N1vBJzXDf8NbBumeECQMFvKetja_featured = [];
	#_trust_4N1vBJzXDf8NbBumeECQMFvKetja_featured = /* @__PURE__ */ new Set();
	#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = [];
	#_trust_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = /* @__PURE__ */ new Set();
	#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = [];
	#_trust_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = /* @__PURE__ */ new Set();
	#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = [];
	#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = [];
	#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = [];
	#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = [];
	#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = [];
	#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = [];
	#_trust_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = /* @__PURE__ */ new Set();
	#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = [];
	#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = /* @__PURE__ */ new Set();
	#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = [];
	#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = /* @__PURE__ */ new Set();
	#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = [];
	#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat = [];
	/**
	* Constructs a new instance of Service with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
		if ("preferredUsername" in values && values.preferredUsername != null) if (typeof values.preferredUsername === "string" || values.preferredUsername instanceof LanguageString) this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = [values.preferredUsername];
		else throw new TypeError("The preferredUsername must be of type string | LanguageString.");
		if ("preferredUsernames" in values && values.preferredUsernames != null) {
			if ("preferredUsername" in values && values.preferredUsername != null) throw new TypeError("Cannot initialize both preferredUsername and preferredUsernames at the same time.");
			if (Array.isArray(values.preferredUsernames) && values.preferredUsernames.every((v) => typeof v === "string" || v instanceof LanguageString)) this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = values.preferredUsernames;
			else throw new TypeError("The preferredUsernames must be an array of type string | LanguageString.");
		}
		if ("publicKey" in values && values.publicKey != null) if (values.publicKey instanceof CryptographicKey || values.publicKey instanceof URL) {
			this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey = [values.publicKey];
			this.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey.add(0);
		} else throw new TypeError("The publicKey must be of type CryptographicKey | URL.");
		if ("publicKeys" in values && values.publicKeys != null) {
			if ("publicKey" in values && values.publicKey != null) throw new TypeError("Cannot initialize both publicKey and publicKeys at the same time.");
			if (Array.isArray(values.publicKeys) && values.publicKeys.every((v) => v instanceof CryptographicKey || v instanceof URL)) {
				this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey = values.publicKeys;
				for (let i = 0; i < values.publicKeys.length; i++) this.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey.add(i);
			} else throw new TypeError("The publicKeys must be an array of type CryptographicKey | URL.");
		}
		if ("assertionMethod" in values && values.assertionMethod != null) if (values.assertionMethod instanceof Multikey || values.assertionMethod instanceof URL) {
			this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = [values.assertionMethod];
			this.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.add(0);
		} else throw new TypeError("The assertionMethod must be of type Multikey | URL.");
		if ("assertionMethods" in values && values.assertionMethods != null) {
			if ("assertionMethod" in values && values.assertionMethod != null) throw new TypeError("Cannot initialize both assertionMethod and assertionMethods at the same time.");
			if (Array.isArray(values.assertionMethods) && values.assertionMethods.every((v) => v instanceof Multikey || v instanceof URL)) {
				this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = values.assertionMethods;
				for (let i = 0; i < values.assertionMethods.length; i++) this.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.add(i);
			} else throw new TypeError("The assertionMethods must be an array of type Multikey | URL.");
		}
		if ("manuallyApprovesFollowers" in values && values.manuallyApprovesFollowers != null) if (typeof values.manuallyApprovesFollowers === "boolean") this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = [values.manuallyApprovesFollowers];
		else throw new TypeError("The manuallyApprovesFollowers must be of type boolean.");
		if ("inbox" in values && values.inbox != null) if (values.inbox instanceof OrderedCollection || values.inbox instanceof OrderedCollectionPage || values.inbox instanceof URL) {
			this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = [values.inbox];
			this.#_trust_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.add(0);
		} else throw new TypeError("The inbox must be of type OrderedCollection | OrderedCollectionPage | URL.");
		if ("outbox" in values && values.outbox != null) if (values.outbox instanceof OrderedCollection || values.outbox instanceof OrderedCollectionPage || values.outbox instanceof URL) {
			this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox = [values.outbox];
			this.#_trust_41QwhqJouoLg3h8dRPKat21brynC_outbox.add(0);
		} else throw new TypeError("The outbox must be of type OrderedCollection | OrderedCollectionPage | URL.");
		if ("following" in values && values.following != null) if (values.following instanceof Collection || values.following instanceof URL) {
			this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = [values.following];
			this.#_trust_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.add(0);
		} else throw new TypeError("The following must be of type Collection | URL.");
		if ("followers" in values && values.followers != null) if (values.followers instanceof Collection || values.followers instanceof URL) {
			this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = [values.followers];
			this.#_trust_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.add(0);
		} else throw new TypeError("The followers must be of type Collection | URL.");
		if ("liked" in values && values.liked != null) if (values.liked instanceof Collection || values.liked instanceof URL) {
			this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = [values.liked];
			this.#_trust_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.add(0);
		} else throw new TypeError("The liked must be of type Collection | URL.");
		if ("featured" in values && values.featured != null) if (values.featured instanceof Collection || values.featured instanceof URL) {
			this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured = [values.featured];
			this.#_trust_4N1vBJzXDf8NbBumeECQMFvKetja_featured.add(0);
		} else throw new TypeError("The featured must be of type Collection | URL.");
		if ("featuredTags" in values && values.featuredTags != null) if (values.featuredTags instanceof Collection || values.featuredTags instanceof URL) {
			this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = [values.featuredTags];
			this.#_trust_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.add(0);
		} else throw new TypeError("The featuredTags must be of type Collection | URL.");
		if ("streams" in values && values.streams != null) if (Array.isArray(values.streams) && values.streams.every((v) => v instanceof Collection || v instanceof URL)) {
			this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = values.streams;
			for (let i = 0; i < values.streams.length; i++) this.#_trust_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.add(i);
		} else throw new TypeError("The streams must be an array of type Collection | URL.");
		if ("endpoints" in values && values.endpoints != null) if (values.endpoints instanceof Endpoints) this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = [values.endpoints];
		else throw new TypeError("The endpoints must be of type Endpoints.");
		if ("discoverable" in values && values.discoverable != null) if (typeof values.discoverable === "boolean") this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = [values.discoverable];
		else throw new TypeError("The discoverable must be of type boolean.");
		if ("suspended" in values && values.suspended != null) if (typeof values.suspended === "boolean") this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = [values.suspended];
		else throw new TypeError("The suspended must be of type boolean.");
		if ("memorial" in values && values.memorial != null) if (typeof values.memorial === "boolean") this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = [values.memorial];
		else throw new TypeError("The memorial must be of type boolean.");
		if ("indexable" in values && values.indexable != null) if (typeof values.indexable === "boolean") this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = [values.indexable];
		else throw new TypeError("The indexable must be of type boolean.");
		if ("successor" in values && values.successor != null) if (values.successor instanceof Application || values.successor instanceof Group || values.successor instanceof Organization || values.successor instanceof Person || values.successor instanceof Service || values.successor instanceof URL) {
			this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = [values.successor];
			this.#_trust_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.add(0);
		} else throw new TypeError("The successor must be of type Application | Group | Organization | Person | Service | URL.");
		if ("alias" in values && values.alias != null) if (values.alias instanceof Application || values.alias instanceof Group || values.alias instanceof Organization || values.alias instanceof Person || values.alias instanceof Service || values.alias instanceof URL) {
			this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = [values.alias];
			this.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.add(0);
		} else throw new TypeError("The alias must be of type Application | Group | Organization | Person | Service | URL.");
		if ("aliases" in values && values.aliases != null) {
			if ("alias" in values && values.alias != null) throw new TypeError("Cannot initialize both alias and aliases at the same time.");
			if (Array.isArray(values.aliases) && values.aliases.every((v) => v instanceof Application || v instanceof Group || v instanceof Organization || v instanceof Person || v instanceof Service || v instanceof URL)) {
				this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = values.aliases;
				for (let i = 0; i < values.aliases.length; i++) this.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.add(i);
			} else throw new TypeError("The aliases must be an array of type Application | Group | Organization | Person | Service | URL.");
		}
		if ("service" in values && values.service != null) if (values.service instanceof DidService || values.service instanceof URL) {
			this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = [values.service];
			this.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.add(0);
		} else throw new TypeError("The service must be of type DidService | URL.");
		if ("services" in values && values.services != null) {
			if ("service" in values && values.service != null) throw new TypeError("Cannot initialize both service and services at the same time.");
			if (Array.isArray(values.services) && values.services.every((v) => v instanceof DidService || v instanceof URL)) {
				this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = values.services;
				for (let i = 0; i < values.services.length; i++) this.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.add(i);
			} else throw new TypeError("The services must be an array of type DidService | URL.");
		}
		if ("followedMessage" in values && values.followedMessage != null) if (typeof values.followedMessage === "string") this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = [values.followedMessage];
		else throw new TypeError("The followedMessage must be of type string.");
		if ("cat" in values && values.cat != null) if (typeof values.cat === "boolean") this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat = [values.cat];
		else throw new TypeError("The cat must be of type boolean.");
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		clone.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername;
		if ("preferredUsername" in values && values.preferredUsername != null) if (typeof values.preferredUsername === "string" || values.preferredUsername instanceof LanguageString) clone.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = [values.preferredUsername];
		else throw new TypeError("The preferredUsername must be of type string | LanguageString.");
		if ("preferredUsernames" in values && values.preferredUsernames != null) {
			if ("preferredUsername" in values && values.preferredUsername != null) throw new TypeError("Cannot update both preferredUsername and preferredUsernames at the same time.");
			if (Array.isArray(values.preferredUsernames) && values.preferredUsernames.every((v) => typeof v === "string" || v instanceof LanguageString)) clone.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = values.preferredUsernames;
			else throw new TypeError("The preferredUsernames must be an array of type string | LanguageString.");
		}
		clone.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey = this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey;
		clone.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey = new Set(this.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey);
		if ("publicKey" in values && values.publicKey != null) if (values.publicKey instanceof CryptographicKey || values.publicKey instanceof URL) {
			clone.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey = [values.publicKey];
			clone.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey = new Set([0]);
		} else throw new TypeError("The publicKey must be of type CryptographicKey | URL.");
		if ("publicKeys" in values && values.publicKeys != null) {
			if ("publicKey" in values && values.publicKey != null) throw new TypeError("Cannot update both publicKey and publicKeys at the same time.");
			if (Array.isArray(values.publicKeys) && values.publicKeys.every((v) => v instanceof CryptographicKey || v instanceof URL)) {
				clone.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey = values.publicKeys;
				clone.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey = /* @__PURE__ */ new Set();
				for (let i = 0; i < values.publicKeys.length; i++) clone.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey.add(i);
			} else throw new TypeError("The publicKeys must be an array of type CryptographicKey | URL.");
		}
		clone.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod;
		clone.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = new Set(this.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod);
		if ("assertionMethod" in values && values.assertionMethod != null) if (values.assertionMethod instanceof Multikey || values.assertionMethod instanceof URL) {
			clone.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = [values.assertionMethod];
			clone.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = new Set([0]);
		} else throw new TypeError("The assertionMethod must be of type Multikey | URL.");
		if ("assertionMethods" in values && values.assertionMethods != null) {
			if ("assertionMethod" in values && values.assertionMethod != null) throw new TypeError("Cannot update both assertionMethod and assertionMethods at the same time.");
			if (Array.isArray(values.assertionMethods) && values.assertionMethods.every((v) => v instanceof Multikey || v instanceof URL)) {
				clone.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = values.assertionMethods;
				clone.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = /* @__PURE__ */ new Set();
				for (let i = 0; i < values.assertionMethods.length; i++) clone.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.add(i);
			} else throw new TypeError("The assertionMethods must be an array of type Multikey | URL.");
		}
		clone.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers;
		if ("manuallyApprovesFollowers" in values && values.manuallyApprovesFollowers != null) if (typeof values.manuallyApprovesFollowers === "boolean") clone.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = [values.manuallyApprovesFollowers];
		else throw new TypeError("The manuallyApprovesFollowers must be of type boolean.");
		clone.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox;
		clone.#_trust_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = new Set(this.#_trust_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox);
		if ("inbox" in values && values.inbox != null) if (values.inbox instanceof OrderedCollection || values.inbox instanceof OrderedCollectionPage || values.inbox instanceof URL) {
			clone.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = [values.inbox];
			clone.#_trust_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = new Set([0]);
		} else throw new TypeError("The inbox must be of type OrderedCollection | OrderedCollectionPage | URL.");
		clone.#_41QwhqJouoLg3h8dRPKat21brynC_outbox = this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox;
		clone.#_trust_41QwhqJouoLg3h8dRPKat21brynC_outbox = new Set(this.#_trust_41QwhqJouoLg3h8dRPKat21brynC_outbox);
		if ("outbox" in values && values.outbox != null) if (values.outbox instanceof OrderedCollection || values.outbox instanceof OrderedCollectionPage || values.outbox instanceof URL) {
			clone.#_41QwhqJouoLg3h8dRPKat21brynC_outbox = [values.outbox];
			clone.#_trust_41QwhqJouoLg3h8dRPKat21brynC_outbox = new Set([0]);
		} else throw new TypeError("The outbox must be of type OrderedCollection | OrderedCollectionPage | URL.");
		clone.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following;
		clone.#_trust_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = new Set(this.#_trust_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following);
		if ("following" in values && values.following != null) if (values.following instanceof Collection || values.following instanceof URL) {
			clone.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = [values.following];
			clone.#_trust_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = new Set([0]);
		} else throw new TypeError("The following must be of type Collection | URL.");
		clone.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers;
		clone.#_trust_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = new Set(this.#_trust_BBCTgfphhsFzpVfKTykGSpBNwoA_followers);
		if ("followers" in values && values.followers != null) if (values.followers instanceof Collection || values.followers instanceof URL) {
			clone.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = [values.followers];
			clone.#_trust_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = new Set([0]);
		} else throw new TypeError("The followers must be of type Collection | URL.");
		clone.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked;
		clone.#_trust_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = new Set(this.#_trust_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked);
		if ("liked" in values && values.liked != null) if (values.liked instanceof Collection || values.liked instanceof URL) {
			clone.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = [values.liked];
			clone.#_trust_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = new Set([0]);
		} else throw new TypeError("The liked must be of type Collection | URL.");
		clone.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured = this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured;
		clone.#_trust_4N1vBJzXDf8NbBumeECQMFvKetja_featured = new Set(this.#_trust_4N1vBJzXDf8NbBumeECQMFvKetja_featured);
		if ("featured" in values && values.featured != null) if (values.featured instanceof Collection || values.featured instanceof URL) {
			clone.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured = [values.featured];
			clone.#_trust_4N1vBJzXDf8NbBumeECQMFvKetja_featured = new Set([0]);
		} else throw new TypeError("The featured must be of type Collection | URL.");
		clone.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags;
		clone.#_trust_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = new Set(this.#_trust_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags);
		if ("featuredTags" in values && values.featuredTags != null) if (values.featuredTags instanceof Collection || values.featuredTags instanceof URL) {
			clone.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = [values.featuredTags];
			clone.#_trust_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = new Set([0]);
		} else throw new TypeError("The featuredTags must be of type Collection | URL.");
		clone.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams;
		clone.#_trust_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = new Set(this.#_trust_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams);
		if ("streams" in values && values.streams != null) if (Array.isArray(values.streams) && values.streams.every((v) => v instanceof Collection || v instanceof URL)) {
			clone.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = values.streams;
			clone.#_trust_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = /* @__PURE__ */ new Set();
			for (let i = 0; i < values.streams.length; i++) clone.#_trust_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.add(i);
		} else throw new TypeError("The streams must be an array of type Collection | URL.");
		clone.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints;
		if ("endpoints" in values && values.endpoints != null) if (values.endpoints instanceof Endpoints) clone.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = [values.endpoints];
		else throw new TypeError("The endpoints must be of type Endpoints.");
		clone.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable;
		if ("discoverable" in values && values.discoverable != null) if (typeof values.discoverable === "boolean") clone.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = [values.discoverable];
		else throw new TypeError("The discoverable must be of type boolean.");
		clone.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended;
		if ("suspended" in values && values.suspended != null) if (typeof values.suspended === "boolean") clone.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = [values.suspended];
		else throw new TypeError("The suspended must be of type boolean.");
		clone.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial;
		if ("memorial" in values && values.memorial != null) if (typeof values.memorial === "boolean") clone.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = [values.memorial];
		else throw new TypeError("The memorial must be of type boolean.");
		clone.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable;
		if ("indexable" in values && values.indexable != null) if (typeof values.indexable === "boolean") clone.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = [values.indexable];
		else throw new TypeError("The indexable must be of type boolean.");
		clone.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo;
		clone.#_trust_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = new Set(this.#_trust_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo);
		if ("successor" in values && values.successor != null) if (values.successor instanceof Application || values.successor instanceof Group || values.successor instanceof Organization || values.successor instanceof Person || values.successor instanceof Service || values.successor instanceof URL) {
			clone.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = [values.successor];
			clone.#_trust_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = new Set([0]);
		} else throw new TypeError("The successor must be of type Application | Group | Organization | Person | Service | URL.");
		clone.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs;
		clone.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = new Set(this.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs);
		if ("alias" in values && values.alias != null) if (values.alias instanceof Application || values.alias instanceof Group || values.alias instanceof Organization || values.alias instanceof Person || values.alias instanceof Service || values.alias instanceof URL) {
			clone.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = [values.alias];
			clone.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = new Set([0]);
		} else throw new TypeError("The alias must be of type Application | Group | Organization | Person | Service | URL.");
		if ("aliases" in values && values.aliases != null) {
			if ("alias" in values && values.alias != null) throw new TypeError("Cannot update both alias and aliases at the same time.");
			if (Array.isArray(values.aliases) && values.aliases.every((v) => v instanceof Application || v instanceof Group || v instanceof Organization || v instanceof Person || v instanceof Service || v instanceof URL)) {
				clone.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = values.aliases;
				clone.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = /* @__PURE__ */ new Set();
				for (let i = 0; i < values.aliases.length; i++) clone.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.add(i);
			} else throw new TypeError("The aliases must be an array of type Application | Group | Organization | Person | Service | URL.");
		}
		clone.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service;
		clone.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = new Set(this.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service);
		if ("service" in values && values.service != null) if (values.service instanceof DidService || values.service instanceof URL) {
			clone.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = [values.service];
			clone.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = new Set([0]);
		} else throw new TypeError("The service must be of type DidService | URL.");
		if ("services" in values && values.services != null) {
			if ("service" in values && values.service != null) throw new TypeError("Cannot update both service and services at the same time.");
			if (Array.isArray(values.services) && values.services.every((v) => v instanceof DidService || v instanceof URL)) {
				clone.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = values.services;
				clone.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = /* @__PURE__ */ new Set();
				for (let i = 0; i < values.services.length; i++) clone.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.add(i);
			} else throw new TypeError("The services must be an array of type DidService | URL.");
		}
		clone.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage;
		if ("followedMessage" in values && values.followedMessage != null) if (typeof values.followedMessage === "string") clone.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = [values.followedMessage];
		else throw new TypeError("The followedMessage must be of type string.");
		clone.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat = this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat;
		if ("cat" in values && values.cat != null) if (typeof values.cat === "boolean") clone.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat = [values.cat];
		else throw new TypeError("The cat must be of type boolean.");
		return clone;
	}
	/** A short username which may be used to refer to the actor,
	* with no uniqueness guarantees.
	*/
	get preferredUsername() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.length < 1) return null;
		return this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername[0];
	}
	/** A short username which may be used to refer to the actor,
	* with no uniqueness guarantees.
	*/
	get preferredUsernames() {
		return this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername;
	}
	async #fetchPublicKey(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#publicKey_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #publicKey_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await CryptographicKey.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://w3id.org/security#Key"].join(", "));
	}
	/**
	* Similar to
	* {@link Service.getPublicKey},
	* but returns its `@id` URL instead of the object itself.
	*/
	get publicKeyId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey.length < 1) return null;
		const v = this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** A public part of the key pair owned by this actor.
	*/
	async getPublicKey(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey.length < 1) return null;
		let v = this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchPublicKey(v, options);
			if (fetched == null) return null;
			this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey[0] = fetched;
			this.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "publicKey" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["publicKey"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#publicKey_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	/**
	* Similar to
	* {@link Service.getPublicKeys},
	* but returns their `@id`s instead of the objects themselves.
	*/
	get publicKeyIds() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		return this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
	}
	/** A public part of the key pair owned by this actor.
	*/
	async *getPublicKeys(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		const vs = this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey;
		for (let i = 0; i < vs.length; i++) {
			let v = vs[i];
			if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey.has(i)) v = v.id;
			if (v instanceof URL) {
				const fetched = await this.#fetchPublicKey(v, options);
				if (fetched == null) continue;
				vs[i] = fetched;
				this.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey.add(i);
				this._cachedJsonLd = void 0;
				yield fetched;
				continue;
			}
			if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "publicKey" in this._cachedJsonLd) {
				const prop = this._cachedJsonLd["publicKey"];
				const obj = Array.isArray(prop) ? prop[i] : prop;
				if (obj != null && typeof obj === "object" && "@context" in obj) v = await this.#publicKey_fromJsonLd(obj, options);
			}
			if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey.has(0)) {
				if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
				getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
					objectId: v.id.href,
					parentObjectId: this.id.href
				});
				continue;
			}
			yield v;
		}
	}
	async #fetchAssertionMethod(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#assertionMethod_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #assertionMethod_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Multikey.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://w3id.org/security#Multikey"].join(", "));
	}
	/**
	* Similar to
	* {@link Service.getAssertionMethod},
	* but returns its `@id` URL instead of the object itself.
	*/
	get assertionMethodId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.length < 1) return null;
		const v = this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** Represents this actor's public keys.  It serves as equivalent to
	* the `publicKeys` property, but is used for [FEP-521a] compliance.
	*
	* [FEP-521a]: https://w3id.org/fep/521a
	*/
	async getAssertionMethod(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.length < 1) return null;
		let v = this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchAssertionMethod(v, options);
			if (fetched == null) return null;
			this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod[0] = fetched;
			this.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "assertionMethod" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["assertionMethod"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#assertionMethod_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	/**
	* Similar to
	* {@link Service.getAssertionMethods},
	* but returns their `@id`s instead of the objects themselves.
	*/
	get assertionMethodIds() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		return this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
	}
	/** Represents this actor's public keys.  It serves as equivalent to
	* the `publicKeys` property, but is used for [FEP-521a] compliance.
	*
	* [FEP-521a]: https://w3id.org/fep/521a
	*/
	async *getAssertionMethods(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		const vs = this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod;
		for (let i = 0; i < vs.length; i++) {
			let v = vs[i];
			if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.has(i)) v = v.id;
			if (v instanceof URL) {
				const fetched = await this.#fetchAssertionMethod(v, options);
				if (fetched == null) continue;
				vs[i] = fetched;
				this.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.add(i);
				this._cachedJsonLd = void 0;
				yield fetched;
				continue;
			}
			if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "assertionMethod" in this._cachedJsonLd) {
				const prop = this._cachedJsonLd["assertionMethod"];
				const obj = Array.isArray(prop) ? prop[i] : prop;
				if (obj != null && typeof obj === "object" && "@context" in obj) v = await this.#assertionMethod_fromJsonLd(obj, options);
			}
			if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.has(0)) {
				if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
				getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
					objectId: v.id.href,
					parentObjectId: this.id.href
				});
				continue;
			}
			yield v;
		}
	}
	/** When `true`, conveys that for this actor, follow requests are not usually
	* automatically approved, but instead are examined by a person who may accept
	* or reject the request, at some time in the future.  Setting of `false`
	* conveys no information and may be ignored.  This information is typically
	* used to affect display of accounts, such as showing an account as private or
	* locked.
	*/
	get manuallyApprovesFollowers() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers.length < 1) return null;
		return this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers[0];
	}
	async #fetchInbox(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#inbox_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #inbox_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await OrderedCollection.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await OrderedCollectionPage.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#OrderedCollection", "https://www.w3.org/ns/activitystreams#OrderedCollectionPage"].join(", "));
	}
	/**
	* Similar to
	* {@link Service.getInbox},
	* but returns its `@id` URL instead of the object itself.
	*/
	get inboxId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.length < 1) return null;
		const v = this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** The inbox stream contains all activities received by the actor.  The server
	* SHOULD filter content according to the requester's permission.  In general,
	* the owner of an inbox is likely to be able to access all of their inbox
	* contents.  Depending on access control, some other content may be public,
	* whereas other content may require authentication for non-owner users,
	* if they can access the inbox at all.
	*
	* The server MUST perform de-duplication of activities returned by the inbox.
	* Duplication can occur if an activity is addressed both to an actor's
	* followers, and a specific actor who also follows the recipient actor,
	* and the server has failed to de-duplicate the recipients list.
	* Such deduplication MUST be performed by comparing the `id` of the activities
	* and dropping any activities already seen.
	*/
	async getInbox(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.length < 1) return null;
		let v = this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchInbox(v, options);
			if (fetched == null) return null;
			this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox[0] = fetched;
			this.#_trust_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "inbox" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["inbox"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#inbox_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchOutbox(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#outbox_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #outbox_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await OrderedCollection.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await OrderedCollectionPage.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#OrderedCollection", "https://www.w3.org/ns/activitystreams#OrderedCollectionPage"].join(", "));
	}
	/**
	* Similar to
	* {@link Service.getOutbox},
	* but returns its `@id` URL instead of the object itself.
	*/
	get outboxId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox.length < 1) return null;
		const v = this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** The outbox stream contains activities the user has published,
	* subject to the ability of the requestor to retrieve the activity
	* (that is, the contents of the outbox are filtered by the permissions of
	* the person reading it).  If a user submits a request without
	* [Authorization](https://www.w3.org/TR/activitypub/#authorization)
	* the server should respond with all of the
	* [Public](https://www.w3.org/TR/activitypub/#public-addressing) posts.
	* This could potentially be all relevant objects published by the user,
	* though the number of available items is left to the discretion of those
	* implementing and deploying the server.
	*/
	async getOutbox(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox.length < 1) return null;
		let v = this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_41QwhqJouoLg3h8dRPKat21brynC_outbox.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchOutbox(v, options);
			if (fetched == null) return null;
			this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox[0] = fetched;
			this.#_trust_41QwhqJouoLg3h8dRPKat21brynC_outbox.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "outbox" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["outbox"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#outbox_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_41QwhqJouoLg3h8dRPKat21brynC_outbox.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchFollowing(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#following_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #following_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Collection.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
	}
	/**
	* Similar to
	* {@link Service.getFollowing},
	* but returns its `@id` URL instead of the object itself.
	*/
	get followingId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.length < 1) return null;
		const v = this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** This is a list of everybody that the actor has followed, added as a
	* [side effect](https://www.w3.org/TR/activitypub/#follow-activity-outbox).
	* The `following` collection MUST be either an {@link OrderedCollection}
	* or a {@link Collection} and MAY be filtered on privileges of
	* an authenticated user or as appropriate when no authentication is given.
	*/
	async getFollowing(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.length < 1) return null;
		let v = this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchFollowing(v, options);
			if (fetched == null) return null;
			this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following[0] = fetched;
			this.#_trust_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "following" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["following"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#following_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchFollowers(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#followers_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #followers_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Collection.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
	}
	/**
	* Similar to
	* {@link Service.getFollowers},
	* but returns its `@id` URL instead of the object itself.
	*/
	get followersId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.length < 1) return null;
		const v = this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** This is a list of everyone who has sent a {@link Follow} activity
	* for the actor, added as a
	* [side effect](https://www.w3.org/TR/activitypub/#follow-activity-outbox).
	* This is where one would find a list of all the actors that are following
	* the actor.  The `followers` collection MUST be either
	* an {@link OrderedCollection} or a {@link Collection} and MAY be filtered on
	* privileges of an authenticated user or as appropriate when no authentication
	* is given.
	*/
	async getFollowers(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.length < 1) return null;
		let v = this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchFollowers(v, options);
			if (fetched == null) return null;
			this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers[0] = fetched;
			this.#_trust_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "followers" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["followers"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#followers_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchLiked(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#liked_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #liked_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Collection.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
	}
	/**
	* Similar to
	* {@link Service.getLiked},
	* but returns its `@id` URL instead of the object itself.
	*/
	get likedId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.length < 1) return null;
		const v = this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** This is a list of every object from all of the actor's {@link Like}
	* activities, added as a
	* [side effect](https://www.w3.org/TR/activitypub/#like-activity-outbox).
	* The `liked` collection MUST be either an {@link OrderedCollection} or
	* a {@link Collection} and MAY be filtered on privileges of an authenticated
	* user or as appropriate when no authentication is given.
	*/
	async getLiked(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.length < 1) return null;
		let v = this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchLiked(v, options);
			if (fetched == null) return null;
			this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked[0] = fetched;
			this.#_trust_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "liked" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["liked"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#liked_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchFeatured(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#featured_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #featured_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Collection.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
	}
	/**
	* Similar to
	* {@link Service.getFeatured},
	* but returns its `@id` URL instead of the object itself.
	*/
	get featuredId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured.length < 1) return null;
		const v = this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** What is known in Mastodon as "pinned statuses", or statuses that are always
	* featured at the top of people's profiles, is implemented using an extra
	* property `featured` on the actor object that points to a {@link Collection}
	* of objects.
	*/
	async getFeatured(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured.length < 1) return null;
		let v = this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_4N1vBJzXDf8NbBumeECQMFvKetja_featured.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchFeatured(v, options);
			if (fetched == null) return null;
			this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured[0] = fetched;
			this.#_trust_4N1vBJzXDf8NbBumeECQMFvKetja_featured.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "featured" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["featured"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#featured_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_4N1vBJzXDf8NbBumeECQMFvKetja_featured.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchFeaturedTags(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#featuredTags_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #featuredTags_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Collection.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
	}
	/**
	* Similar to
	* {@link Service.getFeaturedTags},
	* but returns its `@id` URL instead of the object itself.
	*/
	get featuredTagsId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.length < 1) return null;
		const v = this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** What is known in Mastodon as "featured hashtags", hashtags that are featured
	* at people's profiles, is implemented using an extra property `featuredTags`
	* on the actor object that points to a {@link Collection} of {@link Hashtag}
	* objects specifically.
	*/
	async getFeaturedTags(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.length < 1) return null;
		let v = this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchFeaturedTags(v, options);
			if (fetched == null) return null;
			this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags[0] = fetched;
			this.#_trust_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "featuredTags" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["featuredTags"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#featuredTags_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchStream(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#stream_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #stream_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Collection.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/activitystreams#Collection"].join(", "));
	}
	/**
	* Similar to
	* {@link Service.getStreams},
	* but returns their `@id`s instead of the objects themselves.
	*/
	get streamIds() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		return this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
	}
	/** A list of supplementary Collections which may be of interest.
	*/
	async *getStreams(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		const vs = this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams;
		for (let i = 0; i < vs.length; i++) {
			let v = vs[i];
			if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.has(i)) v = v.id;
			if (v instanceof URL) {
				const fetched = await this.#fetchStream(v, options);
				if (fetched == null) continue;
				vs[i] = fetched;
				this.#_trust_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.add(i);
				this._cachedJsonLd = void 0;
				yield fetched;
				continue;
			}
			if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "streams" in this._cachedJsonLd) {
				const prop = this._cachedJsonLd["streams"];
				const obj = Array.isArray(prop) ? prop[i] : prop;
				if (obj != null && typeof obj === "object" && "@context" in obj) v = await this.#stream_fromJsonLd(obj, options);
			}
			if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.has(0)) {
				if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
				getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
					objectId: v.id.href,
					parentObjectId: this.id.href
				});
				continue;
			}
			yield v;
		}
	}
	/** A JSON object which maps additional (typically server/domain-wide) endpoints
	* which may be useful either for this actor or someone referencing this actor.
	* This mapping may be nested inside the actor document as the value or may be
	* a link to a JSON-LD document with these properties.
	*/
	get endpoints() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints.length < 1) return null;
		return this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints[0];
	}
	/** Allows users to opt-in or opt-out of discoverability features like
	* the profile directory.  This flag may also be used as an indicator of
	* the user's preferences toward being included in external discovery services,
	* such as search engines or other indexing tools.
	*/
	get discoverable() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable.length < 1) return null;
		return this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable[0];
	}
	/** Reports whether a user was locally suspended, for better handling of
	* these accounts.
	*/
	get suspended() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended.length < 1) return null;
		return this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended[0];
	}
	/** Whether the actor is in-memorial state.
	*/
	get memorial() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial.length < 1) return null;
		return this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial[0];
	}
	/** Whether the actor allows to be indexed.
	*/
	get indexable() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable.length < 1) return null;
		return this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable[0];
	}
	async #fetchSuccessor(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#successor_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #successor_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Application.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Group.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Organization.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Person.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Service.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + [
			"https://www.w3.org/ns/activitystreams#Application",
			"https://www.w3.org/ns/activitystreams#Group",
			"https://www.w3.org/ns/activitystreams#Organization",
			"https://www.w3.org/ns/activitystreams#Person",
			"https://www.w3.org/ns/activitystreams#Service"
		].join(", "));
	}
	/**
	* Similar to
	* {@link Service.getSuccessor},
	* but returns its `@id` URL instead of the object itself.
	*/
	get successorId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.length < 1) return null;
		const v = this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** Signifies that an actor has been moved to a different ID. Used in Mastodon-style data portability with the {@link Move} activity; see [ActivityPub Data Portability/Move Action](https://swicg.github.io/activitypub-data-portability/#move-action) for more details.
	*/
	async getSuccessor(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.length < 1) return null;
		let v = this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchSuccessor(v, options);
			if (fetched == null) return null;
			this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo[0] = fetched;
			this.#_trust_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "movedTo" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["movedTo"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#successor_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	async #fetchAlias(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#alias_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #alias_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await Application.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Group.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Organization.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Person.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		try {
			return await Service.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + [
			"https://www.w3.org/ns/activitystreams#Application",
			"https://www.w3.org/ns/activitystreams#Group",
			"https://www.w3.org/ns/activitystreams#Organization",
			"https://www.w3.org/ns/activitystreams#Person",
			"https://www.w3.org/ns/activitystreams#Service"
		].join(", "));
	}
	/**
	* Similar to
	* {@link Service.getAlias},
	* but returns its `@id` URL instead of the object itself.
	*/
	get aliasId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.length < 1) return null;
		const v = this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** The `aliases` (`alsoKnownAs`) property is used to specify alternative names
	* or aliases for an entity.  It can be used to provide additional identifiers
	* or labels for an entity, which can be useful in scenarios where an entity
	* may have multiple names or aliases.
	*/
	async getAlias(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.length < 1) return null;
		let v = this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchAlias(v, options);
			if (fetched == null) return null;
			this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs[0] = fetched;
			this.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "alsoKnownAs" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["alsoKnownAs"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#alias_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	/**
	* Similar to
	* {@link Service.getAliases},
	* but returns their `@id`s instead of the objects themselves.
	*/
	get aliasIds() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		return this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
	}
	/** The `aliases` (`alsoKnownAs`) property is used to specify alternative names
	* or aliases for an entity.  It can be used to provide additional identifiers
	* or labels for an entity, which can be useful in scenarios where an entity
	* may have multiple names or aliases.
	*/
	async *getAliases(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		const vs = this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs;
		for (let i = 0; i < vs.length; i++) {
			let v = vs[i];
			if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.has(i)) v = v.id;
			if (v instanceof URL) {
				const fetched = await this.#fetchAlias(v, options);
				if (fetched == null) continue;
				vs[i] = fetched;
				this.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.add(i);
				this._cachedJsonLd = void 0;
				yield fetched;
				continue;
			}
			if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "alsoKnownAs" in this._cachedJsonLd) {
				const prop = this._cachedJsonLd["alsoKnownAs"];
				const obj = Array.isArray(prop) ? prop[i] : prop;
				if (obj != null && typeof obj === "object" && "@context" in obj) v = await this.#alias_fromJsonLd(obj, options);
			}
			if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.has(0)) {
				if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
				getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
					objectId: v.id.href,
					parentObjectId: this.id.href
				});
				continue;
			}
			yield v;
		}
	}
	async #fetchService(url, options = {}) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.lookup_object", async (span) => {
			let fetchResult;
			try {
				fetchResult = await documentLoader(url.href);
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				span.end();
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to fetch {url}: {error}", {
						error,
						url: url.href
					});
					return null;
				}
				throw error;
			}
			const { document, documentUrl } = fetchResult;
			const baseUrl = new URL(documentUrl);
			try {
				const obj = await this.#service_fromJsonLd(document, {
					documentLoader,
					contextLoader,
					tracerProvider,
					baseUrl
				});
				if (options.crossOrigin !== "trust" && obj?.id != null && obj.id.origin !== baseUrl.origin) {
					if (options.crossOrigin === "throw") throw new Error("The object's @id (" + obj.id.href + ") has a different origin than the document URL (" + baseUrl.href + "); refusing to return the object.  If you want to bypass this check and are aware ofthe security implications, set the crossOrigin option to \"trust\".");
					getLogger(["fedify", "vocab"]).warn("The object's @id ({objectId}) has a different origin than the document URL ({documentUrl}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
						...fetchResult,
						objectId: obj.id.href
					});
					return null;
				}
				span.setAttribute("activitypub.object.id", (obj.id ?? url).href);
				span.setAttribute("activitypub.object.type", obj.constructor.typeId.href);
				return obj;
			} catch (e) {
				if (options.suppressError) {
					getLogger(["fedify", "vocab"]).error("Failed to parse {url}: {error}", {
						error: e,
						url: url.href
					});
					return null;
				}
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(e)
				});
				throw e;
			} finally {
				span.end();
			}
		});
	}
	async #service_fromJsonLd(jsonLd, options) {
		const documentLoader = options.documentLoader ?? this._documentLoader ?? getDocumentLoader();
		const contextLoader = options.contextLoader ?? this._contextLoader ?? getDocumentLoader();
		const tracerProvider = options.tracerProvider ?? this._tracerProvider ?? trace.getTracerProvider();
		const baseUrl = options.baseUrl;
		try {
			return await DidService.fromJsonLd(jsonLd, {
				documentLoader,
				contextLoader,
				tracerProvider,
				baseUrl
			});
		} catch (e) {
			if (!(e instanceof TypeError)) throw e;
		}
		throw new TypeError("Expected an object of any type of: " + ["https://www.w3.org/ns/did#Service"].join(", "));
	}
	/**
	* Similar to
	* {@link Service.getService},
	* but returns its `@id` URL instead of the object itself.
	*/
	get serviceId() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length < 1) return null;
		const v = this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service[0];
		if (v instanceof URL) return v;
		return v.id;
	}
	/** Means of communicating or interacting with the DID subject or associated
	* entities via one or more service endpoints. Examples include discovery
	* services, agent services, social networking services, file storage services,
	* and verifiable credential repository services.
	*/
	async getService(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length < 1) return null;
		let v = this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service[0];
		if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.has(0)) v = v.id;
		if (v instanceof URL) {
			const fetched = await this.#fetchService(v, options);
			if (fetched == null) return null;
			this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service[0] = fetched;
			this.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.add(0);
			this._cachedJsonLd = void 0;
			return fetched;
		}
		if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "service" in this._cachedJsonLd) {
			const prop = this._cachedJsonLd["service"];
			const doc = Array.isArray(prop) ? prop[0] : prop;
			if (doc != null && typeof doc === "object" && "@context" in doc) v = await this.#service_fromJsonLd(doc, options);
		}
		if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.has(0)) {
			if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
			getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
				objectId: v.id.href,
				parentObjectId: this.id.href
			});
			return null;
		}
		return v;
	}
	/**
	* Similar to
	* {@link Service.getServices},
	* but returns their `@id`s instead of the objects themselves.
	*/
	get serviceIds() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		return this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.map((v) => v instanceof URL ? v : v.id).filter((id) => id !== null);
	}
	/** Means of communicating or interacting with the DID subject or associated
	* entities via one or more service endpoints. Examples include discovery
	* services, agent services, social networking services, file storage services,
	* and verifiable credential repository services.
	*/
	async *getServices(options = {}) {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		const vs = this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service;
		for (let i = 0; i < vs.length; i++) {
			let v = vs[i];
			if (options.crossOrigin !== "trust" && !(v instanceof URL) && v.id != null && v.id.origin !== this.id?.origin && !this.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.has(i)) v = v.id;
			if (v instanceof URL) {
				const fetched = await this.#fetchService(v, options);
				if (fetched == null) continue;
				vs[i] = fetched;
				this.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.add(i);
				this._cachedJsonLd = void 0;
				yield fetched;
				continue;
			}
			if (this._cachedJsonLd != null && typeof this._cachedJsonLd === "object" && "@context" in this._cachedJsonLd && "service" in this._cachedJsonLd) {
				const prop = this._cachedJsonLd["service"];
				const obj = Array.isArray(prop) ? prop[i] : prop;
				if (obj != null && typeof obj === "object" && "@context" in obj) v = await this.#service_fromJsonLd(obj, options);
			}
			if (options.crossOrigin !== "trust" && v?.id != null && this.id != null && v.id.origin !== this.id.origin && !this.#_trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.has(0)) {
				if (options.crossOrigin === "throw") throw new Error("The property object's @id (" + v.id.href + ") has a different origin than the property owner's @id (" + this.id.href + "); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".");
				getLogger(["fedify", "vocab"]).warn("The property object's @id ({objectId}) has a different origin than the property owner's @id ({parentObjectId}); refusing to return the object.  If you want to bypass this check and are aware of the security implications, set the crossOrigin option to \"trust\".", {
					objectId: v.id.href,
					parentObjectId: this.id.href
				});
				continue;
			}
			yield v;
		}
	}
	/** This value is used for `Actor` type objects to show message on followed.
	*/
	get followedMessage() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage.length < 1) return null;
		return this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage[0];
	}
	/** Used on actors to indicate that they in some way identify as a cat,
	* expressed as a boolean value. If this property is set to `true`,
	* displaying the actor or their notes will have some special effects
	* attached in some clients.
	*/
	get cat() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat.length < 1) return null;
		return this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat[0];
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		if (options.format == null && this.isCompactable()) {
			const result = await super.toJsonLd({
				...options,
				format: void 0,
				context: void 0
			});
			let compactItems;
			compactItems = [];
			for (const v of this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername) {
				const item = typeof v === "string" ? v : {
					"@value": v.toString(),
					"@language": v.language.compact()
				};
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["preferredUsername"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["publicKey"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["assertionMethod"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers) {
				const item = v;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["manuallyApprovesFollowers"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox) {
				const item = v instanceof URL ? v.href : v instanceof OrderedCollection ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["inbox"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox) {
				const item = v instanceof URL ? v.href : v instanceof OrderedCollection ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["outbox"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["following"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["followers"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["liked"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["featured"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["featuredTags"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["streams"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints) {
				const item = await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["endpoints"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable) {
				const item = v;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["discoverable"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended) {
				const item = v;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["suspended"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial) {
				const item = v;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["memorial"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable) {
				const item = v;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["indexable"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo) {
				const item = v instanceof URL ? v.href : v instanceof Application ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : v instanceof Group ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : v instanceof Organization ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : v instanceof Person ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["movedTo"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs) {
				const item = v instanceof URL ? v.href : v instanceof Application ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : v instanceof Group ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : v instanceof Organization ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : v instanceof Person ? await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				}) : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["alsoKnownAs"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service) {
				const item = v instanceof URL ? v.href : await v.toJsonLd({
					...options,
					format: void 0,
					context: void 0
				});
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["service"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage) {
				const item = v;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["_misskey_followedMessage"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat) {
				const item = v;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["isCat"] = compactItems.length > 1 ? compactItems : compactItems[0];
			result["type"] = "Service";
			if (this.id != null) result["id"] = this.id.href;
			result["@context"] = [
				"https://www.w3.org/ns/activitystreams",
				"https://w3id.org/security/v1",
				"https://w3id.org/security/data-integrity/v1",
				"https://www.w3.org/ns/did/v1",
				"https://w3id.org/security/multikey/v1",
				{
					"alsoKnownAs": {
						"@id": "as:alsoKnownAs",
						"@type": "@id"
					},
					"manuallyApprovesFollowers": "as:manuallyApprovesFollowers",
					"movedTo": {
						"@id": "as:movedTo",
						"@type": "@id"
					},
					"toot": "http://joinmastodon.org/ns#",
					"Emoji": "toot:Emoji",
					"featured": {
						"@id": "toot:featured",
						"@type": "@id"
					},
					"featuredTags": {
						"@id": "toot:featuredTags",
						"@type": "@id"
					},
					"discoverable": "toot:discoverable",
					"suspended": "toot:suspended",
					"memorial": "toot:memorial",
					"indexable": "toot:indexable",
					"schema": "http://schema.org#",
					"PropertyValue": "schema:PropertyValue",
					"value": "schema:value",
					"misskey": "https://misskey-hub.net/ns#",
					"_misskey_followedMessage": "misskey:_misskey_followedMessage",
					"isCat": "misskey:isCat"
				}
			];
			return result;
		}
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		array = [];
		for (const v of this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername) {
			const element = typeof v === "string" ? { "@value": v } : {
				"@value": v.toString(),
				"@language": v.language.compact()
			};
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#preferredUsername"] = propValue;
		}
		array = [];
		for (const v of this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://w3id.org/security#publicKey"] = propValue;
		}
		array = [];
		for (const v of this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://w3id.org/security#assertionMethod"] = propValue;
		}
		array = [];
		for (const v of this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers) {
			const element = { "@value": v };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#manuallyApprovesFollowers"] = propValue;
		}
		array = [];
		for (const v of this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox) {
			const element = v instanceof URL ? { "@id": v.href } : v instanceof OrderedCollection ? await v.toJsonLd(options) : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["http://www.w3.org/ns/ldp#inbox"] = propValue;
		}
		array = [];
		for (const v of this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox) {
			const element = v instanceof URL ? { "@id": v.href } : v instanceof OrderedCollection ? await v.toJsonLd(options) : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#outbox"] = propValue;
		}
		array = [];
		for (const v of this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#following"] = propValue;
		}
		array = [];
		for (const v of this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#followers"] = propValue;
		}
		array = [];
		for (const v of this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#liked"] = propValue;
		}
		array = [];
		for (const v of this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["http://joinmastodon.org/ns#featured"] = propValue;
		}
		array = [];
		for (const v of this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["http://joinmastodon.org/ns#featuredTags"] = propValue;
		}
		array = [];
		for (const v of this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#streams"] = propValue;
		}
		array = [];
		for (const v of this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints) {
			const element = await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#endpoints"] = propValue;
		}
		array = [];
		for (const v of this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable) {
			const element = { "@value": v };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["http://joinmastodon.org/ns#discoverable"] = propValue;
		}
		array = [];
		for (const v of this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended) {
			const element = { "@value": v };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["http://joinmastodon.org/ns#suspended"] = propValue;
		}
		array = [];
		for (const v of this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial) {
			const element = { "@value": v };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["http://joinmastodon.org/ns#memorial"] = propValue;
		}
		array = [];
		for (const v of this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable) {
			const element = { "@value": v };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["http://joinmastodon.org/ns#indexable"] = propValue;
		}
		array = [];
		for (const v of this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo) {
			const element = v instanceof URL ? { "@id": v.href } : v instanceof Application ? await v.toJsonLd(options) : v instanceof Group ? await v.toJsonLd(options) : v instanceof Organization ? await v.toJsonLd(options) : v instanceof Person ? await v.toJsonLd(options) : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#movedTo"] = propValue;
		}
		array = [];
		for (const v of this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs) {
			const element = v instanceof URL ? { "@id": v.href } : v instanceof Application ? await v.toJsonLd(options) : v instanceof Group ? await v.toJsonLd(options) : v instanceof Organization ? await v.toJsonLd(options) : v instanceof Person ? await v.toJsonLd(options) : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#alsoKnownAs"] = propValue;
		}
		array = [];
		for (const v of this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service) {
			const element = v instanceof URL ? { "@id": v.href } : await v.toJsonLd(options);
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/did#service"] = propValue;
		}
		array = [];
		for (const v of this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage) {
			const element = { "@value": v };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://misskey-hub.net/ns#_misskey_followedMessage"] = propValue;
		}
		array = [];
		for (const v of this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat) {
			const element = { "@value": v };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://misskey-hub.net/ns#isCat"] = propValue;
		}
		values["@type"] = ["https://www.w3.org/ns/activitystreams#Service"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? [
			"https://www.w3.org/ns/activitystreams",
			"https://w3id.org/security/v1",
			"https://w3id.org/security/data-integrity/v1",
			"https://www.w3.org/ns/did/v1",
			"https://w3id.org/security/multikey/v1",
			{
				"alsoKnownAs": {
					"@id": "as:alsoKnownAs",
					"@type": "@id"
				},
				"manuallyApprovesFollowers": "as:manuallyApprovesFollowers",
				"movedTo": {
					"@id": "as:movedTo",
					"@type": "@id"
				},
				"toot": "http://joinmastodon.org/ns#",
				"Emoji": "toot:Emoji",
				"featured": {
					"@id": "toot:featured",
					"@type": "@id"
				},
				"featuredTags": {
					"@id": "toot:featuredTags",
					"@type": "@id"
				},
				"discoverable": "toot:discoverable",
				"suspended": "toot:suspended",
				"memorial": "toot:memorial",
				"indexable": "toot:indexable",
				"schema": "http://schema.org#",
				"PropertyValue": "schema:PropertyValue",
				"value": "schema:value",
				"misskey": "https://misskey-hub.net/ns#",
				"_misskey_followedMessage": "misskey:_misskey_followedMessage",
				"isCat": "misskey:isCat"
			}
		];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {
			if ("proof" in compacted && compacted.proof != null) if (Array.isArray(compacted.proof)) for (const element of compacted.proof) element["@context"] = docContext;
			else compacted.proof["@context"] = docContext;
		}
		return compacted;
	}
	isCompactable() {
		if (this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername != null && this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.length > 0) return false;
		if (this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service != null && this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length > 0) return false;
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__Service__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__Service__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Service")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof Service)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		const _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = [];
		let _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array = values["https://www.w3.org/ns/activitystreams#preferredUsername"];
		for (const v of _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array == null ? [] : _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array.length === 1 && "@list" in _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array[0] ? _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array[0]["@list"] : _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername__array) {
			if (v == null) continue;
			const decoded = typeof v === "object" && "@value" in v && typeof v["@value"] === "string" && !("@language" in v) ? v["@value"] : typeof v === "object" && "@language" in v && "@value" in v && typeof v["@language"] === "string" && typeof v["@value"] === "string" ? new LanguageString(v["@value"], v["@language"]) : void 0;
			if (typeof decoded === "undefined") continue;
			_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.push(decoded);
		}
		instance.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername;
		const _axq166E2eZADq34V4MYUc8KMZdC_publicKey = [];
		const _trust_axq166E2eZADq34V4MYUc8KMZdC_publicKey = /* @__PURE__ */ new Set();
		let _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array = values["https://w3id.org/security#publicKey"];
		for (const v of _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array == null ? [] : _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array.length === 1 && "@list" in _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array[0] ? _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array[0]["@list"] : _axq166E2eZADq34V4MYUc8KMZdC_publicKey__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_axq166E2eZADq34V4MYUc8KMZdC_publicKey.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_axq166E2eZADq34V4MYUc8KMZdC_publicKey.push(await CryptographicKey.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey = _axq166E2eZADq34V4MYUc8KMZdC_publicKey;
		const _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = [];
		const _trust_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = /* @__PURE__ */ new Set();
		let _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array = values["https://w3id.org/security#assertionMethod"];
		for (const v of _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array == null ? [] : _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array.length === 1 && "@list" in _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array[0] ? _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array[0]["@list"] : _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.push(await Multikey.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod;
		const _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = [];
		let _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array = values["https://www.w3.org/ns/activitystreams#manuallyApprovesFollowers"];
		for (const v of _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array == null ? [] : _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array.length === 1 && "@list" in _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array[0] ? _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array[0]["@list"] : _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers__array) {
			if (v == null) continue;
			_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers.push(v["@value"]);
		}
		instance.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers;
		const _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = [];
		const _trust_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = /* @__PURE__ */ new Set();
		let _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array = values["http://www.w3.org/ns/ldp#inbox"];
		for (const v of _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array == null ? [] : _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array.length === 1 && "@list" in _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array[0] ? _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array[0]["@list"] : _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			const decoded = typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#OrderedCollection") ? await OrderedCollection.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#OrderedCollectionPage") ? await OrderedCollectionPage.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : void 0;
			if (typeof decoded === "undefined") continue;
			_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.push(decoded);
		}
		instance.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox;
		const _41QwhqJouoLg3h8dRPKat21brynC_outbox = [];
		const _trust_41QwhqJouoLg3h8dRPKat21brynC_outbox = /* @__PURE__ */ new Set();
		let _41QwhqJouoLg3h8dRPKat21brynC_outbox__array = values["https://www.w3.org/ns/activitystreams#outbox"];
		for (const v of _41QwhqJouoLg3h8dRPKat21brynC_outbox__array == null ? [] : _41QwhqJouoLg3h8dRPKat21brynC_outbox__array.length === 1 && "@list" in _41QwhqJouoLg3h8dRPKat21brynC_outbox__array[0] ? _41QwhqJouoLg3h8dRPKat21brynC_outbox__array[0]["@list"] : _41QwhqJouoLg3h8dRPKat21brynC_outbox__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_41QwhqJouoLg3h8dRPKat21brynC_outbox.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			const decoded = typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#OrderedCollection") ? await OrderedCollection.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#OrderedCollectionPage") ? await OrderedCollectionPage.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : void 0;
			if (typeof decoded === "undefined") continue;
			_41QwhqJouoLg3h8dRPKat21brynC_outbox.push(decoded);
		}
		instance.#_41QwhqJouoLg3h8dRPKat21brynC_outbox = _41QwhqJouoLg3h8dRPKat21brynC_outbox;
		const _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = [];
		const _trust_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = /* @__PURE__ */ new Set();
		let _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array = values["https://www.w3.org/ns/activitystreams#following"];
		for (const v of _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array == null ? [] : _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array.length === 1 && "@list" in _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array[0] ? _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array[0]["@list"] : _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.push(await Collection.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following;
		const _BBCTgfphhsFzpVfKTykGSpBNwoA_followers = [];
		const _trust_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = /* @__PURE__ */ new Set();
		let _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array = values["https://www.w3.org/ns/activitystreams#followers"];
		for (const v of _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array == null ? [] : _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array.length === 1 && "@list" in _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array[0] ? _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array[0]["@list"] : _BBCTgfphhsFzpVfKTykGSpBNwoA_followers__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.push(await Collection.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers = _BBCTgfphhsFzpVfKTykGSpBNwoA_followers;
		const _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = [];
		const _trust_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = /* @__PURE__ */ new Set();
		let _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array = values["https://www.w3.org/ns/activitystreams#liked"];
		for (const v of _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array == null ? [] : _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array.length === 1 && "@list" in _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array[0] ? _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array[0]["@list"] : _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.push(await Collection.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked;
		const _4N1vBJzXDf8NbBumeECQMFvKetja_featured = [];
		const _trust_4N1vBJzXDf8NbBumeECQMFvKetja_featured = /* @__PURE__ */ new Set();
		let _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array = values["http://joinmastodon.org/ns#featured"];
		for (const v of _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array == null ? [] : _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array.length === 1 && "@list" in _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array[0] ? _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array[0]["@list"] : _4N1vBJzXDf8NbBumeECQMFvKetja_featured__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_4N1vBJzXDf8NbBumeECQMFvKetja_featured.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_4N1vBJzXDf8NbBumeECQMFvKetja_featured.push(await Collection.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured = _4N1vBJzXDf8NbBumeECQMFvKetja_featured;
		const _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = [];
		const _trust_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = /* @__PURE__ */ new Set();
		let _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array = values["http://joinmastodon.org/ns#featuredTags"];
		for (const v of _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array == null ? [] : _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array.length === 1 && "@list" in _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array[0] ? _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array[0]["@list"] : _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.push(await Collection.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags;
		const _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = [];
		const _trust_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = /* @__PURE__ */ new Set();
		let _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array = values["https://www.w3.org/ns/activitystreams#streams"];
		for (const v of _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array == null ? [] : _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array.length === 1 && "@list" in _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array[0] ? _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array[0]["@list"] : _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.push(await Collection.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams;
		const _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = [];
		let _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array = values["https://www.w3.org/ns/activitystreams#endpoints"];
		for (const v of _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array == null ? [] : _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array.length === 1 && "@list" in _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array[0] ? _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array[0]["@list"] : _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints__array) {
			if (v == null) continue;
			_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints.push(await Endpoints.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints;
		const _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = [];
		let _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array = values["http://joinmastodon.org/ns#discoverable"];
		for (const v of _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array == null ? [] : _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array.length === 1 && "@list" in _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array[0] ? _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array[0]["@list"] : _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable__array) {
			if (v == null) continue;
			_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable.push(v["@value"]);
		}
		instance.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable;
		const _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = [];
		let _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array = values["http://joinmastodon.org/ns#suspended"];
		for (const v of _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array == null ? [] : _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array.length === 1 && "@list" in _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array[0] ? _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array[0]["@list"] : _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended__array) {
			if (v == null) continue;
			_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended.push(v["@value"]);
		}
		instance.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended;
		const _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = [];
		let _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array = values["http://joinmastodon.org/ns#memorial"];
		for (const v of _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array == null ? [] : _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array.length === 1 && "@list" in _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array[0] ? _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array[0]["@list"] : _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial__array) {
			if (v == null) continue;
			_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial.push(v["@value"]);
		}
		instance.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial;
		const _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = [];
		let _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array = values["http://joinmastodon.org/ns#indexable"];
		for (const v of _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array == null ? [] : _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array.length === 1 && "@list" in _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array[0] ? _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array[0]["@list"] : _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable__array) {
			if (v == null) continue;
			_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable.push(v["@value"]);
		}
		instance.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable;
		const _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = [];
		const _trust_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = /* @__PURE__ */ new Set();
		let _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array = values["https://www.w3.org/ns/activitystreams#movedTo"];
		for (const v of _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array == null ? [] : _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array.length === 1 && "@list" in _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array[0] ? _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array[0]["@list"] : _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			const decoded = typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Application") ? await Application.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Group") ? await Group.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Organization") ? await Organization.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Person") ? await Person.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Service") ? await Service.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : void 0;
			if (typeof decoded === "undefined") continue;
			_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.push(decoded);
		}
		instance.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo;
		const _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = [];
		const _trust_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = /* @__PURE__ */ new Set();
		let _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array = values["https://www.w3.org/ns/activitystreams#alsoKnownAs"];
		for (const v of _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array == null ? [] : _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array.length === 1 && "@list" in _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array[0] ? _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array[0]["@list"] : _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			const decoded = typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Application") ? await Application.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Group") ? await Group.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Organization") ? await Organization.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Person") ? await Person.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : typeof v === "object" && "@type" in v && Array.isArray(v["@type"]) && v["@type"].includes("https://www.w3.org/ns/activitystreams#Service") ? await Service.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}) : void 0;
			if (typeof decoded === "undefined") continue;
			_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.push(decoded);
		}
		instance.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs;
		const _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = [];
		const _trust_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = /* @__PURE__ */ new Set();
		let _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array = values["https://www.w3.org/ns/did#service"];
		for (const v of _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array == null ? [] : _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array.length === 1 && "@list" in _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array[0] ? _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array[0]["@list"] : _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service__array) {
			if (v == null) continue;
			if (typeof v === "object" && "@id" in v && !("@type" in v) && globalThis.Object.keys(v).length === 1) {
				_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.push(!URL.canParse(v["@id"]) && v["@id"].startsWith("at://") ? new URL("at://" + encodeURIComponent(v["@id"].substring(5))) : new URL(v["@id"]));
				continue;
			}
			_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.push(await DidService.fromJsonLd(v, {
				...options,
				baseUrl: values["@id"] == null ? options.baseUrl : new URL(values["@id"])
			}));
		}
		instance.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service;
		const _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = [];
		let _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array = values["https://misskey-hub.net/ns#_misskey_followedMessage"];
		for (const v of _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array == null ? [] : _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array.length === 1 && "@list" in _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array[0] ? _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array[0]["@list"] : _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage__array) {
			if (v == null) continue;
			_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage.push(v["@value"]);
		}
		instance.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage;
		const _2xEU4QtkC53RAun67T81Egqt9vmL_isCat = [];
		let _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array = values["https://misskey-hub.net/ns#isCat"];
		for (const v of _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array == null ? [] : _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array.length === 1 && "@list" in _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array[0] ? _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array[0]["@list"] : _2xEU4QtkC53RAun67T81Egqt9vmL_isCat__array) {
			if (v == null) continue;
			_2xEU4QtkC53RAun67T81Egqt9vmL_isCat.push(v["@value"]);
		}
		instance.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat = _2xEU4QtkC53RAun67T81Egqt9vmL_isCat;
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		const _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername = this.#_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.length == 1) proxy.preferredUsername = _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername[0];
		if (_3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.length > 1 || !("preferredUsername" in proxy) && _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername.length > 0) proxy.preferredUsernames = _3isuDgRAKSntq9XdbjiNxjwyPZAf_preferredUsername;
		const _axq166E2eZADq34V4MYUc8KMZdC_publicKey = this.#_axq166E2eZADq34V4MYUc8KMZdC_publicKey.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_axq166E2eZADq34V4MYUc8KMZdC_publicKey.length == 1) proxy.publicKey = _axq166E2eZADq34V4MYUc8KMZdC_publicKey[0];
		if (_axq166E2eZADq34V4MYUc8KMZdC_publicKey.length > 1 || !("publicKey" in proxy) && _axq166E2eZADq34V4MYUc8KMZdC_publicKey.length > 0) proxy.publicKeys = _axq166E2eZADq34V4MYUc8KMZdC_publicKey;
		const _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod = this.#_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.length == 1) proxy.assertionMethod = _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod[0];
		if (_4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.length > 1 || !("assertionMethod" in proxy) && _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod.length > 0) proxy.assertionMethods = _4EHQFWZSz1k1d4LmPrQiMba2GbP3_assertionMethod;
		const _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers = this.#_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers.length == 1) proxy.manuallyApprovesFollowers = _36QNc9MxfkKf6h8sEUQSHnV9NZA_manuallyApprovesFollowers[0];
		const _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox = this.#_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox.length == 1) proxy.inbox = _3ghX3VfZXXbLvhCRH7QJqpzLrXjB_inbox[0];
		const _41QwhqJouoLg3h8dRPKat21brynC_outbox = this.#_41QwhqJouoLg3h8dRPKat21brynC_outbox.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_41QwhqJouoLg3h8dRPKat21brynC_outbox.length == 1) proxy.outbox = _41QwhqJouoLg3h8dRPKat21brynC_outbox[0];
		const _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following = this.#_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3yAv8jymNfNuJUDuBzJ1NQhdbAee_following.length == 1) proxy.following = _3yAv8jymNfNuJUDuBzJ1NQhdbAee_following[0];
		const _BBCTgfphhsFzpVfKTykGSpBNwoA_followers = this.#_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_BBCTgfphhsFzpVfKTykGSpBNwoA_followers.length == 1) proxy.followers = _BBCTgfphhsFzpVfKTykGSpBNwoA_followers[0];
		const _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked = this.#_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3bgkPwJanyTCoVFM9ovRcus8tKkU_liked.length == 1) proxy.liked = _3bgkPwJanyTCoVFM9ovRcus8tKkU_liked[0];
		const _4N1vBJzXDf8NbBumeECQMFvKetja_featured = this.#_4N1vBJzXDf8NbBumeECQMFvKetja_featured.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_4N1vBJzXDf8NbBumeECQMFvKetja_featured.length == 1) proxy.featured = _4N1vBJzXDf8NbBumeECQMFvKetja_featured[0];
		const _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags = this.#_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags.length == 1) proxy.featuredTags = _2MxnRRLq9iPzx5CFq2NPrXdUDCac_featuredTags[0];
		const _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams = this.#_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.length > 1 || !("stream" in proxy) && _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams.length > 0) proxy.streams = _3sG2Hdwn9qzKGu9mpYkqakAMUkH9_streams;
		const _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints = this.#_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints.length == 1) proxy.endpoints = _sEoQwUbfk4hEfugzNQ2ZiDcLMkG_endpoints[0];
		const _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable = this.#_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable.length == 1) proxy.discoverable = _gAJzg1QDc4rcefFsUzGSYmyXvNH_discoverable[0];
		const _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended = this.#_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended.length == 1) proxy.suspended = _2kGKkJtoFWg8c18PaVSqj9NKP4t7_suspended[0];
		const _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial = this.#_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial.length == 1) proxy.memorial = _79S8K4f5J9MWUgCxziRyUe6PTHZ_memorial[0];
		const _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable = this.#_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_2diCorzqPGQQqftp6e4SrCEwEnyk_indexable.length == 1) proxy.indexable = _2diCorzqPGQQqftp6e4SrCEwEnyk_indexable[0];
		const _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo = this.#_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo.length == 1) proxy.successor = _2ZNWDhuNdSXBwEmrB5kwffdKGzok_movedTo[0];
		const _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs = this.#_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.length == 1) proxy.alias = _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs[0];
		if (_3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.length > 1 || !("alias" in proxy) && _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs.length > 0) proxy.aliases = _3NV7TGNhuABbryNjNi4wib4DgNpY_alsoKnownAs;
		const _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service = this.#_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length == 1) proxy.service = _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service[0];
		if (_4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length > 1 || !("service" in proxy) && _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service.length > 0) proxy.services = _4Q6NrKH6bazBGtxwG8vyG77ir7Tg_service;
		const _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage = this.#_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage.length == 1) proxy.followedMessage = _QuxorEK1txp7jGjq8BRQfTPvUwp__misskey_followedMessage[0];
		const _2xEU4QtkC53RAun67T81Egqt9vmL_isCat = this.#_2xEU4QtkC53RAun67T81Egqt9vmL_isCat.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_2xEU4QtkC53RAun67T81Egqt9vmL_isCat.length == 1) proxy.cat = _2xEU4QtkC53RAun67T81Egqt9vmL_isCat[0];
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "Service " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "Service " + inspect(proxy, options);
	}
};
/** Contents of {@link Object}'s `source`.
*/
var Source = class {
	#documentLoader;
	#contextLoader;
	#tracerProvider;
	#warning;
	#cachedJsonLd;
	id;
	get _documentLoader() {
		return this.#documentLoader;
	}
	get _contextLoader() {
		return this.#contextLoader;
	}
	get _tracerProvider() {
		return this.#tracerProvider;
	}
	get _warning() {
		return this.#warning;
	}
	get _cachedJsonLd() {
		return this.#cachedJsonLd;
	}
	set _cachedJsonLd(value) {
		this.#cachedJsonLd = value;
	}
	/**
	* The type URI of {@link Source}: `https://www.w3.org/ns/activitystreams#Source`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#Source");
	}
	#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content = [];
	#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType = [];
	/**
	* Constructs a new instance of Source with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		this.#documentLoader = options.documentLoader;
		this.#contextLoader = options.contextLoader;
		this.#tracerProvider = options.tracerProvider;
		if ("$warning" in options) this.#warning = options.$warning;
		if (values.id == null || values.id instanceof URL) this.id = values.id ?? null;
		else throw new TypeError("The id must be a URL.");
		if ("content" in values && values.content != null) if (typeof values.content === "string" || values.content instanceof LanguageString) this.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content = [values.content];
		else throw new TypeError("The content must be of type string | LanguageString.");
		if ("contents" in values && values.contents != null) {
			if ("content" in values && values.content != null) throw new TypeError("Cannot initialize both content and contents at the same time.");
			if (Array.isArray(values.contents) && values.contents.every((v) => typeof v === "string" || v instanceof LanguageString)) this.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content = values.contents;
			else throw new TypeError("The contents must be an array of type string | LanguageString.");
		}
		if ("mediaType" in values && values.mediaType != null) if (typeof values.mediaType === "string") this.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType = [values.mediaType];
		else throw new TypeError("The mediaType must be of type string.");
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = new this.constructor({ id: values.id ?? this.id }, options);
		clone.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content = this.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content;
		if ("content" in values && values.content != null) if (typeof values.content === "string" || values.content instanceof LanguageString) clone.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content = [values.content];
		else throw new TypeError("The content must be of type string | LanguageString.");
		if ("contents" in values && values.contents != null) {
			if ("content" in values && values.content != null) throw new TypeError("Cannot update both content and contents at the same time.");
			if (Array.isArray(values.contents) && values.contents.every((v) => typeof v === "string" || v instanceof LanguageString)) clone.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content = values.contents;
			else throw new TypeError("The contents must be an array of type string | LanguageString.");
		}
		clone.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType = this.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType;
		if ("mediaType" in values && values.mediaType != null) if (typeof values.mediaType === "string") clone.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType = [values.mediaType];
		else throw new TypeError("The mediaType must be of type string.");
		return clone;
	}
	/** The source content.
	*/
	get content() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content.length < 1) return null;
		return this.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content[0];
	}
	/** The source content.
	*/
	get contents() {
		return this.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content;
	}
	/** The MIME media type of the source content.
	*/
	get mediaType() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType.length < 1) return null;
		return this.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType[0];
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		if (options.format == null && this.isCompactable()) {
			const result = {};
			let compactItems;
			compactItems = [];
			for (const v of this.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content) {
				const item = typeof v === "string" ? v : {
					"@value": v.toString(),
					"@language": v.language.compact()
				};
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["content"] = compactItems.length > 1 ? compactItems : compactItems[0];
			compactItems = [];
			for (const v of this.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType) {
				const item = v;
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["mediaType"] = compactItems.length > 1 ? compactItems : compactItems[0];
			result["type"] = "as:Source";
			if (this.id != null) result["id"] = this.id.href;
			result["@context"] = "https://www.w3.org/ns/activitystreams";
			return result;
		}
		let array;
		const values = {};
		array = [];
		for (const v of this.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content) {
			const element = typeof v === "string" ? { "@value": v } : {
				"@value": v.toString(),
				"@language": v.language.compact()
			};
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#content"] = propValue;
		}
		array = [];
		for (const v of this.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType) {
			const element = { "@value": v };
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#mediaType"] = propValue;
		}
		values["@type"] = ["https://www.w3.org/ns/activitystreams#Source"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? "https://www.w3.org/ns/activitystreams";
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {}
		return compacted;
	}
	isCompactable() {
		if (this.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content != null && this.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content.length > 0) return false;
		return true;
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__Source__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__Source__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Source")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		const instance = new this({ id: "@id" in values ? new URL(values["@id"]) : void 0 }, options);
		const _4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content = [];
		let _4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content__array = values["https://www.w3.org/ns/activitystreams#content"];
		for (const v of _4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content__array == null ? [] : _4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content__array.length === 1 && "@list" in _4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content__array[0] ? _4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content__array[0]["@list"] : _4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content__array) {
			if (v == null) continue;
			const decoded = typeof v === "object" && "@value" in v && typeof v["@value"] === "string" && !("@language" in v) ? v["@value"] : typeof v === "object" && "@language" in v && "@value" in v && typeof v["@language"] === "string" && typeof v["@value"] === "string" ? new LanguageString(v["@value"], v["@language"]) : void 0;
			if (typeof decoded === "undefined") continue;
			_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content.push(decoded);
		}
		instance.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content = _4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content;
		const _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType = [];
		let _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType__array = values["https://www.w3.org/ns/activitystreams#mediaType"];
		for (const v of _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType__array == null ? [] : _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType__array.length === 1 && "@list" in _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType__array[0] ? _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType__array[0]["@list"] : _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType__array) {
			if (v == null) continue;
			_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType.push(v["@value"]);
		}
		instance.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType = _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType;
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = {};
		if (this.id != null) proxy.id = {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(this.id.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(this.id.href, options)
		};
		const _4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content = this.#_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content.length == 1) proxy.content = _4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content[0];
		if (_4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content.length > 1 || !("content" in proxy) && _4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content.length > 0) proxy.contents = _4HuuRSdSrXq8Jj2J9gcdYfoCzeuz_content;
		const _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType = this.#_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType.length == 1) proxy.mediaType = _3BLrzmscsjHCw8TF5BHRW9WkPnX8_mediaType[0];
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "Source " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "Source " + inspect(proxy, options);
	}
};
/** A specialization of {@link Accept} indicating that
* the acceptance is tentative.
*/
var TentativeAccept = class TentativeAccept extends Accept {
	/**
	* The type URI of {@link TentativeAccept}: `https://www.w3.org/ns/activitystreams#TentativeAccept`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#TentativeAccept");
	}
	/**
	* Constructs a new instance of TentativeAccept with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		return clone;
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		values["@type"] = ["https://www.w3.org/ns/activitystreams#TentativeAccept"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? [
			"https://w3id.org/identity/v1",
			"https://www.w3.org/ns/activitystreams",
			"https://w3id.org/security/data-integrity/v1"
		];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {
			if ("proof" in compacted && compacted.proof != null) if (Array.isArray(compacted.proof)) for (const element of compacted.proof) element["@context"] = docContext;
			else compacted.proof["@context"] = docContext;
		}
		return compacted;
	}
	isCompactable() {
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__TentativeAccept__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__TentativeAccept__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#TentativeAccept")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof TentativeAccept)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "TentativeAccept " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "TentativeAccept " + inspect(proxy, options);
	}
};
/** A specialization of {@link Reject} in which
* the rejection is considered tentative.
*/
var TentativeReject = class TentativeReject extends Reject {
	/**
	* The type URI of {@link TentativeReject}: `https://www.w3.org/ns/activitystreams#TentativeReject`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#TentativeReject");
	}
	/**
	* Constructs a new instance of TentativeReject with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		return clone;
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		values["@type"] = ["https://www.w3.org/ns/activitystreams#TentativeReject"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? [
			"https://w3id.org/identity/v1",
			"https://www.w3.org/ns/activitystreams",
			"https://w3id.org/security/data-integrity/v1"
		];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {
			if ("proof" in compacted && compacted.proof != null) if (Array.isArray(compacted.proof)) for (const element of compacted.proof) element["@context"] = docContext;
			else compacted.proof["@context"] = docContext;
		}
		return compacted;
	}
	isCompactable() {
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__TentativeReject__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__TentativeReject__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#TentativeReject")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof TentativeReject)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "TentativeReject " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "TentativeReject " + inspect(proxy, options);
	}
};
/** A `Tombstone` represents a content object that has been deleted.
* It can be used in {@link Collection}s to signify that there used to be
* an object at this position, but it has been deleted.
*/
var Tombstone = class Tombstone extends Object$1 {
	/**
	* The type URI of {@link Tombstone}: `https://www.w3.org/ns/activitystreams#Tombstone`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#Tombstone");
	}
	#_8g8g4LiVMhFTXskuDEqx4ascxUr_deleted = [];
	/**
	* Constructs a new instance of Tombstone with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
		if ("deleted" in values && values.deleted != null) if (values.deleted instanceof Temporal.Instant) this.#_8g8g4LiVMhFTXskuDEqx4ascxUr_deleted = [values.deleted];
		else throw new TypeError("The deleted must be of type Temporal.Instant.");
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		clone.#_8g8g4LiVMhFTXskuDEqx4ascxUr_deleted = this.#_8g8g4LiVMhFTXskuDEqx4ascxUr_deleted;
		if ("deleted" in values && values.deleted != null) if (values.deleted instanceof Temporal.Instant) clone.#_8g8g4LiVMhFTXskuDEqx4ascxUr_deleted = [values.deleted];
		else throw new TypeError("The deleted must be of type Temporal.Instant.");
		return clone;
	}
	/** On a `Tombstone` object, the `deleted` property is a timestamp for when
	* the object was deleted.
	*/
	get deleted() {
		if (this._warning != null) getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
		if (this.#_8g8g4LiVMhFTXskuDEqx4ascxUr_deleted.length < 1) return null;
		return this.#_8g8g4LiVMhFTXskuDEqx4ascxUr_deleted[0];
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		if (options.format == null && this.isCompactable()) {
			const result = await super.toJsonLd({
				...options,
				format: void 0,
				context: void 0
			});
			let compactItems;
			compactItems = [];
			for (const v of this.#_8g8g4LiVMhFTXskuDEqx4ascxUr_deleted) {
				const item = v.toString();
				compactItems.push(item);
			}
			if (compactItems.length > 0) result["deleted"] = compactItems.length > 1 ? compactItems : compactItems[0];
			result["type"] = "Tombstone";
			if (this.id != null) result["id"] = this.id.href;
			result["@context"] = ["https://www.w3.org/ns/activitystreams", "https://w3id.org/security/data-integrity/v1"];
			return result;
		}
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		array = [];
		for (const v of this.#_8g8g4LiVMhFTXskuDEqx4ascxUr_deleted) {
			const element = {
				"@type": "http://www.w3.org/2001/XMLSchema#dateTime",
				"@value": v.toString()
			};
			array.push(element);
		}
		if (array.length > 0) {
			const propValue = array;
			values["https://www.w3.org/ns/activitystreams#deleted"] = propValue;
		}
		values["@type"] = ["https://www.w3.org/ns/activitystreams#Tombstone"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? ["https://www.w3.org/ns/activitystreams", "https://w3id.org/security/data-integrity/v1"];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {
			if ("proof" in compacted && compacted.proof != null) if (Array.isArray(compacted.proof)) for (const element of compacted.proof) element["@context"] = docContext;
			else compacted.proof["@context"] = docContext;
		}
		return compacted;
	}
	isCompactable() {
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__Tombstone__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__Tombstone__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Tombstone")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof Tombstone)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		const _8g8g4LiVMhFTXskuDEqx4ascxUr_deleted = [];
		let _8g8g4LiVMhFTXskuDEqx4ascxUr_deleted__array = values["https://www.w3.org/ns/activitystreams#deleted"];
		for (const v of _8g8g4LiVMhFTXskuDEqx4ascxUr_deleted__array == null ? [] : _8g8g4LiVMhFTXskuDEqx4ascxUr_deleted__array.length === 1 && "@list" in _8g8g4LiVMhFTXskuDEqx4ascxUr_deleted__array[0] ? _8g8g4LiVMhFTXskuDEqx4ascxUr_deleted__array[0]["@list"] : _8g8g4LiVMhFTXskuDEqx4ascxUr_deleted__array) {
			if (v == null) continue;
			_8g8g4LiVMhFTXskuDEqx4ascxUr_deleted.push(Temporal.Instant.from(v["@value"].substring(19).match(/[Z+-]/) ? v["@value"] : v["@value"] + "Z"));
		}
		instance.#_8g8g4LiVMhFTXskuDEqx4ascxUr_deleted = _8g8g4LiVMhFTXskuDEqx4ascxUr_deleted;
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		const _8g8g4LiVMhFTXskuDEqx4ascxUr_deleted = this.#_8g8g4LiVMhFTXskuDEqx4ascxUr_deleted.map((v) => v instanceof URL ? {
			[Symbol.for("Deno.customInspect")]: (inspect, options) => "URL " + inspect(v.href, options),
			[Symbol.for("nodejs.util.inspect.custom")]: (_depth, options, inspect) => "URL " + inspect(v.href, options)
		} : v);
		if (_8g8g4LiVMhFTXskuDEqx4ascxUr_deleted.length == 1) proxy.deleted = _8g8g4LiVMhFTXskuDEqx4ascxUr_deleted[0];
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "Tombstone " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "Tombstone " + inspect(proxy, options);
	}
};
/** Indicates that the `actor` is traveling to `target` from `origin`.
* `Travel` is an `IntransitiveObject` whose `actor` specifies the direct object.
* If the `target` or `origin` are not specified,
* either can be determined by context.
*/
var Travel = class Travel extends IntransitiveActivity {
	/**
	* The type URI of {@link Travel}: `https://www.w3.org/ns/activitystreams#Travel`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#Travel");
	}
	/**
	* Constructs a new instance of Travel with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		return clone;
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		values["@type"] = ["https://www.w3.org/ns/activitystreams#Travel"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? [
			"https://w3id.org/identity/v1",
			"https://www.w3.org/ns/activitystreams",
			"https://w3id.org/security/data-integrity/v1"
		];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {
			if ("proof" in compacted && compacted.proof != null) if (Array.isArray(compacted.proof)) for (const element of compacted.proof) element["@context"] = docContext;
			else compacted.proof["@context"] = docContext;
		}
		return compacted;
	}
	isCompactable() {
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__Travel__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__Travel__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Travel")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof Travel)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "Travel " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "Travel " + inspect(proxy, options);
	}
};
/** Indicates that the `actor` is undoing the `object`.  In most cases,
* the `object` will be an {@link Activity} describing some previously performed
* action (for instance, a person may have previously "liked" an article but,
* for whatever reason, might choose to undo that like at some later point in
* time).
*
* The `target` and `origin` typically have no defined meaning.
*/
var Undo = class Undo extends Activity {
	/**
	* The type URI of {@link Undo}: `https://www.w3.org/ns/activitystreams#Undo`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#Undo");
	}
	/**
	* Constructs a new instance of Undo with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		return clone;
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		values["@type"] = ["https://www.w3.org/ns/activitystreams#Undo"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? [
			"https://w3id.org/identity/v1",
			"https://www.w3.org/ns/activitystreams",
			"https://w3id.org/security/v1",
			"https://w3id.org/security/data-integrity/v1",
			"https://www.w3.org/ns/did/v1",
			"https://w3id.org/security/multikey/v1",
			{
				"litepub": "http://litepub.social/ns#",
				"toot": "http://joinmastodon.org/ns#",
				"EmojiReact": "litepub:EmojiReact",
				"Emoji": "toot:Emoji"
			}
		];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {
			if ("proof" in compacted && compacted.proof != null) if (Array.isArray(compacted.proof)) for (const element of compacted.proof) element["@context"] = docContext;
			else compacted.proof["@context"] = docContext;
		}
		return compacted;
	}
	isCompactable() {
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__Undo__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__Undo__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Undo")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof Undo)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "Undo " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "Undo " + inspect(proxy, options);
	}
};
/** Indicates that the `actor` has updated the `object`.  Note, however,
* that this vocabulary does not define a mechanism for describing the actual
* set of modifications made to `object`.
*
* The `target` and `origin` typically have no defined meaning.
*/
var Update = class Update extends Activity {
	/**
	* The type URI of {@link Update}: `https://www.w3.org/ns/activitystreams#Update`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#Update");
	}
	/**
	* Constructs a new instance of Update with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		return clone;
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		values["@type"] = ["https://www.w3.org/ns/activitystreams#Update"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? [
			"https://w3id.org/identity/v1",
			"https://www.w3.org/ns/activitystreams",
			"https://w3id.org/security/v1",
			"https://w3id.org/security/data-integrity/v1",
			"https://www.w3.org/ns/did/v1",
			"https://w3id.org/security/multikey/v1",
			{
				"alsoKnownAs": {
					"@id": "as:alsoKnownAs",
					"@type": "@id"
				},
				"manuallyApprovesFollowers": "as:manuallyApprovesFollowers",
				"sensitive": "as:sensitive",
				"movedTo": {
					"@id": "as:movedTo",
					"@type": "@id"
				},
				"quoteUrl": "as:quoteUrl",
				"toot": "http://joinmastodon.org/ns#",
				"featured": {
					"@id": "toot:featured",
					"@type": "@id"
				},
				"featuredTags": {
					"@id": "toot:featuredTags",
					"@type": "@id"
				},
				"discoverable": "toot:discoverable",
				"suspended": "toot:suspended",
				"memorial": "toot:memorial",
				"indexable": "toot:indexable",
				"votersCount": {
					"@id": "toot:votersCount",
					"@type": "http://www.w3.org/2001/XMLSchema#nonNegativeInteger"
				},
				"Emoji": "toot:Emoji",
				"Hashtag": "as:Hashtag",
				"schema": "http://schema.org#",
				"PropertyValue": "schema:PropertyValue",
				"value": "schema:value",
				"ChatMessage": "http://litepub.social/ns#ChatMessage",
				"fedibird": "http://fedibird.com/ns#",
				"quoteUri": "fedibird:quoteUri",
				"misskey": "https://misskey-hub.net/ns#",
				"_misskey_quote": "misskey:_misskey_quote",
				"_misskey_followedMessage": "misskey:_misskey_followedMessage",
				"isCat": "misskey:isCat",
				"emojiReactions": {
					"@id": "fedibird:emojiReactions",
					"@type": "@id"
				}
			}
		];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {
			if ("proof" in compacted && compacted.proof != null) if (Array.isArray(compacted.proof)) for (const element of compacted.proof) element["@context"] = docContext;
			else compacted.proof["@context"] = docContext;
		}
		return compacted;
	}
	isCompactable() {
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__Update__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__Update__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Update")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof Update)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "Update " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "Update " + inspect(proxy, options);
	}
};
/** Represents a video document of any kind.
*/
var Video = class Video extends Document {
	/**
	* The type URI of {@link Video}: `https://www.w3.org/ns/activitystreams#Video`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#Video");
	}
	/**
	* Constructs a new instance of Video with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		return clone;
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		if (options.format == null && this.isCompactable()) {
			const result = await super.toJsonLd({
				...options,
				format: void 0,
				context: void 0
			});
			let compactItems;
			result["type"] = "Video";
			if (this.id != null) result["id"] = this.id.href;
			result["@context"] = ["https://www.w3.org/ns/activitystreams", "https://w3id.org/security/data-integrity/v1"];
			return result;
		}
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		values["@type"] = ["https://www.w3.org/ns/activitystreams#Video"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? ["https://www.w3.org/ns/activitystreams", "https://w3id.org/security/data-integrity/v1"];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {
			if ("proof" in compacted && compacted.proof != null) if (Array.isArray(compacted.proof)) for (const element of compacted.proof) element["@context"] = docContext;
			else compacted.proof["@context"] = docContext;
		}
		return compacted;
	}
	isCompactable() {
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__Video__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__Video__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#Video")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof Video)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "Video " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "Video " + inspect(proxy, options);
	}
};
/** Indicates that the `actor` has viewed the object.
*/
var View = class View extends Activity {
	/**
	* The type URI of {@link View}: `https://www.w3.org/ns/activitystreams#View`.
	*/
	static get typeId() {
		return new URL("https://www.w3.org/ns/activitystreams#View");
	}
	/**
	* Constructs a new instance of View with the given values.
	* @param values The values to initialize the instance with.
	* @param options The options to use for initialization.
	*/
	constructor(values, options = {}) {
		super(values, options);
	}
	/**
	* Clones this instance, optionally updating it with the given values.
	* @param values The values to update the clone with.
	* @options The options to use for cloning.
	* @returns The cloned instance.
	*/
	clone(values = {}, options = {}) {
		if (this._warning != null) {
			getLogger(this._warning.category).warn(this._warning.message, this._warning.values);
			options = {
				...options,
				$warning: this._warning
			};
		}
		const clone = super.clone(values, options);
		return clone;
	}
	/**
	* Converts this object to a JSON-LD structure.
	* @param options The options to use.
	*                - `format`: The format of the output: `compact` or
	`expand`.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `context`: The JSON-LD context to use.  Not applicable
	when `format` is set to `'expand'`.
	* @returns The JSON-LD representation of this object.
	*/
	async toJsonLd(options = {}) {
		if (options.format == null && this._cachedJsonLd != null) return this._cachedJsonLd;
		if (options.format !== "compact" && options.context != null) throw new TypeError("The context option can only be used when the format option is set to 'compact'.");
		options = {
			...options,
			contextLoader: options.contextLoader ?? getDocumentLoader()
		};
		let array;
		const baseValues = await super.toJsonLd({
			...options,
			format: "expand",
			context: void 0
		});
		const values = baseValues[0];
		values["@type"] = ["https://www.w3.org/ns/activitystreams#View"];
		if (this.id != null) values["@id"] = this.id.href;
		if (options.format === "expand") return await jsonld.expand(values, { documentLoader: options.contextLoader });
		const docContext = options.context ?? [
			"https://w3id.org/identity/v1",
			"https://www.w3.org/ns/activitystreams",
			"https://w3id.org/security/data-integrity/v1"
		];
		const compacted = await jsonld.compact(values, docContext, { documentLoader: options.contextLoader });
		if (docContext != null) {
			if ("proof" in compacted && compacted.proof != null) if (Array.isArray(compacted.proof)) for (const element of compacted.proof) element["@context"] = docContext;
			else compacted.proof["@context"] = docContext;
		}
		return compacted;
	}
	isCompactable() {
		return super.isCompactable();
	}
	/**
	* Converts a JSON-LD structure to an object of this type.
	* @param json The JSON-LD structure to convert.
	* @param options The options to use.
	*                - `documentLoader`: The loader for remote JSON-LD documents.
	*                - `contextLoader`: The loader for remote JSON-LD contexts.
	*                - `tracerProvider`: The OpenTelemetry tracer provider to use.
	*                  If omitted, the global tracer provider is used.
	* @returns The object of this type.
	* @throws {TypeError} If the given `json` is invalid.
	*/
	static async fromJsonLd(json, options = {}) {
		const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
		const tracer = tracerProvider.getTracer("@fedify/fedify", "1.10.3");
		return await tracer.startActiveSpan("activitypub.parse_object", async (span) => {
			try {
				const object = await this.__fromJsonLd__View__(json, span, options);
				if (object.id != null) span.setAttribute("activitypub.object.id", object.id.href);
				return object;
			} catch (error) {
				span.setStatus({
					code: SpanStatusCode.ERROR,
					message: String(error)
				});
				throw error;
			} finally {
				span.end();
			}
		});
	}
	static async __fromJsonLd__View__(json, span, options = {}) {
		if (typeof json === "undefined") throw new TypeError("Invalid JSON-LD: undefined.");
		else if (json === null) throw new TypeError("Invalid JSON-LD: null.");
		options = {
			...options,
			documentLoader: options.documentLoader ?? getDocumentLoader(),
			contextLoader: options.contextLoader ?? getDocumentLoader(),
			tracerProvider: options.tracerProvider ?? trace.getTracerProvider()
		};
		let values;
		if (globalThis.Object.keys(json).length == 0) values = {};
		else {
			const expanded = await jsonld.expand(json, {
				documentLoader: options.contextLoader,
				keepFreeFloatingNodes: true
			});
			values = expanded[0] ?? {};
		}
		if (options.baseUrl == null && values["@id"] != null) options = {
			...options,
			baseUrl: new URL(values["@id"])
		};
		if ("@type" in values) span.setAttribute("activitypub.object.type", values["@type"]);
		if ("@type" in values && !values["@type"].every((t) => t.startsWith("_:"))) {
			if (!values["@type"].includes("https://www.w3.org/ns/activitystreams#View")) throw new TypeError("Invalid type: " + values["@type"]);
		}
		delete values["@type"];
		const instance = await super.fromJsonLd(values, {
			...options,
			_fromSubclass: true
		});
		if (!(instance instanceof View)) throw new TypeError("Unexpected type: " + instance.constructor.name);
		if (!("_fromSubclass" in options) || !options._fromSubclass) try {
			instance._cachedJsonLd = structuredClone(json);
		} catch {
			getLogger(["fedify", "vocab"]).warn("Failed to cache JSON-LD: {json}", { json });
		}
		return instance;
	}
	_getCustomInspectProxy() {
		const proxy = super._getCustomInspectProxy();
		return proxy;
	}
	[Symbol.for("Deno.customInspect")](inspect, options) {
		const proxy = this._getCustomInspectProxy();
		return "View " + inspect(proxy, options);
	}
	[Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
		const proxy = this._getCustomInspectProxy();
		return "View " + inspect(proxy, options);
	}
};

//#endregion
//#region src/webfinger/lookup.ts
const logger = getLogger([
	"fedify",
	"webfinger",
	"lookup"
]);
const DEFAULT_MAX_REDIRECTION = 5;
/**
* Looks up a WebFinger resource.
* @param resource The resource URL to look up.
* @param options Extra options for looking up the resource.
* @returns The resource descriptor, or `null` if not found.
* @since 0.2.0
*/
async function lookupWebFinger(resource, options = {}) {
	const tracerProvider = options.tracerProvider ?? trace.getTracerProvider();
	const tracer = tracerProvider.getTracer(deno_default.name, deno_default.version);
	return await tracer.startActiveSpan("webfinger.lookup", {
		kind: SpanKind.CLIENT,
		attributes: {
			"webfinger.resource": resource.toString(),
			"webfinger.resource.scheme": typeof resource === "string" ? resource.replace(/:.*$/, "") : resource.protocol.replace(/:$/, "")
		}
	}, async (span) => {
		try {
			const result = await lookupWebFingerInternal(resource, options);
			span.setStatus({ code: result === null ? SpanStatusCode.ERROR : SpanStatusCode.OK });
			return result;
		} catch (error) {
			span.setStatus({
				code: SpanStatusCode.ERROR,
				message: String(error)
			});
			throw error;
		} finally {
			span.end();
		}
	});
}
async function lookupWebFingerInternal(resource, options = {}) {
	if (typeof resource === "string") resource = new URL(resource);
	let protocol = "https:";
	let server;
	if (resource.protocol === "acct:") {
		const atPos = resource.pathname.lastIndexOf("@");
		if (atPos < 0) return null;
		server = resource.pathname.substring(atPos + 1);
		if (server === "") return null;
	} else {
		protocol = resource.protocol;
		server = resource.host;
	}
	let url = new URL(`${protocol}//${server}/.well-known/webfinger`);
	url.searchParams.set("resource", resource.href);
	let redirected = 0;
	while (true) {
		logger.debug("Fetching WebFinger resource descriptor from {url}...", { url: url.href });
		let response;
		if (options.allowPrivateAddress !== true) try {
			await validatePublicUrl(url.href);
		} catch (e) {
			if (e instanceof UrlError) {
				logger.error("Invalid URL for WebFinger resource descriptor: {error}", { error: e });
				return null;
			}
			throw e;
		}
		try {
			response = await fetch(url, {
				headers: {
					Accept: "application/jrd+json",
					"User-Agent": typeof options.userAgent === "string" ? options.userAgent : getUserAgent(options.userAgent)
				},
				redirect: "manual",
				signal: options.signal
			});
		} catch (error) {
			logger.debug("Failed to fetch WebFinger resource descriptor: {error}", {
				url: url.href,
				error
			});
			return null;
		}
		if (response.status >= 300 && response.status < 400 && response.headers.has("Location")) {
			redirected++;
			const maxRedirection = options.maxRedirection ?? DEFAULT_MAX_REDIRECTION;
			if (redirected >= maxRedirection) {
				logger.error("Too many redirections ({redirections}) while fetching WebFinger resource descriptor.", { redirections: redirected });
				return null;
			}
			const redirectedUrl = new URL(response.headers.get("Location"), response.url == null || response.url === "" ? url : response.url);
			if (redirectedUrl.protocol !== url.protocol) {
				logger.error("Redirected to a different protocol ({protocol} to {redirectedProtocol}) while fetching WebFinger resource descriptor.", {
					protocol: url.protocol,
					redirectedProtocol: redirectedUrl.protocol
				});
				return null;
			}
			url = redirectedUrl;
			continue;
		}
		if (!response.ok) {
			logger.debug("Failed to fetch WebFinger resource descriptor: {status} {statusText}.", {
				url: url.href,
				status: response.status,
				statusText: response.statusText
			});
			return null;
		}
		try {
			return await response.json();
		} catch (e) {
			if (e instanceof SyntaxError) {
				logger.debug("Failed to parse WebFinger resource descriptor as JSON: {error}", { error: e });
				return null;
			}
			throw e;
		}
	}
}

//#endregion
//#region src/vocab/type.ts
function getTypeId(object) {
	if (object == null) return object;
	const cls = object.constructor;
	return cls.typeId;
}

//#endregion
export { Activity, Announce, Application, Collection, CollectionPage, Create, CryptographicKey, DataIntegrityProof, Endpoints, FetchError, Follow, Group, Hashtag, HttpHeaderLink, Image, Invite, LanguageString, Link, Multikey, Note, Object$1 as Object, Offer, OrderedCollection, OrderedCollectionPage, Organization, Person, Place, Question, Service, Source, Update, UrlError, __commonJS, __export, __require, __toESM, codes, contexts_default, createRequest, decode, decodeText, deno_default, encode, encodeText, expandIPv6Address, exportMultibaseKey, exportSpki, fetchDocumentLoader, getDocumentLoader, getRemoteDocument, getTypeId, getUserAgent, importMultibaseKey, importPem, importPkcs1, importSpki, isValidPublicIPv4Address, isValidPublicIPv6Address, kvCache, logRequest, lookupWebFinger, names, validatePublicUrl, vocab_exports };