
        import { Temporal } from "@js-temporal/polyfill";
      
import { driverSerializesJson } from "./utils.js";
import { getLogger } from "@logtape/logtape";

//#region src/kv.ts
const logger = getLogger([
	"fedify",
	"postgres",
	"kv"
]);
/**
* A key–value store that uses PostgreSQL as the underlying storage.
*
* @example
* ```ts
* import { createFederation } from "@fedify/fedify";
* import { PostgresKvStore } from "@fedify/postgres";
* import postgres from "postgres";
*
* const federation = createFederation({
*   // ...
*   kv: new PostgresKvStore(postgres("postgres://user:pass@localhost/db")),
* });
* ```
*/
var PostgresKvStore = class {
	#sql;
	#tableName;
	#initialized;
	#driverSerializesJson = false;
	/**
	* Creates a new PostgreSQL key–value store.
	* @param sql The PostgreSQL client to use.
	* @param options The options for the key–value store.
	*/
	constructor(sql, options = {}) {
		this.#sql = sql;
		this.#tableName = options.tableName ?? "fedify_kv_v2";
		this.#initialized = options.initialized ?? false;
	}
	async #expire() {
		await this.#sql`
      DELETE FROM ${this.#sql(this.#tableName)}
      WHERE ttl IS NOT NULL AND created + ttl < CURRENT_TIMESTAMP;
    `;
	}
	async get(key) {
		await this.initialize();
		const result = await this.#sql`
      SELECT value
      FROM ${this.#sql(this.#tableName)}
      WHERE key = ${key} AND (ttl IS NULL OR created + ttl > CURRENT_TIMESTAMP);
    `;
		if (result.length < 1) return void 0;
		return result[0].value;
	}
	async set(key, value, options) {
		await this.initialize();
		const ttl = options?.ttl == null ? null : options.ttl.toString();
		await this.#sql`
      INSERT INTO ${this.#sql(this.#tableName)} (key, value, ttl)
      VALUES (
        ${key},
        ${this.#json(value)},
        ${ttl}
      )
      ON CONFLICT (key)
        DO UPDATE SET value = EXCLUDED.value, ttl = EXCLUDED.ttl;
    `;
		await this.#expire();
	}
	async delete(key) {
		await this.initialize();
		await this.#sql`
      DELETE FROM ${this.#sql(this.#tableName)}
      WHERE key = ${key};
    `;
		await this.#expire();
	}
	/**
	* {@inheritDoc KvStore.list}
	* @since 1.10.0
	*/
	async *list(prefix) {
		await this.initialize();
		let results;
		if (prefix == null || prefix.length === 0) results = await this.#sql`
        SELECT key, value
        FROM ${this.#sql(this.#tableName)}
        WHERE ttl IS NULL OR created + ttl > CURRENT_TIMESTAMP
        ORDER BY key
      `;
		else {
			const prefixLength = prefix.length;
			results = await this.#sql`
        SELECT key, value
        FROM ${this.#sql(this.#tableName)}
        WHERE array_length(key, 1) >= ${prefixLength}
          AND key[1:${prefixLength}] = ${prefix}::text[]
          AND (ttl IS NULL OR created + ttl > CURRENT_TIMESTAMP)
        ORDER BY key
      `;
		}
		for (const row of results) yield {
			key: row.key,
			value: row.value
		};
	}
	/**
	* Creates the table used by the key–value store if it does not already exist.
	* Does nothing if the table already exists.
	*/
	async initialize() {
		if (this.#initialized) return;
		logger.debug("Initializing the key–value store table {tableName}...", { tableName: this.#tableName });
		await this.#sql`
      CREATE UNLOGGED TABLE IF NOT EXISTS ${this.#sql(this.#tableName)} (
        key text[] PRIMARY KEY,
        value jsonb NOT NULL,
        created timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
        ttl interval
      );
    `;
		this.#driverSerializesJson = await driverSerializesJson(this.#sql);
		this.#initialized = true;
		logger.debug("Initialized the key–value store table {tableName}.", { tableName: this.#tableName });
	}
	/**
	* Drops the table used by the key–value store.  Does nothing if the table
	* does not exist.
	*/
	async drop() {
		await this.#sql`DROP TABLE IF EXISTS ${this.#sql(this.#tableName)};`;
	}
	#json(value) {
		if (this.#driverSerializesJson) return this.#sql.json(value);
		return this.#sql.json(JSON.stringify(value));
	}
};

//#endregion
export { PostgresKvStore };